
prj_stm32n6_lcd_Appli.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000034c  34000400  34000400  00000400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000f5e8  3400074c  3400074c  0000074c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000418  3400fd34  3400fd34  0000fd34  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  3401014c  3401014c  00011160  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  3401014c  3401014c  00011160  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  3401014c  34011160  00011160  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  3401014c  3401014c  0001014c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  34010150  34010150  00010150  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         0000004c  34010154  34010154  00010154  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .mtk_exctbl   00000d40  34010400  34010400  00010400  2**10
                  CONTENTS, ALLOC, LOAD, DATA
 10 .noncacheable 00000000  34011140  34011140  00011160  2**0
                  CONTENTS
 11 .gnu.sgstubs  00000020  34011140  34011140  00011140  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .bss          000003cc  34011160  34011160  00011160  2**2
                  ALLOC
 13 .noinit       000022d8  34011530  34011530  00011160  2**3
                  ALLOC
 14 ._user_heap_stack 00000a00  34013808  34013808  00011160  2**0
                  ALLOC
 15 .ARM.attributes 0000003a  00000000  00000000  00011160  2**0
                  CONTENTS, READONLY
 16 .debug_info   00038c12  00000000  00000000  0001119a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_abbrev 0000857f  00000000  00000000  00049dac  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_aranges 00003148  00000000  00000000  00052330  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 00002527  00000000  00000000  00055478  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_macro  0005d78f  00000000  00000000  0005799f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line   0004da71  00000000  00000000  000b512e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_str    00226194  00000000  00000000  00102b9f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .comment      00000043  00000000  00000000  00328d33  2**0
                  CONTENTS, READONLY
 24 .debug_frame  0000cb1c  00000000  00000000  00328d78  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 25 .debug_line_str 000000cd  00000000  00000000  00335894  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

3400074c <__do_global_dtors_aux>:
3400074c:	b510      	push	{r4, lr}
3400074e:	4c05      	ldr	r4, [pc, #20]	@ (34000764 <__do_global_dtors_aux+0x18>)
34000750:	7823      	ldrb	r3, [r4, #0]
34000752:	b933      	cbnz	r3, 34000762 <__do_global_dtors_aux+0x16>
34000754:	4b04      	ldr	r3, [pc, #16]	@ (34000768 <__do_global_dtors_aux+0x1c>)
34000756:	b113      	cbz	r3, 3400075e <__do_global_dtors_aux+0x12>
34000758:	4804      	ldr	r0, [pc, #16]	@ (3400076c <__do_global_dtors_aux+0x20>)
3400075a:	f3af 8000 	nop.w
3400075e:	2301      	movs	r3, #1
34000760:	7023      	strb	r3, [r4, #0]
34000762:	bd10      	pop	{r4, pc}
34000764:	34011160 	.word	0x34011160
34000768:	00000000 	.word	0x00000000
3400076c:	3400fd1c 	.word	0x3400fd1c

34000770 <frame_dummy>:
34000770:	b508      	push	{r3, lr}
34000772:	4b03      	ldr	r3, [pc, #12]	@ (34000780 <frame_dummy+0x10>)
34000774:	b11b      	cbz	r3, 3400077e <frame_dummy+0xe>
34000776:	4903      	ldr	r1, [pc, #12]	@ (34000784 <frame_dummy+0x14>)
34000778:	4803      	ldr	r0, [pc, #12]	@ (34000788 <frame_dummy+0x18>)
3400077a:	f3af 8000 	nop.w
3400077e:	bd08      	pop	{r3, pc}
34000780:	00000000 	.word	0x00000000
34000784:	34011164 	.word	0x34011164
34000788:	3400fd1c 	.word	0x3400fd1c

3400078c <knl_dispatch_entry>:
	.thumb_func
	.globl Csym(knl_dispatch_entry)

Csym(knl_dispatch_entry):	
/*----------------- Start dispatch processing. -----------------*/
	ldr	r0, =Csym(knl_dispatch_disabled)
3400078c:	4828      	ldr	r0, [pc, #160]	@ (34000830 <l_dispatch_200+0x16>)
	ldr	r1, =1
3400078e:	f04f 0101 	mov.w	r1, #1
	str	r1, [r0]			// Dispatch disable
34000792:	6001      	str	r1, [r0, #0]

	ldr	r0, =Csym(knl_ctxtsk)
34000794:	4827      	ldr	r0, [pc, #156]	@ (34000834 <l_dispatch_200+0x1a>)
	ldr	r1, [r0]			// R1 = ctxtsk
34000796:	6801      	ldr	r1, [r0, #0]
	cmp	r1, #0
34000798:	2900      	cmp	r1, #0
	bne	l_dispatch_000
3400079a:	d102      	bne.n	340007a2 <l_dispatch_000>
#if USE_SPMON
	ldr	r2, =INTERNAL_RAM_START
	msr	msplim, r2
#endif
	// Set temporal stack
	ldr	sp, =(Csym(knl_tmp_stack) + TMP_STACK_SIZE)
3400079c:	f8df d098 	ldr.w	sp, [pc, #152]	@ 34000838 <l_dispatch_200+0x1e>
#if USE_SPMON
	ldr	r2, =Csym(knl_tmp_stack)
	msr	msplim, r2
#endif

	b	l_dispatch_100
340007a0:	e011      	b.n	340007c6 <l_dispatch_100>

340007a2 <l_dispatch_000>:

/*----------------- Save "ctxtsk" context. -----------------*/
l_dispatch_000: 
	push	{r4-r11}
340007a2:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
	push	{lr}
340007a6:	b500      	push	{lr}

#if USE_FPU			// Save FPU register
	ldr	r2, [r1, #TCB_tskatr]
340007a8:	690a      	ldr	r2, [r1, #16]
	ands	r2, r2, #TA_FPU
340007aa:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
	beq	l_dispatch_010			// ctxtsk is not a TA_FPU attribute.
340007ae:	d005      	beq.n	340007bc <l_dispatch_010>

	ands	r3,lr, #EXPRN_NO_FPU
340007b0:	f01e 0310 	ands.w	r3, lr, #16
	bne	l_dispatch_010			// ctxtsk does not execute FPU instructions.
340007b4:	d102      	bne.n	340007bc <l_dispatch_010>

	vpush	{s16-s31}			// Push FPU register (S16-S31)
340007b6:	ed2d 8a10 	vpush	{s16-s31}
	push	{r3}				//FPU usage flag
340007ba:	b408      	push	{r3}

340007bc <l_dispatch_010>:

l_dispatch_010:			// End of FPU register save process
#endif /* USE_FPU */

	str	sp, [r1, #TCB_tskctxb + CTXB_ssp]	// Save 'ssp' to TCB
340007bc:	f8c1 d018 	str.w	sp, [r1, #24]

	ldr	r2, =0
340007c0:	f04f 0200 	mov.w	r2, #0
	str	r2, [r0]			// ctxtsk = NULL
340007c4:	6002      	str	r2, [r0, #0]

340007c6 <l_dispatch_100>:


/*----------------- Dispatch from "ctxtsk" to "schedtsk" -----------------*/
l_dispatch_100:
	ldr	r4, =Csym(knl_ctxtsk)
340007c6:	4c1b      	ldr	r4, [pc, #108]	@ (34000834 <l_dispatch_200+0x1a>)
	ldr	r5, =Csym(knl_schedtsk)		// R5 = &schedtsk
340007c8:	4d1c      	ldr	r5, [pc, #112]	@ (3400083c <l_dispatch_200+0x22>)
	ldr	r6, =Csym(knl_lowpow_discnt)	// R6 = &lowpow_discnt
340007ca:	4e1d      	ldr	r6, [pc, #116]	@ (34000840 <l_dispatch_200+0x26>)

340007cc <l_dispatch_110>:

l_dispatch_110:
	ldr	r2, =INTPRI_VAL(INTPRI_MAX_EXTINT_PRI)	// Disable interruput
340007cc:	f04f 0210 	mov.w	r2, #16
	msr	basepri, r2
340007d0:	f382 8811 	msr	BASEPRI, r2

	ldr	r8, [r5]			// R8 = schedtsk
340007d4:	f8d5 8000 	ldr.w	r8, [r5]
	cmp	r8, #0				// Is there 'schedtsk'?
340007d8:	f1b8 0f00 	cmp.w	r8, #0
	bne	l_dispatch_120
340007dc:	d10d      	bne.n	340007fa <l_dispatch_120>

	/* Moves to power saving mode because there are no tasks that can be run. */
	ldr	ip, [r6]			// Is 'low_pow' disabled?
340007de:	f8d6 c000 	ldr.w	ip, [r6]
	cmp	ip, #0
340007e2:	f1bc 0f00 	cmp.w	ip, #0
	it	eq
340007e6:	bf08      	it	eq
	bleq	Csym(low_pow)			// call low_pow()
340007e8:	f00f f9e8 	bleq	3400fbbc <low_pow>

	ldr	r2, =0
340007ec:	f04f 0200 	mov.w	r2, #0
	msr	basepri, r2			// Enable interruput
340007f0:	f382 8811 	msr	BASEPRI, r2
	isb
340007f4:	f3bf 8f6f 	isb	sy

	b	l_dispatch_110
340007f8:	e7e8      	b.n	340007cc <l_dispatch_110>

340007fa <l_dispatch_120>:

l_dispatch_120:			// Switch to 'schedtsk'
	str	r8, [r4]			// ctxtsk = schedtsk
340007fa:	f8c4 8000 	str.w	r8, [r4]
#if USE_SPMON
	ldr	r2, =INTERNAL_RAM_START
	msr	msplim, r2
#endif

	ldr	sp, [r8, #TCB_tskctxb + CTXB_ssp]	// Restore 'ssp' from TCB
340007fe:	f8d8 d018 	ldr.w	sp, [r8, #24]
#endif

/*----------------- Restore "schedtsk" context. -----------------*/

#if USE_FPU			// Restore FPU context
	ldr	r0, [r8, #TCB_tskatr]
34000802:	f8d8 0010 	ldr.w	r0, [r8, #16]
	ands	r0, r0, #TA_FPU
34000806:	f410 5080 	ands.w	r0, r0, #4096	@ 0x1000
	beq	l_dispatch_200			// schedtsk is not a TA_FPU attribute.
3400080a:	d006      	beq.n	3400081a <l_dispatch_200>

	ldr	r3,[sp]				// load FPU usage flag
3400080c:	9b00      	ldr	r3, [sp, #0]
	ands	r3, r3, #EXPRN_NO_FPU
3400080e:	f013 0310 	ands.w	r3, r3, #16
	bne	l_dispatch_200			// schedtsk does not execute FPU instructions.
34000812:	d102      	bne.n	3400081a <l_dispatch_200>

	pop	{r3}
34000814:	bc08      	pop	{r3}
	vpop	{s16-s31}			// Pop FPU register (S16-S31)
34000816:	ecbd 8a10 	vpop	{s16-s31}

3400081a <l_dispatch_200>:

l_dispatch_200:			//  End of FPU register restore process
#endif	/* USE_FPU */

	pop	{lr}
3400081a:	f85d eb04 	ldr.w	lr, [sp], #4
	pop	{r4-r11}
3400081e:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}

	ldr	r0, =Csym(knl_dispatch_disabled)
34000822:	4803      	ldr	r0, [pc, #12]	@ (34000830 <l_dispatch_200+0x16>)
	ldr	r1, =0
34000824:	f04f 0100 	mov.w	r1, #0
	str	r1, [r0]			// Dispatch enable
34000828:	6001      	str	r1, [r0, #0]

	msr	basepri, r1			// Enable inperrupt
3400082a:	f381 8811 	msr	BASEPRI, r1

	bx	lr
3400082e:	4770      	bx	lr
	ldr	r0, =Csym(knl_dispatch_disabled)
34000830:	340127fc 	.word	0x340127fc
	ldr	r0, =Csym(knl_ctxtsk)
34000834:	34012800 	.word	0x34012800
	ldr	sp, =(Csym(knl_tmp_stack) + TMP_STACK_SIZE)
34000838:	340114e8 	.word	0x340114e8
	ldr	r5, =Csym(knl_schedtsk)		// R5 = &schedtsk
3400083c:	34012804 	.word	0x34012804
	ldr	r6, =Csym(knl_lowpow_discnt)	// R6 = &lowpow_discnt
34000840:	340113e4 	.word	0x340113e4

34000844 <task_1>:
	.task		= task_1,
	.tskatr		= TA_HLNG | TA_RNG3,
};

LOCAL void task_1(INT stacd, void *exinf)
{
34000844:	b580      	push	{r7, lr}
34000846:	b08e      	sub	sp, #56	@ 0x38
34000848:	af02      	add	r7, sp, #8
3400084a:	6078      	str	r0, [r7, #4]
3400084c:	6039      	str	r1, [r7, #0]
	UINT	x, y, w, h, dw, dh;

	tm_printf((UB*)"Start task 1\n");
3400084e:	488c      	ldr	r0, [pc, #560]	@ (34000a80 <task_1+0x23c>)
34000850:	f00e fa58 	bl	3400ed04 <tm_printf>

	tliblcd_init();				/* Init LCD */
34000854:	f000 f93c 	bl	34000ad0 <tliblcd_init>
	tliblcd_onoff_lcd(LCD_ON);		/* LCD ON */
34000858:	2001      	movs	r0, #1
3400085a:	f000 f98b 	bl	34000b74 <tliblcd_onoff_lcd>

	/* Get display size */
	w = tliblcd_get_width();
3400085e:	f000 f97d 	bl	34000b5c <tliblcd_get_width>
34000862:	61b8      	str	r0, [r7, #24]
	h = tliblcd_get_height();
34000864:	f000 f96e 	bl	34000b44 <tliblcd_get_height>
34000868:	6178      	str	r0, [r7, #20]
	tm_printf((UB*)"Width:%d  Height:%d\n", w, h);
3400086a:	697a      	ldr	r2, [r7, #20]
3400086c:	69b9      	ldr	r1, [r7, #24]
3400086e:	4885      	ldr	r0, [pc, #532]	@ (34000a84 <task_1+0x240>)
34000870:	f00e fa48 	bl	3400ed04 <tm_printf>

	while(1) {
		/* Cleare Screen */
		tliblcd_clear_scr(TLIBLCD_COLOR_RED);
34000874:	4884      	ldr	r0, [pc, #528]	@ (34000a88 <task_1+0x244>)
34000876:	f000 f9bb 	bl	34000bf0 <tliblcd_clear_scr>
		tk_dly_tsk(500);
3400087a:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
3400087e:	f00c ff21 	bl	3400d6c4 <tk_dly_tsk>
		tliblcd_clear_scr(TLIBLCD_COLOR_GREEN);
34000882:	f04f 20ff 	mov.w	r0, #4278255360	@ 0xff00ff00
34000886:	f000 f9b3 	bl	34000bf0 <tliblcd_clear_scr>
		tk_dly_tsk(500);
3400088a:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
3400088e:	f00c ff19 	bl	3400d6c4 <tk_dly_tsk>
		tliblcd_clear_scr(TLIBLCD_COLOR_BLUE);
34000892:	487e      	ldr	r0, [pc, #504]	@ (34000a8c <task_1+0x248>)
34000894:	f000 f9ac 	bl	34000bf0 <tliblcd_clear_scr>
		tk_dly_tsk(500);
34000898:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
3400089c:	f00c ff12 	bl	3400d6c4 <tk_dly_tsk>
		tliblcd_clear_scr(TLIBLCD_COLOR_WHITE);
340008a0:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
340008a4:	f000 f9a4 	bl	34000bf0 <tliblcd_clear_scr>
		tk_dly_tsk(500);
340008a8:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
340008ac:	f00c ff0a 	bl	3400d6c4 <tk_dly_tsk>

		/* Draw a rectangle */
		x = y = 0; dw = w/10; dh = h/10;
340008b0:	2300      	movs	r3, #0
340008b2:	62bb      	str	r3, [r7, #40]	@ 0x28
340008b4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340008b6:	62fb      	str	r3, [r7, #44]	@ 0x2c
340008b8:	69bb      	ldr	r3, [r7, #24]
340008ba:	4a75      	ldr	r2, [pc, #468]	@ (34000a90 <task_1+0x24c>)
340008bc:	fba2 2303 	umull	r2, r3, r2, r3
340008c0:	08db      	lsrs	r3, r3, #3
340008c2:	613b      	str	r3, [r7, #16]
340008c4:	697b      	ldr	r3, [r7, #20]
340008c6:	4a72      	ldr	r2, [pc, #456]	@ (34000a90 <task_1+0x24c>)
340008c8:	fba2 2303 	umull	r2, r3, r2, r3
340008cc:	08db      	lsrs	r3, r3, #3
340008ce:	60fb      	str	r3, [r7, #12]
		while(y<h) {
340008d0:	e03e      	b.n	34000950 <task_1+0x10c>
			tliblcd_draw_rect(TLIBLCD_COLOR_RED, x, y, w, dh);
340008d2:	68fb      	ldr	r3, [r7, #12]
340008d4:	9300      	str	r3, [sp, #0]
340008d6:	69bb      	ldr	r3, [r7, #24]
340008d8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340008da:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
340008dc:	486a      	ldr	r0, [pc, #424]	@ (34000a88 <task_1+0x244>)
340008de:	f000 f9af 	bl	34000c40 <tliblcd_draw_rect>
			y += dh;
340008e2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340008e4:	68fb      	ldr	r3, [r7, #12]
340008e6:	4413      	add	r3, r2
340008e8:	62bb      	str	r3, [r7, #40]	@ 0x28
			tliblcd_draw_rect(TLIBLCD_COLOR_GREEN, x, y, w, dh);
340008ea:	68fb      	ldr	r3, [r7, #12]
340008ec:	9300      	str	r3, [sp, #0]
340008ee:	69bb      	ldr	r3, [r7, #24]
340008f0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340008f2:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
340008f4:	f04f 20ff 	mov.w	r0, #4278255360	@ 0xff00ff00
340008f8:	f000 f9a2 	bl	34000c40 <tliblcd_draw_rect>
			y += dh;
340008fc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340008fe:	68fb      	ldr	r3, [r7, #12]
34000900:	4413      	add	r3, r2
34000902:	62bb      	str	r3, [r7, #40]	@ 0x28
			tliblcd_draw_rect(TLIBLCD_COLOR_BLUE, x, y, w, dh);
34000904:	68fb      	ldr	r3, [r7, #12]
34000906:	9300      	str	r3, [sp, #0]
34000908:	69bb      	ldr	r3, [r7, #24]
3400090a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400090c:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
3400090e:	485f      	ldr	r0, [pc, #380]	@ (34000a8c <task_1+0x248>)
34000910:	f000 f996 	bl	34000c40 <tliblcd_draw_rect>
			y += dh;
34000914:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34000916:	68fb      	ldr	r3, [r7, #12]
34000918:	4413      	add	r3, r2
3400091a:	62bb      	str	r3, [r7, #40]	@ 0x28
			tliblcd_draw_rect(TLIBLCD_COLOR_WHITE, x, y, w, dh);
3400091c:	68fb      	ldr	r3, [r7, #12]
3400091e:	9300      	str	r3, [sp, #0]
34000920:	69bb      	ldr	r3, [r7, #24]
34000922:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34000924:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
34000926:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
3400092a:	f000 f989 	bl	34000c40 <tliblcd_draw_rect>
			y += dh;
3400092e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34000930:	68fb      	ldr	r3, [r7, #12]
34000932:	4413      	add	r3, r2
34000934:	62bb      	str	r3, [r7, #40]	@ 0x28
			tliblcd_draw_rect(TLIBLCD_COLOR_BLACK, x, y, w, dh);
34000936:	68fb      	ldr	r3, [r7, #12]
34000938:	9300      	str	r3, [sp, #0]
3400093a:	69bb      	ldr	r3, [r7, #24]
3400093c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400093e:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
34000940:	f04f 407f 	mov.w	r0, #4278190080	@ 0xff000000
34000944:	f000 f97c 	bl	34000c40 <tliblcd_draw_rect>
			y += dh;
34000948:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400094a:	68fb      	ldr	r3, [r7, #12]
3400094c:	4413      	add	r3, r2
3400094e:	62bb      	str	r3, [r7, #40]	@ 0x28
		while(y<h) {
34000950:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34000952:	697b      	ldr	r3, [r7, #20]
34000954:	429a      	cmp	r2, r3
34000956:	d3bc      	bcc.n	340008d2 <task_1+0x8e>
		}

		x = w/2 - dw/2; y = h/2 - dh/2; 
34000958:	69bb      	ldr	r3, [r7, #24]
3400095a:	085a      	lsrs	r2, r3, #1
3400095c:	693b      	ldr	r3, [r7, #16]
3400095e:	085b      	lsrs	r3, r3, #1
34000960:	1ad3      	subs	r3, r2, r3
34000962:	62fb      	str	r3, [r7, #44]	@ 0x2c
34000964:	697b      	ldr	r3, [r7, #20]
34000966:	085a      	lsrs	r2, r3, #1
34000968:	68fb      	ldr	r3, [r7, #12]
3400096a:	085b      	lsrs	r3, r3, #1
3400096c:	1ad3      	subs	r3, r2, r3
3400096e:	62bb      	str	r3, [r7, #40]	@ 0x28
		UINT ww = dw; UINT hh = dh;
34000970:	693b      	ldr	r3, [r7, #16]
34000972:	627b      	str	r3, [r7, #36]	@ 0x24
34000974:	68fb      	ldr	r3, [r7, #12]
34000976:	623b      	str	r3, [r7, #32]
		for(UINT i = 0; i<2; i++) {
34000978:	2300      	movs	r3, #0
3400097a:	61fb      	str	r3, [r7, #28]
3400097c:	e078      	b.n	34000a70 <task_1+0x22c>
			tliblcd_draw_rect(TLIBLCD_COLOR_RED, x, y, ww, hh);
3400097e:	6a3b      	ldr	r3, [r7, #32]
34000980:	9300      	str	r3, [sp, #0]
34000982:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34000984:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34000986:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
34000988:	483f      	ldr	r0, [pc, #252]	@ (34000a88 <task_1+0x244>)
3400098a:	f000 f959 	bl	34000c40 <tliblcd_draw_rect>
			x -= dw/2; y -= dh/2; ww += dw; hh += dh;
3400098e:	693b      	ldr	r3, [r7, #16]
34000990:	085b      	lsrs	r3, r3, #1
34000992:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34000994:	1ad3      	subs	r3, r2, r3
34000996:	62fb      	str	r3, [r7, #44]	@ 0x2c
34000998:	68fb      	ldr	r3, [r7, #12]
3400099a:	085b      	lsrs	r3, r3, #1
3400099c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400099e:	1ad3      	subs	r3, r2, r3
340009a0:	62bb      	str	r3, [r7, #40]	@ 0x28
340009a2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
340009a4:	693b      	ldr	r3, [r7, #16]
340009a6:	4413      	add	r3, r2
340009a8:	627b      	str	r3, [r7, #36]	@ 0x24
340009aa:	6a3a      	ldr	r2, [r7, #32]
340009ac:	68fb      	ldr	r3, [r7, #12]
340009ae:	4413      	add	r3, r2
340009b0:	623b      	str	r3, [r7, #32]
			tk_dly_tsk(200);
340009b2:	20c8      	movs	r0, #200	@ 0xc8
340009b4:	f00c fe86 	bl	3400d6c4 <tk_dly_tsk>

			tliblcd_draw_rect(TLIBLCD_COLOR_GREEN, x, y, ww, hh);
340009b8:	6a3b      	ldr	r3, [r7, #32]
340009ba:	9300      	str	r3, [sp, #0]
340009bc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340009be:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340009c0:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
340009c2:	f04f 20ff 	mov.w	r0, #4278255360	@ 0xff00ff00
340009c6:	f000 f93b 	bl	34000c40 <tliblcd_draw_rect>
			x -= dw/2; y -= dh/2; ww += dw; hh += dh;
340009ca:	693b      	ldr	r3, [r7, #16]
340009cc:	085b      	lsrs	r3, r3, #1
340009ce:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
340009d0:	1ad3      	subs	r3, r2, r3
340009d2:	62fb      	str	r3, [r7, #44]	@ 0x2c
340009d4:	68fb      	ldr	r3, [r7, #12]
340009d6:	085b      	lsrs	r3, r3, #1
340009d8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340009da:	1ad3      	subs	r3, r2, r3
340009dc:	62bb      	str	r3, [r7, #40]	@ 0x28
340009de:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
340009e0:	693b      	ldr	r3, [r7, #16]
340009e2:	4413      	add	r3, r2
340009e4:	627b      	str	r3, [r7, #36]	@ 0x24
340009e6:	6a3a      	ldr	r2, [r7, #32]
340009e8:	68fb      	ldr	r3, [r7, #12]
340009ea:	4413      	add	r3, r2
340009ec:	623b      	str	r3, [r7, #32]
			tk_dly_tsk(200);
340009ee:	20c8      	movs	r0, #200	@ 0xc8
340009f0:	f00c fe68 	bl	3400d6c4 <tk_dly_tsk>

			tliblcd_draw_rect(TLIBLCD_COLOR_BLUE, x, y, ww, hh);
340009f4:	6a3b      	ldr	r3, [r7, #32]
340009f6:	9300      	str	r3, [sp, #0]
340009f8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340009fa:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340009fc:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
340009fe:	4823      	ldr	r0, [pc, #140]	@ (34000a8c <task_1+0x248>)
34000a00:	f000 f91e 	bl	34000c40 <tliblcd_draw_rect>
			x -= dw/2; y -= dh/2; ww += dw; hh += dh;
34000a04:	693b      	ldr	r3, [r7, #16]
34000a06:	085b      	lsrs	r3, r3, #1
34000a08:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34000a0a:	1ad3      	subs	r3, r2, r3
34000a0c:	62fb      	str	r3, [r7, #44]	@ 0x2c
34000a0e:	68fb      	ldr	r3, [r7, #12]
34000a10:	085b      	lsrs	r3, r3, #1
34000a12:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34000a14:	1ad3      	subs	r3, r2, r3
34000a16:	62bb      	str	r3, [r7, #40]	@ 0x28
34000a18:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34000a1a:	693b      	ldr	r3, [r7, #16]
34000a1c:	4413      	add	r3, r2
34000a1e:	627b      	str	r3, [r7, #36]	@ 0x24
34000a20:	6a3a      	ldr	r2, [r7, #32]
34000a22:	68fb      	ldr	r3, [r7, #12]
34000a24:	4413      	add	r3, r2
34000a26:	623b      	str	r3, [r7, #32]
			tk_dly_tsk(200);
34000a28:	20c8      	movs	r0, #200	@ 0xc8
34000a2a:	f00c fe4b 	bl	3400d6c4 <tk_dly_tsk>

			tliblcd_draw_rect(TLIBLCD_COLOR_WHITE, x, y, ww, hh);
34000a2e:	6a3b      	ldr	r3, [r7, #32]
34000a30:	9300      	str	r3, [sp, #0]
34000a32:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34000a34:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34000a36:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
34000a38:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
34000a3c:	f000 f900 	bl	34000c40 <tliblcd_draw_rect>
			x -= dw/2; y -= dh/2; ww += dw; hh += dh;
34000a40:	693b      	ldr	r3, [r7, #16]
34000a42:	085b      	lsrs	r3, r3, #1
34000a44:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34000a46:	1ad3      	subs	r3, r2, r3
34000a48:	62fb      	str	r3, [r7, #44]	@ 0x2c
34000a4a:	68fb      	ldr	r3, [r7, #12]
34000a4c:	085b      	lsrs	r3, r3, #1
34000a4e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34000a50:	1ad3      	subs	r3, r2, r3
34000a52:	62bb      	str	r3, [r7, #40]	@ 0x28
34000a54:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34000a56:	693b      	ldr	r3, [r7, #16]
34000a58:	4413      	add	r3, r2
34000a5a:	627b      	str	r3, [r7, #36]	@ 0x24
34000a5c:	6a3a      	ldr	r2, [r7, #32]
34000a5e:	68fb      	ldr	r3, [r7, #12]
34000a60:	4413      	add	r3, r2
34000a62:	623b      	str	r3, [r7, #32]
			tk_dly_tsk(200);
34000a64:	20c8      	movs	r0, #200	@ 0xc8
34000a66:	f00c fe2d 	bl	3400d6c4 <tk_dly_tsk>
		for(UINT i = 0; i<2; i++) {
34000a6a:	69fb      	ldr	r3, [r7, #28]
34000a6c:	3301      	adds	r3, #1
34000a6e:	61fb      	str	r3, [r7, #28]
34000a70:	69fb      	ldr	r3, [r7, #28]
34000a72:	2b01      	cmp	r3, #1
34000a74:	d983      	bls.n	3400097e <task_1+0x13a>
		}
		tk_dly_tsk(500);
34000a76:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
34000a7a:	f00c fe23 	bl	3400d6c4 <tk_dly_tsk>
	while(1) {
34000a7e:	e6f9      	b.n	34000874 <task_1+0x30>
34000a80:	3400fd34 	.word	0x3400fd34
34000a84:	3400fd44 	.word	0x3400fd44
34000a88:	ffff0000 	.word	0xffff0000
34000a8c:	ff0000ff 	.word	0xff0000ff
34000a90:	cccccccd 	.word	0xcccccccd

34000a94 <usermain>:

}

/* usermain関数 */
EXPORT INT usermain(void)
{
34000a94:	b580      	push	{r7, lr}
34000a96:	af00      	add	r7, sp, #0
	tm_putstring((UB*)"Start User-main program.\n");
34000a98:	480a      	ldr	r0, [pc, #40]	@ (34000ac4 <usermain+0x30>)
34000a9a:	f00d fd93 	bl	3400e5c4 <tm_putstring>

	/* Create & Start Tasks */
	tskid_1 = tk_cre_tsk(&ctsk_1);
34000a9e:	480a      	ldr	r0, [pc, #40]	@ (34000ac8 <usermain+0x34>)
34000aa0:	f00c fc50 	bl	3400d344 <tk_cre_tsk>
34000aa4:	4603      	mov	r3, r0
34000aa6:	4a09      	ldr	r2, [pc, #36]	@ (34000acc <usermain+0x38>)
34000aa8:	6013      	str	r3, [r2, #0]
	tk_sta_tsk(tskid_1, 0);
34000aaa:	4b08      	ldr	r3, [pc, #32]	@ (34000acc <usermain+0x38>)
34000aac:	681b      	ldr	r3, [r3, #0]
34000aae:	2100      	movs	r1, #0
34000ab0:	4618      	mov	r0, r3
34000ab2:	f00c fcf5 	bl	3400d4a0 <tk_sta_tsk>

	tk_slp_tsk(TMO_FEVR);
34000ab6:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
34000aba:	f00c fd97 	bl	3400d5ec <tk_slp_tsk>

	return 0;
34000abe:	2300      	movs	r3, #0
}
34000ac0:	4618      	mov	r0, r3
34000ac2:	bd80      	pop	{r7, pc}
34000ac4:	3400fd5c 	.word	0x3400fd5c
34000ac8:	34010154 	.word	0x34010154
34000acc:	3401117c 	.word	0x3401117c

34000ad0 <tliblcd_init>:

 /*
 *  Initialize library
 */
ER tliblcd_init(void)
{
34000ad0:	b580      	push	{r7, lr}
34000ad2:	b082      	sub	sp, #8
34000ad4:	af00      	add	r7, sp, #0
	int32_t	bsp_status;

	bsp_status = BSP_LCD_Init(0, LCD_ORIENTATION_LANDSCAPE);
34000ad6:	2101      	movs	r1, #1
34000ad8:	2000      	movs	r0, #0
34000ada:	f001 f89d 	bl	34001c18 <BSP_LCD_Init>
34000ade:	6078      	str	r0, [r7, #4]
	if(bsp_status!=0) return E_IO;
34000ae0:	687b      	ldr	r3, [r7, #4]
34000ae2:	2b00      	cmp	r3, #0
34000ae4:	d002      	beq.n	34000aec <tliblcd_init+0x1c>
34000ae6:	f06f 0338 	mvn.w	r3, #56	@ 0x38
34000aea:	e01f      	b.n	34000b2c <tliblcd_init+0x5c>

	bsp_status = BSP_LCD_GetXSize(0, &max_x);
34000aec:	4911      	ldr	r1, [pc, #68]	@ (34000b34 <tliblcd_init+0x64>)
34000aee:	2000      	movs	r0, #0
34000af0:	f001 fa46 	bl	34001f80 <BSP_LCD_GetXSize>
34000af4:	6078      	str	r0, [r7, #4]
	if(bsp_status!=0) return E_IO;
34000af6:	687b      	ldr	r3, [r7, #4]
34000af8:	2b00      	cmp	r3, #0
34000afa:	d002      	beq.n	34000b02 <tliblcd_init+0x32>
34000afc:	f06f 0338 	mvn.w	r3, #56	@ 0x38
34000b00:	e014      	b.n	34000b2c <tliblcd_init+0x5c>
	bsp_status = BSP_LCD_GetYSize(0, &max_y);
34000b02:	490d      	ldr	r1, [pc, #52]	@ (34000b38 <tliblcd_init+0x68>)
34000b04:	2000      	movs	r0, #0
34000b06:	f001 fa59 	bl	34001fbc <BSP_LCD_GetYSize>
34000b0a:	6078      	str	r0, [r7, #4]
	if(bsp_status!=0) return E_IO;
34000b0c:	687b      	ldr	r3, [r7, #4]
34000b0e:	2b00      	cmp	r3, #0
34000b10:	d002      	beq.n	34000b18 <tliblcd_init+0x48>
34000b12:	f06f 0338 	mvn.w	r3, #56	@ 0x38
34000b16:	e009      	b.n	34000b2c <tliblcd_init+0x5c>

	lib_semid = tk_cre_sem(&csem);
34000b18:	4808      	ldr	r0, [pc, #32]	@ (34000b3c <tliblcd_init+0x6c>)
34000b1a:	f00b ff63 	bl	3400c9e4 <tk_cre_sem>
34000b1e:	4603      	mov	r3, r0
34000b20:	4a07      	ldr	r2, [pc, #28]	@ (34000b40 <tliblcd_init+0x70>)
34000b22:	6013      	str	r3, [r2, #0]
	return(lib_semid > E_OK? E_OK: (ER)lib_semid);
34000b24:	4b06      	ldr	r3, [pc, #24]	@ (34000b40 <tliblcd_init+0x70>)
34000b26:	681b      	ldr	r3, [r3, #0]
34000b28:	ea03 73e3 	and.w	r3, r3, r3, asr #31
}
34000b2c:	4618      	mov	r0, r3
34000b2e:	3708      	adds	r7, #8
34000b30:	46bd      	mov	sp, r7
34000b32:	bd80      	pop	{r7, pc}
34000b34:	34011184 	.word	0x34011184
34000b38:	34011188 	.word	0x34011188
34000b3c:	3401016c 	.word	0x3401016c
34000b40:	34011180 	.word	0x34011180

34000b44 <tliblcd_get_height>:

/* 
 * Get display size - Height
 */
UW tliblcd_get_height(void)
{
34000b44:	b480      	push	{r7}
34000b46:	af00      	add	r7, sp, #0
	return max_y;
34000b48:	4b03      	ldr	r3, [pc, #12]	@ (34000b58 <tliblcd_get_height+0x14>)
34000b4a:	681b      	ldr	r3, [r3, #0]
}
34000b4c:	4618      	mov	r0, r3
34000b4e:	46bd      	mov	sp, r7
34000b50:	f85d 7b04 	ldr.w	r7, [sp], #4
34000b54:	4770      	bx	lr
34000b56:	bf00      	nop
34000b58:	34011188 	.word	0x34011188

34000b5c <tliblcd_get_width>:

/* 
 * Get display size - Width
 */
UW tliblcd_get_width(void)
{
34000b5c:	b480      	push	{r7}
34000b5e:	af00      	add	r7, sp, #0
	return max_x;
34000b60:	4b03      	ldr	r3, [pc, #12]	@ (34000b70 <tliblcd_get_width+0x14>)
34000b62:	681b      	ldr	r3, [r3, #0]
}
34000b64:	4618      	mov	r0, r3
34000b66:	46bd      	mov	sp, r7
34000b68:	f85d 7b04 	ldr.w	r7, [sp], #4
34000b6c:	4770      	bx	lr
34000b6e:	bf00      	nop
34000b70:	34011184 	.word	0x34011184

34000b74 <tliblcd_onoff_lcd>:

/*
 * LCD ON/OFF
*/
void tliblcd_onoff_lcd(UINT status)
{
34000b74:	b580      	push	{r7, lr}
34000b76:	b084      	sub	sp, #16
34000b78:	af02      	add	r7, sp, #8
34000b7a:	6078      	str	r0, [r7, #4]
	TLIBLCD_LOCK
34000b7c:	4b19      	ldr	r3, [pc, #100]	@ (34000be4 <tliblcd_onoff_lcd+0x70>)
34000b7e:	681b      	ldr	r3, [r3, #0]
34000b80:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
34000b84:	2101      	movs	r1, #1
34000b86:	4618      	mov	r0, r3
34000b88:	f00c f8ce 	bl	3400cd28 <tk_wai_sem>

	if(status == LCD_ON){
34000b8c:	687b      	ldr	r3, [r7, #4]
34000b8e:	2b01      	cmp	r3, #1
34000b90:	d10f      	bne.n	34000bb2 <tliblcd_onoff_lcd+0x3e>
		BSP_LCD_DisplayOn(0);
34000b92:	2000      	movs	r0, #0
34000b94:	f001 fa32 	bl	34001ffc <BSP_LCD_DisplayOn>
		draw_rect (TLIBLCD_COLOR_WHITE, 0, 0, max_x, max_y);
34000b98:	4b13      	ldr	r3, [pc, #76]	@ (34000be8 <tliblcd_onoff_lcd+0x74>)
34000b9a:	681a      	ldr	r2, [r3, #0]
34000b9c:	4b13      	ldr	r3, [pc, #76]	@ (34000bec <tliblcd_onoff_lcd+0x78>)
34000b9e:	681b      	ldr	r3, [r3, #0]
34000ba0:	9300      	str	r3, [sp, #0]
34000ba2:	4613      	mov	r3, r2
34000ba4:	2200      	movs	r2, #0
34000ba6:	2100      	movs	r1, #0
34000ba8:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
34000bac:	f000 f89a 	bl	34000ce4 <draw_rect>
34000bb0:	e00e      	b.n	34000bd0 <tliblcd_onoff_lcd+0x5c>
	} else {
		draw_rect (TLIBLCD_COLOR_BLACK, 0, 0, max_x, max_y);
34000bb2:	4b0d      	ldr	r3, [pc, #52]	@ (34000be8 <tliblcd_onoff_lcd+0x74>)
34000bb4:	681a      	ldr	r2, [r3, #0]
34000bb6:	4b0d      	ldr	r3, [pc, #52]	@ (34000bec <tliblcd_onoff_lcd+0x78>)
34000bb8:	681b      	ldr	r3, [r3, #0]
34000bba:	9300      	str	r3, [sp, #0]
34000bbc:	4613      	mov	r3, r2
34000bbe:	2200      	movs	r2, #0
34000bc0:	2100      	movs	r1, #0
34000bc2:	f04f 407f 	mov.w	r0, #4278190080	@ 0xff000000
34000bc6:	f000 f88d 	bl	34000ce4 <draw_rect>
		BSP_LCD_DisplayOff(0);
34000bca:	2000      	movs	r0, #0
34000bcc:	f001 fa50 	bl	34002070 <BSP_LCD_DisplayOff>
	}

	TLIBLCD_UNLOCK
34000bd0:	4b04      	ldr	r3, [pc, #16]	@ (34000be4 <tliblcd_onoff_lcd+0x70>)
34000bd2:	681b      	ldr	r3, [r3, #0]
34000bd4:	2101      	movs	r1, #1
34000bd6:	4618      	mov	r0, r3
34000bd8:	f00b ffce 	bl	3400cb78 <tk_sig_sem>
}
34000bdc:	bf00      	nop
34000bde:	3708      	adds	r7, #8
34000be0:	46bd      	mov	sp, r7
34000be2:	bd80      	pop	{r7, pc}
34000be4:	34011180 	.word	0x34011180
34000be8:	34011184 	.word	0x34011184
34000bec:	34011188 	.word	0x34011188

34000bf0 <tliblcd_clear_scr>:

/*
 * Clear Screen
*/
void tliblcd_clear_scr(UW color)
{
34000bf0:	b580      	push	{r7, lr}
34000bf2:	b084      	sub	sp, #16
34000bf4:	af02      	add	r7, sp, #8
34000bf6:	6078      	str	r0, [r7, #4]
	TLIBLCD_LOCK
34000bf8:	4b0e      	ldr	r3, [pc, #56]	@ (34000c34 <tliblcd_clear_scr+0x44>)
34000bfa:	681b      	ldr	r3, [r3, #0]
34000bfc:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
34000c00:	2101      	movs	r1, #1
34000c02:	4618      	mov	r0, r3
34000c04:	f00c f890 	bl	3400cd28 <tk_wai_sem>
	draw_rect (color, 0, 0, max_x, max_y);
34000c08:	4b0b      	ldr	r3, [pc, #44]	@ (34000c38 <tliblcd_clear_scr+0x48>)
34000c0a:	681a      	ldr	r2, [r3, #0]
34000c0c:	4b0b      	ldr	r3, [pc, #44]	@ (34000c3c <tliblcd_clear_scr+0x4c>)
34000c0e:	681b      	ldr	r3, [r3, #0]
34000c10:	9300      	str	r3, [sp, #0]
34000c12:	4613      	mov	r3, r2
34000c14:	2200      	movs	r2, #0
34000c16:	2100      	movs	r1, #0
34000c18:	6878      	ldr	r0, [r7, #4]
34000c1a:	f000 f863 	bl	34000ce4 <draw_rect>
	TLIBLCD_UNLOCK
34000c1e:	4b05      	ldr	r3, [pc, #20]	@ (34000c34 <tliblcd_clear_scr+0x44>)
34000c20:	681b      	ldr	r3, [r3, #0]
34000c22:	2101      	movs	r1, #1
34000c24:	4618      	mov	r0, r3
34000c26:	f00b ffa7 	bl	3400cb78 <tk_sig_sem>
}
34000c2a:	bf00      	nop
34000c2c:	3708      	adds	r7, #8
34000c2e:	46bd      	mov	sp, r7
34000c30:	bd80      	pop	{r7, pc}
34000c32:	bf00      	nop
34000c34:	34011180 	.word	0x34011180
34000c38:	34011184 	.word	0x34011184
34000c3c:	34011188 	.word	0x34011188

34000c40 <tliblcd_draw_rect>:

/*
 * Draw a rectangle
 */
void tliblcd_draw_rect(UW color, UW posX, UW posY, UW width, UW height)
{
34000c40:	b580      	push	{r7, lr}
34000c42:	b086      	sub	sp, #24
34000c44:	af02      	add	r7, sp, #8
34000c46:	60f8      	str	r0, [r7, #12]
34000c48:	60b9      	str	r1, [r7, #8]
34000c4a:	607a      	str	r2, [r7, #4]
34000c4c:	603b      	str	r3, [r7, #0]
	if((posX >= max_x)||(posY >= max_y)) return;
34000c4e:	4b22      	ldr	r3, [pc, #136]	@ (34000cd8 <tliblcd_draw_rect+0x98>)
34000c50:	681b      	ldr	r3, [r3, #0]
34000c52:	68ba      	ldr	r2, [r7, #8]
34000c54:	429a      	cmp	r2, r3
34000c56:	d23b      	bcs.n	34000cd0 <tliblcd_draw_rect+0x90>
34000c58:	4b20      	ldr	r3, [pc, #128]	@ (34000cdc <tliblcd_draw_rect+0x9c>)
34000c5a:	681b      	ldr	r3, [r3, #0]
34000c5c:	687a      	ldr	r2, [r7, #4]
34000c5e:	429a      	cmp	r2, r3
34000c60:	d236      	bcs.n	34000cd0 <tliblcd_draw_rect+0x90>

	if(max_x <= (posX + width)) width -= (posX + width)-max_x;
34000c62:	68ba      	ldr	r2, [r7, #8]
34000c64:	683b      	ldr	r3, [r7, #0]
34000c66:	441a      	add	r2, r3
34000c68:	4b1b      	ldr	r3, [pc, #108]	@ (34000cd8 <tliblcd_draw_rect+0x98>)
34000c6a:	681b      	ldr	r3, [r3, #0]
34000c6c:	429a      	cmp	r2, r3
34000c6e:	d308      	bcc.n	34000c82 <tliblcd_draw_rect+0x42>
34000c70:	4b19      	ldr	r3, [pc, #100]	@ (34000cd8 <tliblcd_draw_rect+0x98>)
34000c72:	681a      	ldr	r2, [r3, #0]
34000c74:	68b9      	ldr	r1, [r7, #8]
34000c76:	683b      	ldr	r3, [r7, #0]
34000c78:	440b      	add	r3, r1
34000c7a:	1ad3      	subs	r3, r2, r3
34000c7c:	683a      	ldr	r2, [r7, #0]
34000c7e:	4413      	add	r3, r2
34000c80:	603b      	str	r3, [r7, #0]
	if(max_y <= (posY + height)) height -= (posY + height)-max_y;
34000c82:	687a      	ldr	r2, [r7, #4]
34000c84:	69bb      	ldr	r3, [r7, #24]
34000c86:	441a      	add	r2, r3
34000c88:	4b14      	ldr	r3, [pc, #80]	@ (34000cdc <tliblcd_draw_rect+0x9c>)
34000c8a:	681b      	ldr	r3, [r3, #0]
34000c8c:	429a      	cmp	r2, r3
34000c8e:	d308      	bcc.n	34000ca2 <tliblcd_draw_rect+0x62>
34000c90:	4b12      	ldr	r3, [pc, #72]	@ (34000cdc <tliblcd_draw_rect+0x9c>)
34000c92:	681a      	ldr	r2, [r3, #0]
34000c94:	6879      	ldr	r1, [r7, #4]
34000c96:	69bb      	ldr	r3, [r7, #24]
34000c98:	440b      	add	r3, r1
34000c9a:	1ad3      	subs	r3, r2, r3
34000c9c:	69ba      	ldr	r2, [r7, #24]
34000c9e:	4413      	add	r3, r2
34000ca0:	61bb      	str	r3, [r7, #24]

	TLIBLCD_LOCK
34000ca2:	4b0f      	ldr	r3, [pc, #60]	@ (34000ce0 <tliblcd_draw_rect+0xa0>)
34000ca4:	681b      	ldr	r3, [r3, #0]
34000ca6:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
34000caa:	2101      	movs	r1, #1
34000cac:	4618      	mov	r0, r3
34000cae:	f00c f83b 	bl	3400cd28 <tk_wai_sem>
	draw_rect(color, posX, posY, width, height);
34000cb2:	69bb      	ldr	r3, [r7, #24]
34000cb4:	9300      	str	r3, [sp, #0]
34000cb6:	683b      	ldr	r3, [r7, #0]
34000cb8:	687a      	ldr	r2, [r7, #4]
34000cba:	68b9      	ldr	r1, [r7, #8]
34000cbc:	68f8      	ldr	r0, [r7, #12]
34000cbe:	f000 f811 	bl	34000ce4 <draw_rect>
	TLIBLCD_UNLOCK
34000cc2:	4b07      	ldr	r3, [pc, #28]	@ (34000ce0 <tliblcd_draw_rect+0xa0>)
34000cc4:	681b      	ldr	r3, [r3, #0]
34000cc6:	2101      	movs	r1, #1
34000cc8:	4618      	mov	r0, r3
34000cca:	f00b ff55 	bl	3400cb78 <tk_sig_sem>
34000cce:	e000      	b.n	34000cd2 <tliblcd_draw_rect+0x92>
	if((posX >= max_x)||(posY >= max_y)) return;
34000cd0:	bf00      	nop
}
34000cd2:	3710      	adds	r7, #16
34000cd4:	46bd      	mov	sp, r7
34000cd6:	bd80      	pop	{r7, pc}
34000cd8:	34011184 	.word	0x34011184
34000cdc:	34011188 	.word	0x34011188
34000ce0:	34011180 	.word	0x34011180

34000ce4 <draw_rect>:
#define CONVERTARGB88882RGB565(Color)((((Color & 0xFFU) >> 3) & 0x1FU) |\
                                     (((((Color & 0xFF00U) >> 8) >>2) & 0x3FU) << 5) |\
                                     (((((Color & 0xFF0000U) >> 16) >>3) & 0x1FU) << 11))

LOCAL void draw_rect (UW color, UW posX, UW posY, UW width, UW height)
{
34000ce4:	b580      	push	{r7, lr}
34000ce6:	b086      	sub	sp, #24
34000ce8:	af02      	add	r7, sp, #8
34000cea:	60f8      	str	r0, [r7, #12]
34000cec:	60b9      	str	r1, [r7, #8]
34000cee:	607a      	str	r2, [r7, #4]
34000cf0:	603b      	str	r3, [r7, #0]
	BSP_LCD_FillRect(0, posX, posY, width, height, CONVERTARGB88882RGB565(color));
34000cf2:	68fb      	ldr	r3, [r7, #12]
34000cf4:	08db      	lsrs	r3, r3, #3
34000cf6:	f003 021f 	and.w	r2, r3, #31
34000cfa:	68fb      	ldr	r3, [r7, #12]
34000cfc:	0a9b      	lsrs	r3, r3, #10
34000cfe:	015b      	lsls	r3, r3, #5
34000d00:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
34000d04:	431a      	orrs	r2, r3
34000d06:	68fb      	ldr	r3, [r7, #12]
34000d08:	0cdb      	lsrs	r3, r3, #19
34000d0a:	02db      	lsls	r3, r3, #11
34000d0c:	b29b      	uxth	r3, r3
34000d0e:	4313      	orrs	r3, r2
34000d10:	9301      	str	r3, [sp, #4]
34000d12:	69bb      	ldr	r3, [r7, #24]
34000d14:	9300      	str	r3, [sp, #0]
34000d16:	683b      	ldr	r3, [r7, #0]
34000d18:	687a      	ldr	r2, [r7, #4]
34000d1a:	68b9      	ldr	r1, [r7, #8]
34000d1c:	2000      	movs	r0, #0
34000d1e:	f001 f9e3 	bl	340020e8 <BSP_LCD_FillRect>
34000d22:	bf00      	nop
34000d24:	3710      	adds	r7, #16
34000d26:	46bd      	mov	sp, r7
34000d28:	bd80      	pop	{r7, pc}
	...

34000d2c <LL_AHB3_GRP1_EnableClock>:
  *
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_AHB3_GRP1_EnableClock(uint32_t Periphs)
{
34000d2c:	b480      	push	{r7}
34000d2e:	b085      	sub	sp, #20
34000d30:	af00      	add	r7, sp, #0
34000d32:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB3ENSR, Periphs);
34000d34:	4a07      	ldr	r2, [pc, #28]	@ (34000d54 <LL_AHB3_GRP1_EnableClock+0x28>)
34000d36:	687b      	ldr	r3, [r7, #4]
34000d38:	f8c2 3a58 	str.w	r3, [r2, #2648]	@ 0xa58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB3ENR);
34000d3c:	4b05      	ldr	r3, [pc, #20]	@ (34000d54 <LL_AHB3_GRP1_EnableClock+0x28>)
34000d3e:	f8d3 3258 	ldr.w	r3, [r3, #600]	@ 0x258
34000d42:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34000d44:	68fb      	ldr	r3, [r7, #12]
}
34000d46:	bf00      	nop
34000d48:	3714      	adds	r7, #20
34000d4a:	46bd      	mov	sp, r7
34000d4c:	f85d 7b04 	ldr.w	r7, [sp], #4
34000d50:	4770      	bx	lr
34000d52:	bf00      	nop
34000d54:	56028000 	.word	0x56028000

34000d58 <LL_AHB4_GRP1_EnableClock>:
  *         @arg @ref LL_AHB4_GRP1_PERIPH_PWR
  *         @arg @ref LL_AHB4_GRP1_PERIPH_CRC
  * @retval None
  */
__STATIC_INLINE void LL_AHB4_GRP1_EnableClock(uint32_t Periphs)
{
34000d58:	b480      	push	{r7}
34000d5a:	b085      	sub	sp, #20
34000d5c:	af00      	add	r7, sp, #0
34000d5e:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34000d60:	4a07      	ldr	r2, [pc, #28]	@ (34000d80 <LL_AHB4_GRP1_EnableClock+0x28>)
34000d62:	687b      	ldr	r3, [r7, #4]
34000d64:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->AHB4ENR);
34000d68:	4b05      	ldr	r3, [pc, #20]	@ (34000d80 <LL_AHB4_GRP1_EnableClock+0x28>)
34000d6a:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34000d6e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34000d70:	68fb      	ldr	r3, [r7, #12]
}
34000d72:	bf00      	nop
34000d74:	3714      	adds	r7, #20
34000d76:	46bd      	mov	sp, r7
34000d78:	f85d 7b04 	ldr.w	r7, [sp], #4
34000d7c:	4770      	bx	lr
34000d7e:	bf00      	nop
34000d80:	56028000 	.word	0x56028000

34000d84 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
34000d84:	b580      	push	{r7, lr}
34000d86:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/
  HAL_Init();
34000d88:	f001 fb60 	bl	3400244c <HAL_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
34000d8c:	f000 f954 	bl	34001038 <MX_GPIO_Init>
  MX_ADC1_Init();
34000d90:	f000 f808 	bl	34000da4 <MX_ADC1_Init>
  MX_ADC2_Init();
34000d94:	f000 f89a 	bl	34000ecc <MX_ADC2_Init>
  MX_I2C1_Init();
34000d98:	f000 f90e 	bl	34000fb8 <MX_I2C1_Init>
  /* USER CODE BEGIN 2 */
  /* Start mT-Kernel 3.0 */
  void knl_start_mtkernel(void);
  knl_start_mtkernel();
34000d9c:	f00e f8e4 	bl	3400ef68 <knl_start_mtkernel>
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
34000da0:	bf00      	nop
34000da2:	e7fd      	b.n	34000da0 <main+0x1c>

34000da4 <MX_ADC1_Init>:
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{
34000da4:	b580      	push	{r7, lr}
34000da6:	b092      	sub	sp, #72	@ 0x48
34000da8:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_MultiModeTypeDef multimode = {0};
34000daa:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
34000dae:	2200      	movs	r2, #0
34000db0:	601a      	str	r2, [r3, #0]
34000db2:	605a      	str	r2, [r3, #4]
34000db4:	609a      	str	r2, [r3, #8]
  ADC_ChannelConfTypeDef sConfig = {0};
34000db6:	f107 031c 	add.w	r3, r7, #28
34000dba:	2220      	movs	r2, #32
34000dbc:	2100      	movs	r1, #0
34000dbe:	4618      	mov	r0, r3
34000dc0:	f00e ff80 	bl	3400fcc4 <memset>
  ADC_AnalogWDGConfTypeDef AnalogWDGConfig = {0};
34000dc4:	463b      	mov	r3, r7
34000dc6:	2200      	movs	r2, #0
34000dc8:	601a      	str	r2, [r3, #0]
34000dca:	605a      	str	r2, [r3, #4]
34000dcc:	609a      	str	r2, [r3, #8]
34000dce:	60da      	str	r2, [r3, #12]
34000dd0:	611a      	str	r2, [r3, #16]
34000dd2:	615a      	str	r2, [r3, #20]
34000dd4:	619a      	str	r2, [r3, #24]

  /* USER CODE BEGIN ADC1_Init 1 */
  __HAL_RCC_RIFSC_CLK_ENABLE();
34000dd6:	f44f 7000 	mov.w	r0, #512	@ 0x200
34000dda:	f7ff ffa7 	bl	34000d2c <LL_AHB3_GRP1_EnableClock>
  RIFSC->RISC_SECCFGRx[2] |= 0x1;
34000dde:	4b38      	ldr	r3, [pc, #224]	@ (34000ec0 <MX_ADC1_Init+0x11c>)
34000de0:	699b      	ldr	r3, [r3, #24]
34000de2:	4a37      	ldr	r2, [pc, #220]	@ (34000ec0 <MX_ADC1_Init+0x11c>)
34000de4:	f043 0301 	orr.w	r3, r3, #1
34000de8:	6193      	str	r3, [r2, #24]
  /* USER CODE END ADC1_Init 1 */

  /** Common config
  */
  hadc1.Instance = ADC1;
34000dea:	4b36      	ldr	r3, [pc, #216]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000dec:	4a36      	ldr	r2, [pc, #216]	@ (34000ec8 <MX_ADC1_Init+0x124>)
34000dee:	601a      	str	r2, [r3, #0]
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
34000df0:	4b34      	ldr	r3, [pc, #208]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000df2:	2200      	movs	r2, #0
34000df4:	605a      	str	r2, [r3, #4]
  hadc1.Init.GainCompensation = 0;
34000df6:	4b33      	ldr	r3, [pc, #204]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000df8:	2200      	movs	r2, #0
34000dfa:	609a      	str	r2, [r3, #8]
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
34000dfc:	4b31      	ldr	r3, [pc, #196]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000dfe:	2200      	movs	r2, #0
34000e00:	60da      	str	r2, [r3, #12]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
34000e02:	4b30      	ldr	r3, [pc, #192]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000e04:	2204      	movs	r2, #4
34000e06:	611a      	str	r2, [r3, #16]
  hadc1.Init.LowPowerAutoWait = DISABLE;
34000e08:	4b2e      	ldr	r3, [pc, #184]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000e0a:	2200      	movs	r2, #0
34000e0c:	751a      	strb	r2, [r3, #20]
  hadc1.Init.ContinuousConvMode = DISABLE;
34000e0e:	4b2d      	ldr	r3, [pc, #180]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000e10:	2200      	movs	r2, #0
34000e12:	755a      	strb	r2, [r3, #21]
  hadc1.Init.NbrOfConversion = 1;
34000e14:	4b2b      	ldr	r3, [pc, #172]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000e16:	2201      	movs	r2, #1
34000e18:	619a      	str	r2, [r3, #24]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
34000e1a:	4b2a      	ldr	r3, [pc, #168]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000e1c:	2200      	movs	r2, #0
34000e1e:	771a      	strb	r2, [r3, #28]
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
34000e20:	4b28      	ldr	r3, [pc, #160]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000e22:	2200      	movs	r2, #0
34000e24:	625a      	str	r2, [r3, #36]	@ 0x24
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
34000e26:	4b27      	ldr	r3, [pc, #156]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000e28:	2200      	movs	r2, #0
34000e2a:	629a      	str	r2, [r3, #40]	@ 0x28
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DR;
34000e2c:	4b25      	ldr	r3, [pc, #148]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000e2e:	2200      	movs	r2, #0
34000e30:	631a      	str	r2, [r3, #48]	@ 0x30
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
34000e32:	4b24      	ldr	r3, [pc, #144]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000e34:	2200      	movs	r2, #0
34000e36:	635a      	str	r2, [r3, #52]	@ 0x34
  hadc1.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
34000e38:	4b22      	ldr	r3, [pc, #136]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000e3a:	2200      	movs	r2, #0
34000e3c:	639a      	str	r2, [r3, #56]	@ 0x38
  hadc1.Init.OversamplingMode = DISABLE;
34000e3e:	4b21      	ldr	r3, [pc, #132]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000e40:	2200      	movs	r2, #0
34000e42:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
34000e46:	481f      	ldr	r0, [pc, #124]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000e48:	f002 f852 	bl	34002ef0 <HAL_ADC_Init>
34000e4c:	4603      	mov	r3, r0
34000e4e:	2b00      	cmp	r3, #0
34000e50:	d001      	beq.n	34000e56 <MX_ADC1_Init+0xb2>
  {
    Error_Handler();
34000e52:	f000 f99b 	bl	3400118c <Error_Handler>
  }

  /** Configure the ADC multi-mode
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
34000e56:	2300      	movs	r3, #0
34000e58:	63fb      	str	r3, [r7, #60]	@ 0x3c
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
34000e5a:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
34000e5e:	4619      	mov	r1, r3
34000e60:	4818      	ldr	r0, [pc, #96]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000e62:	f003 fabb 	bl	340043dc <HAL_ADCEx_MultiModeConfigChannel>
34000e66:	4603      	mov	r3, r0
34000e68:	2b00      	cmp	r3, #0
34000e6a:	d001      	beq.n	34000e70 <MX_ADC1_Init+0xcc>
  {
    Error_Handler();
34000e6c:	f000 f98e 	bl	3400118c <Error_Handler>
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_12;
34000e70:	230c      	movs	r3, #12
34000e72:	61fb      	str	r3, [r7, #28]
  sConfig.Rank = ADC_REGULAR_RANK_1;
34000e74:	2306      	movs	r3, #6
34000e76:	623b      	str	r3, [r7, #32]
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
34000e78:	2300      	movs	r3, #0
34000e7a:	627b      	str	r3, [r7, #36]	@ 0x24
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
34000e7c:	f240 33ff 	movw	r3, #1023	@ 0x3ff
34000e80:	62bb      	str	r3, [r7, #40]	@ 0x28
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
34000e82:	2304      	movs	r3, #4
34000e84:	62fb      	str	r3, [r7, #44]	@ 0x2c
  sConfig.Offset = 0;
34000e86:	2300      	movs	r3, #0
34000e88:	633b      	str	r3, [r7, #48]	@ 0x30
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
34000e8a:	f107 031c 	add.w	r3, r7, #28
34000e8e:	4619      	mov	r1, r3
34000e90:	480c      	ldr	r0, [pc, #48]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000e92:	f002 fcbf 	bl	34003814 <HAL_ADC_ConfigChannel>
34000e96:	4603      	mov	r3, r0
34000e98:	2b00      	cmp	r3, #0
34000e9a:	d001      	beq.n	34000ea0 <MX_ADC1_Init+0xfc>
  {
    Error_Handler();
34000e9c:	f000 f976 	bl	3400118c <Error_Handler>
  }

  /** Configure the regular channel to be monitored by WatchDog 2 or 3
  */
  AnalogWDGConfig.FilteringConfig = ADC_AWD_FILTERING_NONE;
34000ea0:	2300      	movs	r3, #0
34000ea2:	61bb      	str	r3, [r7, #24]

  if (HAL_ADC_AnalogWDGConfig(&hadc1, &AnalogWDGConfig) != HAL_OK)
34000ea4:	463b      	mov	r3, r7
34000ea6:	4619      	mov	r1, r3
34000ea8:	4806      	ldr	r0, [pc, #24]	@ (34000ec4 <MX_ADC1_Init+0x120>)
34000eaa:	f002 feb5 	bl	34003c18 <HAL_ADC_AnalogWDGConfig>
34000eae:	4603      	mov	r3, r0
34000eb0:	2b00      	cmp	r3, #0
34000eb2:	d001      	beq.n	34000eb8 <MX_ADC1_Init+0x114>
  {
    Error_Handler();
34000eb4:	f000 f96a 	bl	3400118c <Error_Handler>
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}
34000eb8:	bf00      	nop
34000eba:	3748      	adds	r7, #72	@ 0x48
34000ebc:	46bd      	mov	sp, r7
34000ebe:	bd80      	pop	{r7, pc}
34000ec0:	54024000 	.word	0x54024000
34000ec4:	3401118c 	.word	0x3401118c
34000ec8:	50022000 	.word	0x50022000

34000ecc <MX_ADC2_Init>:
  * @brief ADC2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC2_Init(void)
{
34000ecc:	b580      	push	{r7, lr}
34000ece:	b090      	sub	sp, #64	@ 0x40
34000ed0:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC2_Init 0 */

  /* USER CODE END ADC2_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};
34000ed2:	f107 0320 	add.w	r3, r7, #32
34000ed6:	2220      	movs	r2, #32
34000ed8:	2100      	movs	r1, #0
34000eda:	4618      	mov	r0, r3
34000edc:	f00e fef2 	bl	3400fcc4 <memset>
  ADC_AnalogWDGConfTypeDef AnalogWDGConfig = {0};
34000ee0:	1d3b      	adds	r3, r7, #4
34000ee2:	2200      	movs	r2, #0
34000ee4:	601a      	str	r2, [r3, #0]
34000ee6:	605a      	str	r2, [r3, #4]
34000ee8:	609a      	str	r2, [r3, #8]
34000eea:	60da      	str	r2, [r3, #12]
34000eec:	611a      	str	r2, [r3, #16]
34000eee:	615a      	str	r2, [r3, #20]
34000ef0:	619a      	str	r2, [r3, #24]

  /* USER CODE END ADC2_Init 1 */

  /** Common config
  */
  hadc2.Instance = ADC2;
34000ef2:	4b2f      	ldr	r3, [pc, #188]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000ef4:	4a2f      	ldr	r2, [pc, #188]	@ (34000fb4 <MX_ADC2_Init+0xe8>)
34000ef6:	601a      	str	r2, [r3, #0]
  hadc2.Init.Resolution = ADC_RESOLUTION_12B;
34000ef8:	4b2d      	ldr	r3, [pc, #180]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000efa:	2200      	movs	r2, #0
34000efc:	605a      	str	r2, [r3, #4]
  hadc2.Init.GainCompensation = 0;
34000efe:	4b2c      	ldr	r3, [pc, #176]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000f00:	2200      	movs	r2, #0
34000f02:	609a      	str	r2, [r3, #8]
  hadc2.Init.ScanConvMode = ADC_SCAN_DISABLE;
34000f04:	4b2a      	ldr	r3, [pc, #168]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000f06:	2200      	movs	r2, #0
34000f08:	60da      	str	r2, [r3, #12]
  hadc2.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
34000f0a:	4b29      	ldr	r3, [pc, #164]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000f0c:	2204      	movs	r2, #4
34000f0e:	611a      	str	r2, [r3, #16]
  hadc2.Init.LowPowerAutoWait = DISABLE;
34000f10:	4b27      	ldr	r3, [pc, #156]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000f12:	2200      	movs	r2, #0
34000f14:	751a      	strb	r2, [r3, #20]
  hadc2.Init.ContinuousConvMode = DISABLE;
34000f16:	4b26      	ldr	r3, [pc, #152]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000f18:	2200      	movs	r2, #0
34000f1a:	755a      	strb	r2, [r3, #21]
  hadc2.Init.NbrOfConversion = 1;
34000f1c:	4b24      	ldr	r3, [pc, #144]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000f1e:	2201      	movs	r2, #1
34000f20:	619a      	str	r2, [r3, #24]
  hadc2.Init.DiscontinuousConvMode = DISABLE;
34000f22:	4b23      	ldr	r3, [pc, #140]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000f24:	2200      	movs	r2, #0
34000f26:	771a      	strb	r2, [r3, #28]
  hadc2.Init.ExternalTrigConv = ADC_SOFTWARE_START;
34000f28:	4b21      	ldr	r3, [pc, #132]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000f2a:	2200      	movs	r2, #0
34000f2c:	625a      	str	r2, [r3, #36]	@ 0x24
  hadc2.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
34000f2e:	4b20      	ldr	r3, [pc, #128]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000f30:	2200      	movs	r2, #0
34000f32:	629a      	str	r2, [r3, #40]	@ 0x28
  hadc2.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DR;
34000f34:	4b1e      	ldr	r3, [pc, #120]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000f36:	2200      	movs	r2, #0
34000f38:	631a      	str	r2, [r3, #48]	@ 0x30
  hadc2.Init.Overrun = ADC_OVR_DATA_PRESERVED;
34000f3a:	4b1d      	ldr	r3, [pc, #116]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000f3c:	2200      	movs	r2, #0
34000f3e:	635a      	str	r2, [r3, #52]	@ 0x34
  hadc2.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
34000f40:	4b1b      	ldr	r3, [pc, #108]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000f42:	2200      	movs	r2, #0
34000f44:	639a      	str	r2, [r3, #56]	@ 0x38
  hadc2.Init.OversamplingMode = DISABLE;
34000f46:	4b1a      	ldr	r3, [pc, #104]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000f48:	2200      	movs	r2, #0
34000f4a:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
  if (HAL_ADC_Init(&hadc2) != HAL_OK)
34000f4e:	4818      	ldr	r0, [pc, #96]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000f50:	f001 ffce 	bl	34002ef0 <HAL_ADC_Init>
34000f54:	4603      	mov	r3, r0
34000f56:	2b00      	cmp	r3, #0
34000f58:	d001      	beq.n	34000f5e <MX_ADC2_Init+0x92>
  {
    Error_Handler();
34000f5a:	f000 f917 	bl	3400118c <Error_Handler>
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_18;
34000f5e:	2312      	movs	r3, #18
34000f60:	623b      	str	r3, [r7, #32]
  sConfig.Rank = ADC_REGULAR_RANK_1;
34000f62:	2306      	movs	r3, #6
34000f64:	627b      	str	r3, [r7, #36]	@ 0x24
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
34000f66:	2300      	movs	r3, #0
34000f68:	62bb      	str	r3, [r7, #40]	@ 0x28
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
34000f6a:	f240 33ff 	movw	r3, #1023	@ 0x3ff
34000f6e:	62fb      	str	r3, [r7, #44]	@ 0x2c
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
34000f70:	2304      	movs	r3, #4
34000f72:	633b      	str	r3, [r7, #48]	@ 0x30
  sConfig.Offset = 0;
34000f74:	2300      	movs	r3, #0
34000f76:	637b      	str	r3, [r7, #52]	@ 0x34
  if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK)
34000f78:	f107 0320 	add.w	r3, r7, #32
34000f7c:	4619      	mov	r1, r3
34000f7e:	480c      	ldr	r0, [pc, #48]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000f80:	f002 fc48 	bl	34003814 <HAL_ADC_ConfigChannel>
34000f84:	4603      	mov	r3, r0
34000f86:	2b00      	cmp	r3, #0
34000f88:	d001      	beq.n	34000f8e <MX_ADC2_Init+0xc2>
  {
    Error_Handler();
34000f8a:	f000 f8ff 	bl	3400118c <Error_Handler>
  }

  /** Configure the regular channel to be monitored by WatchDog 2 or 3
  */
  AnalogWDGConfig.FilteringConfig = ADC_AWD_FILTERING_NONE;
34000f8e:	2300      	movs	r3, #0
34000f90:	61fb      	str	r3, [r7, #28]

  if (HAL_ADC_AnalogWDGConfig(&hadc2, &AnalogWDGConfig) != HAL_OK)
34000f92:	1d3b      	adds	r3, r7, #4
34000f94:	4619      	mov	r1, r3
34000f96:	4806      	ldr	r0, [pc, #24]	@ (34000fb0 <MX_ADC2_Init+0xe4>)
34000f98:	f002 fe3e 	bl	34003c18 <HAL_ADC_AnalogWDGConfig>
34000f9c:	4603      	mov	r3, r0
34000f9e:	2b00      	cmp	r3, #0
34000fa0:	d001      	beq.n	34000fa6 <MX_ADC2_Init+0xda>
  {
    Error_Handler();
34000fa2:	f000 f8f3 	bl	3400118c <Error_Handler>
  }
  /* USER CODE BEGIN ADC2_Init 2 */

  /* USER CODE END ADC2_Init 2 */

}
34000fa6:	bf00      	nop
34000fa8:	3740      	adds	r7, #64	@ 0x40
34000faa:	46bd      	mov	sp, r7
34000fac:	bd80      	pop	{r7, pc}
34000fae:	bf00      	nop
34000fb0:	340111ec 	.word	0x340111ec
34000fb4:	50022100 	.word	0x50022100

34000fb8 <MX_I2C1_Init>:
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{
34000fb8:	b580      	push	{r7, lr}
34000fba:	af00      	add	r7, sp, #0
  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
34000fbc:	4b1b      	ldr	r3, [pc, #108]	@ (3400102c <MX_I2C1_Init+0x74>)
34000fbe:	4a1c      	ldr	r2, [pc, #112]	@ (34001030 <MX_I2C1_Init+0x78>)
34000fc0:	601a      	str	r2, [r3, #0]
  hi2c1.Init.Timing = 0x30C0EDFF;
34000fc2:	4b1a      	ldr	r3, [pc, #104]	@ (3400102c <MX_I2C1_Init+0x74>)
34000fc4:	4a1b      	ldr	r2, [pc, #108]	@ (34001034 <MX_I2C1_Init+0x7c>)
34000fc6:	605a      	str	r2, [r3, #4]
  hi2c1.Init.OwnAddress1 = 0;
34000fc8:	4b18      	ldr	r3, [pc, #96]	@ (3400102c <MX_I2C1_Init+0x74>)
34000fca:	2200      	movs	r2, #0
34000fcc:	609a      	str	r2, [r3, #8]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
34000fce:	4b17      	ldr	r3, [pc, #92]	@ (3400102c <MX_I2C1_Init+0x74>)
34000fd0:	2201      	movs	r2, #1
34000fd2:	60da      	str	r2, [r3, #12]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
34000fd4:	4b15      	ldr	r3, [pc, #84]	@ (3400102c <MX_I2C1_Init+0x74>)
34000fd6:	2200      	movs	r2, #0
34000fd8:	611a      	str	r2, [r3, #16]
  hi2c1.Init.OwnAddress2 = 0;
34000fda:	4b14      	ldr	r3, [pc, #80]	@ (3400102c <MX_I2C1_Init+0x74>)
34000fdc:	2200      	movs	r2, #0
34000fde:	615a      	str	r2, [r3, #20]
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
34000fe0:	4b12      	ldr	r3, [pc, #72]	@ (3400102c <MX_I2C1_Init+0x74>)
34000fe2:	2200      	movs	r2, #0
34000fe4:	619a      	str	r2, [r3, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
34000fe6:	4b11      	ldr	r3, [pc, #68]	@ (3400102c <MX_I2C1_Init+0x74>)
34000fe8:	2200      	movs	r2, #0
34000fea:	61da      	str	r2, [r3, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
34000fec:	4b0f      	ldr	r3, [pc, #60]	@ (3400102c <MX_I2C1_Init+0x74>)
34000fee:	2200      	movs	r2, #0
34000ff0:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
34000ff2:	480e      	ldr	r0, [pc, #56]	@ (3400102c <MX_I2C1_Init+0x74>)
34000ff4:	f003 ffea 	bl	34004fcc <HAL_I2C_Init>
34000ff8:	4603      	mov	r3, r0
34000ffa:	2b00      	cmp	r3, #0
34000ffc:	d001      	beq.n	34001002 <MX_I2C1_Init+0x4a>
  {
    Error_Handler();
34000ffe:	f000 f8c5 	bl	3400118c <Error_Handler>
  }

  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
34001002:	2100      	movs	r1, #0
34001004:	4809      	ldr	r0, [pc, #36]	@ (3400102c <MX_I2C1_Init+0x74>)
34001006:	f005 fe19 	bl	34006c3c <HAL_I2CEx_ConfigAnalogFilter>
3400100a:	4603      	mov	r3, r0
3400100c:	2b00      	cmp	r3, #0
3400100e:	d001      	beq.n	34001014 <MX_I2C1_Init+0x5c>
  {
    Error_Handler();
34001010:	f000 f8bc 	bl	3400118c <Error_Handler>
  }

  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
34001014:	2100      	movs	r1, #0
34001016:	4805      	ldr	r0, [pc, #20]	@ (3400102c <MX_I2C1_Init+0x74>)
34001018:	f005 fe5b 	bl	34006cd2 <HAL_I2CEx_ConfigDigitalFilter>
3400101c:	4603      	mov	r3, r0
3400101e:	2b00      	cmp	r3, #0
34001020:	d001      	beq.n	34001026 <MX_I2C1_Init+0x6e>
  {
    Error_Handler();
34001022:	f000 f8b3 	bl	3400118c <Error_Handler>
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}
34001026:	bf00      	nop
34001028:	bd80      	pop	{r7, pc}
3400102a:	bf00      	nop
3400102c:	3401124c 	.word	0x3401124c
34001030:	50005400 	.word	0x50005400
34001034:	30c0edff 	.word	0x30c0edff

34001038 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
34001038:	b580      	push	{r7, lr}
3400103a:	b086      	sub	sp, #24
3400103c:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
3400103e:	1d3b      	adds	r3, r7, #4
34001040:	2200      	movs	r2, #0
34001042:	601a      	str	r2, [r3, #0]
34001044:	605a      	str	r2, [r3, #4]
34001046:	609a      	str	r2, [r3, #8]
34001048:	60da      	str	r2, [r3, #12]
3400104a:	611a      	str	r2, [r3, #16]
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
3400104c:	2004      	movs	r0, #4
3400104e:	f7ff fe83 	bl	34000d58 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOH_CLK_ENABLE();
34001052:	2080      	movs	r0, #128	@ 0x80
34001054:	f7ff fe80 	bl	34000d58 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOD_CLK_ENABLE();
34001058:	2008      	movs	r0, #8
3400105a:	f7ff fe7d 	bl	34000d58 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOB_CLK_ENABLE();
3400105e:	2002      	movs	r0, #2
34001060:	f7ff fe7a 	bl	34000d58 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOE_CLK_ENABLE();
34001064:	2010      	movs	r0, #16
34001066:	f7ff fe77 	bl	34000d58 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOO_CLK_ENABLE();
3400106a:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
3400106e:	f7ff fe73 	bl	34000d58 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOG_CLK_ENABLE();
34001072:	2040      	movs	r0, #64	@ 0x40
34001074:	f7ff fe70 	bl	34000d58 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOF_CLK_ENABLE();
34001078:	2020      	movs	r0, #32
3400107a:	f7ff fe6d 	bl	34000d58 <LL_AHB4_GRP1_EnableClock>
  __HAL_RCC_GPIOA_CLK_ENABLE();
3400107e:	2001      	movs	r0, #1
34001080:	f7ff fe6a 	bl	34000d58 <LL_AHB4_GRP1_EnableClock>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOO, GPIO_PIN_1, GPIO_PIN_RESET);
34001084:	2200      	movs	r2, #0
34001086:	2102      	movs	r1, #2
34001088:	4839      	ldr	r0, [pc, #228]	@ (34001170 <MX_GPIO_Init+0x138>)
3400108a:	f003 ff87 	bl	34004f9c <HAL_GPIO_WritePin>

  /*Configure GPIO pins : LCD_B4_Pin LCD_B5_Pin LCD_R4_Pin */
  GPIO_InitStruct.Pin = LCD_B4_Pin|LCD_B5_Pin|LCD_R4_Pin;
3400108e:	2358      	movs	r3, #88	@ 0x58
34001090:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
34001092:	2302      	movs	r3, #2
34001094:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
34001096:	2300      	movs	r3, #0
34001098:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
3400109a:	2300      	movs	r3, #0
3400109c:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
3400109e:	230e      	movs	r3, #14
340010a0:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
340010a2:	1d3b      	adds	r3, r7, #4
340010a4:	4619      	mov	r1, r3
340010a6:	4833      	ldr	r0, [pc, #204]	@ (34001174 <MX_GPIO_Init+0x13c>)
340010a8:	f003 fdc6 	bl	34004c38 <HAL_GPIO_Init>

  /*Configure GPIO pins : LCD_R2_Pin LCD_R7_Pin LCD_R1_Pin */
  GPIO_InitStruct.Pin = LCD_R2_Pin|LCD_R7_Pin|LCD_R1_Pin;
340010ac:	f44f 4303 	mov.w	r3, #33536	@ 0x8300
340010b0:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
340010b2:	2302      	movs	r3, #2
340010b4:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
340010b6:	2300      	movs	r3, #0
340010b8:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
340010ba:	2300      	movs	r3, #0
340010bc:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
340010be:	230e      	movs	r3, #14
340010c0:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
340010c2:	1d3b      	adds	r3, r7, #4
340010c4:	4619      	mov	r1, r3
340010c6:	482c      	ldr	r0, [pc, #176]	@ (34001178 <MX_GPIO_Init+0x140>)
340010c8:	f003 fdb6 	bl	34004c38 <HAL_GPIO_Init>

  /*Configure GPIO pins : LCD_HSYNC_Pin LCD_B2_Pin LCD_G4_Pin LCD_G6_Pin
                           LCD_G5_Pin LCD_R3_Pin */
  GPIO_InitStruct.Pin = LCD_HSYNC_Pin|LCD_B2_Pin|LCD_G4_Pin|LCD_G6_Pin
340010cc:	f64d 0314 	movw	r3, #55316	@ 0xd814
340010d0:	607b      	str	r3, [r7, #4]
                          |LCD_G5_Pin|LCD_R3_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
340010d2:	2302      	movs	r3, #2
340010d4:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
340010d6:	2300      	movs	r3, #0
340010d8:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
340010da:	2300      	movs	r3, #0
340010dc:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
340010de:	230e      	movs	r3, #14
340010e0:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
340010e2:	1d3b      	adds	r3, r7, #4
340010e4:	4619      	mov	r1, r3
340010e6:	4825      	ldr	r0, [pc, #148]	@ (3400117c <MX_GPIO_Init+0x144>)
340010e8:	f003 fda6 	bl	34004c38 <HAL_GPIO_Init>

  /*Configure GPIO pin : LCD_VSYNC_Pin */
  GPIO_InitStruct.Pin = LCD_VSYNC_Pin;
340010ec:	f44f 6300 	mov.w	r3, #2048	@ 0x800
340010f0:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
340010f2:	2302      	movs	r3, #2
340010f4:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
340010f6:	2300      	movs	r3, #0
340010f8:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
340010fa:	2300      	movs	r3, #0
340010fc:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
340010fe:	230e      	movs	r3, #14
34001100:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(LCD_VSYNC_GPIO_Port, &GPIO_InitStruct);
34001102:	1d3b      	adds	r3, r7, #4
34001104:	4619      	mov	r1, r3
34001106:	481e      	ldr	r0, [pc, #120]	@ (34001180 <MX_GPIO_Init+0x148>)
34001108:	f003 fd96 	bl	34004c38 <HAL_GPIO_Init>

  /*Configure GPIO pin : PO1 */
  GPIO_InitStruct.Pin = GPIO_PIN_1;
3400110c:	2302      	movs	r3, #2
3400110e:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
34001110:	2301      	movs	r3, #1
34001112:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
34001114:	2300      	movs	r3, #0
34001116:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34001118:	2300      	movs	r3, #0
3400111a:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(GPIOO, &GPIO_InitStruct);
3400111c:	1d3b      	adds	r3, r7, #4
3400111e:	4619      	mov	r1, r3
34001120:	4813      	ldr	r0, [pc, #76]	@ (34001170 <MX_GPIO_Init+0x138>)
34001122:	f003 fd89 	bl	34004c38 <HAL_GPIO_Init>

  /*Configure GPIO pins : LCD_B3_Pin LCD_B0_Pin LCD_G1_Pin LCD_R0_Pin
                           LCD_G0_Pin LCd_G7_Pin LCD_DE_Pin LCD_R6_Pin */
  GPIO_InitStruct.Pin = LCD_B3_Pin|LCD_B0_Pin|LCD_G1_Pin|LCD_R0_Pin
34001126:	f64b 1343 	movw	r3, #47427	@ 0xb943
3400112a:	607b      	str	r3, [r7, #4]
                          |LCD_G0_Pin|LCd_G7_Pin|LCD_DE_Pin|LCD_R6_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
3400112c:	2302      	movs	r3, #2
3400112e:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
34001130:	2300      	movs	r3, #0
34001132:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34001134:	2300      	movs	r3, #0
34001136:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
34001138:	230e      	movs	r3, #14
3400113a:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
3400113c:	1d3b      	adds	r3, r7, #4
3400113e:	4619      	mov	r1, r3
34001140:	4810      	ldr	r0, [pc, #64]	@ (34001184 <MX_GPIO_Init+0x14c>)
34001142:	f003 fd79 	bl	34004c38 <HAL_GPIO_Init>

  /*Configure GPIO pins : LCD_G2_Pin LCD_R5_Pin LCD_B1_Pin LCD_B7_Pin
                           LCD_B6_Pin LCD_G3_Pin */
  GPIO_InitStruct.Pin = LCD_G2_Pin|LCD_R5_Pin|LCD_B1_Pin|LCD_B7_Pin
34001146:	f248 1387 	movw	r3, #33159	@ 0x8187
3400114a:	607b      	str	r3, [r7, #4]
                          |LCD_B6_Pin|LCD_G3_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
3400114c:	2302      	movs	r3, #2
3400114e:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
34001150:	2300      	movs	r3, #0
34001152:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34001154:	2300      	movs	r3, #0
34001156:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF14_LCD;
34001158:	230e      	movs	r3, #14
3400115a:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
3400115c:	1d3b      	adds	r3, r7, #4
3400115e:	4619      	mov	r1, r3
34001160:	4809      	ldr	r0, [pc, #36]	@ (34001188 <MX_GPIO_Init+0x150>)
34001162:	f003 fd69 	bl	34004c38 <HAL_GPIO_Init>

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}
34001166:	bf00      	nop
34001168:	3718      	adds	r7, #24
3400116a:	46bd      	mov	sp, r7
3400116c:	bd80      	pop	{r7, pc}
3400116e:	bf00      	nop
34001170:	56023800 	.word	0x56023800
34001174:	56021c00 	.word	0x56021c00
34001178:	56020c00 	.word	0x56020c00
3400117c:	56020400 	.word	0x56020400
34001180:	56021000 	.word	0x56021000
34001184:	56021800 	.word	0x56021800
34001188:	56020000 	.word	0x56020000

3400118c <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
3400118c:	b480      	push	{r7}
3400118e:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
34001190:	b672      	cpsid	i
}
34001192:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
34001194:	bf00      	nop
34001196:	e7fd      	b.n	34001194 <Error_Handler+0x8>

34001198 <__acle_se_SECURE_RegisterCallback>:
  * @param  CallbackId  callback identifier
  * @param  func        pointer to non-secure function
  * @retval None
  */
CMSE_NS_ENTRY void SECURE_RegisterCallback(SECURE_CallbackIDTypeDef CallbackId, void *func)
{
34001198:	b2c0      	uxtb	r0, r0
3400119a:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
3400119e:	b480      	push	{r7}
340011a0:	b082      	sub	sp, #8
340011a2:	af00      	add	r7, sp, #0
340011a4:	4603      	mov	r3, r0
340011a6:	6039      	str	r1, [r7, #0]
340011a8:	71fb      	strb	r3, [r7, #7]
  if(func != NULL)
340011aa:	683b      	ldr	r3, [r7, #0]
340011ac:	2b00      	cmp	r3, #0
340011ae:	d00d      	beq.n	340011cc <__acle_se_SECURE_RegisterCallback+0x34>
  {
    switch(CallbackId)
340011b0:	79fb      	ldrb	r3, [r7, #7]
340011b2:	2b00      	cmp	r3, #0
340011b4:	d002      	beq.n	340011bc <__acle_se_SECURE_RegisterCallback+0x24>
340011b6:	2b01      	cmp	r3, #1
340011b8:	d004      	beq.n	340011c4 <__acle_se_SECURE_RegisterCallback+0x2c>
      case GTZC_ERROR_CB_ID:             /* GTZC Interrupt occurred */
        pSecureErrorCallback = func;
        break;
      default:
        /* unknown */
        break;
340011ba:	e007      	b.n	340011cc <__acle_se_SECURE_RegisterCallback+0x34>
        pSecureFaultCallback = func;
340011bc:	4a09      	ldr	r2, [pc, #36]	@ (340011e4 <__acle_se_SECURE_RegisterCallback+0x4c>)
340011be:	683b      	ldr	r3, [r7, #0]
340011c0:	6013      	str	r3, [r2, #0]
        break;
340011c2:	e003      	b.n	340011cc <__acle_se_SECURE_RegisterCallback+0x34>
        pSecureErrorCallback = func;
340011c4:	4a08      	ldr	r2, [pc, #32]	@ (340011e8 <__acle_se_SECURE_RegisterCallback+0x50>)
340011c6:	683b      	ldr	r3, [r7, #0]
340011c8:	6013      	str	r3, [r2, #0]
        break;
340011ca:	bf00      	nop
    }
  }
}
340011cc:	bf00      	nop
340011ce:	3708      	adds	r7, #8
340011d0:	46bd      	mov	sp, r7
340011d2:	f85d 7b04 	ldr.w	r7, [sp], #4
340011d6:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
340011da:	e89f 900f 	clrm	{r0, r1, r2, r3, ip, APSR}
340011de:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
340011e2:	4774      	bxns	lr
340011e4:	340112a0 	.word	0x340112a0
340011e8:	340112a4 	.word	0x340112a4

340011ec <LL_AHB1_GRP1_EnableClock>:
{
340011ec:	b480      	push	{r7}
340011ee:	b085      	sub	sp, #20
340011f0:	af00      	add	r7, sp, #0
340011f2:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB1ENSR, Periphs);
340011f4:	4a07      	ldr	r2, [pc, #28]	@ (34001214 <LL_AHB1_GRP1_EnableClock+0x28>)
340011f6:	687b      	ldr	r3, [r7, #4]
340011f8:	f8c2 3a50 	str.w	r3, [r2, #2640]	@ 0xa50
  tmpreg = READ_REG(RCC->AHB1ENR);
340011fc:	4b05      	ldr	r3, [pc, #20]	@ (34001214 <LL_AHB1_GRP1_EnableClock+0x28>)
340011fe:	f8d3 3250 	ldr.w	r3, [r3, #592]	@ 0x250
34001202:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34001204:	68fb      	ldr	r3, [r7, #12]
}
34001206:	bf00      	nop
34001208:	3714      	adds	r7, #20
3400120a:	46bd      	mov	sp, r7
3400120c:	f85d 7b04 	ldr.w	r7, [sp], #4
34001210:	4770      	bx	lr
34001212:	bf00      	nop
34001214:	56028000 	.word	0x56028000

34001218 <LL_AHB4_GRP1_EnableClock>:
{
34001218:	b480      	push	{r7}
3400121a:	b085      	sub	sp, #20
3400121c:	af00      	add	r7, sp, #0
3400121e:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34001220:	4a07      	ldr	r2, [pc, #28]	@ (34001240 <LL_AHB4_GRP1_EnableClock+0x28>)
34001222:	687b      	ldr	r3, [r7, #4]
34001224:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34001228:	4b05      	ldr	r3, [pc, #20]	@ (34001240 <LL_AHB4_GRP1_EnableClock+0x28>)
3400122a:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
3400122e:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34001230:	68fb      	ldr	r3, [r7, #12]
}
34001232:	bf00      	nop
34001234:	3714      	adds	r7, #20
34001236:	46bd      	mov	sp, r7
34001238:	f85d 7b04 	ldr.w	r7, [sp], #4
3400123c:	4770      	bx	lr
3400123e:	bf00      	nop
34001240:	56028000 	.word	0x56028000

34001244 <LL_APB1_GRP1_EnableClock>:
  *         @arg @ref LL_APB1_GRP1_PERIPH_UART8
  *         @arg @ref LL_APB1_GRP1_PERIPH_WWDG
  * @retval None
  */
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
34001244:	b480      	push	{r7}
34001246:	b085      	sub	sp, #20
34001248:	af00      	add	r7, sp, #0
3400124a:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB1ENSR1, Periphs);
3400124c:	4a07      	ldr	r2, [pc, #28]	@ (3400126c <LL_APB1_GRP1_EnableClock+0x28>)
3400124e:	687b      	ldr	r3, [r7, #4]
34001250:	f8c2 3a64 	str.w	r3, [r2, #2660]	@ 0xa64
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB1ENR1);
34001254:	4b05      	ldr	r3, [pc, #20]	@ (3400126c <LL_APB1_GRP1_EnableClock+0x28>)
34001256:	f8d3 3264 	ldr.w	r3, [r3, #612]	@ 0x264
3400125a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
3400125c:	68fb      	ldr	r3, [r7, #12]
}
3400125e:	bf00      	nop
34001260:	3714      	adds	r7, #20
34001262:	46bd      	mov	sp, r7
34001264:	f85d 7b04 	ldr.w	r7, [sp], #4
34001268:	4770      	bx	lr
3400126a:	bf00      	nop
3400126c:	56028000 	.word	0x56028000

34001270 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
34001270:	b580      	push	{r7, lr}
34001272:	af00      	add	r7, sp, #0

  /* USER CODE END MspInit 0 */

  /* System interrupt init*/

  HAL_PWREx_EnableVddIO2();
34001274:	f006 fecc 	bl	34008010 <HAL_PWREx_EnableVddIO2>

  HAL_PWREx_EnableVddIO3();
34001278:	f006 feda 	bl	34008030 <HAL_PWREx_EnableVddIO3>

  HAL_PWREx_EnableVddIO4();
3400127c:	f006 fee8 	bl	34008050 <HAL_PWREx_EnableVddIO4>

  HAL_PWREx_EnableVddIO5();
34001280:	f006 fef6 	bl	34008070 <HAL_PWREx_EnableVddIO5>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
34001284:	bf00      	nop
34001286:	bd80      	pop	{r7, pc}

34001288 <HAL_ADC_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hadc: ADC handle pointer
  * @retval None
  */
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
34001288:	b580      	push	{r7, lr}
3400128a:	b0ec      	sub	sp, #432	@ 0x1b0
3400128c:	af00      	add	r7, sp, #0
3400128e:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34001292:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34001296:	6018      	str	r0, [r3, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
34001298:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
3400129c:	2200      	movs	r2, #0
3400129e:	601a      	str	r2, [r3, #0]
340012a0:	605a      	str	r2, [r3, #4]
340012a2:	609a      	str	r2, [r3, #8]
340012a4:	60da      	str	r2, [r3, #12]
340012a6:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
340012a8:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340012ac:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
340012b0:	4618      	mov	r0, r3
340012b2:	f44f 73c8 	mov.w	r3, #400	@ 0x190
340012b6:	461a      	mov	r2, r3
340012b8:	2100      	movs	r1, #0
340012ba:	f00e fd03 	bl	3400fcc4 <memset>
  if(hadc->Instance==ADC1)
340012be:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340012c2:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
340012c6:	681b      	ldr	r3, [r3, #0]
340012c8:	681b      	ldr	r3, [r3, #0]
340012ca:	4a64      	ldr	r2, [pc, #400]	@ (3400145c <HAL_ADC_MspInit+0x1d4>)
340012cc:	4293      	cmp	r3, r2
340012ce:	d16e      	bne.n	340013ae <HAL_ADC_MspInit+0x126>

    /* USER CODE END ADC1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_ADC;
340012d0:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340012d4:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
340012d8:	f04f 0201 	mov.w	r2, #1
340012dc:	f04f 0300 	mov.w	r3, #0
340012e0:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_HCLK;
340012e4:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340012e8:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
340012ec:	2200      	movs	r2, #0
340012ee:	f8c3 20bc 	str.w	r2, [r3, #188]	@ 0xbc
    PeriphClkInitStruct.AdcDivider = 2;
340012f2:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340012f6:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
340012fa:	2202      	movs	r2, #2
340012fc:	f8c3 20c0 	str.w	r2, [r3, #192]	@ 0xc0
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
34001300:	f107 0308 	add.w	r3, r7, #8
34001304:	4618      	mov	r0, r3
34001306:	f007 fa01 	bl	3400870c <HAL_RCCEx_PeriphCLKConfig>
3400130a:	4603      	mov	r3, r0
3400130c:	2b00      	cmp	r3, #0
3400130e:	d001      	beq.n	34001314 <HAL_ADC_MspInit+0x8c>
    {
      Error_Handler();
34001310:	f7ff ff3c 	bl	3400118c <Error_Handler>
    }

    /* Peripheral clock enable */
    HAL_RCC_ADC12_CLK_ENABLED++;
34001314:	4b52      	ldr	r3, [pc, #328]	@ (34001460 <HAL_ADC_MspInit+0x1d8>)
34001316:	681b      	ldr	r3, [r3, #0]
34001318:	3301      	adds	r3, #1
3400131a:	4a51      	ldr	r2, [pc, #324]	@ (34001460 <HAL_ADC_MspInit+0x1d8>)
3400131c:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_ADC12_CLK_ENABLED==1){
3400131e:	4b50      	ldr	r3, [pc, #320]	@ (34001460 <HAL_ADC_MspInit+0x1d8>)
34001320:	681b      	ldr	r3, [r3, #0]
34001322:	2b01      	cmp	r3, #1
34001324:	d102      	bne.n	3400132c <HAL_ADC_MspInit+0xa4>
      __HAL_RCC_ADC12_CLK_ENABLE();
34001326:	2020      	movs	r0, #32
34001328:	f7ff ff60 	bl	340011ec <LL_AHB1_GRP1_EnableClock>
    }

    __HAL_RCC_GPIOF_CLK_ENABLE();
3400132c:	2020      	movs	r0, #32
3400132e:	f7ff ff73 	bl	34001218 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOA_CLK_ENABLE();
34001332:	2001      	movs	r0, #1
34001334:	f7ff ff70 	bl	34001218 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOB_CLK_ENABLE();
34001338:	2002      	movs	r0, #2
3400133a:	f7ff ff6d 	bl	34001218 <LL_AHB4_GRP1_EnableClock>
    PA10     ------> ADC1_INP11
    PA11     ------> ADC1_INP12
    PA12     ------> ADC1_INP13
    PB10     ------> ADC1_INP8
    */
    GPIO_InitStruct.Pin = GPIO_PIN_3;
3400133e:	2308      	movs	r3, #8
34001340:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
34001344:	2303      	movs	r3, #3
34001346:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
3400134a:	2300      	movs	r3, #0
3400134c:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
34001350:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34001354:	4619      	mov	r1, r3
34001356:	4843      	ldr	r0, [pc, #268]	@ (34001464 <HAL_ADC_MspInit+0x1dc>)
34001358:	f003 fc6e 	bl	34004c38 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10|UCPD1_VSENSE_Pin|GPIO_PIN_12;
3400135c:	f44f 53f0 	mov.w	r3, #7680	@ 0x1e00
34001360:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
34001364:	2303      	movs	r3, #3
34001366:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
3400136a:	2300      	movs	r3, #0
3400136c:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
34001370:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34001374:	4619      	mov	r1, r3
34001376:	483c      	ldr	r0, [pc, #240]	@ (34001468 <HAL_ADC_MspInit+0x1e0>)
34001378:	f003 fc5e 	bl	34004c38 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_10;
3400137c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
34001380:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
34001384:	2303      	movs	r3, #3
34001386:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
3400138a:	2300      	movs	r3, #0
3400138c:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
34001390:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34001394:	4619      	mov	r1, r3
34001396:	4835      	ldr	r0, [pc, #212]	@ (3400146c <HAL_ADC_MspInit+0x1e4>)
34001398:	f003 fc4e 	bl	34004c38 <HAL_GPIO_Init>

    /* ADC1 interrupt Init */
    HAL_NVIC_SetPriority(ADC1_2_IRQn, 10, 0);
3400139c:	2200      	movs	r2, #0
3400139e:	210a      	movs	r1, #10
340013a0:	202e      	movs	r0, #46	@ 0x2e
340013a2:	f003 f9a6 	bl	340046f2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC1_2_IRQn);
340013a6:	202e      	movs	r0, #46	@ 0x2e
340013a8:	f003 f9c0 	bl	3400472c <HAL_NVIC_EnableIRQ>
    /* USER CODE BEGIN ADC2_MspInit 1 */

    /* USER CODE END ADC2_MspInit 1 */
  }

}
340013ac:	e050      	b.n	34001450 <HAL_ADC_MspInit+0x1c8>
  else if(hadc->Instance==ADC2)
340013ae:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340013b2:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
340013b6:	681b      	ldr	r3, [r3, #0]
340013b8:	681b      	ldr	r3, [r3, #0]
340013ba:	4a2d      	ldr	r2, [pc, #180]	@ (34001470 <HAL_ADC_MspInit+0x1e8>)
340013bc:	4293      	cmp	r3, r2
340013be:	d147      	bne.n	34001450 <HAL_ADC_MspInit+0x1c8>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_ADC;
340013c0:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340013c4:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
340013c8:	f04f 0201 	mov.w	r2, #1
340013cc:	f04f 0300 	mov.w	r3, #0
340013d0:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_HCLK;
340013d4:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340013d8:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
340013dc:	2200      	movs	r2, #0
340013de:	f8c3 20bc 	str.w	r2, [r3, #188]	@ 0xbc
    PeriphClkInitStruct.AdcDivider = 2;
340013e2:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340013e6:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
340013ea:	2202      	movs	r2, #2
340013ec:	f8c3 20c0 	str.w	r2, [r3, #192]	@ 0xc0
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
340013f0:	f107 0308 	add.w	r3, r7, #8
340013f4:	4618      	mov	r0, r3
340013f6:	f007 f989 	bl	3400870c <HAL_RCCEx_PeriphCLKConfig>
340013fa:	4603      	mov	r3, r0
340013fc:	2b00      	cmp	r3, #0
340013fe:	d001      	beq.n	34001404 <HAL_ADC_MspInit+0x17c>
      Error_Handler();
34001400:	f7ff fec4 	bl	3400118c <Error_Handler>
    HAL_RCC_ADC12_CLK_ENABLED++;
34001404:	4b16      	ldr	r3, [pc, #88]	@ (34001460 <HAL_ADC_MspInit+0x1d8>)
34001406:	681b      	ldr	r3, [r3, #0]
34001408:	3301      	adds	r3, #1
3400140a:	4a15      	ldr	r2, [pc, #84]	@ (34001460 <HAL_ADC_MspInit+0x1d8>)
3400140c:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_ADC12_CLK_ENABLED==1){
3400140e:	4b14      	ldr	r3, [pc, #80]	@ (34001460 <HAL_ADC_MspInit+0x1d8>)
34001410:	681b      	ldr	r3, [r3, #0]
34001412:	2b01      	cmp	r3, #1
34001414:	d102      	bne.n	3400141c <HAL_ADC_MspInit+0x194>
      __HAL_RCC_ADC12_CLK_ENABLE();
34001416:	2020      	movs	r0, #32
34001418:	f7ff fee8 	bl	340011ec <LL_AHB1_GRP1_EnableClock>
    __HAL_RCC_GPIOA_CLK_ENABLE();
3400141c:	2001      	movs	r0, #1
3400141e:	f7ff fefb 	bl	34001218 <LL_AHB4_GRP1_EnableClock>
    GPIO_InitStruct.Pin = GPIO_PIN_5;
34001422:	2320      	movs	r3, #32
34001424:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
34001428:	2303      	movs	r3, #3
3400142a:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
3400142e:	2300      	movs	r3, #0
34001430:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
34001434:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34001438:	4619      	mov	r1, r3
3400143a:	480b      	ldr	r0, [pc, #44]	@ (34001468 <HAL_ADC_MspInit+0x1e0>)
3400143c:	f003 fbfc 	bl	34004c38 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(ADC1_2_IRQn, 10, 0);
34001440:	2200      	movs	r2, #0
34001442:	210a      	movs	r1, #10
34001444:	202e      	movs	r0, #46	@ 0x2e
34001446:	f003 f954 	bl	340046f2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC1_2_IRQn);
3400144a:	202e      	movs	r0, #46	@ 0x2e
3400144c:	f003 f96e 	bl	3400472c <HAL_NVIC_EnableIRQ>
}
34001450:	bf00      	nop
34001452:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
34001456:	46bd      	mov	sp, r7
34001458:	bd80      	pop	{r7, pc}
3400145a:	bf00      	nop
3400145c:	50022000 	.word	0x50022000
34001460:	340112a8 	.word	0x340112a8
34001464:	56021400 	.word	0x56021400
34001468:	56020000 	.word	0x56020000
3400146c:	56020400 	.word	0x56020400
34001470:	50022100 	.word	0x50022100

34001474 <HAL_I2C_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hi2c: I2C handle pointer
  * @retval None
  */
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
34001474:	b580      	push	{r7, lr}
34001476:	b0ec      	sub	sp, #432	@ 0x1b0
34001478:	af00      	add	r7, sp, #0
3400147a:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
3400147e:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
34001482:	6018      	str	r0, [r3, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
34001484:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34001488:	2200      	movs	r2, #0
3400148a:	601a      	str	r2, [r3, #0]
3400148c:	605a      	str	r2, [r3, #4]
3400148e:	609a      	str	r2, [r3, #8]
34001490:	60da      	str	r2, [r3, #12]
34001492:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
34001494:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
34001498:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
3400149c:	4618      	mov	r0, r3
3400149e:	f44f 73c8 	mov.w	r3, #400	@ 0x190
340014a2:	461a      	mov	r2, r3
340014a4:	2100      	movs	r1, #0
340014a6:	f00e fc0d 	bl	3400fcc4 <memset>
  if(hi2c->Instance==I2C1)
340014aa:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340014ae:	f5a3 73d6 	sub.w	r3, r3, #428	@ 0x1ac
340014b2:	681b      	ldr	r3, [r3, #0]
340014b4:	681b      	ldr	r3, [r3, #0]
340014b6:	4a34      	ldr	r2, [pc, #208]	@ (34001588 <HAL_I2C_MspInit+0x114>)
340014b8:	4293      	cmp	r3, r2
340014ba:	d15f      	bne.n	3400157c <HAL_I2C_MspInit+0x108>

    /* USER CODE END I2C1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
340014bc:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340014c0:	f5a3 71d4 	sub.w	r1, r3, #424	@ 0x1a8
340014c4:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
340014c8:	f04f 0300 	mov.w	r3, #0
340014cc:	e9c1 2300 	strd	r2, r3, [r1]
    PeriphClkInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
340014d0:	f507 73d8 	add.w	r3, r7, #432	@ 0x1b0
340014d4:	f5a3 73d4 	sub.w	r3, r3, #424	@ 0x1a8
340014d8:	4a2c      	ldr	r2, [pc, #176]	@ (3400158c <HAL_I2C_MspInit+0x118>)
340014da:	f8c3 20e8 	str.w	r2, [r3, #232]	@ 0xe8
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
340014de:	f107 0308 	add.w	r3, r7, #8
340014e2:	4618      	mov	r0, r3
340014e4:	f007 f912 	bl	3400870c <HAL_RCCEx_PeriphCLKConfig>
340014e8:	4603      	mov	r3, r0
340014ea:	2b00      	cmp	r3, #0
340014ec:	d001      	beq.n	340014f2 <HAL_I2C_MspInit+0x7e>
    {
      Error_Handler();
340014ee:	f7ff fe4d 	bl	3400118c <Error_Handler>
    }

    __HAL_RCC_GPIOC_CLK_ENABLE();
340014f2:	2004      	movs	r0, #4
340014f4:	f7ff fe90 	bl	34001218 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOH_CLK_ENABLE();
340014f8:	2080      	movs	r0, #128	@ 0x80
340014fa:	f7ff fe8d 	bl	34001218 <LL_AHB4_GRP1_EnableClock>
    /**I2C1 GPIO Configuration
    PC1     ------> I2C1_SDA
    PH9     ------> I2C1_SCL
    */
    GPIO_InitStruct.Pin = I2C1_SDA_Pin;
340014fe:	2302      	movs	r3, #2
34001500:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
34001504:	2312      	movs	r3, #18
34001506:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
3400150a:	2300      	movs	r3, #0
3400150c:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
34001510:	2300      	movs	r3, #0
34001512:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
34001516:	2304      	movs	r3, #4
34001518:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(I2C1_SDA_GPIO_Port, &GPIO_InitStruct);
3400151c:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
34001520:	4619      	mov	r1, r3
34001522:	481b      	ldr	r0, [pc, #108]	@ (34001590 <HAL_I2C_MspInit+0x11c>)
34001524:	f003 fb88 	bl	34004c38 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = I2C1_SCL_Pin;
34001528:	f44f 7300 	mov.w	r3, #512	@ 0x200
3400152c:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
34001530:	2312      	movs	r3, #18
34001532:	f8c7 31a0 	str.w	r3, [r7, #416]	@ 0x1a0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
34001536:	2300      	movs	r3, #0
34001538:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
3400153c:	2300      	movs	r3, #0
3400153e:	f8c7 31a8 	str.w	r3, [r7, #424]	@ 0x1a8
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
34001542:	2304      	movs	r3, #4
34001544:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
    HAL_GPIO_Init(I2C1_SCL_GPIO_Port, &GPIO_InitStruct);
34001548:	f507 73ce 	add.w	r3, r7, #412	@ 0x19c
3400154c:	4619      	mov	r1, r3
3400154e:	4811      	ldr	r0, [pc, #68]	@ (34001594 <HAL_I2C_MspInit+0x120>)
34001550:	f003 fb72 	bl	34004c38 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
34001554:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
34001558:	f7ff fe74 	bl	34001244 <LL_APB1_GRP1_EnableClock>
    /* I2C1 interrupt Init */
    HAL_NVIC_SetPriority(I2C1_EV_IRQn, 10, 0);
3400155c:	2200      	movs	r2, #0
3400155e:	210a      	movs	r1, #10
34001560:	2064      	movs	r0, #100	@ 0x64
34001562:	f003 f8c6 	bl	340046f2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);
34001566:	2064      	movs	r0, #100	@ 0x64
34001568:	f003 f8e0 	bl	3400472c <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C1_ER_IRQn, 10, 0);
3400156c:	2200      	movs	r2, #0
3400156e:	210a      	movs	r1, #10
34001570:	2065      	movs	r0, #101	@ 0x65
34001572:	f003 f8be 	bl	340046f2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);
34001576:	2065      	movs	r0, #101	@ 0x65
34001578:	f003 f8d8 	bl	3400472c <HAL_NVIC_EnableIRQ>

    /* USER CODE END I2C1_MspInit 1 */

  }

}
3400157c:	bf00      	nop
3400157e:	f507 77d8 	add.w	r7, r7, #432	@ 0x1b0
34001582:	46bd      	mov	sp, r7
34001584:	bd80      	pop	{r7, pc}
34001586:	bf00      	nop
34001588:	50005400 	.word	0x50005400
3400158c:	0700000c 	.word	0x0700000c
34001590:	56020800 	.word	0x56020800
34001594:	56021c00 	.word	0x56021c00

34001598 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
34001598:	b480      	push	{r7}
3400159a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
3400159c:	bf00      	nop
3400159e:	e7fd      	b.n	3400159c <NMI_Handler+0x4>

340015a0 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
340015a0:	b480      	push	{r7}
340015a2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
340015a4:	bf00      	nop
340015a6:	e7fd      	b.n	340015a4 <HardFault_Handler+0x4>

340015a8 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
340015a8:	b480      	push	{r7}
340015aa:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
340015ac:	bf00      	nop
340015ae:	e7fd      	b.n	340015ac <MemManage_Handler+0x4>

340015b0 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
340015b0:	b480      	push	{r7}
340015b2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
340015b4:	bf00      	nop
340015b6:	e7fd      	b.n	340015b4 <BusFault_Handler+0x4>

340015b8 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
340015b8:	b480      	push	{r7}
340015ba:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
340015bc:	bf00      	nop
340015be:	e7fd      	b.n	340015bc <UsageFault_Handler+0x4>

340015c0 <SecureFault_Handler>:

/**
  * @brief This function handles Secure fault.
  */
void SecureFault_Handler(void)
{
340015c0:	b480      	push	{r7}
340015c2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SecureFault_IRQn 0 */

  /* USER CODE END SecureFault_IRQn 0 */
  while (1)
340015c4:	bf00      	nop
340015c6:	e7fd      	b.n	340015c4 <SecureFault_Handler+0x4>

340015c8 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
340015c8:	b480      	push	{r7}
340015ca:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
340015cc:	bf00      	nop
340015ce:	46bd      	mov	sp, r7
340015d0:	f85d 7b04 	ldr.w	r7, [sp], #4
340015d4:	4770      	bx	lr

340015d6 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
340015d6:	b480      	push	{r7}
340015d8:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
340015da:	bf00      	nop
340015dc:	46bd      	mov	sp, r7
340015de:	f85d 7b04 	ldr.w	r7, [sp], #4
340015e2:	4770      	bx	lr

340015e4 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
340015e4:	b480      	push	{r7}
340015e6:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
340015e8:	bf00      	nop
340015ea:	46bd      	mov	sp, r7
340015ec:	f85d 7b04 	ldr.w	r7, [sp], #4
340015f0:	4770      	bx	lr

340015f2 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
340015f2:	b580      	push	{r7, lr}
340015f4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
340015f6:	f000 ff73 	bl	340024e0 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
340015fa:	bf00      	nop
340015fc:	bd80      	pop	{r7, pc}
	...

34001600 <ADC1_2_IRQHandler>:

/**
  * @brief This function handles ADC1 and ADC2 global interrupt.
  */
void ADC1_2_IRQHandler(void)
{
34001600:	b580      	push	{r7, lr}
34001602:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN ADC1_2_IRQn 0 */

  /* USER CODE END ADC1_2_IRQn 0 */
  HAL_ADC_IRQHandler(&hadc1);
34001604:	4803      	ldr	r0, [pc, #12]	@ (34001614 <ADC1_2_IRQHandler+0x14>)
34001606:	f001 ff05 	bl	34003414 <HAL_ADC_IRQHandler>
  HAL_ADC_IRQHandler(&hadc2);
3400160a:	4803      	ldr	r0, [pc, #12]	@ (34001618 <ADC1_2_IRQHandler+0x18>)
3400160c:	f001 ff02 	bl	34003414 <HAL_ADC_IRQHandler>
  /* USER CODE BEGIN ADC1_2_IRQn 1 */

  /* USER CODE END ADC1_2_IRQn 1 */
}
34001610:	bf00      	nop
34001612:	bd80      	pop	{r7, pc}
34001614:	3401118c 	.word	0x3401118c
34001618:	340111ec 	.word	0x340111ec

3400161c <I2C1_EV_IRQHandler>:

/**
  * @brief This function handles I2C1 Event interrupt.
  */
void I2C1_EV_IRQHandler(void)
{
3400161c:	b580      	push	{r7, lr}
3400161e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C1_EV_IRQn 0 */

  /* USER CODE END I2C1_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c1);
34001620:	4802      	ldr	r0, [pc, #8]	@ (3400162c <I2C1_EV_IRQHandler+0x10>)
34001622:	f003 ff0d 	bl	34005440 <HAL_I2C_EV_IRQHandler>
  /* USER CODE BEGIN I2C1_EV_IRQn 1 */

  /* USER CODE END I2C1_EV_IRQn 1 */
}
34001626:	bf00      	nop
34001628:	bd80      	pop	{r7, pc}
3400162a:	bf00      	nop
3400162c:	3401124c 	.word	0x3401124c

34001630 <I2C1_ER_IRQHandler>:

/**
  * @brief This function handles I2C1 Error interrupt.
  */
void I2C1_ER_IRQHandler(void)
{
34001630:	b580      	push	{r7, lr}
34001632:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C1_ER_IRQn 0 */

  /* USER CODE END I2C1_ER_IRQn 0 */
  HAL_I2C_ER_IRQHandler(&hi2c1);
34001634:	4802      	ldr	r0, [pc, #8]	@ (34001640 <I2C1_ER_IRQHandler+0x10>)
34001636:	f003 ff1d 	bl	34005474 <HAL_I2C_ER_IRQHandler>
  /* USER CODE BEGIN I2C1_ER_IRQn 1 */

  /* USER CODE END I2C1_ER_IRQn 1 */
}
3400163a:	bf00      	nop
3400163c:	bd80      	pop	{r7, pc}
3400163e:	bf00      	nop
34001640:	3401124c 	.word	0x3401124c

34001644 <TZ_SAU_Setup>:
  \brief   Setup a SAU Region
  \details Writes the region information contained in SAU_Region to the
           registers SAU_RNR, SAU_RBAR, and SAU_RLAR
 */
__STATIC_INLINE void TZ_SAU_Setup (void)
{
34001644:	b480      	push	{r7}
34001646:	af00      	add	r7, sp, #0
  #endif /* defined (SCB_CSR_AIRCR_INIT) && (SCB_CSR_AIRCR_INIT == 1U) */

  #if defined (__FPU_USED) && (__FPU_USED == 1U) && \
      defined (TZ_FPU_NS_USAGE) && (TZ_FPU_NS_USAGE == 1U)

    SCB->NSACR = (SCB->NSACR & ~(SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk)) |
34001648:	4b18      	ldr	r3, [pc, #96]	@ (340016ac <TZ_SAU_Setup+0x68>)
3400164a:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
3400164e:	4a17      	ldr	r2, [pc, #92]	@ (340016ac <TZ_SAU_Setup+0x68>)
34001650:	f443 6340 	orr.w	r3, r3, #3072	@ 0xc00
34001654:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
                   ((SCB_NSACR_CP10_11_VAL << SCB_NSACR_CP10_Pos) & (SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk));

    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
34001658:	4b15      	ldr	r3, [pc, #84]	@ (340016b0 <TZ_SAU_Setup+0x6c>)
3400165a:	685b      	ldr	r3, [r3, #4]
                   ((FPU_FPCCR_TS_VAL        << FPU_FPCCR_TS_Pos       ) & FPU_FPCCR_TS_Msk       ) |
3400165c:	f023 53e0 	bic.w	r3, r3, #469762048	@ 0x1c000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
34001660:	4a13      	ldr	r2, [pc, #76]	@ (340016b0 <TZ_SAU_Setup+0x6c>)
                   ((FPU_FPCCR_CLRONRETS_VAL << FPU_FPCCR_CLRONRETS_Pos) & FPU_FPCCR_CLRONRETS_Msk) |
34001662:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
34001666:	6053      	str	r3, [r2, #4]
                   ((FPU_FPCCR_CLRONRET_VAL  << FPU_FPCCR_CLRONRET_Pos ) & FPU_FPCCR_CLRONRET_Msk );
  #endif

  #if defined (NVIC_INIT_ITNS0) && (NVIC_INIT_ITNS0 == 1U)
    NVIC->ITNS[0] = NVIC_INIT_ITNS0_VAL;
34001668:	4b12      	ldr	r3, [pc, #72]	@ (340016b4 <TZ_SAU_Setup+0x70>)
3400166a:	2200      	movs	r2, #0
3400166c:	f8c3 2280 	str.w	r2, [r3, #640]	@ 0x280
  #endif

  #if defined (NVIC_INIT_ITNS1) && (NVIC_INIT_ITNS1 == 1U)
    NVIC->ITNS[1] = NVIC_INIT_ITNS1_VAL;
34001670:	4b10      	ldr	r3, [pc, #64]	@ (340016b4 <TZ_SAU_Setup+0x70>)
34001672:	2200      	movs	r2, #0
34001674:	f8c3 2284 	str.w	r2, [r3, #644]	@ 0x284
  #endif

  #if defined (NVIC_INIT_ITNS2) && (NVIC_INIT_ITNS2 == 1U)
    NVIC->ITNS[2] = NVIC_INIT_ITNS2_VAL;
34001678:	4b0e      	ldr	r3, [pc, #56]	@ (340016b4 <TZ_SAU_Setup+0x70>)
3400167a:	2200      	movs	r2, #0
3400167c:	f8c3 2288 	str.w	r2, [r3, #648]	@ 0x288
  #endif

  #if defined (NVIC_INIT_ITNS3) && (NVIC_INIT_ITNS3 == 1U)
    NVIC->ITNS[3] = NVIC_INIT_ITNS3_VAL;
34001680:	4b0c      	ldr	r3, [pc, #48]	@ (340016b4 <TZ_SAU_Setup+0x70>)
34001682:	2200      	movs	r2, #0
34001684:	f8c3 228c 	str.w	r2, [r3, #652]	@ 0x28c
  #endif

  #if defined (NVIC_INIT_ITNS4) && (NVIC_INIT_ITNS4 == 1U)
    NVIC->ITNS[4] = NVIC_INIT_ITNS4_VAL;
34001688:	4b0a      	ldr	r3, [pc, #40]	@ (340016b4 <TZ_SAU_Setup+0x70>)
3400168a:	2200      	movs	r2, #0
3400168c:	f8c3 2290 	str.w	r2, [r3, #656]	@ 0x290
  #endif

  #if defined (NVIC_INIT_ITNS5) && (NVIC_INIT_ITNS5 == 1U)
    NVIC->ITNS[5] = NVIC_INIT_ITNS5_VAL;
34001690:	4b08      	ldr	r3, [pc, #32]	@ (340016b4 <TZ_SAU_Setup+0x70>)
34001692:	2200      	movs	r2, #0
34001694:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  #endif

  #if defined (NVIC_INIT_ITNS6) && (NVIC_INIT_ITNS6 == 1U)
    NVIC->ITNS[6] = NVIC_INIT_ITNS6_VAL;
34001698:	4b06      	ldr	r3, [pc, #24]	@ (340016b4 <TZ_SAU_Setup+0x70>)
3400169a:	2200      	movs	r2, #0
3400169c:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298
  #endif

}
340016a0:	bf00      	nop
340016a2:	46bd      	mov	sp, r7
340016a4:	f85d 7b04 	ldr.w	r7, [sp], #4
340016a8:	4770      	bx	lr
340016aa:	bf00      	nop
340016ac:	e000ed00 	.word	0xe000ed00
340016b0:	e000ef30 	.word	0xe000ef30
340016b4:	e000e100 	.word	0xe000e100

340016b8 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
340016b8:	b580      	push	{r7, lr}
340016ba:	af00      	add	r7, sp, #0
  /* SAU/IDAU, FPU and Interrupts secure/non-secure allocation settings */
  TZ_SAU_Setup();
340016bc:	f7ff ffc2 	bl	34001644 <TZ_SAU_Setup>

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#else
  SCB->VTOR = INTVECT_START;
340016c0:	4b14      	ldr	r3, [pc, #80]	@ (34001714 <SystemInit+0x5c>)
340016c2:	4a15      	ldr	r2, [pc, #84]	@ (34001718 <SystemInit+0x60>)
340016c4:	609a      	str	r2, [r3, #8]
#endif  /* USER_VECT_TAB_ADDRESS */

  /* System configuration setup */
  RCC->APB4ENSR2 = RCC_APB4ENSR2_SYSCFGENS;
340016c6:	4b15      	ldr	r3, [pc, #84]	@ (3400171c <SystemInit+0x64>)
340016c8:	2201      	movs	r2, #1
340016ca:	f8c3 2a78 	str.w	r2, [r3, #2680]	@ 0xa78
  /* Delay after an RCC peripheral clock enabling */
  (void)RCC->APB4ENR2;
340016ce:	4b13      	ldr	r3, [pc, #76]	@ (3400171c <SystemInit+0x64>)
340016d0:	f8d3 3278 	ldr.w	r3, [r3, #632]	@ 0x278

  /* Set default Vector Table location after system reset or return from Standby */
  SYSCFG->INITSVTORCR = SCB->VTOR;
340016d4:	4b0f      	ldr	r3, [pc, #60]	@ (34001714 <SystemInit+0x5c>)
340016d6:	4a12      	ldr	r2, [pc, #72]	@ (34001720 <SystemInit+0x68>)
340016d8:	689b      	ldr	r3, [r3, #8]
340016da:	6113      	str	r3, [r2, #16]
  /* Read back the value to make sure it is written before deactivating SYSCFG */
  (void) SYSCFG->INITSVTORCR;
340016dc:	4b10      	ldr	r3, [pc, #64]	@ (34001720 <SystemInit+0x68>)
340016de:	691b      	ldr	r3, [r3, #16]
  /* Deactivate SYSCFG clock */
  RCC->APB4ENCR2 = RCC_APB4ENCR2_SYSCFGENC;
340016e0:	4b0e      	ldr	r3, [pc, #56]	@ (3400171c <SystemInit+0x64>)
340016e2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
340016e6:	461a      	mov	r2, r3
340016e8:	2301      	movs	r3, #1
340016ea:	f8c2 3278 	str.w	r3, [r2, #632]	@ 0x278
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
340016ee:	4b09      	ldr	r3, [pc, #36]	@ (34001714 <SystemInit+0x5c>)
340016f0:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
340016f4:	4a07      	ldr	r2, [pc, #28]	@ (34001714 <SystemInit+0x5c>)
340016f6:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
340016fa:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  SCB_NS->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
340016fe:	4b09      	ldr	r3, [pc, #36]	@ (34001724 <SystemInit+0x6c>)
34001700:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34001704:	4a07      	ldr	r2, [pc, #28]	@ (34001724 <SystemInit+0x6c>)
34001706:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
3400170a:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif /* __FPU_PRESENT && __FPU_USED */

}
3400170e:	bf00      	nop
34001710:	bd80      	pop	{r7, pc}
34001712:	bf00      	nop
34001714:	e000ed00 	.word	0xe000ed00
34001718:	34000400 	.word	0x34000400
3400171c:	56028000 	.word	0x56028000
34001720:	56008000 	.word	0x56008000
34001724:	e002ed00 	.word	0xe002ed00

34001728 <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
34001728:	b480      	push	{r7}
3400172a:	b08d      	sub	sp, #52	@ 0x34
3400172c:	af00      	add	r7, sp, #0
  uint32_t sysclk = 0;
3400172e:	2300      	movs	r3, #0
34001730:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t pllm = 0;
34001732:	2300      	movs	r3, #0
34001734:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t plln = 0;
34001736:	2300      	movs	r3, #0
34001738:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pllfracn = 0;
3400173a:	2300      	movs	r3, #0
3400173c:	623b      	str	r3, [r7, #32]
  uint32_t pllp1 = 0;
3400173e:	2300      	movs	r3, #0
34001740:	61fb      	str	r3, [r7, #28]
  uint32_t pllp2 = 0;
34001742:	2300      	movs	r3, #0
34001744:	61bb      	str	r3, [r7, #24]
  uint32_t pllcfgr, pllsource, pllbypass, ic_divider;
  float_t pllvco;

  /* Get CPUCLK source -------------------------------------------------------*/
  switch (RCC->CFGR1 & RCC_CFGR1_CPUSWS)
34001746:	4b9b      	ldr	r3, [pc, #620]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
34001748:	6a1b      	ldr	r3, [r3, #32]
3400174a:	f403 1340 	and.w	r3, r3, #3145728	@ 0x300000
3400174e:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34001752:	d029      	beq.n	340017a8 <SystemCoreClockUpdate+0x80>
34001754:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
34001758:	f200 8180 	bhi.w	34001a5c <SystemCoreClockUpdate+0x334>
3400175c:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34001760:	d01f      	beq.n	340017a2 <SystemCoreClockUpdate+0x7a>
34001762:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34001766:	f200 8179 	bhi.w	34001a5c <SystemCoreClockUpdate+0x334>
3400176a:	2b00      	cmp	r3, #0
3400176c:	d003      	beq.n	34001776 <SystemCoreClockUpdate+0x4e>
3400176e:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34001772:	d00a      	beq.n	3400178a <SystemCoreClockUpdate+0x62>
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
    sysclk = sysclk / ic_divider;
    break;
  default:
    /* Nothing to do, should not occur */
    break;
34001774:	e172      	b.n	34001a5c <SystemCoreClockUpdate+0x334>
    sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
34001776:	4b8f      	ldr	r3, [pc, #572]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
34001778:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400177a:	09db      	lsrs	r3, r3, #7
3400177c:	f003 0303 	and.w	r3, r3, #3
34001780:	4a8d      	ldr	r2, [pc, #564]	@ (340019b8 <SystemCoreClockUpdate+0x290>)
34001782:	fa22 f303 	lsr.w	r3, r2, r3
34001786:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34001788:	e169      	b.n	34001a5e <SystemCoreClockUpdate+0x336>
    if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
3400178a:	4b8a      	ldr	r3, [pc, #552]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
3400178c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400178e:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34001792:	2b00      	cmp	r3, #0
34001794:	d102      	bne.n	3400179c <SystemCoreClockUpdate+0x74>
      sysclk = MSI_VALUE;
34001796:	4b89      	ldr	r3, [pc, #548]	@ (340019bc <SystemCoreClockUpdate+0x294>)
34001798:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
3400179a:	e160      	b.n	34001a5e <SystemCoreClockUpdate+0x336>
      sysclk = 16000000UL;
3400179c:	4b88      	ldr	r3, [pc, #544]	@ (340019c0 <SystemCoreClockUpdate+0x298>)
3400179e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
340017a0:	e15d      	b.n	34001a5e <SystemCoreClockUpdate+0x336>
    sysclk = HSE_VALUE;
340017a2:	4b88      	ldr	r3, [pc, #544]	@ (340019c4 <SystemCoreClockUpdate+0x29c>)
340017a4:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
340017a6:	e15a      	b.n	34001a5e <SystemCoreClockUpdate+0x336>
    switch (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1SEL))
340017a8:	4b82      	ldr	r3, [pc, #520]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
340017aa:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
340017ae:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
340017b2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340017b6:	d066      	beq.n	34001886 <SystemCoreClockUpdate+0x15e>
340017b8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
340017bc:	f200 8091 	bhi.w	340018e2 <SystemCoreClockUpdate+0x1ba>
340017c0:	2b00      	cmp	r3, #0
340017c2:	d003      	beq.n	340017cc <SystemCoreClockUpdate+0xa4>
340017c4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
340017c8:	d02f      	beq.n	3400182a <SystemCoreClockUpdate+0x102>
340017ca:	e08a      	b.n	340018e2 <SystemCoreClockUpdate+0x1ba>
      pllcfgr = READ_REG(RCC->PLL1CFGR1);
340017cc:	4b79      	ldr	r3, [pc, #484]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
340017ce:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
340017d2:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL1CFGR1_PLL1SEL;
340017d4:	68fb      	ldr	r3, [r7, #12]
340017d6:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
340017da:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL1CFGR1_PLL1BYP;
340017dc:	68fb      	ldr	r3, [r7, #12]
340017de:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
340017e2:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
340017e4:	693b      	ldr	r3, [r7, #16]
340017e6:	2b00      	cmp	r3, #0
340017e8:	f040 80a9 	bne.w	3400193e <SystemCoreClockUpdate+0x216>
        pllm = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVM) >>  RCC_PLL1CFGR1_PLL1DIVM_Pos;
340017ec:	68fb      	ldr	r3, [r7, #12]
340017ee:	0d1b      	lsrs	r3, r3, #20
340017f0:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
340017f4:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL1CFGR1_PLL1DIVN) >>  RCC_PLL1CFGR1_PLL1DIVN_Pos;
340017f6:	68fb      	ldr	r3, [r7, #12]
340017f8:	0a1b      	lsrs	r3, r3, #8
340017fa:	f3c3 030b 	ubfx	r3, r3, #0, #12
340017fe:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL1CFGR2, RCC_PLL1CFGR2_PLL1DIVNFRAC) >>  RCC_PLL1CFGR2_PLL1DIVNFRAC_Pos;
34001800:	4b6c      	ldr	r3, [pc, #432]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
34001802:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34001806:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400180a:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL1CFGR3);
3400180c:	4b69      	ldr	r3, [pc, #420]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
3400180e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
34001812:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV1) >>  RCC_PLL1CFGR3_PLL1PDIV1_Pos;
34001814:	68fb      	ldr	r3, [r7, #12]
34001816:	0edb      	lsrs	r3, r3, #27
34001818:	f003 0307 	and.w	r3, r3, #7
3400181c:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL1CFGR3_PLL1PDIV2) >>  RCC_PLL1CFGR3_PLL1PDIV2_Pos;
3400181e:	68fb      	ldr	r3, [r7, #12]
34001820:	0e1b      	lsrs	r3, r3, #24
34001822:	f003 0307 	and.w	r3, r3, #7
34001826:	61bb      	str	r3, [r7, #24]
      break;
34001828:	e089      	b.n	3400193e <SystemCoreClockUpdate+0x216>
      pllcfgr = READ_REG(RCC->PLL2CFGR1);
3400182a:	4b62      	ldr	r3, [pc, #392]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
3400182c:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
34001830:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL2CFGR1_PLL2SEL;
34001832:	68fb      	ldr	r3, [r7, #12]
34001834:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34001838:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL2CFGR1_PLL2BYP;
3400183a:	68fb      	ldr	r3, [r7, #12]
3400183c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
34001840:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
34001842:	693b      	ldr	r3, [r7, #16]
34001844:	2b00      	cmp	r3, #0
34001846:	d17c      	bne.n	34001942 <SystemCoreClockUpdate+0x21a>
        pllm = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVM) >>  RCC_PLL2CFGR1_PLL2DIVM_Pos;
34001848:	68fb      	ldr	r3, [r7, #12]
3400184a:	0d1b      	lsrs	r3, r3, #20
3400184c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34001850:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL2CFGR1_PLL2DIVN) >>  RCC_PLL2CFGR1_PLL2DIVN_Pos;
34001852:	68fb      	ldr	r3, [r7, #12]
34001854:	0a1b      	lsrs	r3, r3, #8
34001856:	f3c3 030b 	ubfx	r3, r3, #0, #12
3400185a:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL2CFGR2, RCC_PLL2CFGR2_PLL2DIVNFRAC) >>  RCC_PLL2CFGR2_PLL2DIVNFRAC_Pos;
3400185c:	4b55      	ldr	r3, [pc, #340]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
3400185e:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34001862:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
34001866:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL2CFGR3);
34001868:	4b52      	ldr	r3, [pc, #328]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
3400186a:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
3400186e:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV1) >>  RCC_PLL2CFGR3_PLL2PDIV1_Pos;
34001870:	68fb      	ldr	r3, [r7, #12]
34001872:	0edb      	lsrs	r3, r3, #27
34001874:	f003 0307 	and.w	r3, r3, #7
34001878:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL2CFGR3_PLL2PDIV2) >>  RCC_PLL2CFGR3_PLL2PDIV2_Pos;
3400187a:	68fb      	ldr	r3, [r7, #12]
3400187c:	0e1b      	lsrs	r3, r3, #24
3400187e:	f003 0307 	and.w	r3, r3, #7
34001882:	61bb      	str	r3, [r7, #24]
      break;
34001884:	e05d      	b.n	34001942 <SystemCoreClockUpdate+0x21a>
      pllcfgr = READ_REG(RCC->PLL3CFGR1);
34001886:	4b4b      	ldr	r3, [pc, #300]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
34001888:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
3400188c:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL3CFGR1_PLL3SEL;
3400188e:	68fb      	ldr	r3, [r7, #12]
34001890:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
34001894:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL3CFGR1_PLL3BYP;
34001896:	68fb      	ldr	r3, [r7, #12]
34001898:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
3400189c:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
3400189e:	693b      	ldr	r3, [r7, #16]
340018a0:	2b00      	cmp	r3, #0
340018a2:	d150      	bne.n	34001946 <SystemCoreClockUpdate+0x21e>
        pllm = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVM) >>  RCC_PLL3CFGR1_PLL3DIVM_Pos;
340018a4:	68fb      	ldr	r3, [r7, #12]
340018a6:	0d1b      	lsrs	r3, r3, #20
340018a8:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
340018ac:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL3CFGR1_PLL3DIVN) >>  RCC_PLL3CFGR1_PLL3DIVN_Pos;
340018ae:	68fb      	ldr	r3, [r7, #12]
340018b0:	0a1b      	lsrs	r3, r3, #8
340018b2:	f3c3 030b 	ubfx	r3, r3, #0, #12
340018b6:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL3CFGR2, RCC_PLL3CFGR2_PLL3DIVNFRAC) >>  RCC_PLL3CFGR2_PLL3DIVNFRAC_Pos;
340018b8:	4b3e      	ldr	r3, [pc, #248]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
340018ba:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
340018be:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
340018c2:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL3CFGR3);
340018c4:	4b3b      	ldr	r3, [pc, #236]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
340018c6:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
340018ca:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV1) >>  RCC_PLL3CFGR3_PLL3PDIV1_Pos;
340018cc:	68fb      	ldr	r3, [r7, #12]
340018ce:	0edb      	lsrs	r3, r3, #27
340018d0:	f003 0307 	and.w	r3, r3, #7
340018d4:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL3CFGR3_PLL3PDIV2) >>  RCC_PLL3CFGR3_PLL3PDIV2_Pos;
340018d6:	68fb      	ldr	r3, [r7, #12]
340018d8:	0e1b      	lsrs	r3, r3, #24
340018da:	f003 0307 	and.w	r3, r3, #7
340018de:	61bb      	str	r3, [r7, #24]
      break;
340018e0:	e031      	b.n	34001946 <SystemCoreClockUpdate+0x21e>
      pllcfgr = READ_REG(RCC->PLL4CFGR1);
340018e2:	4b34      	ldr	r3, [pc, #208]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
340018e4:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
340018e8:	60fb      	str	r3, [r7, #12]
      pllsource = pllcfgr & RCC_PLL4CFGR1_PLL4SEL;
340018ea:	68fb      	ldr	r3, [r7, #12]
340018ec:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
340018f0:	617b      	str	r3, [r7, #20]
      pllbypass = pllcfgr & RCC_PLL4CFGR1_PLL4BYP;
340018f2:	68fb      	ldr	r3, [r7, #12]
340018f4:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
340018f8:	613b      	str	r3, [r7, #16]
      if (pllbypass == 0U)
340018fa:	693b      	ldr	r3, [r7, #16]
340018fc:	2b00      	cmp	r3, #0
340018fe:	d124      	bne.n	3400194a <SystemCoreClockUpdate+0x222>
        pllm = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVM) >>  RCC_PLL4CFGR1_PLL4DIVM_Pos;
34001900:	68fb      	ldr	r3, [r7, #12]
34001902:	0d1b      	lsrs	r3, r3, #20
34001904:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
34001908:	62bb      	str	r3, [r7, #40]	@ 0x28
        plln = (pllcfgr & RCC_PLL4CFGR1_PLL4DIVN) >>  RCC_PLL4CFGR1_PLL4DIVN_Pos;
3400190a:	68fb      	ldr	r3, [r7, #12]
3400190c:	0a1b      	lsrs	r3, r3, #8
3400190e:	f3c3 030b 	ubfx	r3, r3, #0, #12
34001912:	627b      	str	r3, [r7, #36]	@ 0x24
        pllfracn = READ_BIT(RCC->PLL4CFGR2, RCC_PLL4CFGR2_PLL4DIVNFRAC) >>  RCC_PLL4CFGR2_PLL4DIVNFRAC_Pos;
34001914:	4b27      	ldr	r3, [pc, #156]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
34001916:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
3400191a:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
3400191e:	623b      	str	r3, [r7, #32]
        pllcfgr = READ_REG(RCC->PLL4CFGR3);
34001920:	4b24      	ldr	r3, [pc, #144]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
34001922:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34001926:	60fb      	str	r3, [r7, #12]
        pllp1 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV1) >>  RCC_PLL4CFGR3_PLL4PDIV1_Pos;
34001928:	68fb      	ldr	r3, [r7, #12]
3400192a:	0edb      	lsrs	r3, r3, #27
3400192c:	f003 0307 	and.w	r3, r3, #7
34001930:	61fb      	str	r3, [r7, #28]
        pllp2 = (pllcfgr & RCC_PLL4CFGR3_PLL4PDIV2) >>  RCC_PLL4CFGR3_PLL4PDIV2_Pos;
34001932:	68fb      	ldr	r3, [r7, #12]
34001934:	0e1b      	lsrs	r3, r3, #24
34001936:	f003 0307 	and.w	r3, r3, #7
3400193a:	61bb      	str	r3, [r7, #24]
      break;
3400193c:	e005      	b.n	3400194a <SystemCoreClockUpdate+0x222>
      break;
3400193e:	bf00      	nop
34001940:	e004      	b.n	3400194c <SystemCoreClockUpdate+0x224>
      break;
34001942:	bf00      	nop
34001944:	e002      	b.n	3400194c <SystemCoreClockUpdate+0x224>
      break;
34001946:	bf00      	nop
34001948:	e000      	b.n	3400194c <SystemCoreClockUpdate+0x224>
      break;
3400194a:	bf00      	nop
    switch (pllsource)
3400194c:	697b      	ldr	r3, [r7, #20]
3400194e:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
34001952:	d02c      	beq.n	340019ae <SystemCoreClockUpdate+0x286>
34001954:	697b      	ldr	r3, [r7, #20]
34001956:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
3400195a:	d839      	bhi.n	340019d0 <SystemCoreClockUpdate+0x2a8>
3400195c:	697b      	ldr	r3, [r7, #20]
3400195e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34001962:	d021      	beq.n	340019a8 <SystemCoreClockUpdate+0x280>
34001964:	697b      	ldr	r3, [r7, #20]
34001966:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
3400196a:	d831      	bhi.n	340019d0 <SystemCoreClockUpdate+0x2a8>
3400196c:	697b      	ldr	r3, [r7, #20]
3400196e:	2b00      	cmp	r3, #0
34001970:	d004      	beq.n	3400197c <SystemCoreClockUpdate+0x254>
34001972:	697b      	ldr	r3, [r7, #20]
34001974:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
34001978:	d00a      	beq.n	34001990 <SystemCoreClockUpdate+0x268>
      break;
3400197a:	e029      	b.n	340019d0 <SystemCoreClockUpdate+0x2a8>
      sysclk = HSI_VALUE >> ((RCC->HSICFGR & RCC_HSICFGR_HSIDIV) >> RCC_HSICFGR_HSIDIV_Pos);
3400197c:	4b0d      	ldr	r3, [pc, #52]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
3400197e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34001980:	09db      	lsrs	r3, r3, #7
34001982:	f003 0303 	and.w	r3, r3, #3
34001986:	4a0c      	ldr	r2, [pc, #48]	@ (340019b8 <SystemCoreClockUpdate+0x290>)
34001988:	fa22 f303 	lsr.w	r3, r2, r3
3400198c:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
3400198e:	e020      	b.n	340019d2 <SystemCoreClockUpdate+0x2aa>
      if (READ_BIT(RCC->MSICFGR, RCC_MSICFGR_MSIFREQSEL) == 0UL)
34001990:	4b08      	ldr	r3, [pc, #32]	@ (340019b4 <SystemCoreClockUpdate+0x28c>)
34001992:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34001994:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34001998:	2b00      	cmp	r3, #0
3400199a:	d102      	bne.n	340019a2 <SystemCoreClockUpdate+0x27a>
        sysclk = MSI_VALUE;
3400199c:	4b07      	ldr	r3, [pc, #28]	@ (340019bc <SystemCoreClockUpdate+0x294>)
3400199e:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
340019a0:	e017      	b.n	340019d2 <SystemCoreClockUpdate+0x2aa>
        sysclk = 16000000UL;
340019a2:	4b07      	ldr	r3, [pc, #28]	@ (340019c0 <SystemCoreClockUpdate+0x298>)
340019a4:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
340019a6:	e014      	b.n	340019d2 <SystemCoreClockUpdate+0x2aa>
      sysclk = HSE_VALUE;
340019a8:	4b06      	ldr	r3, [pc, #24]	@ (340019c4 <SystemCoreClockUpdate+0x29c>)
340019aa:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
340019ac:	e011      	b.n	340019d2 <SystemCoreClockUpdate+0x2aa>
      sysclk = EXTERNAL_I2S_CLOCK_VALUE;
340019ae:	4b06      	ldr	r3, [pc, #24]	@ (340019c8 <SystemCoreClockUpdate+0x2a0>)
340019b0:	62fb      	str	r3, [r7, #44]	@ 0x2c
      break;
340019b2:	e00e      	b.n	340019d2 <SystemCoreClockUpdate+0x2aa>
340019b4:	56028000 	.word	0x56028000
340019b8:	03d09000 	.word	0x03d09000
340019bc:	003d0900 	.word	0x003d0900
340019c0:	00f42400 	.word	0x00f42400
340019c4:	016e3600 	.word	0x016e3600
340019c8:	00bb8000 	.word	0x00bb8000
340019cc:	4b800000 	.word	0x4b800000
      break;
340019d0:	bf00      	nop
    if (pllbypass == 0U)
340019d2:	693b      	ldr	r3, [r7, #16]
340019d4:	2b00      	cmp	r3, #0
340019d6:	d134      	bne.n	34001a42 <SystemCoreClockUpdate+0x31a>
      pllvco = ((float_t)sysclk * ((float_t)plln + ((float_t)pllfracn/(float_t)0x1000000UL))) / (float_t)pllm;
340019d8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
340019da:	ee07 3a90 	vmov	s15, r3
340019de:	eeb8 7a67 	vcvt.f32.u32	s14, s15
340019e2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340019e4:	ee07 3a90 	vmov	s15, r3
340019e8:	eef8 6a67 	vcvt.f32.u32	s13, s15
340019ec:	6a3b      	ldr	r3, [r7, #32]
340019ee:	ee07 3a90 	vmov	s15, r3
340019f2:	eeb8 6a67 	vcvt.f32.u32	s12, s15
340019f6:	ed5f 5a0b 	vldr	s11, [pc, #-44]	@ 340019cc <SystemCoreClockUpdate+0x2a4>
340019fa:	eec6 7a25 	vdiv.f32	s15, s12, s11
340019fe:	ee76 7aa7 	vadd.f32	s15, s13, s15
34001a02:	ee67 6a27 	vmul.f32	s13, s14, s15
34001a06:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34001a08:	ee07 3a90 	vmov	s15, r3
34001a0c:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34001a10:	eec6 7a87 	vdiv.f32	s15, s13, s14
34001a14:	edc7 7a02 	vstr	s15, [r7, #8]
      sysclk = (uint32_t)((float_t)(pllvco/(((float_t)pllp1) * ((float_t)pllp2))));
34001a18:	69fb      	ldr	r3, [r7, #28]
34001a1a:	ee07 3a90 	vmov	s15, r3
34001a1e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
34001a22:	69bb      	ldr	r3, [r7, #24]
34001a24:	ee07 3a90 	vmov	s15, r3
34001a28:	eef8 7a67 	vcvt.f32.u32	s15, s15
34001a2c:	ee27 7a27 	vmul.f32	s14, s14, s15
34001a30:	edd7 6a02 	vldr	s13, [r7, #8]
34001a34:	eec6 7a87 	vdiv.f32	s15, s13, s14
34001a38:	eefc 7ae7 	vcvt.u32.f32	s15, s15
34001a3c:	ee17 3a90 	vmov	r3, s15
34001a40:	62fb      	str	r3, [r7, #44]	@ 0x2c
    ic_divider = (READ_BIT(RCC->IC1CFGR, RCC_IC1CFGR_IC1INT) >> RCC_IC1CFGR_IC1INT_Pos) + 1UL;
34001a42:	4b0b      	ldr	r3, [pc, #44]	@ (34001a70 <SystemCoreClockUpdate+0x348>)
34001a44:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34001a48:	0c1b      	lsrs	r3, r3, #16
34001a4a:	b2db      	uxtb	r3, r3
34001a4c:	3301      	adds	r3, #1
34001a4e:	607b      	str	r3, [r7, #4]
    sysclk = sysclk / ic_divider;
34001a50:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
34001a52:	687b      	ldr	r3, [r7, #4]
34001a54:	fbb2 f3f3 	udiv	r3, r2, r3
34001a58:	62fb      	str	r3, [r7, #44]	@ 0x2c
    break;
34001a5a:	e000      	b.n	34001a5e <SystemCoreClockUpdate+0x336>
    break;
34001a5c:	bf00      	nop
  }

  /* Return system clock frequency (CPU frequency) */
  SystemCoreClock = sysclk;
34001a5e:	4a05      	ldr	r2, [pc, #20]	@ (34001a74 <SystemCoreClockUpdate+0x34c>)
34001a60:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34001a62:	6013      	str	r3, [r2, #0]
}
34001a64:	bf00      	nop
34001a66:	3734      	adds	r7, #52	@ 0x34
34001a68:	46bd      	mov	sp, r7
34001a6a:	f85d 7b04 	ldr.w	r7, [sp], #4
34001a6e:	4770      	bx	lr
34001a70:	56028000 	.word	0x56028000
34001a74:	3401017c 	.word	0x3401017c

34001a78 <__acle_se_SECURE_SystemCoreClockUpdate>:
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  * @retval SystemCoreClock value
  */
CMSE_NS_ENTRY uint32_t SECURE_SystemCoreClockUpdate(void)
{
34001a78:	ed6d cf81 	vstr	FPCXTNS, [sp, #-4]!
34001a7c:	b588      	push	{r3, r7, lr}
34001a7e:	af00      	add	r7, sp, #0
  SystemCoreClockUpdate();
34001a80:	f7ff fe52 	bl	34001728 <SystemCoreClockUpdate>

  return SystemCoreClock;
34001a84:	4b06      	ldr	r3, [pc, #24]	@ (34001aa0 <__acle_se_SECURE_SystemCoreClockUpdate+0x28>)
34001a86:	681b      	ldr	r3, [r3, #0]
}
34001a88:	4618      	mov	r0, r3
34001a8a:	46bd      	mov	sp, r7
34001a8c:	e8bd 4088 	ldmia.w	sp!, {r3, r7, lr}
34001a90:	ec9f 0a10 	vscclrm	{s0-s15, VPR}
34001a94:	e89f 900e 	clrm	{r1, r2, r3, ip, APSR}
34001a98:	ecfd cf81 	vldr	FPCXTNS, [sp], #4
34001a9c:	4774      	bxns	lr
34001a9e:	bf00      	nop
34001aa0:	3401017c 	.word	0x3401017c

34001aa4 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_sstack
34001aa4:	480f      	ldr	r0, [pc, #60]	@ (34001ae4 <LoopForever+0x4>)
  msr   MSPLIM, r0
34001aa6:	f380 880a 	msr	MSPLIM, r0
  ldr   r0, =_estack
34001aaa:	480f      	ldr	r0, [pc, #60]	@ (34001ae8 <LoopForever+0x8>)
  mov   sp, r0          /* set stack pointer */
34001aac:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
34001aae:	f7ff fe03 	bl	340016b8 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
34001ab2:	480e      	ldr	r0, [pc, #56]	@ (34001aec <LoopForever+0xc>)
  ldr r1, =_edata
34001ab4:	490e      	ldr	r1, [pc, #56]	@ (34001af0 <LoopForever+0x10>)
  ldr r2, =_sidata
34001ab6:	4a0f      	ldr	r2, [pc, #60]	@ (34001af4 <LoopForever+0x14>)
  movs r3, #0
34001ab8:	2300      	movs	r3, #0
  b LoopCopyDataInit
34001aba:	e002      	b.n	34001ac2 <LoopCopyDataInit>

34001abc <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
34001abc:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
34001abe:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
34001ac0:	3304      	adds	r3, #4

34001ac2 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
34001ac2:	18c4      	adds	r4, r0, r3
  cmp r4, r1
34001ac4:	428c      	cmp	r4, r1
  bcc CopyDataInit
34001ac6:	d3f9      	bcc.n	34001abc <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
34001ac8:	4a0b      	ldr	r2, [pc, #44]	@ (34001af8 <LoopForever+0x18>)
  ldr r4, =_ebss
34001aca:	4c0c      	ldr	r4, [pc, #48]	@ (34001afc <LoopForever+0x1c>)
  movs r3, #0
34001acc:	2300      	movs	r3, #0
  b LoopFillZerobss
34001ace:	e001      	b.n	34001ad4 <LoopFillZerobss>

34001ad0 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
34001ad0:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
34001ad2:	3204      	adds	r2, #4

34001ad4 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
34001ad4:	42a2      	cmp	r2, r4
  bcc FillZerobss
34001ad6:	d3fb      	bcc.n	34001ad0 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
34001ad8:	f00e f8fc 	bl	3400fcd4 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
34001adc:	f7ff f952 	bl	34000d84 <main>

34001ae0 <LoopForever>:

LoopForever:
  b LoopForever
34001ae0:	e7fe      	b.n	34001ae0 <LoopForever>
34001ae2:	0000      	.short	0x0000
  ldr   r0, =_sstack
34001ae4:	340ff800 	.word	0x340ff800
  ldr   r0, =_estack
34001ae8:	34100000 	.word	0x34100000
  ldr r0, =_sdata
34001aec:	34010154 	.word	0x34010154
  ldr r1, =_edata
34001af0:	340101a0 	.word	0x340101a0
  ldr r2, =_sidata
34001af4:	34010154 	.word	0x34010154
  ldr r2, =_sbss
34001af8:	34011160 	.word	0x34011160
  ldr r4, =_ebss
34001afc:	3401152c 	.word	0x3401152c

34001b00 <ADF1_FLT0_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
34001b00:	e7fe      	b.n	34001b00 <ADF1_FLT0_IRQHandler>
	...

34001b04 <LL_AHB4_GRP1_EnableClock>:
{
34001b04:	b480      	push	{r7}
34001b06:	b085      	sub	sp, #20
34001b08:	af00      	add	r7, sp, #0
34001b0a:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB4ENSR, Periphs);
34001b0c:	4a07      	ldr	r2, [pc, #28]	@ (34001b2c <LL_AHB4_GRP1_EnableClock+0x28>)
34001b0e:	687b      	ldr	r3, [r7, #4]
34001b10:	f8c2 3a5c 	str.w	r3, [r2, #2652]	@ 0xa5c
  tmpreg = READ_REG(RCC->AHB4ENR);
34001b14:	4b05      	ldr	r3, [pc, #20]	@ (34001b2c <LL_AHB4_GRP1_EnableClock+0x28>)
34001b16:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
34001b1a:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34001b1c:	68fb      	ldr	r3, [r7, #12]
}
34001b1e:	bf00      	nop
34001b20:	3714      	adds	r7, #20
34001b22:	46bd      	mov	sp, r7
34001b24:	f85d 7b04 	ldr.w	r7, [sp], #4
34001b28:	4770      	bx	lr
34001b2a:	bf00      	nop
34001b2c:	56028000 	.word	0x56028000

34001b30 <LL_AHB5_GRP1_EnableClock>:
{
34001b30:	b480      	push	{r7}
34001b32:	b085      	sub	sp, #20
34001b34:	af00      	add	r7, sp, #0
34001b36:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5ENSR, Periphs);
34001b38:	4a07      	ldr	r2, [pc, #28]	@ (34001b58 <LL_AHB5_GRP1_EnableClock+0x28>)
34001b3a:	687b      	ldr	r3, [r7, #4]
34001b3c:	f8c2 3a60 	str.w	r3, [r2, #2656]	@ 0xa60
  tmpreg = READ_REG(RCC->AHB5ENR);
34001b40:	4b05      	ldr	r3, [pc, #20]	@ (34001b58 <LL_AHB5_GRP1_EnableClock+0x28>)
34001b42:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
34001b46:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34001b48:	68fb      	ldr	r3, [r7, #12]
}
34001b4a:	bf00      	nop
34001b4c:	3714      	adds	r7, #20
34001b4e:	46bd      	mov	sp, r7
34001b50:	f85d 7b04 	ldr.w	r7, [sp], #4
34001b54:	4770      	bx	lr
34001b56:	bf00      	nop
34001b58:	56028000 	.word	0x56028000

34001b5c <LL_AHB5_GRP1_ForceReset>:
{
34001b5c:	b480      	push	{r7}
34001b5e:	b083      	sub	sp, #12
34001b60:	af00      	add	r7, sp, #0
34001b62:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTSR, Periphs);
34001b64:	4a04      	ldr	r2, [pc, #16]	@ (34001b78 <LL_AHB5_GRP1_ForceReset+0x1c>)
34001b66:	687b      	ldr	r3, [r7, #4]
34001b68:	f8c2 3a20 	str.w	r3, [r2, #2592]	@ 0xa20
}
34001b6c:	bf00      	nop
34001b6e:	370c      	adds	r7, #12
34001b70:	46bd      	mov	sp, r7
34001b72:	f85d 7b04 	ldr.w	r7, [sp], #4
34001b76:	4770      	bx	lr
34001b78:	56028000 	.word	0x56028000

34001b7c <LL_AHB5_GRP1_ReleaseReset>:
{
34001b7c:	b480      	push	{r7}
34001b7e:	b083      	sub	sp, #12
34001b80:	af00      	add	r7, sp, #0
34001b82:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->AHB5RSTCR, Periphs);
34001b84:	4b06      	ldr	r3, [pc, #24]	@ (34001ba0 <LL_AHB5_GRP1_ReleaseReset+0x24>)
34001b86:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34001b8a:	461a      	mov	r2, r3
34001b8c:	687b      	ldr	r3, [r7, #4]
34001b8e:	f8c2 3220 	str.w	r3, [r2, #544]	@ 0x220
}
34001b92:	bf00      	nop
34001b94:	370c      	adds	r7, #12
34001b96:	46bd      	mov	sp, r7
34001b98:	f85d 7b04 	ldr.w	r7, [sp], #4
34001b9c:	4770      	bx	lr
34001b9e:	bf00      	nop
34001ba0:	56028000 	.word	0x56028000

34001ba4 <LL_APB5_GRP1_EnableClock>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_EnableClock(uint32_t Periphs)
{
34001ba4:	b480      	push	{r7}
34001ba6:	b085      	sub	sp, #20
34001ba8:	af00      	add	r7, sp, #0
34001baa:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  WRITE_REG(RCC->APB5ENSR, Periphs);
34001bac:	4a07      	ldr	r2, [pc, #28]	@ (34001bcc <LL_APB5_GRP1_EnableClock+0x28>)
34001bae:	687b      	ldr	r3, [r7, #4]
34001bb0:	f8c2 3a7c 	str.w	r3, [r2, #2684]	@ 0xa7c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_REG(RCC->APB5ENR);
34001bb4:	4b05      	ldr	r3, [pc, #20]	@ (34001bcc <LL_APB5_GRP1_EnableClock+0x28>)
34001bb6:	f8d3 327c 	ldr.w	r3, [r3, #636]	@ 0x27c
34001bba:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
34001bbc:	68fb      	ldr	r3, [r7, #12]
}
34001bbe:	bf00      	nop
34001bc0:	3714      	adds	r7, #20
34001bc2:	46bd      	mov	sp, r7
34001bc4:	f85d 7b04 	ldr.w	r7, [sp], #4
34001bc8:	4770      	bx	lr
34001bca:	bf00      	nop
34001bcc:	56028000 	.word	0x56028000

34001bd0 <LL_APB5_GRP1_ForceReset>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_ForceReset(uint32_t Periphs)
{
34001bd0:	b480      	push	{r7}
34001bd2:	b083      	sub	sp, #12
34001bd4:	af00      	add	r7, sp, #0
34001bd6:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5RSTSR, Periphs);
34001bd8:	4a04      	ldr	r2, [pc, #16]	@ (34001bec <LL_APB5_GRP1_ForceReset+0x1c>)
34001bda:	687b      	ldr	r3, [r7, #4]
34001bdc:	f8c2 3a3c 	str.w	r3, [r2, #2620]	@ 0xa3c
}
34001be0:	bf00      	nop
34001be2:	370c      	adds	r7, #12
34001be4:	46bd      	mov	sp, r7
34001be6:	f85d 7b04 	ldr.w	r7, [sp], #4
34001bea:	4770      	bx	lr
34001bec:	56028000 	.word	0x56028000

34001bf0 <LL_APB5_GRP1_ReleaseReset>:
  *         @arg @ref LL_APB5_GRP1_PERIPH_LTDC
  *         @arg @ref LL_APB5_GRP1_PERIPH_VENC
  * @retval None
  */
__STATIC_INLINE void LL_APB5_GRP1_ReleaseReset(uint32_t Periphs)
{
34001bf0:	b480      	push	{r7}
34001bf2:	b083      	sub	sp, #12
34001bf4:	af00      	add	r7, sp, #0
34001bf6:	6078      	str	r0, [r7, #4]
  WRITE_REG(RCC->APB5RSTCR, Periphs);
34001bf8:	4b06      	ldr	r3, [pc, #24]	@ (34001c14 <LL_APB5_GRP1_ReleaseReset+0x24>)
34001bfa:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
34001bfe:	461a      	mov	r2, r3
34001c00:	687b      	ldr	r3, [r7, #4]
34001c02:	f8c2 323c 	str.w	r3, [r2, #572]	@ 0x23c
}
34001c06:	bf00      	nop
34001c08:	370c      	adds	r7, #12
34001c0a:	46bd      	mov	sp, r7
34001c0c:	f85d 7b04 	ldr.w	r7, [sp], #4
34001c10:	4770      	bx	lr
34001c12:	bf00      	nop
34001c14:	56028000 	.word	0x56028000

34001c18 <BSP_LCD_Init>:
  * @param  Orientation LCD_ORIENTATION_LANDSCAPE
  * @retval BSP status
  */

int32_t BSP_LCD_Init(uint32_t Instance, uint32_t Orientation)
{
34001c18:	b580      	push	{r7, lr}
34001c1a:	b084      	sub	sp, #16
34001c1c:	af02      	add	r7, sp, #8
34001c1e:	6078      	str	r0, [r7, #4]
34001c20:	6039      	str	r1, [r7, #0]
  return BSP_LCD_InitEx(Instance, Orientation, LCD_PIXEL_FORMAT_RGB565, LCD_DEFAULT_WIDTH, LCD_DEFAULT_HEIGHT);
34001c22:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
34001c26:	9300      	str	r3, [sp, #0]
34001c28:	f44f 7348 	mov.w	r3, #800	@ 0x320
34001c2c:	2202      	movs	r2, #2
34001c2e:	6839      	ldr	r1, [r7, #0]
34001c30:	6878      	ldr	r0, [r7, #4]
34001c32:	f000 f805 	bl	34001c40 <BSP_LCD_InitEx>
34001c36:	4603      	mov	r3, r0
}
34001c38:	4618      	mov	r0, r3
34001c3a:	3708      	adds	r7, #8
34001c3c:	46bd      	mov	sp, r7
34001c3e:	bd80      	pop	{r7, pc}

34001c40 <BSP_LCD_InitEx>:
  * @param  Width       Display width
  * @param  Height      Display height
  * @retval BSP status
  */
int32_t BSP_LCD_InitEx(uint32_t Instance, uint32_t Orientation, uint32_t PixelFormat, uint32_t Width, uint32_t Height)
{
34001c40:	b580      	push	{r7, lr}
34001c42:	b08c      	sub	sp, #48	@ 0x30
34001c44:	af00      	add	r7, sp, #0
34001c46:	60f8      	str	r0, [r7, #12]
34001c48:	60b9      	str	r1, [r7, #8]
34001c4a:	607a      	str	r2, [r7, #4]
34001c4c:	603b      	str	r3, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
34001c4e:	2300      	movs	r3, #0
34001c50:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t ltdc_pixel_format;
  MX_LTDC_LayerConfig_t config = {0};
34001c52:	f107 0310 	add.w	r3, r7, #16
34001c56:	2200      	movs	r2, #0
34001c58:	601a      	str	r2, [r3, #0]
34001c5a:	605a      	str	r2, [r3, #4]
34001c5c:	609a      	str	r2, [r3, #8]
34001c5e:	60da      	str	r2, [r3, #12]
34001c60:	611a      	str	r2, [r3, #16]
34001c62:	615a      	str	r2, [r3, #20]

  if ((Orientation > LCD_ORIENTATION_LANDSCAPE) || (Instance >= LCD_INSTANCES_NBR) || \
34001c64:	68bb      	ldr	r3, [r7, #8]
34001c66:	2b01      	cmp	r3, #1
34001c68:	d80e      	bhi.n	34001c88 <BSP_LCD_InitEx+0x48>
34001c6a:	68fb      	ldr	r3, [r7, #12]
34001c6c:	2b00      	cmp	r3, #0
34001c6e:	d10b      	bne.n	34001c88 <BSP_LCD_InitEx+0x48>
34001c70:	687b      	ldr	r3, [r7, #4]
34001c72:	2b02      	cmp	r3, #2
34001c74:	d00c      	beq.n	34001c90 <BSP_LCD_InitEx+0x50>
     ((PixelFormat != LCD_PIXEL_FORMAT_RGB565) && (PixelFormat != LCD_PIXEL_FORMAT_RGB888) && \
34001c76:	687b      	ldr	r3, [r7, #4]
34001c78:	2b01      	cmp	r3, #1
34001c7a:	d009      	beq.n	34001c90 <BSP_LCD_InitEx+0x50>
34001c7c:	687b      	ldr	r3, [r7, #4]
34001c7e:	2b00      	cmp	r3, #0
34001c80:	d006      	beq.n	34001c90 <BSP_LCD_InitEx+0x50>
      (PixelFormat != LCD_PIXEL_FORMAT_ARGB8888) &&  (PixelFormat != LCD_PIXEL_FORMAT_ARGB4444)))
34001c82:	687b      	ldr	r3, [r7, #4]
34001c84:	2b04      	cmp	r3, #4
34001c86:	d003      	beq.n	34001c90 <BSP_LCD_InitEx+0x50>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34001c88:	f06f 0301 	mvn.w	r3, #1
34001c8c:	62fb      	str	r3, [r7, #44]	@ 0x2c
34001c8e:	e087      	b.n	34001da0 <BSP_LCD_InitEx+0x160>
  }
  else
  {
    if (PixelFormat == LCD_PIXEL_FORMAT_RGB565)
34001c90:	687b      	ldr	r3, [r7, #4]
34001c92:	2b02      	cmp	r3, #2
34001c94:	d109      	bne.n	34001caa <BSP_LCD_InitEx+0x6a>
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_RGB565;
34001c96:	2304      	movs	r3, #4
34001c98:	62bb      	str	r3, [r7, #40]	@ 0x28
      Lcd_Ctx[Instance].BppFactor = 2U;
34001c9a:	4a44      	ldr	r2, [pc, #272]	@ (34001dac <BSP_LCD_InitEx+0x16c>)
34001c9c:	68fb      	ldr	r3, [r7, #12]
34001c9e:	015b      	lsls	r3, r3, #5
34001ca0:	4413      	add	r3, r2
34001ca2:	3310      	adds	r3, #16
34001ca4:	2202      	movs	r2, #2
34001ca6:	601a      	str	r2, [r3, #0]
34001ca8:	e022      	b.n	34001cf0 <BSP_LCD_InitEx+0xb0>
    }
    else if  (PixelFormat == LCD_PIXEL_FORMAT_RGB888)
34001caa:	687b      	ldr	r3, [r7, #4]
34001cac:	2b01      	cmp	r3, #1
34001cae:	d109      	bne.n	34001cc4 <BSP_LCD_InitEx+0x84>
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_RGB888;
34001cb0:	2306      	movs	r3, #6
34001cb2:	62bb      	str	r3, [r7, #40]	@ 0x28
      Lcd_Ctx[Instance].BppFactor = 3U;
34001cb4:	4a3d      	ldr	r2, [pc, #244]	@ (34001dac <BSP_LCD_InitEx+0x16c>)
34001cb6:	68fb      	ldr	r3, [r7, #12]
34001cb8:	015b      	lsls	r3, r3, #5
34001cba:	4413      	add	r3, r2
34001cbc:	3310      	adds	r3, #16
34001cbe:	2203      	movs	r2, #3
34001cc0:	601a      	str	r2, [r3, #0]
34001cc2:	e015      	b.n	34001cf0 <BSP_LCD_InitEx+0xb0>
    }
    else if  (PixelFormat == LCD_PIXEL_FORMAT_ARGB4444)
34001cc4:	687b      	ldr	r3, [r7, #4]
34001cc6:	2b04      	cmp	r3, #4
34001cc8:	d109      	bne.n	34001cde <BSP_LCD_InitEx+0x9e>
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_ARGB4444;
34001cca:	2308      	movs	r3, #8
34001ccc:	62bb      	str	r3, [r7, #40]	@ 0x28
      Lcd_Ctx[Instance].BppFactor = 2U;
34001cce:	4a37      	ldr	r2, [pc, #220]	@ (34001dac <BSP_LCD_InitEx+0x16c>)
34001cd0:	68fb      	ldr	r3, [r7, #12]
34001cd2:	015b      	lsls	r3, r3, #5
34001cd4:	4413      	add	r3, r2
34001cd6:	3310      	adds	r3, #16
34001cd8:	2202      	movs	r2, #2
34001cda:	601a      	str	r2, [r3, #0]
34001cdc:	e008      	b.n	34001cf0 <BSP_LCD_InitEx+0xb0>
    }
    else /* LCD_PIXEL_FORMAT_ARGB8888 */
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_ARGB8888;
34001cde:	2300      	movs	r3, #0
34001ce0:	62bb      	str	r3, [r7, #40]	@ 0x28
      Lcd_Ctx[Instance].BppFactor = 4U;
34001ce2:	4a32      	ldr	r2, [pc, #200]	@ (34001dac <BSP_LCD_InitEx+0x16c>)
34001ce4:	68fb      	ldr	r3, [r7, #12]
34001ce6:	015b      	lsls	r3, r3, #5
34001ce8:	4413      	add	r3, r2
34001cea:	3310      	adds	r3, #16
34001cec:	2204      	movs	r2, #4
34001cee:	601a      	str	r2, [r3, #0]
    }

    /* Store pixel format, xsize and ysize information */
    Lcd_Ctx[Instance].PixelFormat = PixelFormat;
34001cf0:	4a2e      	ldr	r2, [pc, #184]	@ (34001dac <BSP_LCD_InitEx+0x16c>)
34001cf2:	68fb      	ldr	r3, [r7, #12]
34001cf4:	015b      	lsls	r3, r3, #5
34001cf6:	4413      	add	r3, r2
34001cf8:	330c      	adds	r3, #12
34001cfa:	687a      	ldr	r2, [r7, #4]
34001cfc:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].XSize  = Width;
34001cfe:	4a2b      	ldr	r2, [pc, #172]	@ (34001dac <BSP_LCD_InitEx+0x16c>)
34001d00:	68fb      	ldr	r3, [r7, #12]
34001d02:	015b      	lsls	r3, r3, #5
34001d04:	4413      	add	r3, r2
34001d06:	683a      	ldr	r2, [r7, #0]
34001d08:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].YSize  = Height;
34001d0a:	4a28      	ldr	r2, [pc, #160]	@ (34001dac <BSP_LCD_InitEx+0x16c>)
34001d0c:	68fb      	ldr	r3, [r7, #12]
34001d0e:	015b      	lsls	r3, r3, #5
34001d10:	4413      	add	r3, r2
34001d12:	3304      	adds	r3, #4
34001d14:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34001d16:	601a      	str	r2, [r3, #0]

    /* Initializes peripherals instance value */
    hlcd_ltdc.Instance = LTDC;
34001d18:	4b25      	ldr	r3, [pc, #148]	@ (34001db0 <BSP_LCD_InitEx+0x170>)
34001d1a:	4a26      	ldr	r2, [pc, #152]	@ (34001db4 <BSP_LCD_InitEx+0x174>)
34001d1c:	601a      	str	r2, [r3, #0]
    hlcd_dma2d.Instance = DMA2D;
34001d1e:	4b26      	ldr	r3, [pc, #152]	@ (34001db8 <BSP_LCD_InitEx+0x178>)
34001d20:	4a26      	ldr	r2, [pc, #152]	@ (34001dbc <BSP_LCD_InitEx+0x17c>)
34001d22:	601a      	str	r2, [r3, #0]
      {
        return BSP_ERROR_PERIPH_FAILURE;
      }
    }
#else
    LTDC_MspInit(&hlcd_ltdc);
34001d24:	4822      	ldr	r0, [pc, #136]	@ (34001db0 <BSP_LCD_InitEx+0x170>)
34001d26:	f000 fabd 	bl	340022a4 <LTDC_MspInit>
#endif /* (USE_HAL_LTDC_REGISTER_CALLBACKS == 1) */

    DMA2D_MspInit(&hlcd_dma2d);
34001d2a:	4823      	ldr	r0, [pc, #140]	@ (34001db8 <BSP_LCD_InitEx+0x178>)
34001d2c:	f000 fb76 	bl	3400241c <DMA2D_MspInit>

    if (MX_LTDC_ClockConfig(&hlcd_ltdc) != HAL_OK)
34001d30:	481f      	ldr	r0, [pc, #124]	@ (34001db0 <BSP_LCD_InitEx+0x170>)
34001d32:	f000 f8dc 	bl	34001eee <MX_LTDC_ClockConfig>
34001d36:	4603      	mov	r3, r0
34001d38:	2b00      	cmp	r3, #0
34001d3a:	d003      	beq.n	34001d44 <BSP_LCD_InitEx+0x104>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
34001d3c:	f06f 0303 	mvn.w	r3, #3
34001d40:	62fb      	str	r3, [r7, #44]	@ 0x2c
34001d42:	e00a      	b.n	34001d5a <BSP_LCD_InitEx+0x11a>
    }
    else
    {
      if (MX_LTDC_Init(&hlcd_ltdc, Width, Height) != HAL_OK)
34001d44:	6bba      	ldr	r2, [r7, #56]	@ 0x38
34001d46:	6839      	ldr	r1, [r7, #0]
34001d48:	4819      	ldr	r0, [pc, #100]	@ (34001db0 <BSP_LCD_InitEx+0x170>)
34001d4a:	f000 f83b 	bl	34001dc4 <MX_LTDC_Init>
34001d4e:	4603      	mov	r3, r0
34001d50:	2b00      	cmp	r3, #0
34001d52:	d002      	beq.n	34001d5a <BSP_LCD_InitEx+0x11a>
      {
        ret = BSP_ERROR_PERIPH_FAILURE;
34001d54:	f06f 0303 	mvn.w	r3, #3
34001d58:	62fb      	str	r3, [r7, #44]	@ 0x2c
      }
    }

    if (ret == BSP_ERROR_NONE)
34001d5a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34001d5c:	2b00      	cmp	r3, #0
34001d5e:	d11f      	bne.n	34001da0 <BSP_LCD_InitEx+0x160>
      else
      {
#endif /* DATA_IN_ExtRAM */
        /* Configure default LTDC Layer 0. This configuration can be override by calling
        BSP_LCD_ConfigLayer() at application level */
        config.X0          = 0;
34001d60:	2300      	movs	r3, #0
34001d62:	613b      	str	r3, [r7, #16]
        config.X1          = Width;
34001d64:	683b      	ldr	r3, [r7, #0]
34001d66:	617b      	str	r3, [r7, #20]
        config.Y0          = 0;
34001d68:	2300      	movs	r3, #0
34001d6a:	61bb      	str	r3, [r7, #24]
        config.Y1          = Height;
34001d6c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
34001d6e:	61fb      	str	r3, [r7, #28]
        config.PixelFormat = ltdc_pixel_format;
34001d70:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34001d72:	623b      	str	r3, [r7, #32]
        config.Address     = LCD_LAYER_0_ADDRESS;
34001d74:	4b12      	ldr	r3, [pc, #72]	@ (34001dc0 <BSP_LCD_InitEx+0x180>)
34001d76:	627b      	str	r3, [r7, #36]	@ 0x24

        if (MX_LTDC_ConfigLayer(&hlcd_ltdc, 0, &config) != HAL_OK)
34001d78:	f107 0310 	add.w	r3, r7, #16
34001d7c:	461a      	mov	r2, r3
34001d7e:	2100      	movs	r1, #0
34001d80:	480b      	ldr	r0, [pc, #44]	@ (34001db0 <BSP_LCD_InitEx+0x170>)
34001d82:	f000 f86b 	bl	34001e5c <MX_LTDC_ConfigLayer>
34001d86:	4603      	mov	r3, r0
34001d88:	2b00      	cmp	r3, #0
34001d8a:	d002      	beq.n	34001d92 <BSP_LCD_InitEx+0x152>
        {
          ret = BSP_ERROR_PERIPH_FAILURE;
34001d8c:	f06f 0303 	mvn.w	r3, #3
34001d90:	62fb      	str	r3, [r7, #44]	@ 0x2c
        }

        /* By default the reload is activated and executed immediately */
        Lcd_Ctx[Instance].ReloadEnable = 1U;
34001d92:	4a06      	ldr	r2, [pc, #24]	@ (34001dac <BSP_LCD_InitEx+0x16c>)
34001d94:	68fb      	ldr	r3, [r7, #12]
34001d96:	015b      	lsls	r3, r3, #5
34001d98:	4413      	add	r3, r2
34001d9a:	3318      	adds	r3, #24
34001d9c:	2201      	movs	r2, #1
34001d9e:	601a      	str	r2, [r3, #0]
      }
#endif /* DATA_IN_ExtRAM */
    }
  }

  return ret;
34001da0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
}
34001da2:	4618      	mov	r0, r3
34001da4:	3730      	adds	r7, #48	@ 0x30
34001da6:	46bd      	mov	sp, r7
34001da8:	bd80      	pop	{r7, pc}
34001daa:	bf00      	nop
34001dac:	340113bc 	.word	0x340113bc
34001db0:	34011314 	.word	0x34011314
34001db4:	58001000 	.word	0x58001000
34001db8:	340112ac 	.word	0x340112ac
34001dbc:	58021000 	.word	0x58021000
34001dc0:	34100000 	.word	0x34100000

34001dc4 <MX_LTDC_Init>:
  * @param  Width  LTDC width
  * @param  Height LTDC height
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_LTDC_Init(LTDC_HandleTypeDef *hltdc, uint32_t Width, uint32_t Height)
{
34001dc4:	b580      	push	{r7, lr}
34001dc6:	b084      	sub	sp, #16
34001dc8:	af00      	add	r7, sp, #0
34001dca:	60f8      	str	r0, [r7, #12]
34001dcc:	60b9      	str	r1, [r7, #8]
34001dce:	607a      	str	r2, [r7, #4]
  hltdc->Instance = LTDC;
34001dd0:	68fb      	ldr	r3, [r7, #12]
34001dd2:	4a21      	ldr	r2, [pc, #132]	@ (34001e58 <MX_LTDC_Init+0x94>)
34001dd4:	601a      	str	r2, [r3, #0]
  hltdc->Init.HSPolarity = LTDC_HSPOLARITY_AL;
34001dd6:	68fb      	ldr	r3, [r7, #12]
34001dd8:	2200      	movs	r2, #0
34001dda:	605a      	str	r2, [r3, #4]
  hltdc->Init.VSPolarity = LTDC_VSPOLARITY_AL;
34001ddc:	68fb      	ldr	r3, [r7, #12]
34001dde:	2200      	movs	r2, #0
34001de0:	609a      	str	r2, [r3, #8]
  hltdc->Init.DEPolarity = LTDC_DEPOLARITY_AL;
34001de2:	68fb      	ldr	r3, [r7, #12]
34001de4:	2200      	movs	r2, #0
34001de6:	60da      	str	r2, [r3, #12]
  hltdc->Init.PCPolarity = LTDC_PCPOLARITY_IPC;
34001de8:	68fb      	ldr	r3, [r7, #12]
34001dea:	2200      	movs	r2, #0
34001dec:	611a      	str	r2, [r3, #16]

  hltdc->Init.HorizontalSync     = (uint32_t)RK050HR18_HSYNC - 1U;
34001dee:	68fb      	ldr	r3, [r7, #12]
34001df0:	2203      	movs	r2, #3
34001df2:	615a      	str	r2, [r3, #20]
  hltdc->Init.AccumulatedHBP     = (uint32_t)RK050HR18_HSYNC + (uint32_t)RK050HR18_HBP - 1U;
34001df4:	68fb      	ldr	r3, [r7, #12]
34001df6:	220b      	movs	r2, #11
34001df8:	61da      	str	r2, [r3, #28]
  hltdc->Init.AccumulatedActiveW = (uint32_t)RK050HR18_HSYNC + Width + (uint32_t)RK050HR18_HBP -1U;
34001dfa:	68bb      	ldr	r3, [r7, #8]
34001dfc:	f103 020b 	add.w	r2, r3, #11
34001e00:	68fb      	ldr	r3, [r7, #12]
34001e02:	625a      	str	r2, [r3, #36]	@ 0x24
  hltdc->Init.TotalWidth         = (uint32_t)RK050HR18_HSYNC + Width + (uint32_t)RK050HR18_HBP + RK050HR18_HFP - 1U;
34001e04:	68bb      	ldr	r3, [r7, #8]
34001e06:	f103 0213 	add.w	r2, r3, #19
34001e0a:	68fb      	ldr	r3, [r7, #12]
34001e0c:	62da      	str	r2, [r3, #44]	@ 0x2c
  hltdc->Init.VerticalSync       = (uint32_t)RK050HR18_VSYNC - 1U;
34001e0e:	68fb      	ldr	r3, [r7, #12]
34001e10:	2203      	movs	r2, #3
34001e12:	619a      	str	r2, [r3, #24]
  hltdc->Init.AccumulatedVBP     = (uint32_t)RK050HR18_VSYNC + (uint32_t)RK050HR18_VBP - 1U;
34001e14:	68fb      	ldr	r3, [r7, #12]
34001e16:	220b      	movs	r2, #11
34001e18:	621a      	str	r2, [r3, #32]
  hltdc->Init.AccumulatedActiveH = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP -1U;
34001e1a:	687b      	ldr	r3, [r7, #4]
34001e1c:	f103 020b 	add.w	r2, r3, #11
34001e20:	68fb      	ldr	r3, [r7, #12]
34001e22:	629a      	str	r2, [r3, #40]	@ 0x28
  hltdc->Init.TotalHeigh         = (uint32_t)RK050HR18_VSYNC + Height + (uint32_t)RK050HR18_VBP + RK050HR18_VFP - 1U;
34001e24:	687b      	ldr	r3, [r7, #4]
34001e26:	f103 0213 	add.w	r2, r3, #19
34001e2a:	68fb      	ldr	r3, [r7, #12]
34001e2c:	631a      	str	r2, [r3, #48]	@ 0x30

  hltdc->Init.Backcolor.Blue  = 0x0;
34001e2e:	68fb      	ldr	r3, [r7, #12]
34001e30:	2200      	movs	r2, #0
34001e32:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  hltdc->Init.Backcolor.Green = 0x0;
34001e36:	68fb      	ldr	r3, [r7, #12]
34001e38:	2200      	movs	r2, #0
34001e3a:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
  hltdc->Init.Backcolor.Red   = 0x0;
34001e3e:	68fb      	ldr	r3, [r7, #12]
34001e40:	2200      	movs	r2, #0
34001e42:	f883 2036 	strb.w	r2, [r3, #54]	@ 0x36

  return HAL_LTDC_Init(hltdc);
34001e46:	68f8      	ldr	r0, [r7, #12]
34001e48:	f004 ff8f 	bl	34006d6a <HAL_LTDC_Init>
34001e4c:	4603      	mov	r3, r0
}
34001e4e:	4618      	mov	r0, r3
34001e50:	3710      	adds	r7, #16
34001e52:	46bd      	mov	sp, r7
34001e54:	bd80      	pop	{r7, pc}
34001e56:	bf00      	nop
34001e58:	58001000 	.word	0x58001000

34001e5c <MX_LTDC_ConfigLayer>:
  * @param  LayerIndex Layer 0 or 1
  * @param  Config     Layer configuration
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, uint32_t LayerIndex, MX_LTDC_LayerConfig_t *Config)
{
34001e5c:	b580      	push	{r7, lr}
34001e5e:	b092      	sub	sp, #72	@ 0x48
34001e60:	af00      	add	r7, sp, #0
34001e62:	60f8      	str	r0, [r7, #12]
34001e64:	60b9      	str	r1, [r7, #8]
34001e66:	607a      	str	r2, [r7, #4]
  LTDC_LayerCfgTypeDef pLayerCfg ={0};
34001e68:	f107 0314 	add.w	r3, r7, #20
34001e6c:	2234      	movs	r2, #52	@ 0x34
34001e6e:	2100      	movs	r1, #0
34001e70:	4618      	mov	r0, r3
34001e72:	f00d ff27 	bl	3400fcc4 <memset>

  pLayerCfg.WindowX0 = Config->X0;
34001e76:	687b      	ldr	r3, [r7, #4]
34001e78:	681b      	ldr	r3, [r3, #0]
34001e7a:	617b      	str	r3, [r7, #20]
  pLayerCfg.WindowX1 = Config->X1;
34001e7c:	687b      	ldr	r3, [r7, #4]
34001e7e:	685b      	ldr	r3, [r3, #4]
34001e80:	61bb      	str	r3, [r7, #24]
  pLayerCfg.WindowY0 = Config->Y0;
34001e82:	687b      	ldr	r3, [r7, #4]
34001e84:	689b      	ldr	r3, [r3, #8]
34001e86:	61fb      	str	r3, [r7, #28]
  pLayerCfg.WindowY1 = Config->Y1;
34001e88:	687b      	ldr	r3, [r7, #4]
34001e8a:	68db      	ldr	r3, [r3, #12]
34001e8c:	623b      	str	r3, [r7, #32]
  pLayerCfg.PixelFormat = Config->PixelFormat;
34001e8e:	687b      	ldr	r3, [r7, #4]
34001e90:	691b      	ldr	r3, [r3, #16]
34001e92:	627b      	str	r3, [r7, #36]	@ 0x24
  pLayerCfg.Alpha = LTDC_LxCACR_CONSTA;
34001e94:	23ff      	movs	r3, #255	@ 0xff
34001e96:	62bb      	str	r3, [r7, #40]	@ 0x28
  pLayerCfg.Alpha0 = 0;
34001e98:	2300      	movs	r3, #0
34001e9a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
34001e9c:	f44f 63c0 	mov.w	r3, #1536	@ 0x600
34001ea0:	633b      	str	r3, [r7, #48]	@ 0x30
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
34001ea2:	2307      	movs	r3, #7
34001ea4:	637b      	str	r3, [r7, #52]	@ 0x34
  pLayerCfg.FBStartAdress = Config->Address;
34001ea6:	687b      	ldr	r3, [r7, #4]
34001ea8:	695b      	ldr	r3, [r3, #20]
34001eaa:	63bb      	str	r3, [r7, #56]	@ 0x38
  pLayerCfg.ImageWidth = (Config->X1 - Config->X0);
34001eac:	687b      	ldr	r3, [r7, #4]
34001eae:	685a      	ldr	r2, [r3, #4]
34001eb0:	687b      	ldr	r3, [r7, #4]
34001eb2:	681b      	ldr	r3, [r3, #0]
34001eb4:	1ad3      	subs	r3, r2, r3
34001eb6:	63fb      	str	r3, [r7, #60]	@ 0x3c
  pLayerCfg.ImageHeight = (Config->Y1 - Config->Y0);
34001eb8:	687b      	ldr	r3, [r7, #4]
34001eba:	68da      	ldr	r2, [r3, #12]
34001ebc:	687b      	ldr	r3, [r7, #4]
34001ebe:	689b      	ldr	r3, [r3, #8]
34001ec0:	1ad3      	subs	r3, r2, r3
34001ec2:	643b      	str	r3, [r7, #64]	@ 0x40
  pLayerCfg.Backcolor.Blue = 0;
34001ec4:	2300      	movs	r3, #0
34001ec6:	f887 3044 	strb.w	r3, [r7, #68]	@ 0x44
  pLayerCfg.Backcolor.Green = 0;
34001eca:	2300      	movs	r3, #0
34001ecc:	f887 3045 	strb.w	r3, [r7, #69]	@ 0x45
  pLayerCfg.Backcolor.Red = 0;
34001ed0:	2300      	movs	r3, #0
34001ed2:	f887 3046 	strb.w	r3, [r7, #70]	@ 0x46
  return HAL_LTDC_ConfigLayer(hltdc, &pLayerCfg, LayerIndex);
34001ed6:	f107 0314 	add.w	r3, r7, #20
34001eda:	68ba      	ldr	r2, [r7, #8]
34001edc:	4619      	mov	r1, r3
34001ede:	68f8      	ldr	r0, [r7, #12]
34001ee0:	f004 fff8 	bl	34006ed4 <HAL_LTDC_ConfigLayer>
34001ee4:	4603      	mov	r3, r0
}
34001ee6:	4618      	mov	r0, r3
34001ee8:	3748      	adds	r7, #72	@ 0x48
34001eea:	46bd      	mov	sp, r7
34001eec:	bd80      	pop	{r7, pc}

34001eee <MX_LTDC_ClockConfig>:
  * @param  hltdc  LTDC Handle
  *         Being __weak it can be overwritten by the application
  * @retval HAL_status
  */
__weak HAL_StatusTypeDef MX_LTDC_ClockConfig(LTDC_HandleTypeDef *hltdc)
{
34001eee:	b580      	push	{r7, lr}
34001ef0:	b0e8      	sub	sp, #416	@ 0x1a0
34001ef2:	af00      	add	r7, sp, #0
34001ef4:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34001ef8:	f5a3 73ce 	sub.w	r3, r3, #412	@ 0x19c
34001efc:	6018      	str	r0, [r3, #0]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hltdc);

  HAL_StatusTypeDef   status =  HAL_OK;
34001efe:	2300      	movs	r3, #0
34001f00:	f887 319f 	strb.w	r3, [r7, #415]	@ 0x19f
  RCC_PeriphCLKInitTypeDef RCC_PeriphCLKInitStruct = {0};
34001f04:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34001f08:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
34001f0c:	4618      	mov	r0, r3
34001f0e:	f44f 73c8 	mov.w	r3, #400	@ 0x190
34001f12:	461a      	mov	r2, r3
34001f14:	2100      	movs	r1, #0
34001f16:	f00d fed5 	bl	3400fcc4 <memset>
  /* PLL3_VCO Input = HSE_VALUE/PLLM = 48 Mhz / 192 = 0.25 */
  /* PLL3_VCO Output = PLL3_VCO Input * PLLN = 0.25 Mhz * 100 = 25 */
  /* PLLLCDCLK = PLL3_VCO Output/(PLLP1 * PLLP2) = 25/1 = 25Mhz */
  /* LTDC clock frequency = PLLLCDCLK = 25 Mhz */

  RCC_PeriphCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
34001f1a:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34001f1e:	f5a3 71cc 	sub.w	r1, r3, #408	@ 0x198
34001f22:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
34001f26:	f04f 0300 	mov.w	r3, #0
34001f2a:	e9c1 2300 	strd	r2, r3, [r1]
  RCC_PeriphCLKInitStruct.LtdcClockSelection = RCC_LTDCCLKSOURCE_IC16;
34001f2e:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34001f32:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
34001f36:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
34001f3a:	f8c3 2118 	str.w	r2, [r3, #280]	@ 0x118
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC16].ClockSelection = RCC_ICCLKSOURCE_PLL4;
34001f3e:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34001f42:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
34001f46:	f04f 5240 	mov.w	r2, #805306368	@ 0x30000000
34001f4a:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  RCC_PeriphCLKInitStruct.ICSelection[RCC_IC16].ClockDivider = 2;
34001f4e:	f507 73d0 	add.w	r3, r7, #416	@ 0x1a0
34001f52:	f5a3 73cc 	sub.w	r3, r3, #408	@ 0x198
34001f56:	2202      	movs	r2, #2
34001f58:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  if (HAL_RCCEx_PeriphCLKConfig(&RCC_PeriphCLKInitStruct) != HAL_OK)
34001f5c:	f107 0308 	add.w	r3, r7, #8
34001f60:	4618      	mov	r0, r3
34001f62:	f006 fbd3 	bl	3400870c <HAL_RCCEx_PeriphCLKConfig>
34001f66:	4603      	mov	r3, r0
34001f68:	2b00      	cmp	r3, #0
34001f6a:	d002      	beq.n	34001f72 <MX_LTDC_ClockConfig+0x84>
  {
    status = HAL_ERROR;
34001f6c:	2301      	movs	r3, #1
34001f6e:	f887 319f 	strb.w	r3, [r7, #415]	@ 0x19f
  }

  return status;
34001f72:	f897 319f 	ldrb.w	r3, [r7, #415]	@ 0x19f
}
34001f76:	4618      	mov	r0, r3
34001f78:	f507 77d0 	add.w	r7, r7, #416	@ 0x1a0
34001f7c:	46bd      	mov	sp, r7
34001f7e:	bd80      	pop	{r7, pc}

34001f80 <BSP_LCD_GetXSize>:
  * @param  Instance  LCD Instance
  * @param  XSize     LCD width
  * @retval BSP status
  */
int32_t BSP_LCD_GetXSize(uint32_t Instance, uint32_t *XSize)
{
34001f80:	b480      	push	{r7}
34001f82:	b085      	sub	sp, #20
34001f84:	af00      	add	r7, sp, #0
34001f86:	6078      	str	r0, [r7, #4]
34001f88:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
34001f8a:	2300      	movs	r3, #0
34001f8c:	60fb      	str	r3, [r7, #12]

  if(Instance >= LCD_INSTANCES_NBR)
34001f8e:	687b      	ldr	r3, [r7, #4]
34001f90:	2b00      	cmp	r3, #0
34001f92:	d003      	beq.n	34001f9c <BSP_LCD_GetXSize+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34001f94:	f06f 0301 	mvn.w	r3, #1
34001f98:	60fb      	str	r3, [r7, #12]
34001f9a:	e006      	b.n	34001faa <BSP_LCD_GetXSize+0x2a>
  }
  else
  {
    *XSize = Lcd_Ctx[Instance].XSize;
34001f9c:	4a06      	ldr	r2, [pc, #24]	@ (34001fb8 <BSP_LCD_GetXSize+0x38>)
34001f9e:	687b      	ldr	r3, [r7, #4]
34001fa0:	015b      	lsls	r3, r3, #5
34001fa2:	4413      	add	r3, r2
34001fa4:	681a      	ldr	r2, [r3, #0]
34001fa6:	683b      	ldr	r3, [r7, #0]
34001fa8:	601a      	str	r2, [r3, #0]
  }

  return ret;
34001faa:	68fb      	ldr	r3, [r7, #12]
}
34001fac:	4618      	mov	r0, r3
34001fae:	3714      	adds	r7, #20
34001fb0:	46bd      	mov	sp, r7
34001fb2:	f85d 7b04 	ldr.w	r7, [sp], #4
34001fb6:	4770      	bx	lr
34001fb8:	340113bc 	.word	0x340113bc

34001fbc <BSP_LCD_GetYSize>:
  * @param  Instance  LCD Instance
  * @param  YSize     LCD Height
  * @retval BSP status
  */
int32_t BSP_LCD_GetYSize(uint32_t Instance, uint32_t *YSize)
{
34001fbc:	b480      	push	{r7}
34001fbe:	b085      	sub	sp, #20
34001fc0:	af00      	add	r7, sp, #0
34001fc2:	6078      	str	r0, [r7, #4]
34001fc4:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
34001fc6:	2300      	movs	r3, #0
34001fc8:	60fb      	str	r3, [r7, #12]

  if(Instance >= LCD_INSTANCES_NBR)
34001fca:	687b      	ldr	r3, [r7, #4]
34001fcc:	2b00      	cmp	r3, #0
34001fce:	d003      	beq.n	34001fd8 <BSP_LCD_GetYSize+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34001fd0:	f06f 0301 	mvn.w	r3, #1
34001fd4:	60fb      	str	r3, [r7, #12]
34001fd6:	e007      	b.n	34001fe8 <BSP_LCD_GetYSize+0x2c>
  }
  else
  {
    *YSize = Lcd_Ctx[Instance].YSize;
34001fd8:	4a07      	ldr	r2, [pc, #28]	@ (34001ff8 <BSP_LCD_GetYSize+0x3c>)
34001fda:	687b      	ldr	r3, [r7, #4]
34001fdc:	015b      	lsls	r3, r3, #5
34001fde:	4413      	add	r3, r2
34001fe0:	3304      	adds	r3, #4
34001fe2:	681a      	ldr	r2, [r3, #0]
34001fe4:	683b      	ldr	r3, [r7, #0]
34001fe6:	601a      	str	r2, [r3, #0]
  }

  return ret;
34001fe8:	68fb      	ldr	r3, [r7, #12]
}
34001fea:	4618      	mov	r0, r3
34001fec:	3714      	adds	r7, #20
34001fee:	46bd      	mov	sp, r7
34001ff0:	f85d 7b04 	ldr.w	r7, [sp], #4
34001ff4:	4770      	bx	lr
34001ff6:	bf00      	nop
34001ff8:	340113bc 	.word	0x340113bc

34001ffc <BSP_LCD_DisplayOn>:
  * @brief  Switch On the display.
  * @param  Instance    LCD Instance
  * @retval BSP status
  */
int32_t BSP_LCD_DisplayOn(uint32_t Instance)
{
34001ffc:	b580      	push	{r7, lr}
34001ffe:	b088      	sub	sp, #32
34002000:	af00      	add	r7, sp, #0
34002002:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
34002004:	2300      	movs	r3, #0
34002006:	61fb      	str	r3, [r7, #28]
  GPIO_InitTypeDef gpio_init_structure = {0};
34002008:	f107 0308 	add.w	r3, r7, #8
3400200c:	2200      	movs	r2, #0
3400200e:	601a      	str	r2, [r3, #0]
34002010:	605a      	str	r2, [r3, #4]
34002012:	609a      	str	r2, [r3, #8]
34002014:	60da      	str	r2, [r3, #12]
34002016:	611a      	str	r2, [r3, #16]

  if(Instance >= LCD_INSTANCES_NBR)
34002018:	687b      	ldr	r3, [r7, #4]
3400201a:	2b00      	cmp	r3, #0
3400201c:	d003      	beq.n	34002026 <BSP_LCD_DisplayOn+0x2a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
3400201e:	f06f 0301 	mvn.w	r3, #1
34002022:	61fb      	str	r3, [r7, #28]
34002024:	e01a      	b.n	3400205c <BSP_LCD_DisplayOn+0x60>
  }
  else
  {
    __HAL_LTDC_ENABLE(&hlcd_ltdc);
34002026:	4b10      	ldr	r3, [pc, #64]	@ (34002068 <BSP_LCD_DisplayOn+0x6c>)
34002028:	681b      	ldr	r3, [r3, #0]
3400202a:	699a      	ldr	r2, [r3, #24]
3400202c:	4b0e      	ldr	r3, [pc, #56]	@ (34002068 <BSP_LCD_DisplayOn+0x6c>)
3400202e:	681b      	ldr	r3, [r3, #0]
34002030:	f042 0201 	orr.w	r2, r2, #1
34002034:	619a      	str	r2, [r3, #24]
    gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
34002036:	2301      	movs	r3, #1
34002038:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Pull = GPIO_PULLUP;
3400203a:	2301      	movs	r3, #1
3400203c:	613b      	str	r3, [r7, #16]
    gpio_init_structure.Pin  = LCD_DISP_EN_PIN;
3400203e:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
34002042:	60bb      	str	r3, [r7, #8]
    HAL_GPIO_Init(LCD_DISP_EN_GPIO_PORT, &gpio_init_structure);
34002044:	f107 0308 	add.w	r3, r7, #8
34002048:	4619      	mov	r1, r3
3400204a:	4808      	ldr	r0, [pc, #32]	@ (3400206c <BSP_LCD_DisplayOn+0x70>)
3400204c:	f002 fdf4 	bl	34004c38 <HAL_GPIO_Init>

    /* Assert LCD_DISP_EN pin */
    HAL_GPIO_WritePin(LCD_DISP_EN_GPIO_PORT,LCD_DISP_EN_PIN, GPIO_PIN_SET);
34002050:	2201      	movs	r2, #1
34002052:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
34002056:	4805      	ldr	r0, [pc, #20]	@ (3400206c <BSP_LCD_DisplayOn+0x70>)
34002058:	f002 ffa0 	bl	34004f9c <HAL_GPIO_WritePin>
  }

  return ret;
3400205c:	69fb      	ldr	r3, [r7, #28]
}
3400205e:	4618      	mov	r0, r3
34002060:	3720      	adds	r7, #32
34002062:	46bd      	mov	sp, r7
34002064:	bd80      	pop	{r7, pc}
34002066:	bf00      	nop
34002068:	34011314 	.word	0x34011314
3400206c:	56021800 	.word	0x56021800

34002070 <BSP_LCD_DisplayOff>:
  * @brief  Switch Off the display.
  * @param  Instance    LCD Instance
  * @retval BSP status
  */
int32_t BSP_LCD_DisplayOff(uint32_t Instance)
{
34002070:	b580      	push	{r7, lr}
34002072:	b088      	sub	sp, #32
34002074:	af00      	add	r7, sp, #0
34002076:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
34002078:	2300      	movs	r3, #0
3400207a:	61fb      	str	r3, [r7, #28]
  GPIO_InitTypeDef gpio_init_structure = {0};
3400207c:	f107 0308 	add.w	r3, r7, #8
34002080:	2200      	movs	r2, #0
34002082:	601a      	str	r2, [r3, #0]
34002084:	605a      	str	r2, [r3, #4]
34002086:	609a      	str	r2, [r3, #8]
34002088:	60da      	str	r2, [r3, #12]
3400208a:	611a      	str	r2, [r3, #16]

  if(Instance >= LCD_INSTANCES_NBR)
3400208c:	687b      	ldr	r3, [r7, #4]
3400208e:	2b00      	cmp	r3, #0
34002090:	d003      	beq.n	3400209a <BSP_LCD_DisplayOff+0x2a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
34002092:	f06f 0301 	mvn.w	r3, #1
34002096:	61fb      	str	r3, [r7, #28]
34002098:	e01c      	b.n	340020d4 <BSP_LCD_DisplayOff+0x64>
  }
  else
  {
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
3400209a:	2301      	movs	r3, #1
3400209c:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Pull      = GPIO_NOPULL;
3400209e:	2300      	movs	r3, #0
340020a0:	613b      	str	r3, [r7, #16]
    gpio_init_structure.Speed     = GPIO_SPEED_FREQ_MEDIUM;
340020a2:	2301      	movs	r3, #1
340020a4:	617b      	str	r3, [r7, #20]
    gpio_init_structure.Pin       = LCD_DISP_EN_PIN;
340020a6:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
340020aa:	60bb      	str	r3, [r7, #8]
    HAL_GPIO_Init(LCD_DISP_EN_GPIO_PORT, &gpio_init_structure);
340020ac:	f107 0308 	add.w	r3, r7, #8
340020b0:	4619      	mov	r1, r3
340020b2:	480b      	ldr	r0, [pc, #44]	@ (340020e0 <BSP_LCD_DisplayOff+0x70>)
340020b4:	f002 fdc0 	bl	34004c38 <HAL_GPIO_Init>

    HAL_GPIO_WritePin(LCD_DISP_EN_GPIO_PORT,LCD_DISP_EN_PIN, GPIO_PIN_RESET);
340020b8:	2200      	movs	r2, #0
340020ba:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
340020be:	4808      	ldr	r0, [pc, #32]	@ (340020e0 <BSP_LCD_DisplayOff+0x70>)
340020c0:	f002 ff6c 	bl	34004f9c <HAL_GPIO_WritePin>

    __HAL_LTDC_DISABLE(&hlcd_ltdc);
340020c4:	4b07      	ldr	r3, [pc, #28]	@ (340020e4 <BSP_LCD_DisplayOff+0x74>)
340020c6:	681b      	ldr	r3, [r3, #0]
340020c8:	699a      	ldr	r2, [r3, #24]
340020ca:	4b06      	ldr	r3, [pc, #24]	@ (340020e4 <BSP_LCD_DisplayOff+0x74>)
340020cc:	681b      	ldr	r3, [r3, #0]
340020ce:	f022 0201 	bic.w	r2, r2, #1
340020d2:	619a      	str	r2, [r3, #24]

  }

  return ret;
340020d4:	69fb      	ldr	r3, [r7, #28]
}
340020d6:	4618      	mov	r0, r3
340020d8:	3720      	adds	r7, #32
340020da:	46bd      	mov	sp, r7
340020dc:	bd80      	pop	{r7, pc}
340020de:	bf00      	nop
340020e0:	56021800 	.word	0x56021800
340020e4:	34011314 	.word	0x34011314

340020e8 <BSP_LCD_FillRect>:
  * @param  Height Rectangle height
  * @param  Color RGB color
  * @retval BSP status
  */
int32_t BSP_LCD_FillRect(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Width, uint32_t Height, uint32_t Color)
{
340020e8:	b580      	push	{r7, lr}
340020ea:	b088      	sub	sp, #32
340020ec:	af02      	add	r7, sp, #8
340020ee:	60f8      	str	r0, [r7, #12]
340020f0:	60b9      	str	r1, [r7, #8]
340020f2:	607a      	str	r2, [r7, #4]
340020f4:	603b      	str	r3, [r7, #0]
  uint32_t  Xaddress;

  /* Get the rectangle start address */
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
340020f6:	4a1b      	ldr	r2, [pc, #108]	@ (34002164 <BSP_LCD_FillRect+0x7c>)
340020f8:	68fb      	ldr	r3, [r7, #12]
340020fa:	015b      	lsls	r3, r3, #5
340020fc:	4413      	add	r3, r2
340020fe:	3308      	adds	r3, #8
34002100:	681b      	ldr	r3, [r3, #0]
34002102:	4a19      	ldr	r2, [pc, #100]	@ (34002168 <BSP_LCD_FillRect+0x80>)
34002104:	2134      	movs	r1, #52	@ 0x34
34002106:	fb01 f303 	mul.w	r3, r1, r3
3400210a:	4413      	add	r3, r2
3400210c:	335c      	adds	r3, #92	@ 0x5c
3400210e:	681a      	ldr	r2, [r3, #0]
34002110:	4914      	ldr	r1, [pc, #80]	@ (34002164 <BSP_LCD_FillRect+0x7c>)
34002112:	68fb      	ldr	r3, [r7, #12]
34002114:	015b      	lsls	r3, r3, #5
34002116:	440b      	add	r3, r1
34002118:	3310      	adds	r3, #16
3400211a:	681b      	ldr	r3, [r3, #0]
3400211c:	4811      	ldr	r0, [pc, #68]	@ (34002164 <BSP_LCD_FillRect+0x7c>)
3400211e:	68f9      	ldr	r1, [r7, #12]
34002120:	0149      	lsls	r1, r1, #5
34002122:	4401      	add	r1, r0
34002124:	6809      	ldr	r1, [r1, #0]
34002126:	6878      	ldr	r0, [r7, #4]
34002128:	fb01 f000 	mul.w	r0, r1, r0
3400212c:	68b9      	ldr	r1, [r7, #8]
3400212e:	4401      	add	r1, r0
34002130:	fb01 f303 	mul.w	r3, r1, r3
34002134:	4413      	add	r3, r2
34002136:	617b      	str	r3, [r7, #20]

  /* Fill the rectangle */
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Width, Height, (Lcd_Ctx[Instance].XSize - Width), Color);
34002138:	6979      	ldr	r1, [r7, #20]
3400213a:	4a0a      	ldr	r2, [pc, #40]	@ (34002164 <BSP_LCD_FillRect+0x7c>)
3400213c:	68fb      	ldr	r3, [r7, #12]
3400213e:	015b      	lsls	r3, r3, #5
34002140:	4413      	add	r3, r2
34002142:	681a      	ldr	r2, [r3, #0]
34002144:	683b      	ldr	r3, [r7, #0]
34002146:	1ad3      	subs	r3, r2, r3
34002148:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3400214a:	9201      	str	r2, [sp, #4]
3400214c:	9300      	str	r3, [sp, #0]
3400214e:	6a3b      	ldr	r3, [r7, #32]
34002150:	683a      	ldr	r2, [r7, #0]
34002152:	68f8      	ldr	r0, [r7, #12]
34002154:	f000 f80a 	bl	3400216c <LL_FillBuffer>

  return BSP_ERROR_NONE;
34002158:	2300      	movs	r3, #0
}
3400215a:	4618      	mov	r0, r3
3400215c:	3718      	adds	r7, #24
3400215e:	46bd      	mov	sp, r7
34002160:	bd80      	pop	{r7, pc}
34002162:	bf00      	nop
34002164:	340113bc 	.word	0x340113bc
34002168:	34011314 	.word	0x34011314

3400216c <LL_FillBuffer>:
  * @param  ySize Buffer height
  * @param  OffLine Offset
  * @param  Color RGB color
  */
static void LL_FillBuffer(uint32_t Instance, uint32_t *pDst, uint32_t xSize, uint32_t ySize, uint32_t OffLine, uint32_t Color)
{
3400216c:	b580      	push	{r7, lr}
3400216e:	b088      	sub	sp, #32
34002170:	af02      	add	r7, sp, #8
34002172:	60f8      	str	r0, [r7, #12]
34002174:	60b9      	str	r1, [r7, #8]
34002176:	607a      	str	r2, [r7, #4]
34002178:	603b      	str	r3, [r7, #0]
  uint32_t output_color_mode;
  uint32_t input_color = Color;
3400217a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400217c:	613b      	str	r3, [r7, #16]

  switch(Lcd_Ctx[Instance].PixelFormat)
3400217e:	4a46      	ldr	r2, [pc, #280]	@ (34002298 <LL_FillBuffer+0x12c>)
34002180:	68fb      	ldr	r3, [r7, #12]
34002182:	015b      	lsls	r3, r3, #5
34002184:	4413      	add	r3, r2
34002186:	330c      	adds	r3, #12
34002188:	681b      	ldr	r3, [r3, #0]
3400218a:	2b04      	cmp	r3, #4
3400218c:	d02f      	beq.n	340021ee <LL_FillBuffer+0x82>
3400218e:	2b04      	cmp	r3, #4
34002190:	d859      	bhi.n	34002246 <LL_FillBuffer+0xda>
34002192:	2b01      	cmp	r3, #1
34002194:	d050      	beq.n	34002238 <LL_FillBuffer+0xcc>
34002196:	2b02      	cmp	r3, #2
34002198:	d155      	bne.n	34002246 <LL_FillBuffer+0xda>
  {
  case LCD_PIXEL_FORMAT_RGB565:
    output_color_mode = DMA2D_OUTPUT_RGB565; /* RGB565 */
3400219a:	2302      	movs	r3, #2
3400219c:	617b      	str	r3, [r7, #20]
    input_color = CONVERTRGB5652ARGB8888(Color);
3400219e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340021a0:	0adb      	lsrs	r3, r3, #11
340021a2:	f003 021f 	and.w	r2, r3, #31
340021a6:	4613      	mov	r3, r2
340021a8:	011b      	lsls	r3, r3, #4
340021aa:	4413      	add	r3, r2
340021ac:	015a      	lsls	r2, r3, #5
340021ae:	1ad3      	subs	r3, r2, r3
340021b0:	3317      	adds	r3, #23
340021b2:	099b      	lsrs	r3, r3, #6
340021b4:	0419      	lsls	r1, r3, #16
340021b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340021b8:	095b      	lsrs	r3, r3, #5
340021ba:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
340021be:	4613      	mov	r3, r2
340021c0:	01db      	lsls	r3, r3, #7
340021c2:	4413      	add	r3, r2
340021c4:	005b      	lsls	r3, r3, #1
340021c6:	4413      	add	r3, r2
340021c8:	3321      	adds	r3, #33	@ 0x21
340021ca:	099b      	lsrs	r3, r3, #6
340021cc:	021b      	lsls	r3, r3, #8
340021ce:	4319      	orrs	r1, r3
340021d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340021d2:	f003 021f 	and.w	r2, r3, #31
340021d6:	4613      	mov	r3, r2
340021d8:	011b      	lsls	r3, r3, #4
340021da:	4413      	add	r3, r2
340021dc:	015a      	lsls	r2, r3, #5
340021de:	1ad3      	subs	r3, r2, r3
340021e0:	3317      	adds	r3, #23
340021e2:	099b      	lsrs	r3, r3, #6
340021e4:	430b      	orrs	r3, r1
340021e6:	f043 437f 	orr.w	r3, r3, #4278190080	@ 0xff000000
340021ea:	613b      	str	r3, [r7, #16]
    break;
340021ec:	e02e      	b.n	3400224c <LL_FillBuffer+0xe0>
  case LCD_PIXEL_FORMAT_ARGB4444:
    output_color_mode = DMA2D_OUTPUT_ARGB4444; /* ARGB4444 */
340021ee:	2304      	movs	r3, #4
340021f0:	617b      	str	r3, [r7, #20]
    input_color = CONVERTARGB44442ARGB8888(Color);
340021f2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340021f4:	0b1b      	lsrs	r3, r3, #12
340021f6:	f003 020f 	and.w	r2, r3, #15
340021fa:	4613      	mov	r3, r2
340021fc:	011b      	lsls	r3, r3, #4
340021fe:	4413      	add	r3, r2
34002200:	0619      	lsls	r1, r3, #24
34002202:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002204:	0a1b      	lsrs	r3, r3, #8
34002206:	f003 020f 	and.w	r2, r3, #15
3400220a:	4613      	mov	r3, r2
3400220c:	011b      	lsls	r3, r3, #4
3400220e:	4413      	add	r3, r2
34002210:	041b      	lsls	r3, r3, #16
34002212:	4319      	orrs	r1, r3
34002214:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002216:	091b      	lsrs	r3, r3, #4
34002218:	f003 020f 	and.w	r2, r3, #15
3400221c:	4613      	mov	r3, r2
3400221e:	011b      	lsls	r3, r3, #4
34002220:	4413      	add	r3, r2
34002222:	021b      	lsls	r3, r3, #8
34002224:	4319      	orrs	r1, r3
34002226:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34002228:	f003 020f 	and.w	r2, r3, #15
3400222c:	4613      	mov	r3, r2
3400222e:	011b      	lsls	r3, r3, #4
34002230:	4413      	add	r3, r2
34002232:	430b      	orrs	r3, r1
34002234:	613b      	str	r3, [r7, #16]
    break;
34002236:	e009      	b.n	3400224c <LL_FillBuffer+0xe0>
  case LCD_PIXEL_FORMAT_RGB888:
    output_color_mode = DMA2D_OUTPUT_RGB888; /* RGB888 */
34002238:	2301      	movs	r3, #1
3400223a:	617b      	str	r3, [r7, #20]
    input_color = CONVERTRGB8882ARGB8888(Color);
3400223c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400223e:	f043 437f 	orr.w	r3, r3, #4278190080	@ 0xff000000
34002242:	613b      	str	r3, [r7, #16]
    break;
34002244:	e002      	b.n	3400224c <LL_FillBuffer+0xe0>
  default:
    output_color_mode = DMA2D_OUTPUT_ARGB8888; /* ARGB8888 */
34002246:	2300      	movs	r3, #0
34002248:	617b      	str	r3, [r7, #20]
    break;
3400224a:	bf00      	nop
  }

  /* Register to memory mode with ARGB8888 as color Mode */
  hlcd_dma2d.Init.Mode         = DMA2D_R2M;
3400224c:	4b13      	ldr	r3, [pc, #76]	@ (3400229c <LL_FillBuffer+0x130>)
3400224e:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
34002252:	605a      	str	r2, [r3, #4]
  hlcd_dma2d.Init.ColorMode    = output_color_mode;
34002254:	4a11      	ldr	r2, [pc, #68]	@ (3400229c <LL_FillBuffer+0x130>)
34002256:	697b      	ldr	r3, [r7, #20]
34002258:	6093      	str	r3, [r2, #8]
  hlcd_dma2d.Init.OutputOffset = OffLine;
3400225a:	4a10      	ldr	r2, [pc, #64]	@ (3400229c <LL_FillBuffer+0x130>)
3400225c:	6a3b      	ldr	r3, [r7, #32]
3400225e:	60d3      	str	r3, [r2, #12]

  hlcd_dma2d.Instance = DMA2D;
34002260:	4b0e      	ldr	r3, [pc, #56]	@ (3400229c <LL_FillBuffer+0x130>)
34002262:	4a0f      	ldr	r2, [pc, #60]	@ (340022a0 <LL_FillBuffer+0x134>)
34002264:	601a      	str	r2, [r3, #0]

  /* DMA2D Initialization */
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
34002266:	480d      	ldr	r0, [pc, #52]	@ (3400229c <LL_FillBuffer+0x130>)
34002268:	f002 fab1 	bl	340047ce <HAL_DMA2D_Init>
3400226c:	4603      	mov	r3, r0
3400226e:	2b00      	cmp	r3, #0
34002270:	d10e      	bne.n	34002290 <LL_FillBuffer+0x124>
  {
    if (HAL_DMA2D_Start(&hlcd_dma2d, input_color, (uint32_t)pDst, xSize, ySize) == HAL_OK)
34002272:	68ba      	ldr	r2, [r7, #8]
34002274:	683b      	ldr	r3, [r7, #0]
34002276:	9300      	str	r3, [sp, #0]
34002278:	687b      	ldr	r3, [r7, #4]
3400227a:	6939      	ldr	r1, [r7, #16]
3400227c:	4807      	ldr	r0, [pc, #28]	@ (3400229c <LL_FillBuffer+0x130>)
3400227e:	f002 fb11 	bl	340048a4 <HAL_DMA2D_Start>
34002282:	4603      	mov	r3, r0
34002284:	2b00      	cmp	r3, #0
34002286:	d103      	bne.n	34002290 <LL_FillBuffer+0x124>
    {
      /* Polling For DMA transfer */
      (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
34002288:	2132      	movs	r1, #50	@ 0x32
3400228a:	4804      	ldr	r0, [pc, #16]	@ (3400229c <LL_FillBuffer+0x130>)
3400228c:	f002 fb35 	bl	340048fa <HAL_DMA2D_PollForTransfer>
    }
  }
}
34002290:	bf00      	nop
34002292:	3718      	adds	r7, #24
34002294:	46bd      	mov	sp, r7
34002296:	bd80      	pop	{r7, pc}
34002298:	340113bc 	.word	0x340113bc
3400229c:	340112ac 	.word	0x340112ac
340022a0:	58021000 	.word	0x58021000

340022a4 <LTDC_MspInit>:
  * @brief  Initialize the BSP LTDC Msp.
  * @param  hltdc  LTDC handle
  * @retval None
  */
static void LTDC_MspInit(LTDC_HandleTypeDef *hltdc)
{
340022a4:	b580      	push	{r7, lr}
340022a6:	b088      	sub	sp, #32
340022a8:	af00      	add	r7, sp, #0
340022aa:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef  gpio_init_structure = {0};
340022ac:	f107 030c 	add.w	r3, r7, #12
340022b0:	2200      	movs	r2, #0
340022b2:	601a      	str	r2, [r3, #0]
340022b4:	605a      	str	r2, [r3, #4]
340022b6:	609a      	str	r2, [r3, #8]
340022b8:	60da      	str	r2, [r3, #12]
340022ba:	611a      	str	r2, [r3, #16]

  if (hltdc->Instance == LTDC)
340022bc:	687b      	ldr	r3, [r7, #4]
340022be:	681b      	ldr	r3, [r3, #0]
340022c0:	4a4e      	ldr	r2, [pc, #312]	@ (340023fc <LTDC_MspInit+0x158>)
340022c2:	4293      	cmp	r3, r2
340022c4:	f040 8095 	bne.w	340023f2 <LTDC_MspInit+0x14e>
  {
    __HAL_RCC_LTDC_CLK_ENABLE();
340022c8:	2002      	movs	r0, #2
340022ca:	f7ff fc6b 	bl	34001ba4 <LL_APB5_GRP1_EnableClock>

    __HAL_RCC_LTDC_FORCE_RESET();
340022ce:	2002      	movs	r0, #2
340022d0:	f7ff fc7e 	bl	34001bd0 <LL_APB5_GRP1_ForceReset>
    __HAL_RCC_LTDC_RELEASE_RESET();
340022d4:	2002      	movs	r0, #2
340022d6:	f7ff fc8b 	bl	34001bf0 <LL_APB5_GRP1_ReleaseReset>
    /* PB13 LCD_CLK     */
    /* PQ4  LCD_INT     */
    /* PQ6  LCD_BL_CTRL */
    /* PE1  NRST        */

    __HAL_RCC_GPIOA_CLK_ENABLE();
340022da:	2001      	movs	r0, #1
340022dc:	f7ff fc12 	bl	34001b04 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOB_CLK_ENABLE();
340022e0:	2002      	movs	r0, #2
340022e2:	f7ff fc0f 	bl	34001b04 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOD_CLK_ENABLE();
340022e6:	2008      	movs	r0, #8
340022e8:	f7ff fc0c 	bl	34001b04 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOE_CLK_ENABLE();
340022ec:	2010      	movs	r0, #16
340022ee:	f7ff fc09 	bl	34001b04 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOG_CLK_ENABLE();
340022f2:	2040      	movs	r0, #64	@ 0x40
340022f4:	f7ff fc06 	bl	34001b04 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOH_CLK_ENABLE();
340022f8:	2080      	movs	r0, #128	@ 0x80
340022fa:	f7ff fc03 	bl	34001b04 <LL_AHB4_GRP1_EnableClock>
    __HAL_RCC_GPIOQ_CLK_ENABLE();
340022fe:	f44f 3080 	mov.w	r0, #65536	@ 0x10000
34002302:	f7ff fbff 	bl	34001b04 <LL_AHB4_GRP1_EnableClock>

    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
34002306:	2302      	movs	r3, #2
34002308:	613b      	str	r3, [r7, #16]
    gpio_init_structure.Pull      = GPIO_NOPULL;
3400230a:	2300      	movs	r3, #0
3400230c:	617b      	str	r3, [r7, #20]
    gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
3400230e:	2302      	movs	r3, #2
34002310:	61bb      	str	r3, [r7, #24]

    /* G3, G2, B7, B1, B6, R5 */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_15;
34002312:	f248 1387 	movw	r3, #33159	@ 0x8187
34002316:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34002318:	230e      	movs	r3, #14
3400231a:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOA, &gpio_init_structure);
3400231c:	f107 030c 	add.w	r3, r7, #12
34002320:	4619      	mov	r1, r3
34002322:	4837      	ldr	r0, [pc, #220]	@ (34002400 <LTDC_MspInit+0x15c>)
34002324:	f002 fc88 	bl	34004c38 <HAL_GPIO_Init>

    /* LCD_CLK, LCD_HSYNC B2, R3, G6, G5, G4 */
    gpio_init_structure.Pin       = GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_2 | GPIO_PIN_4 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_15;
34002328:	f64f 0314 	movw	r3, #63508	@ 0xf814
3400232c:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
3400232e:	230e      	movs	r3, #14
34002330:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOB, &gpio_init_structure);
34002332:	f107 030c 	add.w	r3, r7, #12
34002336:	4619      	mov	r1, r3
34002338:	4832      	ldr	r0, [pc, #200]	@ (34002404 <LTDC_MspInit+0x160>)
3400233a:	f002 fc7d 	bl	34004c38 <HAL_GPIO_Init>

    /* R7, R1, R2 */
    gpio_init_structure.Pin       = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_15;
3400233e:	f44f 4303 	mov.w	r3, #33536	@ 0x8300
34002342:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34002344:	230e      	movs	r3, #14
34002346:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOD, &gpio_init_structure);
34002348:	f107 030c 	add.w	r3, r7, #12
3400234c:	4619      	mov	r1, r3
3400234e:	482e      	ldr	r0, [pc, #184]	@ (34002408 <LTDC_MspInit+0x164>)
34002350:	f002 fc72 	bl	34004c38 <HAL_GPIO_Init>

    /* LCD_VSYNC */
    gpio_init_structure.Pin       = GPIO_PIN_11;
34002354:	f44f 6300 	mov.w	r3, #2048	@ 0x800
34002358:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
3400235a:	230e      	movs	r3, #14
3400235c:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
3400235e:	f107 030c 	add.w	r3, r7, #12
34002362:	4619      	mov	r1, r3
34002364:	4829      	ldr	r0, [pc, #164]	@ (3400240c <LTDC_MspInit+0x168>)
34002366:	f002 fc67 	bl	34004c38 <HAL_GPIO_Init>

    /* R0, G1, B3, G7, R6, G0 */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_6 | GPIO_PIN_8 | GPIO_PIN_11 | GPIO_PIN_12 ;
3400236a:	f641 1343 	movw	r3, #6467	@ 0x1943
3400236e:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34002370:	230e      	movs	r3, #14
34002372:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
34002374:	f107 030c 	add.w	r3, r7, #12
34002378:	4619      	mov	r1, r3
3400237a:	4825      	ldr	r0, [pc, #148]	@ (34002410 <LTDC_MspInit+0x16c>)
3400237c:	f002 fc5c 	bl	34004c38 <HAL_GPIO_Init>

    /* B4, R4, B5 */
    gpio_init_structure.Pin       = GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_6;
34002380:	2358      	movs	r3, #88	@ 0x58
34002382:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Alternate = GPIO_AF14_LCD;
34002384:	230e      	movs	r3, #14
34002386:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOH, &gpio_init_structure);
34002388:	f107 030c 	add.w	r3, r7, #12
3400238c:	4619      	mov	r1, r3
3400238e:	4821      	ldr	r0, [pc, #132]	@ (34002414 <LTDC_MspInit+0x170>)
34002390:	f002 fc52 	bl	34004c38 <HAL_GPIO_Init>

    /* NRST */
    gpio_init_structure.Pin       = GPIO_PIN_1;
34002394:	2302      	movs	r3, #2
34002396:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
34002398:	2301      	movs	r3, #1
3400239a:	613b      	str	r3, [r7, #16]
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
3400239c:	f107 030c 	add.w	r3, r7, #12
340023a0:	4619      	mov	r1, r3
340023a2:	481a      	ldr	r0, [pc, #104]	@ (3400240c <LTDC_MspInit+0x168>)
340023a4:	f002 fc48 	bl	34004c38 <HAL_GPIO_Init>

    /* LCD_ONOFF, LCD_BL_CTRL */
    gpio_init_structure.Pin       = GPIO_PIN_3 | GPIO_PIN_6;
340023a8:	2348      	movs	r3, #72	@ 0x48
340023aa:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
340023ac:	2301      	movs	r3, #1
340023ae:	613b      	str	r3, [r7, #16]
    HAL_GPIO_Init(GPIOQ, &gpio_init_structure);
340023b0:	f107 030c 	add.w	r3, r7, #12
340023b4:	4619      	mov	r1, r3
340023b6:	4818      	ldr	r0, [pc, #96]	@ (34002418 <LTDC_MspInit+0x174>)
340023b8:	f002 fc3e 	bl	34004c38 <HAL_GPIO_Init>

    /* LCD_DE */
    gpio_init_structure.Pin       = GPIO_PIN_13;
340023bc:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
340023c0:	60fb      	str	r3, [r7, #12]
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
340023c2:	2301      	movs	r3, #1
340023c4:	613b      	str	r3, [r7, #16]
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
340023c6:	f107 030c 	add.w	r3, r7, #12
340023ca:	4619      	mov	r1, r3
340023cc:	4810      	ldr	r0, [pc, #64]	@ (34002410 <LTDC_MspInit+0x16c>)
340023ce:	f002 fc33 	bl	34004c38 <HAL_GPIO_Init>

    HAL_GPIO_WritePin(GPIOQ, GPIO_PIN_3, GPIO_PIN_SET); /* LCD On */ /* PQ3  LCD_ONOFF   */
340023d2:	2201      	movs	r2, #1
340023d4:	2108      	movs	r1, #8
340023d6:	4810      	ldr	r0, [pc, #64]	@ (34002418 <LTDC_MspInit+0x174>)
340023d8:	f002 fde0 	bl	34004f9c <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOG, GPIO_PIN_13, GPIO_PIN_SET); /* Display Enable */ /* PG13 LCD_DE      */
340023dc:	2201      	movs	r2, #1
340023de:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
340023e2:	480b      	ldr	r0, [pc, #44]	@ (34002410 <LTDC_MspInit+0x16c>)
340023e4:	f002 fdda 	bl	34004f9c <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(GPIOQ, GPIO_PIN_6, GPIO_PIN_SET); /* 100% Brightness */ /* PQ6  LCD_BL_CTRL */
340023e8:	2201      	movs	r2, #1
340023ea:	2140      	movs	r1, #64	@ 0x40
340023ec:	480a      	ldr	r0, [pc, #40]	@ (34002418 <LTDC_MspInit+0x174>)
340023ee:	f002 fdd5 	bl	34004f9c <HAL_GPIO_WritePin>

  }
}
340023f2:	bf00      	nop
340023f4:	3720      	adds	r7, #32
340023f6:	46bd      	mov	sp, r7
340023f8:	bd80      	pop	{r7, pc}
340023fa:	bf00      	nop
340023fc:	58001000 	.word	0x58001000
34002400:	56020000 	.word	0x56020000
34002404:	56020400 	.word	0x56020400
34002408:	56020c00 	.word	0x56020c00
3400240c:	56021000 	.word	0x56021000
34002410:	56021800 	.word	0x56021800
34002414:	56021c00 	.word	0x56021c00
34002418:	56024000 	.word	0x56024000

3400241c <DMA2D_MspInit>:
  * @brief  Initialize the BSP DMA2D Msp.
  * @param  hdma2d  DMA2D handle
  * @retval None
  */
static void DMA2D_MspInit(DMA2D_HandleTypeDef *hdma2d)
{
3400241c:	b580      	push	{r7, lr}
3400241e:	b082      	sub	sp, #8
34002420:	af00      	add	r7, sp, #0
34002422:	6078      	str	r0, [r7, #4]
  if(hdma2d->Instance == DMA2D)
34002424:	687b      	ldr	r3, [r7, #4]
34002426:	681b      	ldr	r3, [r3, #0]
34002428:	4a07      	ldr	r2, [pc, #28]	@ (34002448 <DMA2D_MspInit+0x2c>)
3400242a:	4293      	cmp	r3, r2
3400242c:	d108      	bne.n	34002440 <DMA2D_MspInit+0x24>
  {
    /** Enable the DMA2D clock */
    __HAL_RCC_DMA2D_CLK_ENABLE();
3400242e:	2002      	movs	r0, #2
34002430:	f7ff fb7e 	bl	34001b30 <LL_AHB5_GRP1_EnableClock>

    /** Toggle Sw reset of DMA2D IP */
    __HAL_RCC_DMA2D_FORCE_RESET();
34002434:	2002      	movs	r0, #2
34002436:	f7ff fb91 	bl	34001b5c <LL_AHB5_GRP1_ForceReset>
    __HAL_RCC_DMA2D_RELEASE_RESET();
3400243a:	2002      	movs	r0, #2
3400243c:	f7ff fb9e 	bl	34001b7c <LL_AHB5_GRP1_ReleaseReset>
  }
}
34002440:	bf00      	nop
34002442:	3708      	adds	r7, #8
34002444:	46bd      	mov	sp, r7
34002446:	bd80      	pop	{r7, pc}
34002448:	58021000 	.word	0x58021000

3400244c <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
3400244c:	b580      	push	{r7, lr}
3400244e:	af00      	add	r7, sp, #0
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
34002450:	2003      	movs	r0, #3
34002452:	f002 f943 	bl	340046dc <HAL_NVIC_SetPriorityGrouping>

  /* Ensure time base clock coherency in SystemCoreClock global variable */
  SystemCoreClockUpdate();
34002456:	f7ff f967 	bl	34001728 <SystemCoreClockUpdate>

  /* Initialize 1ms tick time base (default SysTick based on HSI clock after Reset) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
3400245a:	200f      	movs	r0, #15
3400245c:	f000 f80a 	bl	34002474 <HAL_InitTick>
34002460:	4603      	mov	r3, r0
34002462:	2b00      	cmp	r3, #0
34002464:	d001      	beq.n	3400246a <HAL_Init+0x1e>
  {
    return HAL_ERROR;
34002466:	2301      	movs	r3, #1
34002468:	e002      	b.n	34002470 <HAL_Init+0x24>
  }

  /* Init the low level hardware */
  HAL_MspInit();
3400246a:	f7fe ff01 	bl	34001270 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
3400246e:	2300      	movs	r3, #0
}
34002470:	4618      	mov	r0, r3
34002472:	bd80      	pop	{r7, pc}

34002474 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
34002474:	b580      	push	{r7, lr}
34002476:	b082      	sub	sp, #8
34002478:	af00      	add	r7, sp, #0
3400247a:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq == 0UL)
3400247c:	4b15      	ldr	r3, [pc, #84]	@ (340024d4 <HAL_InitTick+0x60>)
3400247e:	781b      	ldrb	r3, [r3, #0]
34002480:	2b00      	cmp	r3, #0
34002482:	d101      	bne.n	34002488 <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
34002484:	2301      	movs	r3, #1
34002486:	e021      	b.n	340024cc <HAL_InitTick+0x58>
  }

  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
34002488:	4b13      	ldr	r3, [pc, #76]	@ (340024d8 <HAL_InitTick+0x64>)
3400248a:	681a      	ldr	r2, [r3, #0]
3400248c:	4b11      	ldr	r3, [pc, #68]	@ (340024d4 <HAL_InitTick+0x60>)
3400248e:	781b      	ldrb	r3, [r3, #0]
34002490:	4619      	mov	r1, r3
34002492:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
34002496:	fbb3 f3f1 	udiv	r3, r3, r1
3400249a:	fbb2 f3f3 	udiv	r3, r2, r3
3400249e:	4618      	mov	r0, r3
340024a0:	f002 f952 	bl	34004748 <HAL_SYSTICK_Config>
340024a4:	4603      	mov	r3, r0
340024a6:	2b00      	cmp	r3, #0
340024a8:	d001      	beq.n	340024ae <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
340024aa:	2301      	movs	r3, #1
340024ac:	e00e      	b.n	340024cc <HAL_InitTick+0x58>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
340024ae:	687b      	ldr	r3, [r7, #4]
340024b0:	2b0f      	cmp	r3, #15
340024b2:	d80a      	bhi.n	340024ca <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
340024b4:	2200      	movs	r2, #0
340024b6:	6879      	ldr	r1, [r7, #4]
340024b8:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
340024bc:	f002 f919 	bl	340046f2 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
340024c0:	4a06      	ldr	r2, [pc, #24]	@ (340024dc <HAL_InitTick+0x68>)
340024c2:	687b      	ldr	r3, [r7, #4]
340024c4:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
340024c6:	2300      	movs	r3, #0
340024c8:	e000      	b.n	340024cc <HAL_InitTick+0x58>
    return HAL_ERROR;
340024ca:	2301      	movs	r3, #1
}
340024cc:	4618      	mov	r0, r3
340024ce:	3708      	adds	r7, #8
340024d0:	46bd      	mov	sp, r7
340024d2:	bd80      	pop	{r7, pc}
340024d4:	34010184 	.word	0x34010184
340024d8:	3401017c 	.word	0x3401017c
340024dc:	34010180 	.word	0x34010180

340024e0 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
340024e0:	b480      	push	{r7}
340024e2:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
340024e4:	4b06      	ldr	r3, [pc, #24]	@ (34002500 <HAL_IncTick+0x20>)
340024e6:	781b      	ldrb	r3, [r3, #0]
340024e8:	461a      	mov	r2, r3
340024ea:	4b06      	ldr	r3, [pc, #24]	@ (34002504 <HAL_IncTick+0x24>)
340024ec:	681b      	ldr	r3, [r3, #0]
340024ee:	4413      	add	r3, r2
340024f0:	4a04      	ldr	r2, [pc, #16]	@ (34002504 <HAL_IncTick+0x24>)
340024f2:	6013      	str	r3, [r2, #0]
}
340024f4:	bf00      	nop
340024f6:	46bd      	mov	sp, r7
340024f8:	f85d 7b04 	ldr.w	r7, [sp], #4
340024fc:	4770      	bx	lr
340024fe:	bf00      	nop
34002500:	34010184 	.word	0x34010184
34002504:	340113dc 	.word	0x340113dc

34002508 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
34002508:	b480      	push	{r7}
3400250a:	af00      	add	r7, sp, #0
  return uwTick;
3400250c:	4b03      	ldr	r3, [pc, #12]	@ (3400251c <HAL_GetTick+0x14>)
3400250e:	681b      	ldr	r3, [r3, #0]
}
34002510:	4618      	mov	r0, r3
34002512:	46bd      	mov	sp, r7
34002514:	f85d 7b04 	ldr.w	r7, [sp], #4
34002518:	4770      	bx	lr
3400251a:	bf00      	nop
3400251c:	340113dc 	.word	0x340113dc

34002520 <LL_ADC_SetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t PathInternal)
{
34002520:	b480      	push	{r7}
34002522:	b083      	sub	sp, #12
34002524:	af00      	add	r7, sp, #0
34002526:	6078      	str	r0, [r7, #4]
34002528:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VBATEN, PathInternal);
3400252a:	687b      	ldr	r3, [r7, #4]
3400252c:	689b      	ldr	r3, [r3, #8]
3400252e:	f023 72a0 	bic.w	r2, r3, #20971520	@ 0x1400000
34002532:	683b      	ldr	r3, [r7, #0]
34002534:	431a      	orrs	r2, r3
34002536:	687b      	ldr	r3, [r7, #4]
34002538:	609a      	str	r2, [r3, #8]
}
3400253a:	bf00      	nop
3400253c:	370c      	adds	r7, #12
3400253e:	46bd      	mov	sp, r7
34002540:	f85d 7b04 	ldr.w	r7, [sp], #4
34002544:	4770      	bx	lr

34002546 <LL_ADC_GetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_NONE
  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  */
__STATIC_INLINE uint32_t LL_ADC_GetCommonPathInternalCh(const ADC_Common_TypeDef *ADCxy_COMMON)
{
34002546:	b480      	push	{r7}
34002548:	b083      	sub	sp, #12
3400254a:	af00      	add	r7, sp, #0
3400254c:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_VBATEN));
3400254e:	687b      	ldr	r3, [r7, #4]
34002550:	689b      	ldr	r3, [r3, #8]
34002552:	f003 73a0 	and.w	r3, r3, #20971520	@ 0x1400000
}
34002556:	4618      	mov	r0, r3
34002558:	370c      	adds	r7, #12
3400255a:	46bd      	mov	sp, r7
3400255c:	f85d 7b04 	ldr.w	r7, [sp], #4
34002560:	4770      	bx	lr

34002562 <LL_ADC_SetPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_NONE
  *         @arg @ref LL_ADC_PATH_INTERNAL_VDDCORE
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetPathInternalCh(ADC_TypeDef *ADCx, uint32_t PathInternal)
{
34002562:	b480      	push	{r7}
34002564:	b083      	sub	sp, #12
34002566:	af00      	add	r7, sp, #0
34002568:	6078      	str	r0, [r7, #4]
3400256a:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCx->OR, ADC_OR_OP2, (PathInternal >> ADC_PATH_INTERNAL_POS));
3400256c:	687b      	ldr	r3, [r7, #4]
3400256e:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34002572:	f023 0204 	bic.w	r2, r3, #4
34002576:	683b      	ldr	r3, [r7, #0]
34002578:	0c1b      	lsrs	r3, r3, #16
3400257a:	431a      	orrs	r2, r3
3400257c:	687b      	ldr	r3, [r7, #4]
3400257e:	f8c3 20d0 	str.w	r2, [r3, #208]	@ 0xd0
}
34002582:	bf00      	nop
34002584:	370c      	adds	r7, #12
34002586:	46bd      	mov	sp, r7
34002588:	f85d 7b04 	ldr.w	r7, [sp], #4
3400258c:	4770      	bx	lr

3400258e <LL_ADC_GetPathInternalCh>:
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_ADC_PATH_INTERNAL_NONE
  *         @arg @ref LL_ADC_PATH_INTERNAL_VDDCORE
  */
__STATIC_INLINE uint32_t LL_ADC_GetPathInternalCh(const ADC_TypeDef *ADCx)
{
3400258e:	b480      	push	{r7}
34002590:	b083      	sub	sp, #12
34002592:	af00      	add	r7, sp, #0
34002594:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCx->OR, ADC_OR_OP2)) << ADC_PATH_INTERNAL_POS;
34002596:	687b      	ldr	r3, [r7, #4]
34002598:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
3400259c:	041b      	lsls	r3, r3, #16
3400259e:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
}
340025a2:	4618      	mov	r0, r3
340025a4:	370c      	adds	r7, #12
340025a6:	46bd      	mov	sp, r7
340025a8:	f85d 7b04 	ldr.w	r7, [sp], #4
340025ac:	4770      	bx	lr

340025ae <LL_ADC_GetResolution>:
  *         @arg @ref LL_ADC_RESOLUTION_10B
  *         @arg @ref LL_ADC_RESOLUTION_8B
  *         @arg @ref LL_ADC_RESOLUTION_6B
  */
__STATIC_INLINE uint32_t LL_ADC_GetResolution(const ADC_TypeDef *ADCx)
{
340025ae:	b480      	push	{r7}
340025b0:	b083      	sub	sp, #12
340025b2:	af00      	add	r7, sp, #0
340025b4:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCx->CFGR1, ADC_CFGR1_RES));
340025b6:	687b      	ldr	r3, [r7, #4]
340025b8:	68db      	ldr	r3, [r3, #12]
340025ba:	f003 030c 	and.w	r3, r3, #12
}
340025be:	4618      	mov	r0, r3
340025c0:	370c      	adds	r7, #12
340025c2:	46bd      	mov	sp, r7
340025c4:	f85d 7b04 	ldr.w	r7, [sp], #4
340025c8:	4770      	bx	lr

340025ca <LL_ADC_SetOffsetChannel>:
  *         (1) On this STM32 series, parameter available only on ADC instance: ADC1.\n
  *         (2) On this STM32 series, parameter available only on ADC instance: ADC2.\n
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetChannel(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t Channel)
{
340025ca:	b480      	push	{r7}
340025cc:	b087      	sub	sp, #28
340025ce:	af00      	add	r7, sp, #0
340025d0:	60f8      	str	r0, [r7, #12]
340025d2:	60b9      	str	r1, [r7, #8]
340025d4:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg_offset_cfg = __ADC_PTR_REG_OFFSET(ADCx->OFCFGR1, Offsety);
340025d6:	68fb      	ldr	r3, [r7, #12]
340025d8:	3350      	adds	r3, #80	@ 0x50
340025da:	461a      	mov	r2, r3
340025dc:	68bb      	ldr	r3, [r7, #8]
340025de:	009b      	lsls	r3, r3, #2
340025e0:	4413      	add	r3, r2
340025e2:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg_offset_cfg,
340025e4:	697b      	ldr	r3, [r7, #20]
340025e6:	681b      	ldr	r3, [r3, #0]
340025e8:	f023 4278 	bic.w	r2, r3, #4160749568	@ 0xf8000000
340025ec:	687b      	ldr	r3, [r7, #4]
340025ee:	06db      	lsls	r3, r3, #27
340025f0:	431a      	orrs	r2, r3
340025f2:	697b      	ldr	r3, [r7, #20]
340025f4:	601a      	str	r2, [r3, #0]
             ADC_OFCFGR1_OFFSET_CH,
             (Channel & ADC_CHANNEL_NUMBER_MASK) << ADC_OFCFGR1_OFFSET_CH_Pos);
}
340025f6:	bf00      	nop
340025f8:	371c      	adds	r7, #28
340025fa:	46bd      	mov	sp, r7
340025fc:	f85d 7b04 	ldr.w	r7, [sp], #4
34002600:	4770      	bx	lr

34002602 <LL_ADC_GetOffsetChannel>:
  *         (3) For ADC channel read back from ADC register,
  *             comparison with internal channel parameter to be done
  *             using helper macro @ref __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL().
  */
__STATIC_INLINE uint32_t LL_ADC_GetOffsetChannel(const ADC_TypeDef *ADCx, uint32_t Offsety)
{
34002602:	b480      	push	{r7}
34002604:	b085      	sub	sp, #20
34002606:	af00      	add	r7, sp, #0
34002608:	6078      	str	r0, [r7, #4]
3400260a:	6039      	str	r1, [r7, #0]
  const __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFCFGR1, Offsety);
3400260c:	687b      	ldr	r3, [r7, #4]
3400260e:	3350      	adds	r3, #80	@ 0x50
34002610:	461a      	mov	r2, r3
34002612:	683b      	ldr	r3, [r7, #0]
34002614:	009b      	lsls	r3, r3, #2
34002616:	4413      	add	r3, r2
34002618:	60fb      	str	r3, [r7, #12]

  return (uint32_t) __LL_ADC_DECIMAL_NB_TO_CHANNEL(READ_BIT(*preg, ADC_OFCFGR1_OFFSET_CH) >> ADC_OFCFGR1_OFFSET_CH_Pos);
3400261a:	68fb      	ldr	r3, [r7, #12]
3400261c:	681b      	ldr	r3, [r3, #0]
3400261e:	0edb      	lsrs	r3, r3, #27
34002620:	f003 031f 	and.w	r3, r3, #31
}
34002624:	4618      	mov	r0, r3
34002626:	3714      	adds	r7, #20
34002628:	46bd      	mov	sp, r7
3400262a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400262e:	4770      	bx	lr

34002630 <LL_ADC_SetOffsetLevel>:
  *         @arg @ref LL_ADC_OFFSET_4
  * @param  OffsetLevel Value between Min_Data=0x000 and Max_Data=0x00FFFFFF
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetLevel(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetLevel)
{
34002630:	b480      	push	{r7}
34002632:	b087      	sub	sp, #28
34002634:	af00      	add	r7, sp, #0
34002636:	60f8      	str	r0, [r7, #12]
34002638:	60b9      	str	r1, [r7, #8]
3400263a:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg_offset_val = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
3400263c:	68fb      	ldr	r3, [r7, #12]
3400263e:	3360      	adds	r3, #96	@ 0x60
34002640:	461a      	mov	r2, r3
34002642:	68bb      	ldr	r3, [r7, #8]
34002644:	009b      	lsls	r3, r3, #2
34002646:	4413      	add	r3, r2
34002648:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg_offset_val,
3400264a:	697b      	ldr	r3, [r7, #20]
3400264c:	681b      	ldr	r3, [r3, #0]
3400264e:	0d9b      	lsrs	r3, r3, #22
34002650:	059b      	lsls	r3, r3, #22
34002652:	687a      	ldr	r2, [r7, #4]
34002654:	431a      	orrs	r2, r3
34002656:	697b      	ldr	r3, [r7, #20]
34002658:	601a      	str	r2, [r3, #0]
             ADC_OFR1_OFFSET,
             OffsetLevel);
}
3400265a:	bf00      	nop
3400265c:	371c      	adds	r7, #28
3400265e:	46bd      	mov	sp, r7
34002660:	f85d 7b04 	ldr.w	r7, [sp], #4
34002664:	4770      	bx	lr

34002666 <LL_ADC_SetOffsetSign>:
  *         @arg @ref LL_ADC_OFFSET_SIGN_NEGATIVE
  *         @arg @ref LL_ADC_OFFSET_SIGN_POSITIVE
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetSign(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetSign)
{
34002666:	b480      	push	{r7}
34002668:	b087      	sub	sp, #28
3400266a:	af00      	add	r7, sp, #0
3400266c:	60f8      	str	r0, [r7, #12]
3400266e:	60b9      	str	r1, [r7, #8]
34002670:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFCFGR1, Offsety);
34002672:	68fb      	ldr	r3, [r7, #12]
34002674:	3350      	adds	r3, #80	@ 0x50
34002676:	461a      	mov	r2, r3
34002678:	68bb      	ldr	r3, [r7, #8]
3400267a:	009b      	lsls	r3, r3, #2
3400267c:	4413      	add	r3, r2
3400267e:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
34002680:	697b      	ldr	r3, [r7, #20]
34002682:	681b      	ldr	r3, [r3, #0]
34002684:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34002688:	687b      	ldr	r3, [r7, #4]
3400268a:	431a      	orrs	r2, r3
3400268c:	697b      	ldr	r3, [r7, #20]
3400268e:	601a      	str	r2, [r3, #0]
             ADC_OFCFGR1_POSOFF,
             OffsetSign);
}
34002690:	bf00      	nop
34002692:	371c      	adds	r7, #28
34002694:	46bd      	mov	sp, r7
34002696:	f85d 7b04 	ldr.w	r7, [sp], #4
3400269a:	4770      	bx	lr

3400269c <LL_ADC_SetOffsetSignedSaturation>:
  *         @arg @ref LL_ADC_OFFSET_SIGNED_SAT_DISABLE
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetSignedSaturation(ADC_TypeDef *ADCx, uint32_t Offsety,
                                                      uint32_t OffsetSignedSaturation)
{
3400269c:	b480      	push	{r7}
3400269e:	b087      	sub	sp, #28
340026a0:	af00      	add	r7, sp, #0
340026a2:	60f8      	str	r0, [r7, #12]
340026a4:	60b9      	str	r1, [r7, #8]
340026a6:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFCFGR1, Offsety);
340026a8:	68fb      	ldr	r3, [r7, #12]
340026aa:	3350      	adds	r3, #80	@ 0x50
340026ac:	461a      	mov	r2, r3
340026ae:	68bb      	ldr	r3, [r7, #8]
340026b0:	009b      	lsls	r3, r3, #2
340026b2:	4413      	add	r3, r2
340026b4:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg, ADC_OFCFGR1_SSAT, OffsetSignedSaturation);
340026b6:	697b      	ldr	r3, [r7, #20]
340026b8:	681b      	ldr	r3, [r3, #0]
340026ba:	f023 6280 	bic.w	r2, r3, #67108864	@ 0x4000000
340026be:	687b      	ldr	r3, [r7, #4]
340026c0:	431a      	orrs	r2, r3
340026c2:	697b      	ldr	r3, [r7, #20]
340026c4:	601a      	str	r2, [r3, #0]
}
340026c6:	bf00      	nop
340026c8:	371c      	adds	r7, #28
340026ca:	46bd      	mov	sp, r7
340026cc:	f85d 7b04 	ldr.w	r7, [sp], #4
340026d0:	4770      	bx	lr

340026d2 <LL_ADC_SetOffsetUnsignedSaturation>:
  *         @arg @ref LL_ADC_OFFSET_UNSIGNED_SAT_DISABLE
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffsetUnsignedSaturation(ADC_TypeDef *ADCx, uint32_t Offsety,
                                                        uint32_t OffsetUnsignedSaturation)
{
340026d2:	b480      	push	{r7}
340026d4:	b087      	sub	sp, #28
340026d6:	af00      	add	r7, sp, #0
340026d8:	60f8      	str	r0, [r7, #12]
340026da:	60b9      	str	r1, [r7, #8]
340026dc:	607a      	str	r2, [r7, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFCFGR1, Offsety);
340026de:	68fb      	ldr	r3, [r7, #12]
340026e0:	3350      	adds	r3, #80	@ 0x50
340026e2:	461a      	mov	r2, r3
340026e4:	68bb      	ldr	r3, [r7, #8]
340026e6:	009b      	lsls	r3, r3, #2
340026e8:	4413      	add	r3, r2
340026ea:	617b      	str	r3, [r7, #20]
  MODIFY_REG(*preg, ADC_OFCFGR1_USAT, OffsetUnsignedSaturation);
340026ec:	697b      	ldr	r3, [r7, #20]
340026ee:	681b      	ldr	r3, [r3, #0]
340026f0:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
340026f4:	687b      	ldr	r3, [r7, #4]
340026f6:	431a      	orrs	r2, r3
340026f8:	697b      	ldr	r3, [r7, #20]
340026fa:	601a      	str	r2, [r3, #0]
}
340026fc:	bf00      	nop
340026fe:	371c      	adds	r7, #28
34002700:	46bd      	mov	sp, r7
34002702:	f85d 7b04 	ldr.w	r7, [sp], #4
34002706:	4770      	bx	lr

34002708 <LL_ADC_SetGainCompensation>:
  *         0           Gain compensation will be disabled and value set to 0
  *         1 -> 16393  Gain compensation will be enabled with specified value
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetGainCompensation(ADC_TypeDef *ADCx, uint32_t GainCompensation)
{
34002708:	b480      	push	{r7}
3400270a:	b083      	sub	sp, #12
3400270c:	af00      	add	r7, sp, #0
3400270e:	6078      	str	r0, [r7, #4]
34002710:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCx->GCOMP, ADC_GCOMP_GCOMPCOEFF, GainCompensation);
34002712:	687b      	ldr	r3, [r7, #4]
34002714:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
34002716:	f423 537f 	bic.w	r3, r3, #16320	@ 0x3fc0
3400271a:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
3400271e:	683a      	ldr	r2, [r7, #0]
34002720:	431a      	orrs	r2, r3
34002722:	687b      	ldr	r3, [r7, #4]
34002724:	671a      	str	r2, [r3, #112]	@ 0x70
  MODIFY_REG(ADCx->GCOMP, ADC_GCOMP_GCOMP, ((GainCompensation == 0UL) ? 0UL : 1UL) << ADC_GCOMP_GCOMP_Pos);
34002726:	687b      	ldr	r3, [r7, #4]
34002728:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
3400272a:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3400272e:	683a      	ldr	r2, [r7, #0]
34002730:	2a00      	cmp	r2, #0
34002732:	d002      	beq.n	3400273a <LL_ADC_SetGainCompensation+0x32>
34002734:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
34002738:	e000      	b.n	3400273c <LL_ADC_SetGainCompensation+0x34>
3400273a:	2200      	movs	r2, #0
3400273c:	431a      	orrs	r2, r3
3400273e:	687b      	ldr	r3, [r7, #4]
34002740:	671a      	str	r2, [r3, #112]	@ 0x70
}
34002742:	bf00      	nop
34002744:	370c      	adds	r7, #12
34002746:	46bd      	mov	sp, r7
34002748:	f85d 7b04 	ldr.w	r7, [sp], #4
3400274c:	4770      	bx	lr

3400274e <LL_ADC_REG_IsTriggerSourceSWStart>:
  * @param  ADCx ADC instance
  * @retval Value "0" if trigger source external trigger
  *         Value "1" if trigger source SW start.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsTriggerSourceSWStart(const ADC_TypeDef *ADCx)
{
3400274e:	b480      	push	{r7}
34002750:	b083      	sub	sp, #12
34002752:	af00      	add	r7, sp, #0
34002754:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CFGR1, ADC_CFGR1_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR1_EXTEN)) ? 1UL : 0UL);
34002756:	687b      	ldr	r3, [r7, #4]
34002758:	68db      	ldr	r3, [r3, #12]
3400275a:	f403 6340 	and.w	r3, r3, #3072	@ 0xc00
3400275e:	2b00      	cmp	r3, #0
34002760:	d101      	bne.n	34002766 <LL_ADC_REG_IsTriggerSourceSWStart+0x18>
34002762:	2301      	movs	r3, #1
34002764:	e000      	b.n	34002768 <LL_ADC_REG_IsTriggerSourceSWStart+0x1a>
34002766:	2300      	movs	r3, #0
}
34002768:	4618      	mov	r0, r3
3400276a:	370c      	adds	r7, #12
3400276c:	46bd      	mov	sp, r7
3400276e:	f85d 7b04 	ldr.w	r7, [sp], #4
34002772:	4770      	bx	lr

34002774 <LL_ADC_REG_SetSequencerRanks>:
  *         (1) On this STM32 series, parameter available only on ADC instance: ADC1.\n
  *         (2) On this STM32 series, parameter available only on ADC instance: ADC2.\n
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)
{
34002774:	b480      	push	{r7}
34002776:	b087      	sub	sp, #28
34002778:	af00      	add	r7, sp, #0
3400277a:	60f8      	str	r0, [r7, #12]
3400277c:	60b9      	str	r1, [r7, #8]
3400277e:	607a      	str	r2, [r7, #4]
  /* Set bits with content of parameter "Channel" with bits position          */
  /* in register and register position depending on parameter "Rank".         */
  /* Parameters "Rank" and "Channel" are used with masks because containing   */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1,
34002780:	68fb      	ldr	r3, [r7, #12]
34002782:	3330      	adds	r3, #48	@ 0x30
34002784:	461a      	mov	r2, r3
34002786:	68bb      	ldr	r3, [r7, #8]
34002788:	0a1b      	lsrs	r3, r3, #8
3400278a:	009b      	lsls	r3, r3, #2
3400278c:	f003 030c 	and.w	r3, r3, #12
34002790:	4413      	add	r3, r2
34002792:	617b      	str	r3, [r7, #20]
                                             ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));

  MODIFY_REG(*preg,
34002794:	697b      	ldr	r3, [r7, #20]
34002796:	681a      	ldr	r2, [r3, #0]
34002798:	68bb      	ldr	r3, [r7, #8]
3400279a:	f003 031f 	and.w	r3, r3, #31
3400279e:	211f      	movs	r1, #31
340027a0:	fa01 f303 	lsl.w	r3, r1, r3
340027a4:	43db      	mvns	r3, r3
340027a6:	401a      	ands	r2, r3
340027a8:	687b      	ldr	r3, [r7, #4]
340027aa:	f003 011f 	and.w	r1, r3, #31
340027ae:	68bb      	ldr	r3, [r7, #8]
340027b0:	f003 031f 	and.w	r3, r3, #31
340027b4:	fa01 f303 	lsl.w	r3, r1, r3
340027b8:	431a      	orrs	r2, r3
340027ba:	697b      	ldr	r3, [r7, #20]
340027bc:	601a      	str	r2, [r3, #0]
             ADC_CHANNEL_NUMBER_MASK_POSBIT0 << (Rank & ADC_REG_RANK_ID_SQRX_MASK),
             (Channel & ADC_CHANNEL_NUMBER_MASK) << (Rank & ADC_REG_RANK_ID_SQRX_MASK));
}
340027be:	bf00      	nop
340027c0:	371c      	adds	r7, #28
340027c2:	46bd      	mov	sp, r7
340027c4:	f85d 7b04 	ldr.w	r7, [sp], #4
340027c8:	4770      	bx	lr

340027ca <LL_ADC_SetChannelPreselection>:
  *         (1) On this STM32 series, parameter available only on ADC instance: ADC1.\n
  *         (2) On this STM32 series, parameter available only on ADC instance: ADC2.\n
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelPreselection(ADC_TypeDef *ADCx, uint32_t Channel)
{
340027ca:	b480      	push	{r7}
340027cc:	b085      	sub	sp, #20
340027ce:	af00      	add	r7, sp, #0
340027d0:	6078      	str	r0, [r7, #4]
340027d2:	6039      	str	r1, [r7, #0]
  __IO uint32_t channel_preselectione = READ_REG(ADCx->PCSEL);
340027d4:	687b      	ldr	r3, [r7, #4]
340027d6:	69db      	ldr	r3, [r3, #28]
340027d8:	60fb      	str	r3, [r7, #12]
  WRITE_REG(ADCx->PCSEL,
340027da:	683b      	ldr	r3, [r7, #0]
340027dc:	f003 031f 	and.w	r3, r3, #31
340027e0:	2201      	movs	r2, #1
340027e2:	409a      	lsls	r2, r3
340027e4:	68fb      	ldr	r3, [r7, #12]
340027e6:	431a      	orrs	r2, r3
340027e8:	687b      	ldr	r3, [r7, #4]
340027ea:	61da      	str	r2, [r3, #28]
            channel_preselectione | (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)Channel) & 0x1FUL)));
}
340027ec:	bf00      	nop
340027ee:	3714      	adds	r7, #20
340027f0:	46bd      	mov	sp, r7
340027f2:	f85d 7b04 	ldr.w	r7, [sp], #4
340027f6:	4770      	bx	lr

340027f8 <LL_ADC_INJ_IsTriggerSourceSWStart>:
  * @param  ADCx ADC instance
  * @retval Value "0" if trigger source external trigger
  *         Value "1" if trigger source SW start.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsTriggerSourceSWStart(const ADC_TypeDef *ADCx)
{
340027f8:	b480      	push	{r7}
340027fa:	b083      	sub	sp, #12
340027fc:	af00      	add	r7, sp, #0
340027fe:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->JSQR, ADC_JSQR_JEXTEN) == (LL_ADC_INJ_TRIG_SOFTWARE & ADC_JSQR_JEXTEN)) ? 1UL : 0UL);
34002800:	687b      	ldr	r3, [r7, #4]
34002802:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34002804:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
34002808:	2b00      	cmp	r3, #0
3400280a:	d101      	bne.n	34002810 <LL_ADC_INJ_IsTriggerSourceSWStart+0x18>
3400280c:	2301      	movs	r3, #1
3400280e:	e000      	b.n	34002812 <LL_ADC_INJ_IsTriggerSourceSWStart+0x1a>
34002810:	2300      	movs	r3, #0
}
34002812:	4618      	mov	r0, r3
34002814:	370c      	adds	r7, #12
34002816:	46bd      	mov	sp, r7
34002818:	f85d 7b04 	ldr.w	r7, [sp], #4
3400281c:	4770      	bx	lr
	...

34002820 <LL_ADC_SetChannelSamplingTime>:
  *         @arg @ref LL_ADC_SAMPLINGTIME_246CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_1499CYCLES_5
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
{
34002820:	b480      	push	{r7}
34002822:	b087      	sub	sp, #28
34002824:	af00      	add	r7, sp, #0
34002826:	60f8      	str	r0, [r7, #12]
34002828:	60b9      	str	r1, [r7, #8]
3400282a:	607a      	str	r2, [r7, #4]
  /* Set bits with content of parameter "SamplingTime" with bits position     */
  /* in register and register position depending on parameter "Channel".      */
  /* Parameter "Channel" is used with masks because containing                */
  /* other bits reserved for other purpose.                                   */
  const uint32_t iChannel = __ADC_CHANNEL_INDEX(Channel);
3400282c:	68bb      	ldr	r3, [r7, #8]
3400282e:	f003 031f 	and.w	r3, r3, #31
34002832:	2b00      	cmp	r3, #0
34002834:	f000 8087 	beq.w	34002946 <LL_ADC_SetChannelSamplingTime+0x126>
34002838:	68bb      	ldr	r3, [r7, #8]
3400283a:	f003 031f 	and.w	r3, r3, #31
3400283e:	2b01      	cmp	r3, #1
34002840:	d07f      	beq.n	34002942 <LL_ADC_SetChannelSamplingTime+0x122>
34002842:	68bb      	ldr	r3, [r7, #8]
34002844:	f003 031f 	and.w	r3, r3, #31
34002848:	2b02      	cmp	r3, #2
3400284a:	d078      	beq.n	3400293e <LL_ADC_SetChannelSamplingTime+0x11e>
3400284c:	68bb      	ldr	r3, [r7, #8]
3400284e:	f003 031f 	and.w	r3, r3, #31
34002852:	2b03      	cmp	r3, #3
34002854:	d071      	beq.n	3400293a <LL_ADC_SetChannelSamplingTime+0x11a>
34002856:	68bb      	ldr	r3, [r7, #8]
34002858:	f003 031f 	and.w	r3, r3, #31
3400285c:	2b04      	cmp	r3, #4
3400285e:	d06a      	beq.n	34002936 <LL_ADC_SetChannelSamplingTime+0x116>
34002860:	68bb      	ldr	r3, [r7, #8]
34002862:	f003 031f 	and.w	r3, r3, #31
34002866:	2b05      	cmp	r3, #5
34002868:	d063      	beq.n	34002932 <LL_ADC_SetChannelSamplingTime+0x112>
3400286a:	68bb      	ldr	r3, [r7, #8]
3400286c:	f003 031f 	and.w	r3, r3, #31
34002870:	2b06      	cmp	r3, #6
34002872:	d05c      	beq.n	3400292e <LL_ADC_SetChannelSamplingTime+0x10e>
34002874:	68bb      	ldr	r3, [r7, #8]
34002876:	f003 031f 	and.w	r3, r3, #31
3400287a:	2b07      	cmp	r3, #7
3400287c:	d055      	beq.n	3400292a <LL_ADC_SetChannelSamplingTime+0x10a>
3400287e:	68bb      	ldr	r3, [r7, #8]
34002880:	f003 031f 	and.w	r3, r3, #31
34002884:	2b08      	cmp	r3, #8
34002886:	d04e      	beq.n	34002926 <LL_ADC_SetChannelSamplingTime+0x106>
34002888:	68bb      	ldr	r3, [r7, #8]
3400288a:	f003 031f 	and.w	r3, r3, #31
3400288e:	2b09      	cmp	r3, #9
34002890:	d047      	beq.n	34002922 <LL_ADC_SetChannelSamplingTime+0x102>
34002892:	68bb      	ldr	r3, [r7, #8]
34002894:	f003 031f 	and.w	r3, r3, #31
34002898:	2b0a      	cmp	r3, #10
3400289a:	d040      	beq.n	3400291e <LL_ADC_SetChannelSamplingTime+0xfe>
3400289c:	68bb      	ldr	r3, [r7, #8]
3400289e:	f003 031f 	and.w	r3, r3, #31
340028a2:	2b0b      	cmp	r3, #11
340028a4:	d039      	beq.n	3400291a <LL_ADC_SetChannelSamplingTime+0xfa>
340028a6:	68bb      	ldr	r3, [r7, #8]
340028a8:	f003 031f 	and.w	r3, r3, #31
340028ac:	2b0c      	cmp	r3, #12
340028ae:	d032      	beq.n	34002916 <LL_ADC_SetChannelSamplingTime+0xf6>
340028b0:	68bb      	ldr	r3, [r7, #8]
340028b2:	f003 031f 	and.w	r3, r3, #31
340028b6:	2b0d      	cmp	r3, #13
340028b8:	d02b      	beq.n	34002912 <LL_ADC_SetChannelSamplingTime+0xf2>
340028ba:	68bb      	ldr	r3, [r7, #8]
340028bc:	f003 031f 	and.w	r3, r3, #31
340028c0:	2b0e      	cmp	r3, #14
340028c2:	d024      	beq.n	3400290e <LL_ADC_SetChannelSamplingTime+0xee>
340028c4:	68bb      	ldr	r3, [r7, #8]
340028c6:	f003 031f 	and.w	r3, r3, #31
340028ca:	2b0f      	cmp	r3, #15
340028cc:	d01d      	beq.n	3400290a <LL_ADC_SetChannelSamplingTime+0xea>
340028ce:	68bb      	ldr	r3, [r7, #8]
340028d0:	f003 031f 	and.w	r3, r3, #31
340028d4:	2b10      	cmp	r3, #16
340028d6:	d016      	beq.n	34002906 <LL_ADC_SetChannelSamplingTime+0xe6>
340028d8:	68bb      	ldr	r3, [r7, #8]
340028da:	f003 031f 	and.w	r3, r3, #31
340028de:	2b11      	cmp	r3, #17
340028e0:	d00f      	beq.n	34002902 <LL_ADC_SetChannelSamplingTime+0xe2>
340028e2:	68bb      	ldr	r3, [r7, #8]
340028e4:	f003 031f 	and.w	r3, r3, #31
340028e8:	2b12      	cmp	r3, #18
340028ea:	d008      	beq.n	340028fe <LL_ADC_SetChannelSamplingTime+0xde>
340028ec:	68bb      	ldr	r3, [r7, #8]
340028ee:	f003 031f 	and.w	r3, r3, #31
340028f2:	2b13      	cmp	r3, #19
340028f4:	d101      	bne.n	340028fa <LL_ADC_SetChannelSamplingTime+0xda>
340028f6:	2313      	movs	r3, #19
340028f8:	e026      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
340028fa:	2300      	movs	r3, #0
340028fc:	e024      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
340028fe:	2312      	movs	r3, #18
34002900:	e022      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
34002902:	2311      	movs	r3, #17
34002904:	e020      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
34002906:	2310      	movs	r3, #16
34002908:	e01e      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
3400290a:	230f      	movs	r3, #15
3400290c:	e01c      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
3400290e:	230e      	movs	r3, #14
34002910:	e01a      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
34002912:	230d      	movs	r3, #13
34002914:	e018      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
34002916:	230c      	movs	r3, #12
34002918:	e016      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
3400291a:	230b      	movs	r3, #11
3400291c:	e014      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
3400291e:	230a      	movs	r3, #10
34002920:	e012      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
34002922:	2309      	movs	r3, #9
34002924:	e010      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
34002926:	2308      	movs	r3, #8
34002928:	e00e      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
3400292a:	2307      	movs	r3, #7
3400292c:	e00c      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
3400292e:	2306      	movs	r3, #6
34002930:	e00a      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
34002932:	2305      	movs	r3, #5
34002934:	e008      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
34002936:	2304      	movs	r3, #4
34002938:	e006      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
3400293a:	2303      	movs	r3, #3
3400293c:	e004      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
3400293e:	2302      	movs	r3, #2
34002940:	e002      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
34002942:	2301      	movs	r3, #1
34002944:	e000      	b.n	34002948 <LL_ADC_SetChannelSamplingTime+0x128>
34002946:	2300      	movs	r3, #0
34002948:	617b      	str	r3, [r7, #20]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1,
3400294a:	68fb      	ldr	r3, [r7, #12]
3400294c:	3314      	adds	r3, #20
3400294e:	4619      	mov	r1, r3
34002950:	4a15      	ldr	r2, [pc, #84]	@ (340029a8 <LL_ADC_SetChannelSamplingTime+0x188>)
34002952:	697b      	ldr	r3, [r7, #20]
34002954:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34002958:	0e5b      	lsrs	r3, r3, #25
3400295a:	009b      	lsls	r3, r3, #2
3400295c:	f003 0304 	and.w	r3, r3, #4
34002960:	440b      	add	r3, r1
34002962:	613b      	str	r3, [r7, #16]
                                             ((ADC_CHANNEL_LUT[iChannel]
                                               & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
  MODIFY_REG(*preg,
34002964:	693b      	ldr	r3, [r7, #16]
34002966:	681a      	ldr	r2, [r3, #0]
34002968:	490f      	ldr	r1, [pc, #60]	@ (340029a8 <LL_ADC_SetChannelSamplingTime+0x188>)
3400296a:	697b      	ldr	r3, [r7, #20]
3400296c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
34002970:	0d1b      	lsrs	r3, r3, #20
34002972:	f003 031f 	and.w	r3, r3, #31
34002976:	2107      	movs	r1, #7
34002978:	fa01 f303 	lsl.w	r3, r1, r3
3400297c:	43db      	mvns	r3, r3
3400297e:	401a      	ands	r2, r3
34002980:	4909      	ldr	r1, [pc, #36]	@ (340029a8 <LL_ADC_SetChannelSamplingTime+0x188>)
34002982:	697b      	ldr	r3, [r7, #20]
34002984:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
34002988:	0d1b      	lsrs	r3, r3, #20
3400298a:	f003 031f 	and.w	r3, r3, #31
3400298e:	6879      	ldr	r1, [r7, #4]
34002990:	fa01 f303 	lsl.w	r3, r1, r3
34002994:	431a      	orrs	r2, r3
34002996:	693b      	ldr	r3, [r7, #16]
34002998:	601a      	str	r2, [r3, #0]
             ADC_SMPR1_SMP0 << ((ADC_CHANNEL_LUT[iChannel] & ADC_CHANNEL_SMPx_BITOFFSET_MASK)
                                >> ADC_CHANNEL_SMPx_BITOFFSET_POS),
             SamplingTime   << ((ADC_CHANNEL_LUT[iChannel] & ADC_CHANNEL_SMPx_BITOFFSET_MASK)
                                >> ADC_CHANNEL_SMPx_BITOFFSET_POS));
}
3400299a:	bf00      	nop
3400299c:	371c      	adds	r7, #28
3400299e:	46bd      	mov	sp, r7
340029a0:	f85d 7b04 	ldr.w	r7, [sp], #4
340029a4:	4770      	bx	lr
340029a6:	bf00      	nop
340029a8:	34010000 	.word	0x34010000

340029ac <LL_ADC_SetChannelSingleDiff>:
  *         @arg @ref LL_ADC_SINGLE_ENDED
  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSingleDiff(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SingleDiff)
{
340029ac:	b480      	push	{r7}
340029ae:	b087      	sub	sp, #28
340029b0:	af00      	add	r7, sp, #0
340029b2:	60f8      	str	r0, [r7, #12]
340029b4:	60b9      	str	r1, [r7, #8]
340029b6:	607a      	str	r2, [r7, #4]
  /* Bits of channels in single or differential mode are set only for         */
  /* differential mode (for single mode, mask of bits allowed to be set is    */
  /* shifted out of range of bits of channels in single or differential mode. */
  const uint32_t iChannel = __ADC_CHANNEL_INDEX(Channel);
340029b8:	68bb      	ldr	r3, [r7, #8]
340029ba:	f003 031f 	and.w	r3, r3, #31
340029be:	2b00      	cmp	r3, #0
340029c0:	f000 8087 	beq.w	34002ad2 <LL_ADC_SetChannelSingleDiff+0x126>
340029c4:	68bb      	ldr	r3, [r7, #8]
340029c6:	f003 031f 	and.w	r3, r3, #31
340029ca:	2b01      	cmp	r3, #1
340029cc:	d07f      	beq.n	34002ace <LL_ADC_SetChannelSingleDiff+0x122>
340029ce:	68bb      	ldr	r3, [r7, #8]
340029d0:	f003 031f 	and.w	r3, r3, #31
340029d4:	2b02      	cmp	r3, #2
340029d6:	d078      	beq.n	34002aca <LL_ADC_SetChannelSingleDiff+0x11e>
340029d8:	68bb      	ldr	r3, [r7, #8]
340029da:	f003 031f 	and.w	r3, r3, #31
340029de:	2b03      	cmp	r3, #3
340029e0:	d071      	beq.n	34002ac6 <LL_ADC_SetChannelSingleDiff+0x11a>
340029e2:	68bb      	ldr	r3, [r7, #8]
340029e4:	f003 031f 	and.w	r3, r3, #31
340029e8:	2b04      	cmp	r3, #4
340029ea:	d06a      	beq.n	34002ac2 <LL_ADC_SetChannelSingleDiff+0x116>
340029ec:	68bb      	ldr	r3, [r7, #8]
340029ee:	f003 031f 	and.w	r3, r3, #31
340029f2:	2b05      	cmp	r3, #5
340029f4:	d063      	beq.n	34002abe <LL_ADC_SetChannelSingleDiff+0x112>
340029f6:	68bb      	ldr	r3, [r7, #8]
340029f8:	f003 031f 	and.w	r3, r3, #31
340029fc:	2b06      	cmp	r3, #6
340029fe:	d05c      	beq.n	34002aba <LL_ADC_SetChannelSingleDiff+0x10e>
34002a00:	68bb      	ldr	r3, [r7, #8]
34002a02:	f003 031f 	and.w	r3, r3, #31
34002a06:	2b07      	cmp	r3, #7
34002a08:	d055      	beq.n	34002ab6 <LL_ADC_SetChannelSingleDiff+0x10a>
34002a0a:	68bb      	ldr	r3, [r7, #8]
34002a0c:	f003 031f 	and.w	r3, r3, #31
34002a10:	2b08      	cmp	r3, #8
34002a12:	d04e      	beq.n	34002ab2 <LL_ADC_SetChannelSingleDiff+0x106>
34002a14:	68bb      	ldr	r3, [r7, #8]
34002a16:	f003 031f 	and.w	r3, r3, #31
34002a1a:	2b09      	cmp	r3, #9
34002a1c:	d047      	beq.n	34002aae <LL_ADC_SetChannelSingleDiff+0x102>
34002a1e:	68bb      	ldr	r3, [r7, #8]
34002a20:	f003 031f 	and.w	r3, r3, #31
34002a24:	2b0a      	cmp	r3, #10
34002a26:	d040      	beq.n	34002aaa <LL_ADC_SetChannelSingleDiff+0xfe>
34002a28:	68bb      	ldr	r3, [r7, #8]
34002a2a:	f003 031f 	and.w	r3, r3, #31
34002a2e:	2b0b      	cmp	r3, #11
34002a30:	d039      	beq.n	34002aa6 <LL_ADC_SetChannelSingleDiff+0xfa>
34002a32:	68bb      	ldr	r3, [r7, #8]
34002a34:	f003 031f 	and.w	r3, r3, #31
34002a38:	2b0c      	cmp	r3, #12
34002a3a:	d032      	beq.n	34002aa2 <LL_ADC_SetChannelSingleDiff+0xf6>
34002a3c:	68bb      	ldr	r3, [r7, #8]
34002a3e:	f003 031f 	and.w	r3, r3, #31
34002a42:	2b0d      	cmp	r3, #13
34002a44:	d02b      	beq.n	34002a9e <LL_ADC_SetChannelSingleDiff+0xf2>
34002a46:	68bb      	ldr	r3, [r7, #8]
34002a48:	f003 031f 	and.w	r3, r3, #31
34002a4c:	2b0e      	cmp	r3, #14
34002a4e:	d024      	beq.n	34002a9a <LL_ADC_SetChannelSingleDiff+0xee>
34002a50:	68bb      	ldr	r3, [r7, #8]
34002a52:	f003 031f 	and.w	r3, r3, #31
34002a56:	2b0f      	cmp	r3, #15
34002a58:	d01d      	beq.n	34002a96 <LL_ADC_SetChannelSingleDiff+0xea>
34002a5a:	68bb      	ldr	r3, [r7, #8]
34002a5c:	f003 031f 	and.w	r3, r3, #31
34002a60:	2b10      	cmp	r3, #16
34002a62:	d016      	beq.n	34002a92 <LL_ADC_SetChannelSingleDiff+0xe6>
34002a64:	68bb      	ldr	r3, [r7, #8]
34002a66:	f003 031f 	and.w	r3, r3, #31
34002a6a:	2b11      	cmp	r3, #17
34002a6c:	d00f      	beq.n	34002a8e <LL_ADC_SetChannelSingleDiff+0xe2>
34002a6e:	68bb      	ldr	r3, [r7, #8]
34002a70:	f003 031f 	and.w	r3, r3, #31
34002a74:	2b12      	cmp	r3, #18
34002a76:	d008      	beq.n	34002a8a <LL_ADC_SetChannelSingleDiff+0xde>
34002a78:	68bb      	ldr	r3, [r7, #8]
34002a7a:	f003 031f 	and.w	r3, r3, #31
34002a7e:	2b13      	cmp	r3, #19
34002a80:	d101      	bne.n	34002a86 <LL_ADC_SetChannelSingleDiff+0xda>
34002a82:	2313      	movs	r3, #19
34002a84:	e026      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002a86:	2300      	movs	r3, #0
34002a88:	e024      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002a8a:	2312      	movs	r3, #18
34002a8c:	e022      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002a8e:	2311      	movs	r3, #17
34002a90:	e020      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002a92:	2310      	movs	r3, #16
34002a94:	e01e      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002a96:	230f      	movs	r3, #15
34002a98:	e01c      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002a9a:	230e      	movs	r3, #14
34002a9c:	e01a      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002a9e:	230d      	movs	r3, #13
34002aa0:	e018      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002aa2:	230c      	movs	r3, #12
34002aa4:	e016      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002aa6:	230b      	movs	r3, #11
34002aa8:	e014      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002aaa:	230a      	movs	r3, #10
34002aac:	e012      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002aae:	2309      	movs	r3, #9
34002ab0:	e010      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002ab2:	2308      	movs	r3, #8
34002ab4:	e00e      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002ab6:	2307      	movs	r3, #7
34002ab8:	e00c      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002aba:	2306      	movs	r3, #6
34002abc:	e00a      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002abe:	2305      	movs	r3, #5
34002ac0:	e008      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002ac2:	2304      	movs	r3, #4
34002ac4:	e006      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002ac6:	2303      	movs	r3, #3
34002ac8:	e004      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002aca:	2302      	movs	r3, #2
34002acc:	e002      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002ace:	2301      	movs	r3, #1
34002ad0:	e000      	b.n	34002ad4 <LL_ADC_SetChannelSingleDiff+0x128>
34002ad2:	2300      	movs	r3, #0
34002ad4:	617b      	str	r3, [r7, #20]
  MODIFY_REG(ADCx->DIFSEL,
34002ad6:	68fb      	ldr	r3, [r7, #12]
34002ad8:	f8d3 20c0 	ldr.w	r2, [r3, #192]	@ 0xc0
34002adc:	490f      	ldr	r1, [pc, #60]	@ (34002b1c <LL_ADC_SetChannelSingleDiff+0x170>)
34002ade:	697b      	ldr	r3, [r7, #20]
34002ae0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
34002ae4:	f3c3 0313 	ubfx	r3, r3, #0, #20
34002ae8:	43db      	mvns	r3, r3
34002aea:	401a      	ands	r2, r3
34002aec:	490b      	ldr	r1, [pc, #44]	@ (34002b1c <LL_ADC_SetChannelSingleDiff+0x170>)
34002aee:	697b      	ldr	r3, [r7, #20]
34002af0:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
34002af4:	687b      	ldr	r3, [r7, #4]
34002af6:	f003 0318 	and.w	r3, r3, #24
34002afa:	4809      	ldr	r0, [pc, #36]	@ (34002b20 <LL_ADC_SetChannelSingleDiff+0x174>)
34002afc:	fa20 f303 	lsr.w	r3, r0, r3
34002b00:	400b      	ands	r3, r1
34002b02:	f3c3 0313 	ubfx	r3, r3, #0, #20
34002b06:	431a      	orrs	r2, r3
34002b08:	68fb      	ldr	r3, [r7, #12]
34002b0a:	f8c3 20c0 	str.w	r2, [r3, #192]	@ 0xc0
             ADC_CHANNEL_LUT[iChannel] & ADC_SINGLEDIFF_CHANNEL_MASK,
             (ADC_CHANNEL_LUT[iChannel] & ADC_SINGLEDIFF_CHANNEL_MASK)
             & (ADC_DIFSEL_DIFSEL >> (SingleDiff & ADC_SINGLEDIFF_CHANNEL_SHIFT_MASK)));
}
34002b0e:	bf00      	nop
34002b10:	371c      	adds	r7, #28
34002b12:	46bd      	mov	sp, r7
34002b14:	f85d 7b04 	ldr.w	r7, [sp], #4
34002b18:	4770      	bx	lr
34002b1a:	bf00      	nop
34002b1c:	34010000 	.word	0x34010000
34002b20:	000fffff 	.word	0x000fffff

34002b24 <LL_ADC_SetAnalogWDMonitChannels>:
  *         (0) On this STM32 series, parameter available only on analog watchdog instance: AWD1.\n
  *         (1) On this STM32 series, parameter available only on ADC instance: ADC2, ADC3.
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetAnalogWDMonitChannels(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t AWDChannelGroup)
{
34002b24:	b480      	push	{r7}
34002b26:	b087      	sub	sp, #28
34002b28:	af00      	add	r7, sp, #0
34002b2a:	60f8      	str	r0, [r7, #12]
34002b2c:	60b9      	str	r1, [r7, #8]
34002b2e:	607a      	str	r2, [r7, #4]
  /* Set bits with content of parameter "AWDChannelGroup" with bits position  */
  /* in register and register position depending on parameter "AWDy".         */
  /* Parameters "AWDChannelGroup" and "AWDy" are used with masks because      */
  /* containing other bits reserved for other purpose.                        */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->CFGR1,
34002b30:	68fb      	ldr	r3, [r7, #12]
34002b32:	330c      	adds	r3, #12
34002b34:	4618      	mov	r0, r3
34002b36:	68bb      	ldr	r3, [r7, #8]
34002b38:	0d1b      	lsrs	r3, r3, #20
34002b3a:	f003 0103 	and.w	r1, r3, #3
34002b3e:	68bb      	ldr	r3, [r7, #8]
34002b40:	f003 0201 	and.w	r2, r3, #1
34002b44:	4613      	mov	r3, r2
34002b46:	00db      	lsls	r3, r3, #3
34002b48:	4413      	add	r3, r2
34002b4a:	009b      	lsls	r3, r3, #2
34002b4c:	440b      	add	r3, r1
34002b4e:	009b      	lsls	r3, r3, #2
34002b50:	4403      	add	r3, r0
34002b52:	617b      	str	r3, [r7, #20]
                                             ((AWDy & ADC_AWD_CRX_REGOFFSET_MASK) >> ADC_AWD_CRX_REGOFFSET_POS)
                                             + ((AWDy & ADC_AWD_CR12_REGOFFSETGAP_MASK)
                                                * ADC_AWD_CR12_REGOFFSETGAP_VAL));

  MODIFY_REG(*preg,
34002b54:	697b      	ldr	r3, [r7, #20]
34002b56:	681a      	ldr	r2, [r3, #0]
34002b58:	68bb      	ldr	r3, [r7, #8]
34002b5a:	f023 4302 	bic.w	r3, r3, #2181038080	@ 0x82000000
34002b5e:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
34002b62:	43db      	mvns	r3, r3
34002b64:	401a      	ands	r2, r3
34002b66:	6879      	ldr	r1, [r7, #4]
34002b68:	68bb      	ldr	r3, [r7, #8]
34002b6a:	400b      	ands	r3, r1
34002b6c:	431a      	orrs	r2, r3
34002b6e:	697b      	ldr	r3, [r7, #20]
34002b70:	601a      	str	r2, [r3, #0]
             (AWDy & ADC_AWD_CR_ALL_CHANNEL_MASK),
             AWDChannelGroup & AWDy);
}
34002b72:	bf00      	nop
34002b74:	371c      	adds	r7, #28
34002b76:	46bd      	mov	sp, r7
34002b78:	f85d 7b04 	ldr.w	r7, [sp], #4
34002b7c:	4770      	bx	lr
	...

34002b80 <LL_ADC_SetAnalogWDThresholds>:
  * @param  AWDThresholdValue Value between Min_Data=0x000 and Max_Data=0xFFF
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetAnalogWDThresholds(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t AWDThresholdsHighLow,
                                                  uint32_t AWDThresholdValue)
{
34002b80:	b480      	push	{r7}
34002b82:	b087      	sub	sp, #28
34002b84:	af00      	add	r7, sp, #0
34002b86:	60f8      	str	r0, [r7, #12]
34002b88:	60b9      	str	r1, [r7, #8]
34002b8a:	607a      	str	r2, [r7, #4]
34002b8c:	603b      	str	r3, [r7, #0]
  /* Set bits with content of parameter "AWDThresholdValue" with bits         */
  /* position in register and register position depending on parameters       */
  /* "AWDThresholdsHighLow" and "AWDy".                                       */
  /* Parameters "AWDy" and "AWDThresholdValue" are used with masks because    */
  /* containing other bits reserved for other purpose.                        */
  if (AWDy == LL_ADC_AWD1)
34002b8e:	68bb      	ldr	r3, [r7, #8]
34002b90:	4a12      	ldr	r2, [pc, #72]	@ (34002bdc <LL_ADC_SetAnalogWDThresholds+0x5c>)
34002b92:	4293      	cmp	r3, r2
34002b94:	d107      	bne.n	34002ba6 <LL_ADC_SetAnalogWDThresholds+0x26>
  {
    preg = __ADC_PTR_REG_OFFSET(ADCx->AWD1LTR, (AWDThresholdsHighLow));
34002b96:	68fb      	ldr	r3, [r7, #12]
34002b98:	33a8      	adds	r3, #168	@ 0xa8
34002b9a:	461a      	mov	r2, r3
34002b9c:	687b      	ldr	r3, [r7, #4]
34002b9e:	009b      	lsls	r3, r3, #2
34002ba0:	4413      	add	r3, r2
34002ba2:	617b      	str	r3, [r7, #20]
34002ba4:	e00c      	b.n	34002bc0 <LL_ADC_SetAnalogWDThresholds+0x40>
  }
  else
  {
    preg = __ADC_PTR_REG_OFFSET(ADCx->AWD1LTR, (((AWDy & ADC_AWD_TRX_REGOFFSET_MASK)
34002ba6:	68fb      	ldr	r3, [r7, #12]
34002ba8:	33a8      	adds	r3, #168	@ 0xa8
34002baa:	4619      	mov	r1, r3
34002bac:	68bb      	ldr	r3, [r7, #8]
34002bae:	0d1b      	lsrs	r3, r3, #20
34002bb0:	f003 0303 	and.w	r3, r3, #3
34002bb4:	005a      	lsls	r2, r3, #1
34002bb6:	687b      	ldr	r3, [r7, #4]
34002bb8:	4413      	add	r3, r2
34002bba:	009b      	lsls	r3, r3, #2
34002bbc:	440b      	add	r3, r1
34002bbe:	617b      	str	r3, [r7, #20]
                                                 >> ADC_AWD_TRX_REGOFFSET_POS) * 2UL)
                                + (AWDThresholdsHighLow));
  }

  MODIFY_REG(*preg, ADC_AWD1LTR_LTR, AWDThresholdValue);
34002bc0:	697b      	ldr	r3, [r7, #20]
34002bc2:	681b      	ldr	r3, [r3, #0]
34002bc4:	0ddb      	lsrs	r3, r3, #23
34002bc6:	05db      	lsls	r3, r3, #23
34002bc8:	683a      	ldr	r2, [r7, #0]
34002bca:	431a      	orrs	r2, r3
34002bcc:	697b      	ldr	r3, [r7, #20]
34002bce:	601a      	str	r2, [r3, #0]
}
34002bd0:	bf00      	nop
34002bd2:	371c      	adds	r7, #28
34002bd4:	46bd      	mov	sp, r7
34002bd6:	f85d 7b04 	ldr.w	r7, [sp], #4
34002bda:	4770      	bx	lr
34002bdc:	7dc00000 	.word	0x7dc00000

34002be0 <LL_ADC_SetAWDFilteringConfiguration>:
  *         @arg @ref LL_ADC_AWD_FILTERING_7SAMPLES
  *         @arg @ref LL_ADC_AWD_FILTERING_8SAMPLES
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetAWDFilteringConfiguration(ADC_TypeDef *ADCx, uint32_t AWDy, uint32_t FilteringConfig)
{
34002be0:	b480      	push	{r7}
34002be2:	b085      	sub	sp, #20
34002be4:	af00      	add	r7, sp, #0
34002be6:	60f8      	str	r0, [r7, #12]
34002be8:	60b9      	str	r1, [r7, #8]
34002bea:	607a      	str	r2, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  (void)(AWDy);
  MODIFY_REG(ADCx->AWD1HTR, ADC_AWD1HTR_AWDFILT, FilteringConfig);
34002bec:	68fb      	ldr	r3, [r7, #12]
34002bee:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
34002bf2:	f023 4260 	bic.w	r2, r3, #3758096384	@ 0xe0000000
34002bf6:	687b      	ldr	r3, [r7, #4]
34002bf8:	431a      	orrs	r2, r3
34002bfa:	68fb      	ldr	r3, [r7, #12]
34002bfc:	f8c3 20ac 	str.w	r2, [r3, #172]	@ 0xac
}
34002c00:	bf00      	nop
34002c02:	3714      	adds	r7, #20
34002c04:	46bd      	mov	sp, r7
34002c06:	f85d 7b04 	ldr.w	r7, [sp], #4
34002c0a:	4770      	bx	lr

34002c0c <LL_ADC_GetMultimode>:
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_SIM
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM
  */
__STATIC_INLINE uint32_t LL_ADC_GetMultimode(const ADC_Common_TypeDef *ADCxy_COMMON)
{
34002c0c:	b480      	push	{r7}
34002c0e:	b083      	sub	sp, #12
34002c10:	af00      	add	r7, sp, #0
34002c12:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
34002c14:	687b      	ldr	r3, [r7, #4]
34002c16:	689b      	ldr	r3, [r3, #8]
34002c18:	f003 031f 	and.w	r3, r3, #31
}
34002c1c:	4618      	mov	r0, r3
34002c1e:	370c      	adds	r7, #12
34002c20:	46bd      	mov	sp, r7
34002c22:	f85d 7b04 	ldr.w	r7, [sp], #4
34002c26:	4770      	bx	lr

34002c28 <LL_ADC_GetMultiDataFormat>:
  *         @arg @ref LL_ADC_MULTI_REG_DATA_EACH_ADC
  *         @arg @ref LL_ADC_MULTI_REG_DATA_COMMON_32B
  *         @arg @ref LL_ADC_MULTI_REG_DATA_COMMON_16B
  */
__STATIC_INLINE uint32_t LL_ADC_GetMultiDataFormat(const ADC_Common_TypeDef *ADCxy_COMMON)
{
34002c28:	b480      	push	{r7}
34002c2a:	b083      	sub	sp, #12
34002c2c:	af00      	add	r7, sp, #0
34002c2e:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DAMDF));
34002c30:	687b      	ldr	r3, [r7, #4]
34002c32:	689b      	ldr	r3, [r3, #8]
34002c34:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
}
34002c38:	4618      	mov	r0, r3
34002c3a:	370c      	adds	r7, #12
34002c3c:	46bd      	mov	sp, r7
34002c3e:	f85d 7b04 	ldr.w	r7, [sp], #4
34002c42:	4770      	bx	lr

34002c44 <LL_ADC_DisableDeepPowerDown>:
  * @rmtoll CR       DEEPPWD        LL_ADC_DisableDeepPowerDown
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableDeepPowerDown(ADC_TypeDef *ADCx)
{
34002c44:	b480      	push	{r7}
34002c46:	b083      	sub	sp, #12
34002c48:	af00      	add	r7, sp, #0
34002c4a:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
34002c4c:	687b      	ldr	r3, [r7, #4]
34002c4e:	689b      	ldr	r3, [r3, #8]
34002c50:	f023 5300 	bic.w	r3, r3, #536870912	@ 0x20000000
34002c54:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34002c58:	687a      	ldr	r2, [r7, #4]
34002c5a:	6093      	str	r3, [r2, #8]
}
34002c5c:	bf00      	nop
34002c5e:	370c      	adds	r7, #12
34002c60:	46bd      	mov	sp, r7
34002c62:	f85d 7b04 	ldr.w	r7, [sp], #4
34002c66:	4770      	bx	lr

34002c68 <LL_ADC_IsDeepPowerDownEnabled>:
  * @rmtoll CR       DEEPPWD        LL_ADC_IsDeepPowerDownEnabled
  * @param  ADCx ADC instance
  * @retval 0: deep power down is disabled, 1: deep power down is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDeepPowerDownEnabled(const ADC_TypeDef *ADCx)
{
34002c68:	b480      	push	{r7}
34002c6a:	b083      	sub	sp, #12
34002c6c:	af00      	add	r7, sp, #0
34002c6e:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
34002c70:	687b      	ldr	r3, [r7, #4]
34002c72:	689b      	ldr	r3, [r3, #8]
34002c74:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
34002c78:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
34002c7c:	d101      	bne.n	34002c82 <LL_ADC_IsDeepPowerDownEnabled+0x1a>
34002c7e:	2301      	movs	r3, #1
34002c80:	e000      	b.n	34002c84 <LL_ADC_IsDeepPowerDownEnabled+0x1c>
34002c82:	2300      	movs	r3, #0
}
34002c84:	4618      	mov	r0, r3
34002c86:	370c      	adds	r7, #12
34002c88:	46bd      	mov	sp, r7
34002c8a:	f85d 7b04 	ldr.w	r7, [sp], #4
34002c8e:	4770      	bx	lr

34002c90 <LL_ADC_Enable>:
  * @rmtoll CR       ADEN           LL_ADC_Enable
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_Enable(ADC_TypeDef *ADCx)
{
34002c90:	b480      	push	{r7}
34002c92:	b083      	sub	sp, #12
34002c94:	af00      	add	r7, sp, #0
34002c96:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
34002c98:	687b      	ldr	r3, [r7, #4]
34002c9a:	689b      	ldr	r3, [r3, #8]
34002c9c:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34002ca0:	f043 0201 	orr.w	r2, r3, #1
34002ca4:	687b      	ldr	r3, [r7, #4]
34002ca6:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADEN);
}
34002ca8:	bf00      	nop
34002caa:	370c      	adds	r7, #12
34002cac:	46bd      	mov	sp, r7
34002cae:	f85d 7b04 	ldr.w	r7, [sp], #4
34002cb2:	4770      	bx	lr

34002cb4 <LL_ADC_Disable>:
  * @rmtoll CR       ADDIS          LL_ADC_Disable
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_Disable(ADC_TypeDef *ADCx)
{
34002cb4:	b480      	push	{r7}
34002cb6:	b083      	sub	sp, #12
34002cb8:	af00      	add	r7, sp, #0
34002cba:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
34002cbc:	687b      	ldr	r3, [r7, #4]
34002cbe:	689b      	ldr	r3, [r3, #8]
34002cc0:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34002cc4:	f043 0202 	orr.w	r2, r3, #2
34002cc8:	687b      	ldr	r3, [r7, #4]
34002cca:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADDIS);
}
34002ccc:	bf00      	nop
34002cce:	370c      	adds	r7, #12
34002cd0:	46bd      	mov	sp, r7
34002cd2:	f85d 7b04 	ldr.w	r7, [sp], #4
34002cd6:	4770      	bx	lr

34002cd8 <LL_ADC_IsEnabled>:
  * @rmtoll CR       ADEN           LL_ADC_IsEnabled
  * @param  ADCx ADC instance
  * @retval 0: ADC is disabled, 1: ADC is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabled(const ADC_TypeDef *ADCx)
{
34002cd8:	b480      	push	{r7}
34002cda:	b083      	sub	sp, #12
34002cdc:	af00      	add	r7, sp, #0
34002cde:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
34002ce0:	687b      	ldr	r3, [r7, #4]
34002ce2:	689b      	ldr	r3, [r3, #8]
34002ce4:	f003 0301 	and.w	r3, r3, #1
34002ce8:	2b01      	cmp	r3, #1
34002cea:	d101      	bne.n	34002cf0 <LL_ADC_IsEnabled+0x18>
34002cec:	2301      	movs	r3, #1
34002cee:	e000      	b.n	34002cf2 <LL_ADC_IsEnabled+0x1a>
34002cf0:	2300      	movs	r3, #0
}
34002cf2:	4618      	mov	r0, r3
34002cf4:	370c      	adds	r7, #12
34002cf6:	46bd      	mov	sp, r7
34002cf8:	f85d 7b04 	ldr.w	r7, [sp], #4
34002cfc:	4770      	bx	lr

34002cfe <LL_ADC_IsDisableOngoing>:
  * @rmtoll CR       ADDIS          LL_ADC_IsDisableOngoing
  * @param  ADCx ADC instance
  * @retval 0: no ADC disable command on going.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDisableOngoing(const ADC_TypeDef *ADCx)
{
34002cfe:	b480      	push	{r7}
34002d00:	b083      	sub	sp, #12
34002d02:	af00      	add	r7, sp, #0
34002d04:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
34002d06:	687b      	ldr	r3, [r7, #4]
34002d08:	689b      	ldr	r3, [r3, #8]
34002d0a:	f003 0302 	and.w	r3, r3, #2
34002d0e:	2b02      	cmp	r3, #2
34002d10:	d101      	bne.n	34002d16 <LL_ADC_IsDisableOngoing+0x18>
34002d12:	2301      	movs	r3, #1
34002d14:	e000      	b.n	34002d18 <LL_ADC_IsDisableOngoing+0x1a>
34002d16:	2300      	movs	r3, #0
}
34002d18:	4618      	mov	r0, r3
34002d1a:	370c      	adds	r7, #12
34002d1c:	46bd      	mov	sp, r7
34002d1e:	f85d 7b04 	ldr.w	r7, [sp], #4
34002d22:	4770      	bx	lr

34002d24 <LL_ADC_REG_StartConversion>:
  * @rmtoll CR       ADSTART        LL_ADC_REG_StartConversion
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_StartConversion(ADC_TypeDef *ADCx)
{
34002d24:	b480      	push	{r7}
34002d26:	b083      	sub	sp, #12
34002d28:	af00      	add	r7, sp, #0
34002d2a:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
34002d2c:	687b      	ldr	r3, [r7, #4]
34002d2e:	689b      	ldr	r3, [r3, #8]
34002d30:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34002d34:	f043 0204 	orr.w	r2, r3, #4
34002d38:	687b      	ldr	r3, [r7, #4]
34002d3a:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADSTART);
}
34002d3c:	bf00      	nop
34002d3e:	370c      	adds	r7, #12
34002d40:	46bd      	mov	sp, r7
34002d42:	f85d 7b04 	ldr.w	r7, [sp], #4
34002d46:	4770      	bx	lr

34002d48 <LL_ADC_REG_StopConversion>:
  * @rmtoll CR       ADSTP          LL_ADC_REG_StopConversion
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_StopConversion(ADC_TypeDef *ADCx)
{
34002d48:	b480      	push	{r7}
34002d4a:	b083      	sub	sp, #12
34002d4c:	af00      	add	r7, sp, #0
34002d4e:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
34002d50:	687b      	ldr	r3, [r7, #4]
34002d52:	689b      	ldr	r3, [r3, #8]
34002d54:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34002d58:	f043 0210 	orr.w	r2, r3, #16
34002d5c:	687b      	ldr	r3, [r7, #4]
34002d5e:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADSTP);
}
34002d60:	bf00      	nop
34002d62:	370c      	adds	r7, #12
34002d64:	46bd      	mov	sp, r7
34002d66:	f85d 7b04 	ldr.w	r7, [sp], #4
34002d6a:	4770      	bx	lr

34002d6c <LL_ADC_REG_IsConversionOngoing>:
  * @rmtoll CR       ADSTART        LL_ADC_REG_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(const ADC_TypeDef *ADCx)
{
34002d6c:	b480      	push	{r7}
34002d6e:	b083      	sub	sp, #12
34002d70:	af00      	add	r7, sp, #0
34002d72:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
34002d74:	687b      	ldr	r3, [r7, #4]
34002d76:	689b      	ldr	r3, [r3, #8]
34002d78:	f003 0304 	and.w	r3, r3, #4
34002d7c:	2b04      	cmp	r3, #4
34002d7e:	d101      	bne.n	34002d84 <LL_ADC_REG_IsConversionOngoing+0x18>
34002d80:	2301      	movs	r3, #1
34002d82:	e000      	b.n	34002d86 <LL_ADC_REG_IsConversionOngoing+0x1a>
34002d84:	2300      	movs	r3, #0
}
34002d86:	4618      	mov	r0, r3
34002d88:	370c      	adds	r7, #12
34002d8a:	46bd      	mov	sp, r7
34002d8c:	f85d 7b04 	ldr.w	r7, [sp], #4
34002d90:	4770      	bx	lr

34002d92 <LL_ADC_INJ_StopConversion>:
  * @rmtoll CR       JADSTP         LL_ADC_INJ_StopConversion
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_INJ_StopConversion(ADC_TypeDef *ADCx)
{
34002d92:	b480      	push	{r7}
34002d94:	b083      	sub	sp, #12
34002d96:	af00      	add	r7, sp, #0
34002d98:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
34002d9a:	687b      	ldr	r3, [r7, #4]
34002d9c:	689b      	ldr	r3, [r3, #8]
34002d9e:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
34002da2:	f043 0220 	orr.w	r2, r3, #32
34002da6:	687b      	ldr	r3, [r7, #4]
34002da8:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_JADSTP);
}
34002daa:	bf00      	nop
34002dac:	370c      	adds	r7, #12
34002dae:	46bd      	mov	sp, r7
34002db0:	f85d 7b04 	ldr.w	r7, [sp], #4
34002db4:	4770      	bx	lr

34002db6 <LL_ADC_INJ_IsConversionOngoing>:
  * @rmtoll CR       JADSTART       LL_ADC_INJ_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(const ADC_TypeDef *ADCx)
{
34002db6:	b480      	push	{r7}
34002db8:	b083      	sub	sp, #12
34002dba:	af00      	add	r7, sp, #0
34002dbc:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
34002dbe:	687b      	ldr	r3, [r7, #4]
34002dc0:	689b      	ldr	r3, [r3, #8]
34002dc2:	f003 0308 	and.w	r3, r3, #8
34002dc6:	2b08      	cmp	r3, #8
34002dc8:	d101      	bne.n	34002dce <LL_ADC_INJ_IsConversionOngoing+0x18>
34002dca:	2301      	movs	r3, #1
34002dcc:	e000      	b.n	34002dd0 <LL_ADC_INJ_IsConversionOngoing+0x1a>
34002dce:	2300      	movs	r3, #0
}
34002dd0:	4618      	mov	r0, r3
34002dd2:	370c      	adds	r7, #12
34002dd4:	46bd      	mov	sp, r7
34002dd6:	f85d 7b04 	ldr.w	r7, [sp], #4
34002dda:	4770      	bx	lr

34002ddc <LL_ADC_ClearFlag_AWD1>:
  * @rmtoll ISR      AWD1           LL_ADC_ClearFlag_AWD1
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ClearFlag_AWD1(ADC_TypeDef *ADCx)
{
34002ddc:	b480      	push	{r7}
34002dde:	b083      	sub	sp, #12
34002de0:	af00      	add	r7, sp, #0
34002de2:	6078      	str	r0, [r7, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_AWD1);
34002de4:	687b      	ldr	r3, [r7, #4]
34002de6:	2280      	movs	r2, #128	@ 0x80
34002de8:	601a      	str	r2, [r3, #0]
}
34002dea:	bf00      	nop
34002dec:	370c      	adds	r7, #12
34002dee:	46bd      	mov	sp, r7
34002df0:	f85d 7b04 	ldr.w	r7, [sp], #4
34002df4:	4770      	bx	lr

34002df6 <LL_ADC_ClearFlag_AWD2>:
  * @rmtoll ISR      AWD2           LL_ADC_ClearFlag_AWD2
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ClearFlag_AWD2(ADC_TypeDef *ADCx)
{
34002df6:	b480      	push	{r7}
34002df8:	b083      	sub	sp, #12
34002dfa:	af00      	add	r7, sp, #0
34002dfc:	6078      	str	r0, [r7, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_AWD2);
34002dfe:	687b      	ldr	r3, [r7, #4]
34002e00:	f44f 7280 	mov.w	r2, #256	@ 0x100
34002e04:	601a      	str	r2, [r3, #0]
}
34002e06:	bf00      	nop
34002e08:	370c      	adds	r7, #12
34002e0a:	46bd      	mov	sp, r7
34002e0c:	f85d 7b04 	ldr.w	r7, [sp], #4
34002e10:	4770      	bx	lr

34002e12 <LL_ADC_ClearFlag_AWD3>:
  * @rmtoll ISR      AWD3           LL_ADC_ClearFlag_AWD3
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_ClearFlag_AWD3(ADC_TypeDef *ADCx)
{
34002e12:	b480      	push	{r7}
34002e14:	b083      	sub	sp, #12
34002e16:	af00      	add	r7, sp, #0
34002e18:	6078      	str	r0, [r7, #4]
  WRITE_REG(ADCx->ISR, LL_ADC_FLAG_AWD3);
34002e1a:	687b      	ldr	r3, [r7, #4]
34002e1c:	f44f 7200 	mov.w	r2, #512	@ 0x200
34002e20:	601a      	str	r2, [r3, #0]
}
34002e22:	bf00      	nop
34002e24:	370c      	adds	r7, #12
34002e26:	46bd      	mov	sp, r7
34002e28:	f85d 7b04 	ldr.w	r7, [sp], #4
34002e2c:	4770      	bx	lr

34002e2e <LL_ADC_EnableIT_AWD1>:
  * @rmtoll IER      AWD1IE         LL_ADC_EnableIT_AWD1
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_AWD1(ADC_TypeDef *ADCx)
{
34002e2e:	b480      	push	{r7}
34002e30:	b083      	sub	sp, #12
34002e32:	af00      	add	r7, sp, #0
34002e34:	6078      	str	r0, [r7, #4]
  SET_BIT(ADCx->IER, LL_ADC_IT_AWD1);
34002e36:	687b      	ldr	r3, [r7, #4]
34002e38:	685b      	ldr	r3, [r3, #4]
34002e3a:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
34002e3e:	687b      	ldr	r3, [r7, #4]
34002e40:	605a      	str	r2, [r3, #4]
}
34002e42:	bf00      	nop
34002e44:	370c      	adds	r7, #12
34002e46:	46bd      	mov	sp, r7
34002e48:	f85d 7b04 	ldr.w	r7, [sp], #4
34002e4c:	4770      	bx	lr

34002e4e <LL_ADC_EnableIT_AWD2>:
  * @rmtoll IER      AWD2IE         LL_ADC_EnableIT_AWD2
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_AWD2(ADC_TypeDef *ADCx)
{
34002e4e:	b480      	push	{r7}
34002e50:	b083      	sub	sp, #12
34002e52:	af00      	add	r7, sp, #0
34002e54:	6078      	str	r0, [r7, #4]
  SET_BIT(ADCx->IER, LL_ADC_IT_AWD2);
34002e56:	687b      	ldr	r3, [r7, #4]
34002e58:	685b      	ldr	r3, [r3, #4]
34002e5a:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
34002e5e:	687b      	ldr	r3, [r7, #4]
34002e60:	605a      	str	r2, [r3, #4]
}
34002e62:	bf00      	nop
34002e64:	370c      	adds	r7, #12
34002e66:	46bd      	mov	sp, r7
34002e68:	f85d 7b04 	ldr.w	r7, [sp], #4
34002e6c:	4770      	bx	lr

34002e6e <LL_ADC_EnableIT_AWD3>:
  * @rmtoll IER      AWD3IE         LL_ADC_EnableIT_AWD3
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableIT_AWD3(ADC_TypeDef *ADCx)
{
34002e6e:	b480      	push	{r7}
34002e70:	b083      	sub	sp, #12
34002e72:	af00      	add	r7, sp, #0
34002e74:	6078      	str	r0, [r7, #4]
  SET_BIT(ADCx->IER, LL_ADC_IT_AWD3);
34002e76:	687b      	ldr	r3, [r7, #4]
34002e78:	685b      	ldr	r3, [r3, #4]
34002e7a:	f443 7200 	orr.w	r2, r3, #512	@ 0x200
34002e7e:	687b      	ldr	r3, [r7, #4]
34002e80:	605a      	str	r2, [r3, #4]
}
34002e82:	bf00      	nop
34002e84:	370c      	adds	r7, #12
34002e86:	46bd      	mov	sp, r7
34002e88:	f85d 7b04 	ldr.w	r7, [sp], #4
34002e8c:	4770      	bx	lr

34002e8e <LL_ADC_DisableIT_AWD1>:
  * @rmtoll IER      AWD1IE         LL_ADC_DisableIT_AWD1
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_AWD1(ADC_TypeDef *ADCx)
{
34002e8e:	b480      	push	{r7}
34002e90:	b083      	sub	sp, #12
34002e92:	af00      	add	r7, sp, #0
34002e94:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_AWD1);
34002e96:	687b      	ldr	r3, [r7, #4]
34002e98:	685b      	ldr	r3, [r3, #4]
34002e9a:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
34002e9e:	687b      	ldr	r3, [r7, #4]
34002ea0:	605a      	str	r2, [r3, #4]
}
34002ea2:	bf00      	nop
34002ea4:	370c      	adds	r7, #12
34002ea6:	46bd      	mov	sp, r7
34002ea8:	f85d 7b04 	ldr.w	r7, [sp], #4
34002eac:	4770      	bx	lr

34002eae <LL_ADC_DisableIT_AWD2>:
  * @rmtoll IER      AWD2IE         LL_ADC_DisableIT_AWD2
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_AWD2(ADC_TypeDef *ADCx)
{
34002eae:	b480      	push	{r7}
34002eb0:	b083      	sub	sp, #12
34002eb2:	af00      	add	r7, sp, #0
34002eb4:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_AWD2);
34002eb6:	687b      	ldr	r3, [r7, #4]
34002eb8:	685b      	ldr	r3, [r3, #4]
34002eba:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
34002ebe:	687b      	ldr	r3, [r7, #4]
34002ec0:	605a      	str	r2, [r3, #4]
}
34002ec2:	bf00      	nop
34002ec4:	370c      	adds	r7, #12
34002ec6:	46bd      	mov	sp, r7
34002ec8:	f85d 7b04 	ldr.w	r7, [sp], #4
34002ecc:	4770      	bx	lr

34002ece <LL_ADC_DisableIT_AWD3>:
  * @rmtoll IER      AWD3IE         LL_ADC_DisableIT_AWD3
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableIT_AWD3(ADC_TypeDef *ADCx)
{
34002ece:	b480      	push	{r7}
34002ed0:	b083      	sub	sp, #12
34002ed2:	af00      	add	r7, sp, #0
34002ed4:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(ADCx->IER, LL_ADC_IT_AWD3);
34002ed6:	687b      	ldr	r3, [r7, #4]
34002ed8:	685b      	ldr	r3, [r3, #4]
34002eda:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
34002ede:	687b      	ldr	r3, [r7, #4]
34002ee0:	605a      	str	r2, [r3, #4]
}
34002ee2:	bf00      	nop
34002ee4:	370c      	adds	r7, #12
34002ee6:	46bd      	mov	sp, r7
34002ee8:	f85d 7b04 	ldr.w	r7, [sp], #4
34002eec:	4770      	bx	lr
	...

34002ef0 <HAL_ADC_Init>:
  *         without disabling the other ADCs sharing the same ADC common instance.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
34002ef0:	b580      	push	{r7, lr}
34002ef2:	b088      	sub	sp, #32
34002ef4:	af00      	add	r7, sp, #0
34002ef6:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
34002ef8:	2300      	movs	r3, #0
34002efa:	77fb      	strb	r3, [r7, #31]
  uint32_t tmp_adc_reg_is_conversion_on_going;
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;

  /* Check ADC handle */
  if (hadc == NULL)
34002efc:	687b      	ldr	r3, [r7, #4]
34002efe:	2b00      	cmp	r3, #0
34002f00:	d101      	bne.n	34002f06 <HAL_ADC_Init+0x16>
  {
    return HAL_ERROR;
34002f02:	2301      	movs	r3, #1
34002f04:	e108      	b.n	34003118 <HAL_ADC_Init+0x228>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));

  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
34002f06:	687b      	ldr	r3, [r7, #4]
34002f08:	68db      	ldr	r3, [r3, #12]
34002f0a:	2b00      	cmp	r3, #0
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
34002f0c:	687b      	ldr	r3, [r7, #4]
34002f0e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002f10:	2b00      	cmp	r3, #0
34002f12:	d109      	bne.n	34002f28 <HAL_ADC_Init+0x38>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
34002f14:	6878      	ldr	r0, [r7, #4]
34002f16:	f7fe f9b7 	bl	34001288 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
34002f1a:	687b      	ldr	r3, [r7, #4]
34002f1c:	2200      	movs	r2, #0
34002f1e:	65da      	str	r2, [r3, #92]	@ 0x5c

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
34002f20:	687b      	ldr	r3, [r7, #4]
34002f22:	2200      	movs	r2, #0
34002f24:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54
  }

  /* ADC must be disabled to set configuration bits                            */
  if (LL_ADC_IsEnabled(hadc->Instance) != 0UL)
34002f28:	687b      	ldr	r3, [r7, #4]
34002f2a:	681b      	ldr	r3, [r3, #0]
34002f2c:	4618      	mov	r0, r3
34002f2e:	f7ff fed3 	bl	34002cd8 <LL_ADC_IsEnabled>
34002f32:	4603      	mov	r3, r0
34002f34:	2b00      	cmp	r3, #0
34002f36:	d001      	beq.n	34002f3c <HAL_ADC_Init+0x4c>
  {
    return HAL_ERROR;
34002f38:	2301      	movs	r3, #1
34002f3a:	e0ed      	b.n	34003118 <HAL_ADC_Init+0x228>
  }

  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
34002f3c:	687b      	ldr	r3, [r7, #4]
34002f3e:	681b      	ldr	r3, [r3, #0]
34002f40:	4618      	mov	r0, r3
34002f42:	f7ff fe91 	bl	34002c68 <LL_ADC_IsDeepPowerDownEnabled>
34002f46:	4603      	mov	r3, r0
34002f48:	2b00      	cmp	r3, #0
34002f4a:	d004      	beq.n	34002f56 <HAL_ADC_Init+0x66>
  {
    /* Disable ADC deep power down mode */
    LL_ADC_DisableDeepPowerDown(hadc->Instance);
34002f4c:	687b      	ldr	r3, [r7, #4]
34002f4e:	681b      	ldr	r3, [r3, #0]
34002f50:	4618      	mov	r0, r3
34002f52:	f7ff fe77 	bl	34002c44 <LL_ADC_DisableDeepPowerDown>
  }
  /* Configuration of ADC parameters if previous preliminary actions are      */
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
34002f56:	687b      	ldr	r3, [r7, #4]
34002f58:	681b      	ldr	r3, [r3, #0]
34002f5a:	4618      	mov	r0, r3
34002f5c:	f7ff ff06 	bl	34002d6c <LL_ADC_REG_IsConversionOngoing>
34002f60:	6178      	str	r0, [r7, #20]

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
34002f62:	687b      	ldr	r3, [r7, #4]
34002f64:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002f66:	f003 0310 	and.w	r3, r3, #16
34002f6a:	2b00      	cmp	r3, #0
34002f6c:	f040 80cb 	bne.w	34003106 <HAL_ADC_Init+0x216>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
34002f70:	697b      	ldr	r3, [r7, #20]
34002f72:	2b00      	cmp	r3, #0
34002f74:	f040 80c7 	bne.w	34003106 <HAL_ADC_Init+0x216>
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
34002f78:	687b      	ldr	r3, [r7, #4]
34002f7a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34002f7c:	f423 7381 	bic.w	r3, r3, #258	@ 0x102
34002f80:	f043 0202 	orr.w	r2, r3, #2
34002f84:	687b      	ldr	r3, [r7, #4]
34002f86:	659a      	str	r2, [r3, #88]	@ 0x58
    /*  - continuous conversion mode               Init.ContinuousConvMode    */
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */

    tmpCFGR1 = (ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)         |
34002f88:	687b      	ldr	r3, [r7, #4]
34002f8a:	7d5b      	ldrb	r3, [r3, #21]
34002f8c:	035a      	lsls	r2, r3, #13
                hadc->Init.Overrun                                                    |
34002f8e:	687b      	ldr	r3, [r7, #4]
34002f90:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
    tmpCFGR1 = (ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)         |
34002f92:	431a      	orrs	r2, r3
                hadc->Init.Resolution                                                 |
34002f94:	687b      	ldr	r3, [r7, #4]
34002f96:	685b      	ldr	r3, [r3, #4]
                hadc->Init.Overrun                                                    |
34002f98:	431a      	orrs	r2, r3
                ADC_CFGR1_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
34002f9a:	687b      	ldr	r3, [r7, #4]
34002f9c:	7f1b      	ldrb	r3, [r3, #28]
34002f9e:	041b      	lsls	r3, r3, #16
    tmpCFGR1 = (ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)         |
34002fa0:	4313      	orrs	r3, r2
34002fa2:	61bb      	str	r3, [r7, #24]

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
34002fa4:	687b      	ldr	r3, [r7, #4]
34002fa6:	7f1b      	ldrb	r3, [r3, #28]
34002fa8:	2b01      	cmp	r3, #1
34002faa:	d106      	bne.n	34002fba <HAL_ADC_Init+0xca>
    {
      tmpCFGR1 |= ADC_CFGR1_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
34002fac:	687b      	ldr	r3, [r7, #4]
34002fae:	6a1b      	ldr	r3, [r3, #32]
34002fb0:	3b01      	subs	r3, #1
34002fb2:	045b      	lsls	r3, r3, #17
34002fb4:	69ba      	ldr	r2, [r7, #24]
34002fb6:	4313      	orrs	r3, r2
34002fb8:	61bb      	str	r3, [r7, #24]
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
34002fba:	687b      	ldr	r3, [r7, #4]
34002fbc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34002fbe:	2b00      	cmp	r3, #0
34002fc0:	d009      	beq.n	34002fd6 <HAL_ADC_Init+0xe6>
    {
      tmpCFGR1 |= ((hadc->Init.ExternalTrigConv & ADC_CFGR1_EXTSEL)
34002fc2:	687b      	ldr	r3, [r7, #4]
34002fc4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34002fc6:	f403 7278 	and.w	r2, r3, #992	@ 0x3e0
                   | hadc->Init.ExternalTrigConvEdge
34002fca:	687b      	ldr	r3, [r7, #4]
34002fcc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34002fce:	4313      	orrs	r3, r2
      tmpCFGR1 |= ((hadc->Init.ExternalTrigConv & ADC_CFGR1_EXTSEL)
34002fd0:	69ba      	ldr	r2, [r7, #24]
34002fd2:	4313      	orrs	r3, r2
34002fd4:	61bb      	str	r3, [r7, #24]
                  );
    }

    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR1, ADC_CFGR1_FIELDS_1, tmpCFGR1);
34002fd6:	687b      	ldr	r3, [r7, #4]
34002fd8:	681b      	ldr	r3, [r3, #0]
34002fda:	68da      	ldr	r2, [r3, #12]
34002fdc:	4b50      	ldr	r3, [pc, #320]	@ (34003120 <HAL_ADC_Init+0x230>)
34002fde:	4013      	ands	r3, r2
34002fe0:	687a      	ldr	r2, [r7, #4]
34002fe2:	6812      	ldr	r2, [r2, #0]
34002fe4:	69b9      	ldr	r1, [r7, #24]
34002fe6:	430b      	orrs	r3, r1
34002fe8:	60d3      	str	r3, [r2, #12]

    /* Configuration of sampling mode */
    MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_BULB | ADC_CFGR2_SMPTRIG, hadc->Init.SamplingMode);
34002fea:	687b      	ldr	r3, [r7, #4]
34002fec:	681b      	ldr	r3, [r3, #0]
34002fee:	691b      	ldr	r3, [r3, #16]
34002ff0:	f423 4120 	bic.w	r1, r3, #40960	@ 0xa000
34002ff4:	687b      	ldr	r3, [r7, #4]
34002ff6:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34002ff8:	687b      	ldr	r3, [r7, #4]
34002ffa:	681b      	ldr	r3, [r3, #0]
34002ffc:	430a      	orrs	r2, r1
34002ffe:	611a      	str	r2, [r3, #16]
    /* Parameters that can be updated when ADC is disabled or enabled without */
    /* conversion on going on regular and injected groups:                    */
    /*  - Conversion data management      Init.ConversionDataManagement       */
    /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
    /*  - Oversampling parameters         Init.Oversampling                   */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
34003000:	687b      	ldr	r3, [r7, #4]
34003002:	681b      	ldr	r3, [r3, #0]
34003004:	4618      	mov	r0, r3
34003006:	f7ff feb1 	bl	34002d6c <LL_ADC_REG_IsConversionOngoing>
3400300a:	6138      	str	r0, [r7, #16]
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
3400300c:	687b      	ldr	r3, [r7, #4]
3400300e:	681b      	ldr	r3, [r3, #0]
34003010:	4618      	mov	r0, r3
34003012:	f7ff fed0 	bl	34002db6 <LL_ADC_INJ_IsConversionOngoing>
34003016:	60f8      	str	r0, [r7, #12]
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
34003018:	693b      	ldr	r3, [r7, #16]
3400301a:	2b00      	cmp	r3, #0
3400301c:	d151      	bne.n	340030c2 <HAL_ADC_Init+0x1d2>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
3400301e:	68fb      	ldr	r3, [r7, #12]
34003020:	2b00      	cmp	r3, #0
34003022:	d14e      	bne.n	340030c2 <HAL_ADC_Init+0x1d2>
       )
    {
      tmpCFGR1 = (
                   ADC_CFGR1_AUTODELAY((uint32_t)hadc->Init.LowPowerAutoWait)        |
34003024:	687b      	ldr	r3, [r7, #4]
34003026:	7d1b      	ldrb	r3, [r3, #20]
34003028:	039a      	lsls	r2, r3, #14
                   ADC_CFGR1_DMACONTREQ((uint32_t)hadc->Init.ConversionDataManagement));
3400302a:	687b      	ldr	r3, [r7, #4]
3400302c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
      tmpCFGR1 = (
3400302e:	4313      	orrs	r3, r2
34003030:	61bb      	str	r3, [r7, #24]

      MODIFY_REG(hadc->Instance->CFGR1, ADC_CFGR1_FIELDS_2, tmpCFGR1);
34003032:	687b      	ldr	r3, [r7, #4]
34003034:	681b      	ldr	r3, [r3, #0]
34003036:	68db      	ldr	r3, [r3, #12]
34003038:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
3400303c:	f023 0303 	bic.w	r3, r3, #3
34003040:	687a      	ldr	r2, [r7, #4]
34003042:	6812      	ldr	r2, [r2, #0]
34003044:	69b9      	ldr	r1, [r7, #24]
34003046:	430b      	orrs	r3, r1
34003048:	60d3      	str	r3, [r2, #12]

      LL_ADC_SetGainCompensation(hadc->Instance, hadc->Init.GainCompensation);
3400304a:	687b      	ldr	r3, [r7, #4]
3400304c:	681a      	ldr	r2, [r3, #0]
3400304e:	687b      	ldr	r3, [r7, #4]
34003050:	689b      	ldr	r3, [r3, #8]
34003052:	4619      	mov	r1, r3
34003054:	4610      	mov	r0, r2
34003056:	f7ff fb57 	bl	34002708 <LL_ADC_SetGainCompensation>

      if (hadc->Init.OversamplingMode == ENABLE)
3400305a:	687b      	ldr	r3, [r7, #4]
3400305c:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
34003060:	2b01      	cmp	r3, #1
34003062:	d11b      	bne.n	3400309c <HAL_ADC_Init+0x1ac>
        assert_param(IS_ADC_OVERSAMPLING_RATIO(hadc->Init.Oversampling.Ratio));
        assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversampling.RightBitShift));
        assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
        assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));

        if ((hadc->Init.ExternalTrigConv == ADC_SOFTWARE_START)
34003064:	687b      	ldr	r3, [r7, #4]
34003066:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34003068:	2b00      	cmp	r3, #0
        /*  - Oversampling Ratio                                               */
        /*  - Right bit shift                                                  */
        /*  - Left bit shift                                                   */
        /*  - Triggered mode                                                   */
        /*  - Oversampling mode (continued/resumed)                            */
        MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_FIELDS,
3400306a:	687b      	ldr	r3, [r7, #4]
3400306c:	681b      	ldr	r3, [r3, #0]
3400306e:	691a      	ldr	r2, [r3, #16]
34003070:	4b2c      	ldr	r3, [pc, #176]	@ (34003124 <HAL_ADC_Init+0x234>)
34003072:	4013      	ands	r3, r2
34003074:	687a      	ldr	r2, [r7, #4]
34003076:	6c12      	ldr	r2, [r2, #64]	@ 0x40
34003078:	3a01      	subs	r2, #1
3400307a:	0411      	lsls	r1, r2, #16
3400307c:	687a      	ldr	r2, [r7, #4]
3400307e:	6c52      	ldr	r2, [r2, #68]	@ 0x44
34003080:	4311      	orrs	r1, r2
34003082:	687a      	ldr	r2, [r7, #4]
34003084:	6c92      	ldr	r2, [r2, #72]	@ 0x48
34003086:	4311      	orrs	r1, r2
34003088:	687a      	ldr	r2, [r7, #4]
3400308a:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
3400308c:	430a      	orrs	r2, r1
3400308e:	431a      	orrs	r2, r3
34003090:	687b      	ldr	r3, [r7, #4]
34003092:	681b      	ldr	r3, [r3, #0]
34003094:	f042 0201 	orr.w	r2, r2, #1
34003098:	611a      	str	r2, [r3, #16]
3400309a:	e007      	b.n	340030ac <HAL_ADC_Init+0x1bc>

      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
3400309c:	687b      	ldr	r3, [r7, #4]
3400309e:	681b      	ldr	r3, [r3, #0]
340030a0:	691a      	ldr	r2, [r3, #16]
340030a2:	687b      	ldr	r3, [r7, #4]
340030a4:	681b      	ldr	r3, [r3, #0]
340030a6:	f022 0201 	bic.w	r2, r2, #1
340030aa:	611a      	str	r2, [r3, #16]
      }

      /* Set the LeftShift parameter: it is applied to the final result with or without oversampling */
      MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_LSHIFT, hadc->Init.LeftBitShift);
340030ac:	687b      	ldr	r3, [r7, #4]
340030ae:	681b      	ldr	r3, [r3, #0]
340030b0:	691b      	ldr	r3, [r3, #16]
340030b2:	f023 4170 	bic.w	r1, r3, #4026531840	@ 0xf0000000
340030b6:	687b      	ldr	r3, [r7, #4]
340030b8:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
340030ba:	687b      	ldr	r3, [r7, #4]
340030bc:	681b      	ldr	r3, [r3, #0]
340030be:	430a      	orrs	r2, r1
340030c0:	611a      	str	r2, [r3, #16]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
340030c2:	687b      	ldr	r3, [r7, #4]
340030c4:	68db      	ldr	r3, [r3, #12]
340030c6:	2b01      	cmp	r3, #1
340030c8:	d10c      	bne.n	340030e4 <HAL_ADC_Init+0x1f4>
    {
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
340030ca:	687b      	ldr	r3, [r7, #4]
340030cc:	681b      	ldr	r3, [r3, #0]
340030ce:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
340030d0:	f023 010f 	bic.w	r1, r3, #15
340030d4:	687b      	ldr	r3, [r7, #4]
340030d6:	699b      	ldr	r3, [r3, #24]
340030d8:	1e5a      	subs	r2, r3, #1
340030da:	687b      	ldr	r3, [r7, #4]
340030dc:	681b      	ldr	r3, [r3, #0]
340030de:	430a      	orrs	r2, r1
340030e0:	631a      	str	r2, [r3, #48]	@ 0x30
340030e2:	e007      	b.n	340030f4 <HAL_ADC_Init+0x204>
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
340030e4:	687b      	ldr	r3, [r7, #4]
340030e6:	681b      	ldr	r3, [r3, #0]
340030e8:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
340030ea:	687b      	ldr	r3, [r7, #4]
340030ec:	681b      	ldr	r3, [r3, #0]
340030ee:	f022 020f 	bic.w	r2, r2, #15
340030f2:	631a      	str	r2, [r3, #48]	@ 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
340030f4:	687b      	ldr	r3, [r7, #4]
340030f6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340030f8:	f023 0303 	bic.w	r3, r3, #3
340030fc:	f043 0201 	orr.w	r2, r3, #1
34003100:	687b      	ldr	r3, [r7, #4]
34003102:	659a      	str	r2, [r3, #88]	@ 0x58
34003104:	e007      	b.n	34003116 <HAL_ADC_Init+0x226>
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
34003106:	687b      	ldr	r3, [r7, #4]
34003108:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400310a:	f043 0210 	orr.w	r2, r3, #16
3400310e:	687b      	ldr	r3, [r7, #4]
34003110:	659a      	str	r2, [r3, #88]	@ 0x58

    tmp_hal_status = HAL_ERROR;
34003112:	2301      	movs	r3, #1
34003114:	77fb      	strb	r3, [r7, #31]
  }

  return tmp_hal_status;
34003116:	7ffb      	ldrb	r3, [r7, #31]
}
34003118:	4618      	mov	r0, r3
3400311a:	3720      	adds	r7, #32
3400311c:	46bd      	mov	sp, r7
3400311e:	bd80      	pop	{r7, pc}
34003120:	fff0c013 	.word	0xfff0c013
34003124:	fc00f81e 	.word	0xfc00f81e

34003128 <HAL_ADC_Start_IT>:
  *          before calling HAL_ADC_Start_IT().
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef *hadc)
{
34003128:	b580      	push	{r7, lr}
3400312a:	b086      	sub	sp, #24
3400312c:	af00      	add	r7, sp, #0
3400312e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status;
#if defined(ADC_MULTIMODE_SUPPORT)
  const ADC_TypeDef *tmpADC_Master;
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
34003130:	4891      	ldr	r0, [pc, #580]	@ (34003378 <HAL_ADC_Start_IT+0x250>)
34003132:	f7ff fd6b 	bl	34002c0c <LL_ADC_GetMultimode>
34003136:	6138      	str	r0, [r7, #16]

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Perform ADC enable and conversion start if no conversion is on going */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
34003138:	687b      	ldr	r3, [r7, #4]
3400313a:	681b      	ldr	r3, [r3, #0]
3400313c:	4618      	mov	r0, r3
3400313e:	f7ff fe15 	bl	34002d6c <LL_ADC_REG_IsConversionOngoing>
34003142:	4603      	mov	r3, r0
34003144:	2b00      	cmp	r3, #0
34003146:	f040 8110 	bne.w	3400336a <HAL_ADC_Start_IT+0x242>
  {
    /* Process locked */
    __HAL_LOCK(hadc);
3400314a:	687b      	ldr	r3, [r7, #4]
3400314c:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34003150:	2b01      	cmp	r3, #1
34003152:	d101      	bne.n	34003158 <HAL_ADC_Start_IT+0x30>
34003154:	2302      	movs	r3, #2
34003156:	e10b      	b.n	34003370 <HAL_ADC_Start_IT+0x248>
34003158:	687b      	ldr	r3, [r7, #4]
3400315a:	2201      	movs	r2, #1
3400315c:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Enable the ADC peripheral */
    tmp_hal_status = ADC_Enable(hadc);
34003160:	6878      	ldr	r0, [r7, #4]
34003162:	f001 f82b 	bl	340041bc <ADC_Enable>
34003166:	4603      	mov	r3, r0
34003168:	75fb      	strb	r3, [r7, #23]

    /* Start conversion if ADC is effectively enabled */
    if (tmp_hal_status == HAL_OK)
3400316a:	7dfb      	ldrb	r3, [r7, #23]
3400316c:	2b00      	cmp	r3, #0
3400316e:	f040 80f7 	bne.w	34003360 <HAL_ADC_Start_IT+0x238>
    {
      /* Set ADC state                                                        */
      /* - Clear state bitfield related to regular group conversion results   */
      /* - Set state bitfield related to regular operation                    */
      ADC_STATE_CLR_SET(hadc->State,
34003172:	687b      	ldr	r3, [r7, #4]
34003174:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003176:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
3400317a:	f023 0301 	bic.w	r3, r3, #1
3400317e:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
34003182:	687b      	ldr	r3, [r7, #4]
34003184:	659a      	str	r2, [r3, #88]	@ 0x58

#if defined(ADC_MULTIMODE_SUPPORT)
      /* Reset HAL_ADC_STATE_MULTIMODE_SLAVE bit
        - if ADC instance is master or if multimode feature is not available
        - if multimode setting is disabled (ADC instance slave in independent mode) */
      if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
34003186:	687b      	ldr	r3, [r7, #4]
34003188:	681b      	ldr	r3, [r3, #0]
3400318a:	4a7c      	ldr	r2, [pc, #496]	@ (3400337c <HAL_ADC_Start_IT+0x254>)
3400318c:	4293      	cmp	r3, r2
3400318e:	d002      	beq.n	34003196 <HAL_ADC_Start_IT+0x6e>
34003190:	687b      	ldr	r3, [r7, #4]
34003192:	681b      	ldr	r3, [r3, #0]
34003194:	e000      	b.n	34003198 <HAL_ADC_Start_IT+0x70>
34003196:	4b7a      	ldr	r3, [pc, #488]	@ (34003380 <HAL_ADC_Start_IT+0x258>)
34003198:	687a      	ldr	r2, [r7, #4]
3400319a:	6812      	ldr	r2, [r2, #0]
3400319c:	4293      	cmp	r3, r2
3400319e:	d002      	beq.n	340031a6 <HAL_ADC_Start_IT+0x7e>
          || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
340031a0:	693b      	ldr	r3, [r7, #16]
340031a2:	2b00      	cmp	r3, #0
340031a4:	d105      	bne.n	340031b2 <HAL_ADC_Start_IT+0x8a>
         )
      {
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
340031a6:	687b      	ldr	r3, [r7, #4]
340031a8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340031aa:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
340031ae:	687b      	ldr	r3, [r7, #4]
340031b0:	659a      	str	r2, [r3, #88]	@ 0x58
      }
#endif /* ADC_MULTIMODE_SUPPORT */

      /* Set ADC error code */
      /* Check if a conversion is on going on ADC group injected */
      if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) != 0UL)
340031b2:	687b      	ldr	r3, [r7, #4]
340031b4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340031b6:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
340031ba:	2b00      	cmp	r3, #0
340031bc:	d006      	beq.n	340031cc <HAL_ADC_Start_IT+0xa4>
      {
        /* Reset ADC error code fields related to regular conversions only */
        CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
340031be:	687b      	ldr	r3, [r7, #4]
340031c0:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
340031c2:	f023 0206 	bic.w	r2, r3, #6
340031c6:	687b      	ldr	r3, [r7, #4]
340031c8:	65da      	str	r2, [r3, #92]	@ 0x5c
340031ca:	e002      	b.n	340031d2 <HAL_ADC_Start_IT+0xaa>
      }
      else
      {
        /* Reset all ADC error code fields */
        ADC_CLEAR_ERRORCODE(hadc);
340031cc:	687b      	ldr	r3, [r7, #4]
340031ce:	2200      	movs	r2, #0
340031d0:	65da      	str	r2, [r3, #92]	@ 0x5c
      }

      /* Clear ADC group regular conversion flag and overrun flag               */
      /* (To ensure of no unknown state from potential previous ADC operations) */
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
340031d2:	687b      	ldr	r3, [r7, #4]
340031d4:	681b      	ldr	r3, [r3, #0]
340031d6:	221c      	movs	r2, #28
340031d8:	601a      	str	r2, [r3, #0]

      /* Unlock before starting ADC conversions: in case of potential         */
      /* interruption, to let the process to ADC IRQ Handler.                 */
      __HAL_UNLOCK(hadc);
340031da:	687b      	ldr	r3, [r7, #4]
340031dc:	2200      	movs	r2, #0
340031de:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

      /* Disable all interruptions before enabling the desired ones */
      __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_EOS | ADC_IT_OVR));
340031e2:	687b      	ldr	r3, [r7, #4]
340031e4:	681b      	ldr	r3, [r3, #0]
340031e6:	685a      	ldr	r2, [r3, #4]
340031e8:	687b      	ldr	r3, [r7, #4]
340031ea:	681b      	ldr	r3, [r3, #0]
340031ec:	f022 021c 	bic.w	r2, r2, #28
340031f0:	605a      	str	r2, [r3, #4]

      /* Enable ADC end of conversion interrupt */
      switch (hadc->Init.EOCSelection)
340031f2:	687b      	ldr	r3, [r7, #4]
340031f4:	691b      	ldr	r3, [r3, #16]
340031f6:	2b08      	cmp	r3, #8
340031f8:	d108      	bne.n	3400320c <HAL_ADC_Start_IT+0xe4>
      {
        case ADC_EOC_SEQ_CONV:
          __HAL_ADC_ENABLE_IT(hadc, ADC_IT_EOS);
340031fa:	687b      	ldr	r3, [r7, #4]
340031fc:	681b      	ldr	r3, [r3, #0]
340031fe:	685a      	ldr	r2, [r3, #4]
34003200:	687b      	ldr	r3, [r7, #4]
34003202:	681b      	ldr	r3, [r3, #0]
34003204:	f042 0208 	orr.w	r2, r2, #8
34003208:	605a      	str	r2, [r3, #4]
          break;
3400320a:	e008      	b.n	3400321e <HAL_ADC_Start_IT+0xf6>
        /* case ADC_EOC_SINGLE_CONV */
        default:
          __HAL_ADC_ENABLE_IT(hadc, ADC_IT_EOC);
3400320c:	687b      	ldr	r3, [r7, #4]
3400320e:	681b      	ldr	r3, [r3, #0]
34003210:	685a      	ldr	r2, [r3, #4]
34003212:	687b      	ldr	r3, [r7, #4]
34003214:	681b      	ldr	r3, [r3, #0]
34003216:	f042 0204 	orr.w	r2, r2, #4
3400321a:	605a      	str	r2, [r3, #4]
          break;
3400321c:	bf00      	nop

      /* Enable ADC overrun interrupt */
      /* If hadc->Init.Overrun is set to ADC_OVR_DATA_PRESERVED, only then is
         ADC_IT_OVR enabled; otherwise data overwrite is considered as normal
         behavior and no CPU time is lost for a non-processed interruption */
      if (hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)
3400321e:	687b      	ldr	r3, [r7, #4]
34003220:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34003222:	2b00      	cmp	r3, #0
34003224:	d107      	bne.n	34003236 <HAL_ADC_Start_IT+0x10e>
      {
        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
34003226:	687b      	ldr	r3, [r7, #4]
34003228:	681b      	ldr	r3, [r3, #0]
3400322a:	685a      	ldr	r2, [r3, #4]
3400322c:	687b      	ldr	r3, [r7, #4]
3400322e:	681b      	ldr	r3, [r3, #0]
34003230:	f042 0210 	orr.w	r2, r2, #16
34003234:	605a      	str	r2, [r3, #4]
      /* Case of multimode enabled (when multimode feature is available):     */
      /*  - if ADC is slave and dual regular conversions are enabled, ADC is  */
      /*    enabled only (conversion is not started),                         */
      /*  - if ADC is master, ADC is enabled and conversion is started.       */
#if defined(ADC_MULTIMODE_SUPPORT)
      if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
34003236:	687b      	ldr	r3, [r7, #4]
34003238:	681b      	ldr	r3, [r3, #0]
3400323a:	4a50      	ldr	r2, [pc, #320]	@ (3400337c <HAL_ADC_Start_IT+0x254>)
3400323c:	4293      	cmp	r3, r2
3400323e:	d002      	beq.n	34003246 <HAL_ADC_Start_IT+0x11e>
34003240:	687b      	ldr	r3, [r7, #4]
34003242:	681b      	ldr	r3, [r3, #0]
34003244:	e000      	b.n	34003248 <HAL_ADC_Start_IT+0x120>
34003246:	4b4e      	ldr	r3, [pc, #312]	@ (34003380 <HAL_ADC_Start_IT+0x258>)
34003248:	687a      	ldr	r2, [r7, #4]
3400324a:	6812      	ldr	r2, [r2, #0]
3400324c:	4293      	cmp	r3, r2
3400324e:	d008      	beq.n	34003262 <HAL_ADC_Start_IT+0x13a>
          || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
34003250:	693b      	ldr	r3, [r7, #16]
34003252:	2b00      	cmp	r3, #0
34003254:	d005      	beq.n	34003262 <HAL_ADC_Start_IT+0x13a>
          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
34003256:	693b      	ldr	r3, [r7, #16]
34003258:	2b05      	cmp	r3, #5
3400325a:	d002      	beq.n	34003262 <HAL_ADC_Start_IT+0x13a>
          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
3400325c:	693b      	ldr	r3, [r7, #16]
3400325e:	2b09      	cmp	r3, #9
34003260:	d13a      	bne.n	340032d8 <HAL_ADC_Start_IT+0x1b0>
         )
      {
        /* ADC instance is not a multimode slave instance with multimode regular conversions enabled */
        if (READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_JAUTO) != 0UL)
34003262:	687b      	ldr	r3, [r7, #4]
34003264:	681b      	ldr	r3, [r3, #0]
34003266:	68db      	ldr	r3, [r3, #12]
34003268:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
3400326c:	2b00      	cmp	r3, #0
3400326e:	d02d      	beq.n	340032cc <HAL_ADC_Start_IT+0x1a4>
        {
          ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
34003270:	687b      	ldr	r3, [r7, #4]
34003272:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003274:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
34003278:	f443 5280 	orr.w	r2, r3, #4096	@ 0x1000
3400327c:	687b      	ldr	r3, [r7, #4]
3400327e:	659a      	str	r2, [r3, #88]	@ 0x58

          /* Enable as well injected interruptions in case
           HAL_ADCEx_InjectedStart_IT() has not been called beforehand. This
           allows to start regular and injected conversions when JAUTO is
           set with a single call to HAL_ADC_Start_IT() */
          switch (hadc->Init.EOCSelection)
34003280:	687b      	ldr	r3, [r7, #4]
34003282:	691b      	ldr	r3, [r3, #16]
34003284:	2b08      	cmp	r3, #8
34003286:	d110      	bne.n	340032aa <HAL_ADC_Start_IT+0x182>
          {
            case ADC_EOC_SEQ_CONV:
              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
34003288:	687b      	ldr	r3, [r7, #4]
3400328a:	681b      	ldr	r3, [r3, #0]
3400328c:	685a      	ldr	r2, [r3, #4]
3400328e:	687b      	ldr	r3, [r7, #4]
34003290:	681b      	ldr	r3, [r3, #0]
34003292:	f022 0220 	bic.w	r2, r2, #32
34003296:	605a      	str	r2, [r3, #4]
              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOS);
34003298:	687b      	ldr	r3, [r7, #4]
3400329a:	681b      	ldr	r3, [r3, #0]
3400329c:	685a      	ldr	r2, [r3, #4]
3400329e:	687b      	ldr	r3, [r7, #4]
340032a0:	681b      	ldr	r3, [r3, #0]
340032a2:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
340032a6:	605a      	str	r2, [r3, #4]
              break;
340032a8:	e010      	b.n	340032cc <HAL_ADC_Start_IT+0x1a4>
            /* case ADC_EOC_SINGLE_CONV */
            default:
              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOS);
340032aa:	687b      	ldr	r3, [r7, #4]
340032ac:	681b      	ldr	r3, [r3, #0]
340032ae:	685a      	ldr	r2, [r3, #4]
340032b0:	687b      	ldr	r3, [r7, #4]
340032b2:	681b      	ldr	r3, [r3, #0]
340032b4:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
340032b8:	605a      	str	r2, [r3, #4]
              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
340032ba:	687b      	ldr	r3, [r7, #4]
340032bc:	681b      	ldr	r3, [r3, #0]
340032be:	685a      	ldr	r2, [r3, #4]
340032c0:	687b      	ldr	r3, [r7, #4]
340032c2:	681b      	ldr	r3, [r3, #0]
340032c4:	f042 0220 	orr.w	r2, r2, #32
340032c8:	605a      	str	r2, [r3, #4]
              break;
340032ca:	bf00      	nop
          }
        }

        /* Start ADC group regular conversion */
        LL_ADC_REG_StartConversion(hadc->Instance);
340032cc:	687b      	ldr	r3, [r7, #4]
340032ce:	681b      	ldr	r3, [r3, #0]
340032d0:	4618      	mov	r0, r3
340032d2:	f7ff fd27 	bl	34002d24 <LL_ADC_REG_StartConversion>
340032d6:	e04a      	b.n	3400336e <HAL_ADC_Start_IT+0x246>
      }
      else
      {
        /* ADC instance is a multimode slave instance with multimode regular conversions enabled */
        SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
340032d8:	687b      	ldr	r3, [r7, #4]
340032da:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340032dc:	f443 1280 	orr.w	r2, r3, #1048576	@ 0x100000
340032e0:	687b      	ldr	r3, [r7, #4]
340032e2:	659a      	str	r2, [r3, #88]	@ 0x58
        /* if Master ADC JAUTO bit is set, Slave injected interruptions
           are enabled nevertheless (for same reason as above) */
        tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
340032e4:	687b      	ldr	r3, [r7, #4]
340032e6:	681b      	ldr	r3, [r3, #0]
340032e8:	4a24      	ldr	r2, [pc, #144]	@ (3400337c <HAL_ADC_Start_IT+0x254>)
340032ea:	4293      	cmp	r3, r2
340032ec:	d002      	beq.n	340032f4 <HAL_ADC_Start_IT+0x1cc>
340032ee:	687b      	ldr	r3, [r7, #4]
340032f0:	681b      	ldr	r3, [r3, #0]
340032f2:	e000      	b.n	340032f6 <HAL_ADC_Start_IT+0x1ce>
340032f4:	4b22      	ldr	r3, [pc, #136]	@ (34003380 <HAL_ADC_Start_IT+0x258>)
340032f6:	60fb      	str	r3, [r7, #12]
        if (READ_BIT(tmpADC_Master->CFGR1, ADC_CFGR1_JAUTO) != 0UL)
340032f8:	68fb      	ldr	r3, [r7, #12]
340032fa:	68db      	ldr	r3, [r3, #12]
340032fc:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34003300:	2b00      	cmp	r3, #0
34003302:	d034      	beq.n	3400336e <HAL_ADC_Start_IT+0x246>
        {
          /* First, update Slave State in setting HAL_ADC_STATE_INJ_BUSY bit
             and in resetting HAL_ADC_STATE_INJ_EOC bit */
          ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
34003304:	687b      	ldr	r3, [r7, #4]
34003306:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003308:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
3400330c:	f443 5280 	orr.w	r2, r3, #4096	@ 0x1000
34003310:	687b      	ldr	r3, [r7, #4]
34003312:	659a      	str	r2, [r3, #88]	@ 0x58
          /* Next, set Slave injected interruptions */
          switch (hadc->Init.EOCSelection)
34003314:	687b      	ldr	r3, [r7, #4]
34003316:	691b      	ldr	r3, [r3, #16]
34003318:	2b08      	cmp	r3, #8
3400331a:	d110      	bne.n	3400333e <HAL_ADC_Start_IT+0x216>
          {
            case ADC_EOC_SEQ_CONV:
              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
3400331c:	687b      	ldr	r3, [r7, #4]
3400331e:	681b      	ldr	r3, [r3, #0]
34003320:	685a      	ldr	r2, [r3, #4]
34003322:	687b      	ldr	r3, [r7, #4]
34003324:	681b      	ldr	r3, [r3, #0]
34003326:	f022 0220 	bic.w	r2, r2, #32
3400332a:	605a      	str	r2, [r3, #4]
              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOS);
3400332c:	687b      	ldr	r3, [r7, #4]
3400332e:	681b      	ldr	r3, [r3, #0]
34003330:	685a      	ldr	r2, [r3, #4]
34003332:	687b      	ldr	r3, [r7, #4]
34003334:	681b      	ldr	r3, [r3, #0]
34003336:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
3400333a:	605a      	str	r2, [r3, #4]
              break;
3400333c:	e017      	b.n	3400336e <HAL_ADC_Start_IT+0x246>
            /* case ADC_EOC_SINGLE_CONV */
            default:
              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOS);
3400333e:	687b      	ldr	r3, [r7, #4]
34003340:	681b      	ldr	r3, [r3, #0]
34003342:	685a      	ldr	r2, [r3, #4]
34003344:	687b      	ldr	r3, [r7, #4]
34003346:	681b      	ldr	r3, [r3, #0]
34003348:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
3400334c:	605a      	str	r2, [r3, #4]
              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
3400334e:	687b      	ldr	r3, [r7, #4]
34003350:	681b      	ldr	r3, [r3, #0]
34003352:	685a      	ldr	r2, [r3, #4]
34003354:	687b      	ldr	r3, [r7, #4]
34003356:	681b      	ldr	r3, [r3, #0]
34003358:	f042 0220 	orr.w	r2, r2, #32
3400335c:	605a      	str	r2, [r3, #4]
              break;
3400335e:	e006      	b.n	3400336e <HAL_ADC_Start_IT+0x246>
      LL_ADC_REG_StartConversion(hadc->Instance);
#endif /* ADC_MULTIMODE_SUPPORT */
    }
    else
    {
      __HAL_UNLOCK(hadc);
34003360:	687b      	ldr	r3, [r7, #4]
34003362:	2200      	movs	r2, #0
34003364:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54
34003368:	e001      	b.n	3400336e <HAL_ADC_Start_IT+0x246>
    }

  }
  else
  {
    tmp_hal_status = HAL_BUSY;
3400336a:	2302      	movs	r3, #2
3400336c:	75fb      	strb	r3, [r7, #23]
  }

  return tmp_hal_status;
3400336e:	7dfb      	ldrb	r3, [r7, #23]
}
34003370:	4618      	mov	r0, r3
34003372:	3718      	adds	r7, #24
34003374:	46bd      	mov	sp, r7
34003376:	bd80      	pop	{r7, pc}
34003378:	50022300 	.word	0x50022300
3400337c:	50022100 	.word	0x50022100
34003380:	50022000 	.word	0x50022000

34003384 <HAL_ADC_Stop_IT>:
  *         end-of-conversion, disable ADC peripheral.
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef *hadc)
{
34003384:	b580      	push	{r7, lr}
34003386:	b084      	sub	sp, #16
34003388:	af00      	add	r7, sp, #0
3400338a:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Process locked */
  __HAL_LOCK(hadc);
3400338c:	687b      	ldr	r3, [r7, #4]
3400338e:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34003392:	2b01      	cmp	r3, #1
34003394:	d101      	bne.n	3400339a <HAL_ADC_Stop_IT+0x16>
34003396:	2302      	movs	r3, #2
34003398:	e02b      	b.n	340033f2 <HAL_ADC_Stop_IT+0x6e>
3400339a:	687b      	ldr	r3, [r7, #4]
3400339c:	2201      	movs	r2, #1
3400339e:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  /* 1. Stop potential conversion on going, on ADC groups regular and injected */
  tmp_hal_status = ADC_ConversionStop(hadc, ADC_REGULAR_INJECTED_GROUP);
340033a2:	2103      	movs	r1, #3
340033a4:	6878      	ldr	r0, [r7, #4]
340033a6:	f000 fe4d 	bl	34004044 <ADC_ConversionStop>
340033aa:	4603      	mov	r3, r0
340033ac:	73fb      	strb	r3, [r7, #15]

  /* Disable ADC peripheral if conversions are effectively stopped */
  if (tmp_hal_status == HAL_OK)
340033ae:	7bfb      	ldrb	r3, [r7, #15]
340033b0:	2b00      	cmp	r3, #0
340033b2:	d119      	bne.n	340033e8 <HAL_ADC_Stop_IT+0x64>
  {
    /* Disable ADC end of conversion interrupt for regular group */
    /* Disable ADC overrun interrupt */
    __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_EOS | ADC_IT_OVR));
340033b4:	687b      	ldr	r3, [r7, #4]
340033b6:	681b      	ldr	r3, [r3, #0]
340033b8:	685a      	ldr	r2, [r3, #4]
340033ba:	687b      	ldr	r3, [r7, #4]
340033bc:	681b      	ldr	r3, [r3, #0]
340033be:	f022 021c 	bic.w	r2, r2, #28
340033c2:	605a      	str	r2, [r3, #4]

    /* 2. Disable the ADC peripheral */
    tmp_hal_status = ADC_Disable(hadc);
340033c4:	6878      	ldr	r0, [r7, #4]
340033c6:	f000 ff5b 	bl	34004280 <ADC_Disable>
340033ca:	4603      	mov	r3, r0
340033cc:	73fb      	strb	r3, [r7, #15]

    /* Check if ADC is effectively disabled */
    if (tmp_hal_status == HAL_OK)
340033ce:	7bfb      	ldrb	r3, [r7, #15]
340033d0:	2b00      	cmp	r3, #0
340033d2:	d109      	bne.n	340033e8 <HAL_ADC_Stop_IT+0x64>
    {
      /* Set ADC state */
      ADC_STATE_CLR_SET(hadc->State,
340033d4:	687b      	ldr	r3, [r7, #4]
340033d6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340033d8:	f423 5388 	bic.w	r3, r3, #4352	@ 0x1100
340033dc:	f023 0301 	bic.w	r3, r3, #1
340033e0:	f043 0201 	orr.w	r2, r3, #1
340033e4:	687b      	ldr	r3, [r7, #4]
340033e6:	659a      	str	r2, [r3, #88]	@ 0x58
                        HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
                        HAL_ADC_STATE_READY);
    }
  }

  __HAL_UNLOCK(hadc);
340033e8:	687b      	ldr	r3, [r7, #4]
340033ea:	2200      	movs	r2, #0
340033ec:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  return tmp_hal_status;
340033f0:	7bfb      	ldrb	r3, [r7, #15]
}
340033f2:	4618      	mov	r0, r3
340033f4:	3710      	adds	r7, #16
340033f6:	46bd      	mov	sp, r7
340033f8:	bd80      	pop	{r7, pc}

340033fa <HAL_ADC_GetValue>:
  *         or @ref __HAL_ADC_CLEAR_FLAG(&hadc, ADC_FLAG_EOS).
  * @param hadc ADC handle
  * @retval ADC group regular conversion data
  */
uint32_t HAL_ADC_GetValue(const ADC_HandleTypeDef *hadc)
{
340033fa:	b480      	push	{r7}
340033fc:	b083      	sub	sp, #12
340033fe:	af00      	add	r7, sp, #0
34003400:	6078      	str	r0, [r7, #4]

  /* Note: EOC flag is not cleared here by software because automatically     */
  /*       cleared by hardware when reading register DR.                      */

  /* Return ADC converted value */
  return hadc->Instance->DR;
34003402:	687b      	ldr	r3, [r7, #4]
34003404:	681b      	ldr	r3, [r3, #0]
34003406:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
}
34003408:	4618      	mov	r0, r3
3400340a:	370c      	adds	r7, #12
3400340c:	46bd      	mov	sp, r7
3400340e:	f85d 7b04 	ldr.w	r7, [sp], #4
34003412:	4770      	bx	lr

34003414 <HAL_ADC_IRQHandler>:
  * @brief  Handle ADC interrupt request.
  * @param hadc ADC handle
  * @retval None
  */
void HAL_ADC_IRQHandler(ADC_HandleTypeDef *hadc)
{
34003414:	b580      	push	{r7, lr}
34003416:	b08a      	sub	sp, #40	@ 0x28
34003418:	af00      	add	r7, sp, #0
3400341a:	6078      	str	r0, [r7, #4]
  uint32_t overrun_error = 0UL; /* flag set if overrun occurrence has to be considered as an error */
3400341c:	2300      	movs	r3, #0
3400341e:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t tmp_isr = hadc->Instance->ISR;
34003420:	687b      	ldr	r3, [r7, #4]
34003422:	681b      	ldr	r3, [r3, #0]
34003424:	681b      	ldr	r3, [r3, #0]
34003426:	61fb      	str	r3, [r7, #28]
  uint32_t tmp_ier = hadc->Instance->IER;
34003428:	687b      	ldr	r3, [r7, #4]
3400342a:	681b      	ldr	r3, [r3, #0]
3400342c:	685b      	ldr	r3, [r3, #4]
3400342e:	61bb      	str	r3, [r7, #24]
  uint32_t tmp_adc_inj_is_trigger_source_sw_start;
  uint32_t tmp_adc_reg_is_trigger_source_sw_start;
  uint32_t tmp_cfgr;
#if defined(ADC_MULTIMODE_SUPPORT)
  const ADC_TypeDef *tmpADC_Master;
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
34003430:	4882      	ldr	r0, [pc, #520]	@ (3400363c <HAL_ADC_IRQHandler+0x228>)
34003432:	f7ff fbeb 	bl	34002c0c <LL_ADC_GetMultimode>
34003436:	6178      	str	r0, [r7, #20]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));

  /* ========== Check End of Sampling flag for ADC group regular ========== */
  if (((tmp_isr & ADC_FLAG_EOSMP) == ADC_FLAG_EOSMP) && ((tmp_ier & ADC_IT_EOSMP) == ADC_IT_EOSMP))
34003438:	69fb      	ldr	r3, [r7, #28]
3400343a:	f003 0302 	and.w	r3, r3, #2
3400343e:	2b00      	cmp	r3, #0
34003440:	d017      	beq.n	34003472 <HAL_ADC_IRQHandler+0x5e>
34003442:	69bb      	ldr	r3, [r7, #24]
34003444:	f003 0302 	and.w	r3, r3, #2
34003448:	2b00      	cmp	r3, #0
3400344a:	d012      	beq.n	34003472 <HAL_ADC_IRQHandler+0x5e>
  {
    /* Update state machine on end of sampling status if not in error state */
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
3400344c:	687b      	ldr	r3, [r7, #4]
3400344e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003450:	f003 0310 	and.w	r3, r3, #16
34003454:	2b00      	cmp	r3, #0
34003456:	d105      	bne.n	34003464 <HAL_ADC_IRQHandler+0x50>
    {
      /* Set ADC state */
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOSMP);
34003458:	687b      	ldr	r3, [r7, #4]
3400345a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400345c:	f443 6200 	orr.w	r2, r3, #2048	@ 0x800
34003460:	687b      	ldr	r3, [r7, #4]
34003462:	659a      	str	r2, [r3, #88]	@ 0x58

    /* End Of Sampling callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->EndOfSamplingCallback(hadc);
#else
    HAL_ADCEx_EndOfSamplingCallback(hadc);
34003464:	6878      	ldr	r0, [r7, #4]
34003466:	f000 ffae 	bl	340043c6 <HAL_ADCEx_EndOfSamplingCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear regular group conversion flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOSMP);
3400346a:	687b      	ldr	r3, [r7, #4]
3400346c:	681b      	ldr	r3, [r3, #0]
3400346e:	2202      	movs	r2, #2
34003470:	601a      	str	r2, [r3, #0]
  }

  /* ====== Check ADC group regular end of unitary conversion sequence conversions ===== */
  if ((((tmp_isr & ADC_FLAG_EOC) == ADC_FLAG_EOC) && ((tmp_ier & ADC_IT_EOC) == ADC_IT_EOC)) ||
34003472:	69fb      	ldr	r3, [r7, #28]
34003474:	f003 0304 	and.w	r3, r3, #4
34003478:	2b00      	cmp	r3, #0
3400347a:	d004      	beq.n	34003486 <HAL_ADC_IRQHandler+0x72>
3400347c:	69bb      	ldr	r3, [r7, #24]
3400347e:	f003 0304 	and.w	r3, r3, #4
34003482:	2b00      	cmp	r3, #0
34003484:	d10a      	bne.n	3400349c <HAL_ADC_IRQHandler+0x88>
      (((tmp_isr & ADC_FLAG_EOS) == ADC_FLAG_EOS) && ((tmp_ier & ADC_IT_EOS) == ADC_IT_EOS)))
34003486:	69fb      	ldr	r3, [r7, #28]
34003488:	f003 0308 	and.w	r3, r3, #8
  if ((((tmp_isr & ADC_FLAG_EOC) == ADC_FLAG_EOC) && ((tmp_ier & ADC_IT_EOC) == ADC_IT_EOC)) ||
3400348c:	2b00      	cmp	r3, #0
3400348e:	f000 8083 	beq.w	34003598 <HAL_ADC_IRQHandler+0x184>
      (((tmp_isr & ADC_FLAG_EOS) == ADC_FLAG_EOS) && ((tmp_ier & ADC_IT_EOS) == ADC_IT_EOS)))
34003492:	69bb      	ldr	r3, [r7, #24]
34003494:	f003 0308 	and.w	r3, r3, #8
34003498:	2b00      	cmp	r3, #0
3400349a:	d07d      	beq.n	34003598 <HAL_ADC_IRQHandler+0x184>
  {
    /* Update state machine on conversion status if not in error state */
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
3400349c:	687b      	ldr	r3, [r7, #4]
3400349e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340034a0:	f003 0310 	and.w	r3, r3, #16
340034a4:	2b00      	cmp	r3, #0
340034a6:	d105      	bne.n	340034b4 <HAL_ADC_IRQHandler+0xa0>
    {
      /* Set ADC state */
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
340034a8:	687b      	ldr	r3, [r7, #4]
340034aa:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340034ac:	f443 7200 	orr.w	r2, r3, #512	@ 0x200
340034b0:	687b      	ldr	r3, [r7, #4]
340034b2:	659a      	str	r2, [r3, #88]	@ 0x58
    }

    /* Determine whether any further conversion upcoming on group regular     */
    /* by external trigger, continuous mode or scan sequence on going         */
    /* to disable interruption.                                               */
    if (LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance) != 0UL)
340034b4:	687b      	ldr	r3, [r7, #4]
340034b6:	681b      	ldr	r3, [r3, #0]
340034b8:	4618      	mov	r0, r3
340034ba:	f7ff f948 	bl	3400274e <LL_ADC_REG_IsTriggerSourceSWStart>
340034be:	4603      	mov	r3, r0
340034c0:	2b00      	cmp	r3, #0
340034c2:	d062      	beq.n	3400358a <HAL_ADC_IRQHandler+0x176>
    {
      /* Get relevant register CFGR in ADC instance of ADC master or slave    */
      /* in function of multimode state (for devices with multimode           */
      /* available).                                                          */
#if defined(ADC_MULTIMODE_SUPPORT)
      if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
340034c4:	687b      	ldr	r3, [r7, #4]
340034c6:	681b      	ldr	r3, [r3, #0]
340034c8:	4a5d      	ldr	r2, [pc, #372]	@ (34003640 <HAL_ADC_IRQHandler+0x22c>)
340034ca:	4293      	cmp	r3, r2
340034cc:	d002      	beq.n	340034d4 <HAL_ADC_IRQHandler+0xc0>
340034ce:	687b      	ldr	r3, [r7, #4]
340034d0:	681b      	ldr	r3, [r3, #0]
340034d2:	e000      	b.n	340034d6 <HAL_ADC_IRQHandler+0xc2>
340034d4:	4b5b      	ldr	r3, [pc, #364]	@ (34003644 <HAL_ADC_IRQHandler+0x230>)
340034d6:	687a      	ldr	r2, [r7, #4]
340034d8:	6812      	ldr	r2, [r2, #0]
340034da:	4293      	cmp	r3, r2
340034dc:	d008      	beq.n	340034f0 <HAL_ADC_IRQHandler+0xdc>
          || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
340034de:	697b      	ldr	r3, [r7, #20]
340034e0:	2b00      	cmp	r3, #0
340034e2:	d005      	beq.n	340034f0 <HAL_ADC_IRQHandler+0xdc>
          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
340034e4:	697b      	ldr	r3, [r7, #20]
340034e6:	2b05      	cmp	r3, #5
340034e8:	d002      	beq.n	340034f0 <HAL_ADC_IRQHandler+0xdc>
          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
340034ea:	697b      	ldr	r3, [r7, #20]
340034ec:	2b09      	cmp	r3, #9
340034ee:	d104      	bne.n	340034fa <HAL_ADC_IRQHandler+0xe6>
         )
      {
        /* check CONT bit directly in handle ADC CFGR register */
        tmp_cfgr = READ_REG(hadc->Instance->CFGR1);
340034f0:	687b      	ldr	r3, [r7, #4]
340034f2:	681b      	ldr	r3, [r3, #0]
340034f4:	68db      	ldr	r3, [r3, #12]
340034f6:	623b      	str	r3, [r7, #32]
340034f8:	e00c      	b.n	34003514 <HAL_ADC_IRQHandler+0x100>
      }
      else
      {
        /* else need to check Master ADC CONT bit */
        tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
340034fa:	687b      	ldr	r3, [r7, #4]
340034fc:	681b      	ldr	r3, [r3, #0]
340034fe:	4a50      	ldr	r2, [pc, #320]	@ (34003640 <HAL_ADC_IRQHandler+0x22c>)
34003500:	4293      	cmp	r3, r2
34003502:	d002      	beq.n	3400350a <HAL_ADC_IRQHandler+0xf6>
34003504:	687b      	ldr	r3, [r7, #4]
34003506:	681b      	ldr	r3, [r3, #0]
34003508:	e000      	b.n	3400350c <HAL_ADC_IRQHandler+0xf8>
3400350a:	4b4e      	ldr	r3, [pc, #312]	@ (34003644 <HAL_ADC_IRQHandler+0x230>)
3400350c:	613b      	str	r3, [r7, #16]
        tmp_cfgr = READ_REG(tmpADC_Master->CFGR1);
3400350e:	693b      	ldr	r3, [r7, #16]
34003510:	68db      	ldr	r3, [r3, #12]
34003512:	623b      	str	r3, [r7, #32]
#else
      tmp_cfgr = READ_REG(hadc->Instance->CFGR1);
#endif /* ADC_MULTIMODE_SUPPORT */

      /* Carry on if continuous mode is disabled */
      if (READ_BIT(tmp_cfgr, ADC_CFGR1_CONT) != ADC_CFGR1_CONT)
34003514:	6a3b      	ldr	r3, [r7, #32]
34003516:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
3400351a:	2b00      	cmp	r3, #0
3400351c:	d135      	bne.n	3400358a <HAL_ADC_IRQHandler+0x176>
      {
        /* If End of Sequence is reached, disable interrupts */
        if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS))
3400351e:	687b      	ldr	r3, [r7, #4]
34003520:	681b      	ldr	r3, [r3, #0]
34003522:	681b      	ldr	r3, [r3, #0]
34003524:	f003 0308 	and.w	r3, r3, #8
34003528:	2b08      	cmp	r3, #8
3400352a:	d12e      	bne.n	3400358a <HAL_ADC_IRQHandler+0x176>
        {
          /* Allowed to modify bits ADC_IT_EOC/ADC_IT_EOS only if bit         */
          /* ADSTART==0 (no conversion on going)                              */
          if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
3400352c:	687b      	ldr	r3, [r7, #4]
3400352e:	681b      	ldr	r3, [r3, #0]
34003530:	4618      	mov	r0, r3
34003532:	f7ff fc1b 	bl	34002d6c <LL_ADC_REG_IsConversionOngoing>
34003536:	4603      	mov	r3, r0
34003538:	2b00      	cmp	r3, #0
3400353a:	d11a      	bne.n	34003572 <HAL_ADC_IRQHandler+0x15e>
          {
            /* Disable ADC end of sequence conversion interrupt */
            /* Note: Overrun interrupt was enabled with EOC interrupt in      */
            /* HAL_Start_IT(), but is not disabled here because can be used   */
            /* by overrun IRQ process below.                                  */
            __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
3400353c:	687b      	ldr	r3, [r7, #4]
3400353e:	681b      	ldr	r3, [r3, #0]
34003540:	685a      	ldr	r2, [r3, #4]
34003542:	687b      	ldr	r3, [r7, #4]
34003544:	681b      	ldr	r3, [r3, #0]
34003546:	f022 020c 	bic.w	r2, r2, #12
3400354a:	605a      	str	r2, [r3, #4]

            /* Set ADC state */
            CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
3400354c:	687b      	ldr	r3, [r7, #4]
3400354e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003550:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
34003554:	687b      	ldr	r3, [r7, #4]
34003556:	659a      	str	r2, [r3, #88]	@ 0x58

            if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
34003558:	687b      	ldr	r3, [r7, #4]
3400355a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400355c:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
34003560:	2b00      	cmp	r3, #0
34003562:	d112      	bne.n	3400358a <HAL_ADC_IRQHandler+0x176>
            {
              SET_BIT(hadc->State, HAL_ADC_STATE_READY);
34003564:	687b      	ldr	r3, [r7, #4]
34003566:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003568:	f043 0201 	orr.w	r2, r3, #1
3400356c:	687b      	ldr	r3, [r7, #4]
3400356e:	659a      	str	r2, [r3, #88]	@ 0x58
34003570:	e00b      	b.n	3400358a <HAL_ADC_IRQHandler+0x176>
            }
          }
          else
          {
            /* Change ADC state to error state */
            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
34003572:	687b      	ldr	r3, [r7, #4]
34003574:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003576:	f043 0210 	orr.w	r2, r3, #16
3400357a:	687b      	ldr	r3, [r7, #4]
3400357c:	659a      	str	r2, [r3, #88]	@ 0x58

            /* Set ADC error code to ADC peripheral internal error */
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
3400357e:	687b      	ldr	r3, [r7, #4]
34003580:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34003582:	f043 0201 	orr.w	r2, r3, #1
34003586:	687b      	ldr	r3, [r7, #4]
34003588:	65da      	str	r2, [r3, #92]	@ 0x5c
    /*       possibility to use:                                              */
    /*        " if ( __HAL_ADC_GET_FLAG(&hadc, ADC_FLAG_EOS)) "               */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->ConvCpltCallback(hadc);
#else
    HAL_ADC_ConvCpltCallback(hadc);
3400358a:	6878      	ldr	r0, [r7, #4]
3400358c:	f00b fdac 	bl	3400f0e8 <HAL_ADC_ConvCpltCallback>
    /* Clear regular group conversion flag */
    /* Note: in case of overrun set to ADC_OVR_DATA_PRESERVED, end of         */
    /*       conversion flags clear induces the release of the preserved data.*/
    /*       Therefore, if the preserved data value is needed, it must be     */
    /*       read preliminarily into HAL_ADC_ConvCpltCallback().              */
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
34003590:	687b      	ldr	r3, [r7, #4]
34003592:	681b      	ldr	r3, [r3, #0]
34003594:	220c      	movs	r2, #12
34003596:	601a      	str	r2, [r3, #0]
  }

  /* ====== Check ADC group injected end of unitary conversion sequence conversions ===== */
  if ((((tmp_isr & ADC_FLAG_JEOC) == ADC_FLAG_JEOC) && ((tmp_ier & ADC_IT_JEOC) == ADC_IT_JEOC)) ||
34003598:	69fb      	ldr	r3, [r7, #28]
3400359a:	f003 0320 	and.w	r3, r3, #32
3400359e:	2b00      	cmp	r3, #0
340035a0:	d004      	beq.n	340035ac <HAL_ADC_IRQHandler+0x198>
340035a2:	69bb      	ldr	r3, [r7, #24]
340035a4:	f003 0320 	and.w	r3, r3, #32
340035a8:	2b00      	cmp	r3, #0
340035aa:	d10b      	bne.n	340035c4 <HAL_ADC_IRQHandler+0x1b0>
      (((tmp_isr & ADC_FLAG_JEOS) == ADC_FLAG_JEOS) && ((tmp_ier & ADC_IT_JEOS) == ADC_IT_JEOS)))
340035ac:	69fb      	ldr	r3, [r7, #28]
340035ae:	f003 0340 	and.w	r3, r3, #64	@ 0x40
  if ((((tmp_isr & ADC_FLAG_JEOC) == ADC_FLAG_JEOC) && ((tmp_ier & ADC_IT_JEOC) == ADC_IT_JEOC)) ||
340035b2:	2b00      	cmp	r3, #0
340035b4:	f000 808d 	beq.w	340036d2 <HAL_ADC_IRQHandler+0x2be>
      (((tmp_isr & ADC_FLAG_JEOS) == ADC_FLAG_JEOS) && ((tmp_ier & ADC_IT_JEOS) == ADC_IT_JEOS)))
340035b8:	69bb      	ldr	r3, [r7, #24]
340035ba:	f003 0340 	and.w	r3, r3, #64	@ 0x40
340035be:	2b00      	cmp	r3, #0
340035c0:	f000 8087 	beq.w	340036d2 <HAL_ADC_IRQHandler+0x2be>
  {
    /* Update state machine on conversion status if not in error state */
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
340035c4:	687b      	ldr	r3, [r7, #4]
340035c6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340035c8:	f003 0310 	and.w	r3, r3, #16
340035cc:	2b00      	cmp	r3, #0
340035ce:	d105      	bne.n	340035dc <HAL_ADC_IRQHandler+0x1c8>
    {
      /* Set ADC state */
      SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
340035d0:	687b      	ldr	r3, [r7, #4]
340035d2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340035d4:	f443 5200 	orr.w	r2, r3, #8192	@ 0x2000
340035d8:	687b      	ldr	r3, [r7, #4]
340035da:	659a      	str	r2, [r3, #88]	@ 0x58
    }

    /* Retrieve ADC configuration */
    tmp_adc_inj_is_trigger_source_sw_start = LL_ADC_INJ_IsTriggerSourceSWStart(hadc->Instance);
340035dc:	687b      	ldr	r3, [r7, #4]
340035de:	681b      	ldr	r3, [r3, #0]
340035e0:	4618      	mov	r0, r3
340035e2:	f7ff f909 	bl	340027f8 <LL_ADC_INJ_IsTriggerSourceSWStart>
340035e6:	60f8      	str	r0, [r7, #12]
    tmp_adc_reg_is_trigger_source_sw_start = LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance);
340035e8:	687b      	ldr	r3, [r7, #4]
340035ea:	681b      	ldr	r3, [r3, #0]
340035ec:	4618      	mov	r0, r3
340035ee:	f7ff f8ae 	bl	3400274e <LL_ADC_REG_IsTriggerSourceSWStart>
340035f2:	60b8      	str	r0, [r7, #8]
    /* Get relevant register CFGR in ADC instance of ADC master or slave  */
    /* in function of multimode state (for devices with multimode         */
    /* available).                                                        */
#if defined(ADC_MULTIMODE_SUPPORT)
    if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
340035f4:	687b      	ldr	r3, [r7, #4]
340035f6:	681b      	ldr	r3, [r3, #0]
340035f8:	4a11      	ldr	r2, [pc, #68]	@ (34003640 <HAL_ADC_IRQHandler+0x22c>)
340035fa:	4293      	cmp	r3, r2
340035fc:	d002      	beq.n	34003604 <HAL_ADC_IRQHandler+0x1f0>
340035fe:	687b      	ldr	r3, [r7, #4]
34003600:	681b      	ldr	r3, [r3, #0]
34003602:	e000      	b.n	34003606 <HAL_ADC_IRQHandler+0x1f2>
34003604:	4b0f      	ldr	r3, [pc, #60]	@ (34003644 <HAL_ADC_IRQHandler+0x230>)
34003606:	687a      	ldr	r2, [r7, #4]
34003608:	6812      	ldr	r2, [r2, #0]
3400360a:	4293      	cmp	r3, r2
3400360c:	d008      	beq.n	34003620 <HAL_ADC_IRQHandler+0x20c>
        || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
3400360e:	697b      	ldr	r3, [r7, #20]
34003610:	2b00      	cmp	r3, #0
34003612:	d005      	beq.n	34003620 <HAL_ADC_IRQHandler+0x20c>
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_SIMULT)
34003614:	697b      	ldr	r3, [r7, #20]
34003616:	2b06      	cmp	r3, #6
34003618:	d002      	beq.n	34003620 <HAL_ADC_IRQHandler+0x20c>
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_INTERL)
3400361a:	697b      	ldr	r3, [r7, #20]
3400361c:	2b07      	cmp	r3, #7
3400361e:	d104      	bne.n	3400362a <HAL_ADC_IRQHandler+0x216>
       )
    {
      tmp_cfgr = READ_REG(hadc->Instance->CFGR1);
34003620:	687b      	ldr	r3, [r7, #4]
34003622:	681b      	ldr	r3, [r3, #0]
34003624:	68db      	ldr	r3, [r3, #12]
34003626:	623b      	str	r3, [r7, #32]
34003628:	e013      	b.n	34003652 <HAL_ADC_IRQHandler+0x23e>
    }
    else
    {
      tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
3400362a:	687b      	ldr	r3, [r7, #4]
3400362c:	681b      	ldr	r3, [r3, #0]
3400362e:	4a04      	ldr	r2, [pc, #16]	@ (34003640 <HAL_ADC_IRQHandler+0x22c>)
34003630:	4293      	cmp	r3, r2
34003632:	d009      	beq.n	34003648 <HAL_ADC_IRQHandler+0x234>
34003634:	687b      	ldr	r3, [r7, #4]
34003636:	681b      	ldr	r3, [r3, #0]
34003638:	e007      	b.n	3400364a <HAL_ADC_IRQHandler+0x236>
3400363a:	bf00      	nop
3400363c:	50022300 	.word	0x50022300
34003640:	50022100 	.word	0x50022100
34003644:	50022000 	.word	0x50022000
34003648:	4b66      	ldr	r3, [pc, #408]	@ (340037e4 <HAL_ADC_IRQHandler+0x3d0>)
3400364a:	613b      	str	r3, [r7, #16]
      tmp_cfgr = READ_REG(tmpADC_Master->CFGR1);
3400364c:	693b      	ldr	r3, [r7, #16]
3400364e:	68db      	ldr	r3, [r3, #12]
34003650:	623b      	str	r3, [r7, #32]
    /* Disable interruption if no further conversion upcoming by injected     */
    /* external trigger or by automatic injected conversion with regular      */
    /* group having no further conversion upcoming (same conditions as        */
    /* regular group interruption disabling above),                           */
    /* and if injected scan sequence is completed.                            */
    if (tmp_adc_inj_is_trigger_source_sw_start != 0UL)
34003652:	68fb      	ldr	r3, [r7, #12]
34003654:	2b00      	cmp	r3, #0
34003656:	d035      	beq.n	340036c4 <HAL_ADC_IRQHandler+0x2b0>
    {
      if (((READ_BIT(tmp_cfgr, ADC_CFGR1_JAUTO) == 0UL) ||
34003658:	6a3b      	ldr	r3, [r7, #32]
3400365a:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
3400365e:	2b00      	cmp	r3, #0
34003660:	d007      	beq.n	34003672 <HAL_ADC_IRQHandler+0x25e>
34003662:	68bb      	ldr	r3, [r7, #8]
34003664:	2b00      	cmp	r3, #0
34003666:	d02d      	beq.n	340036c4 <HAL_ADC_IRQHandler+0x2b0>
           ((tmp_adc_reg_is_trigger_source_sw_start != 0UL)  &&
            (READ_BIT(tmp_cfgr, ADC_CFGR1_CONT) == 0UL))))
34003668:	6a3b      	ldr	r3, [r7, #32]
3400366a:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
           ((tmp_adc_reg_is_trigger_source_sw_start != 0UL)  &&
3400366e:	2b00      	cmp	r3, #0
34003670:	d128      	bne.n	340036c4 <HAL_ADC_IRQHandler+0x2b0>
      {
        /* If End of Sequence is reached, disable interrupts */
        if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS))
34003672:	687b      	ldr	r3, [r7, #4]
34003674:	681b      	ldr	r3, [r3, #0]
34003676:	681b      	ldr	r3, [r3, #0]
34003678:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400367c:	2b40      	cmp	r3, #64	@ 0x40
3400367e:	d121      	bne.n	340036c4 <HAL_ADC_IRQHandler+0x2b0>
        {
          if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) == 0UL)
34003680:	687b      	ldr	r3, [r7, #4]
34003682:	681b      	ldr	r3, [r3, #0]
34003684:	4618      	mov	r0, r3
34003686:	f7ff fb96 	bl	34002db6 <LL_ADC_INJ_IsConversionOngoing>
3400368a:	4603      	mov	r3, r0
3400368c:	2b00      	cmp	r3, #0
3400368e:	d119      	bne.n	340036c4 <HAL_ADC_IRQHandler+0x2b0>
          {
            /* Disable ADC end of sequence conversion interrupt  */
            __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC | ADC_IT_JEOS);
34003690:	687b      	ldr	r3, [r7, #4]
34003692:	681b      	ldr	r3, [r3, #0]
34003694:	685a      	ldr	r2, [r3, #4]
34003696:	687b      	ldr	r3, [r7, #4]
34003698:	681b      	ldr	r3, [r3, #0]
3400369a:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
3400369e:	605a      	str	r2, [r3, #4]

            /* Set ADC state */
            CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
340036a0:	687b      	ldr	r3, [r7, #4]
340036a2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340036a4:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
340036a8:	687b      	ldr	r3, [r7, #4]
340036aa:	659a      	str	r2, [r3, #88]	@ 0x58

            if ((hadc->State & HAL_ADC_STATE_REG_BUSY) == 0UL)
340036ac:	687b      	ldr	r3, [r7, #4]
340036ae:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340036b0:	f403 7380 	and.w	r3, r3, #256	@ 0x100
340036b4:	2b00      	cmp	r3, #0
340036b6:	d105      	bne.n	340036c4 <HAL_ADC_IRQHandler+0x2b0>
            {
              SET_BIT(hadc->State, HAL_ADC_STATE_READY);
340036b8:	687b      	ldr	r3, [r7, #4]
340036ba:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340036bc:	f043 0201 	orr.w	r2, r3, #1
340036c0:	687b      	ldr	r3, [r7, #4]
340036c2:	659a      	str	r2, [r3, #88]	@ 0x58
              interruption has been triggered by end of conversion or end of
              sequence.    */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->InjectedConvCpltCallback(hadc);
#else
    HAL_ADCEx_InjectedConvCpltCallback(hadc);
340036c4:	6878      	ldr	r0, [r7, #4]
340036c6:	f000 fe60 	bl	3400438a <HAL_ADCEx_InjectedConvCpltCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear injected group conversion flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC | ADC_FLAG_JEOS);
340036ca:	687b      	ldr	r3, [r7, #4]
340036cc:	681b      	ldr	r3, [r3, #0]
340036ce:	2260      	movs	r2, #96	@ 0x60
340036d0:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check Analog watchdog 1 flag ========== */
  if (((tmp_isr & ADC_FLAG_AWD1) == ADC_FLAG_AWD1) && ((tmp_ier & ADC_IT_AWD1) == ADC_IT_AWD1))
340036d2:	69fb      	ldr	r3, [r7, #28]
340036d4:	f003 0380 	and.w	r3, r3, #128	@ 0x80
340036d8:	2b00      	cmp	r3, #0
340036da:	d011      	beq.n	34003700 <HAL_ADC_IRQHandler+0x2ec>
340036dc:	69bb      	ldr	r3, [r7, #24]
340036de:	f003 0380 	and.w	r3, r3, #128	@ 0x80
340036e2:	2b00      	cmp	r3, #0
340036e4:	d00c      	beq.n	34003700 <HAL_ADC_IRQHandler+0x2ec>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
340036e6:	687b      	ldr	r3, [r7, #4]
340036e8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340036ea:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
340036ee:	687b      	ldr	r3, [r7, #4]
340036f0:	659a      	str	r2, [r3, #88]	@ 0x58

    /* Level out of window 1 callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->LevelOutOfWindowCallback(hadc);
#else
    HAL_ADC_LevelOutOfWindowCallback(hadc);
340036f2:	6878      	ldr	r0, [r7, #4]
340036f4:	f000 f87a 	bl	340037ec <HAL_ADC_LevelOutOfWindowCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear ADC analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD1);
340036f8:	687b      	ldr	r3, [r7, #4]
340036fa:	681b      	ldr	r3, [r3, #0]
340036fc:	2280      	movs	r2, #128	@ 0x80
340036fe:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check analog watchdog 2 flag ========== */
  if (((tmp_isr & ADC_FLAG_AWD2) == ADC_FLAG_AWD2) && ((tmp_ier & ADC_IT_AWD2) == ADC_IT_AWD2))
34003700:	69fb      	ldr	r3, [r7, #28]
34003702:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34003706:	2b00      	cmp	r3, #0
34003708:	d012      	beq.n	34003730 <HAL_ADC_IRQHandler+0x31c>
3400370a:	69bb      	ldr	r3, [r7, #24]
3400370c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
34003710:	2b00      	cmp	r3, #0
34003712:	d00d      	beq.n	34003730 <HAL_ADC_IRQHandler+0x31c>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD2);
34003714:	687b      	ldr	r3, [r7, #4]
34003716:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003718:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
3400371c:	687b      	ldr	r3, [r7, #4]
3400371e:	659a      	str	r2, [r3, #88]	@ 0x58

    /* Level out of window 2 callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->LevelOutOfWindow2Callback(hadc);
#else
    HAL_ADCEx_LevelOutOfWindow2Callback(hadc);
34003720:	6878      	ldr	r0, [r7, #4]
34003722:	f000 fe3c 	bl	3400439e <HAL_ADCEx_LevelOutOfWindow2Callback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear ADC analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD2);
34003726:	687b      	ldr	r3, [r7, #4]
34003728:	681b      	ldr	r3, [r3, #0]
3400372a:	f44f 7280 	mov.w	r2, #256	@ 0x100
3400372e:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check analog watchdog 3 flag ========== */
  if (((tmp_isr & ADC_FLAG_AWD3) == ADC_FLAG_AWD3) && ((tmp_ier & ADC_IT_AWD3) == ADC_IT_AWD3))
34003730:	69fb      	ldr	r3, [r7, #28]
34003732:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34003736:	2b00      	cmp	r3, #0
34003738:	d012      	beq.n	34003760 <HAL_ADC_IRQHandler+0x34c>
3400373a:	69bb      	ldr	r3, [r7, #24]
3400373c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
34003740:	2b00      	cmp	r3, #0
34003742:	d00d      	beq.n	34003760 <HAL_ADC_IRQHandler+0x34c>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD3);
34003744:	687b      	ldr	r3, [r7, #4]
34003746:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003748:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
3400374c:	687b      	ldr	r3, [r7, #4]
3400374e:	659a      	str	r2, [r3, #88]	@ 0x58

    /* Level out of window 3 callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->LevelOutOfWindow3Callback(hadc);
#else
    HAL_ADCEx_LevelOutOfWindow3Callback(hadc);
34003750:	6878      	ldr	r0, [r7, #4]
34003752:	f000 fe2e 	bl	340043b2 <HAL_ADCEx_LevelOutOfWindow3Callback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear ADC analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD3);
34003756:	687b      	ldr	r3, [r7, #4]
34003758:	681b      	ldr	r3, [r3, #0]
3400375a:	f44f 7200 	mov.w	r2, #512	@ 0x200
3400375e:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check Overrun flag ========== */
  if (((tmp_isr & ADC_FLAG_OVR) == ADC_FLAG_OVR) && ((tmp_ier & ADC_IT_OVR) == ADC_IT_OVR))
34003760:	69fb      	ldr	r3, [r7, #28]
34003762:	f003 0310 	and.w	r3, r3, #16
34003766:	2b00      	cmp	r3, #0
34003768:	d038      	beq.n	340037dc <HAL_ADC_IRQHandler+0x3c8>
3400376a:	69bb      	ldr	r3, [r7, #24]
3400376c:	f003 0310 	and.w	r3, r3, #16
34003770:	2b00      	cmp	r3, #0
34003772:	d033      	beq.n	340037dc <HAL_ADC_IRQHandler+0x3c8>
    /* overrun event is not considered as an error.                           */
    /* (cf ref manual "Managing conversions without using the DMA and without */
    /* overrun ")                                                             */
    /* Exception for usage with DMA overrun event always considered as an     */
    /* error.                                                                 */
    if (hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)
34003774:	687b      	ldr	r3, [r7, #4]
34003776:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34003778:	2b00      	cmp	r3, #0
3400377a:	d102      	bne.n	34003782 <HAL_ADC_IRQHandler+0x36e>
    {
      overrun_error = 1UL;
3400377c:	2301      	movs	r3, #1
3400377e:	627b      	str	r3, [r7, #36]	@ 0x24
34003780:	e016      	b.n	340037b0 <HAL_ADC_IRQHandler+0x39c>
    }
    else
    {
      /* Check DMA configuration */
#if defined(ADC_MULTIMODE_SUPPORT)
      if (tmp_multimode_config != LL_ADC_MULTI_INDEPENDENT)
34003782:	697b      	ldr	r3, [r7, #20]
34003784:	2b00      	cmp	r3, #0
34003786:	d00a      	beq.n	3400379e <HAL_ADC_IRQHandler+0x38a>
      {
        overrun_error = 1UL;
34003788:	2301      	movs	r3, #1
3400378a:	627b      	str	r3, [r7, #36]	@ 0x24

        /* Multimode (when feature is available) is enabled,
           Common Control Register MDMA bits must be checked. */
        if (LL_ADC_GetMultiDataFormat(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) != LL_ADC_MULTI_REG_DATA_EACH_ADC)
3400378c:	4816      	ldr	r0, [pc, #88]	@ (340037e8 <HAL_ADC_IRQHandler+0x3d4>)
3400378e:	f7ff fa4b 	bl	34002c28 <LL_ADC_GetMultiDataFormat>
34003792:	4603      	mov	r3, r0
34003794:	2b00      	cmp	r3, #0
34003796:	d00b      	beq.n	340037b0 <HAL_ADC_IRQHandler+0x39c>
        {
          overrun_error = 1UL;
34003798:	2301      	movs	r3, #1
3400379a:	627b      	str	r3, [r7, #36]	@ 0x24
3400379c:	e008      	b.n	340037b0 <HAL_ADC_IRQHandler+0x39c>
      }
      else
#endif /* ADC_MULTIMODE_SUPPORT */
      {
        /* Multimode not set or feature not available or ADC independent */
        if ((hadc->Instance->CFGR1 & ADC_CFGR1_DMNGT) != 0UL)
3400379e:	687b      	ldr	r3, [r7, #4]
340037a0:	681b      	ldr	r3, [r3, #0]
340037a2:	68db      	ldr	r3, [r3, #12]
340037a4:	f003 0303 	and.w	r3, r3, #3
340037a8:	2b00      	cmp	r3, #0
340037aa:	d001      	beq.n	340037b0 <HAL_ADC_IRQHandler+0x39c>
        {
          overrun_error = 1UL;
340037ac:	2301      	movs	r3, #1
340037ae:	627b      	str	r3, [r7, #36]	@ 0x24
        }
      }
    }

    if (overrun_error == 1UL)
340037b0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
340037b2:	2b01      	cmp	r3, #1
340037b4:	d10e      	bne.n	340037d4 <HAL_ADC_IRQHandler+0x3c0>
    {
      /* Change ADC state to error state */
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);
340037b6:	687b      	ldr	r3, [r7, #4]
340037b8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340037ba:	f443 6280 	orr.w	r2, r3, #1024	@ 0x400
340037be:	687b      	ldr	r3, [r7, #4]
340037c0:	659a      	str	r2, [r3, #88]	@ 0x58

      /* Set ADC error code to overrun */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
340037c2:	687b      	ldr	r3, [r7, #4]
340037c4:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
340037c6:	f043 0202 	orr.w	r2, r3, #2
340037ca:	687b      	ldr	r3, [r7, #4]
340037cc:	65da      	str	r2, [r3, #92]	@ 0x5c
      /*       Therefore, old ADC conversion data can be retrieved in         */
      /*       function "HAL_ADC_ErrorCallback()".                            */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
      hadc->ErrorCallback(hadc);
#else
      HAL_ADC_ErrorCallback(hadc);
340037ce:	6878      	ldr	r0, [r7, #4]
340037d0:	f000 f816 	bl	34003800 <HAL_ADC_ErrorCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
    }

    /* Clear ADC overrun flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
340037d4:	687b      	ldr	r3, [r7, #4]
340037d6:	681b      	ldr	r3, [r3, #0]
340037d8:	2210      	movs	r2, #16
340037da:	601a      	str	r2, [r3, #0]
  }

}
340037dc:	bf00      	nop
340037de:	3728      	adds	r7, #40	@ 0x28
340037e0:	46bd      	mov	sp, r7
340037e2:	bd80      	pop	{r7, pc}
340037e4:	50022000 	.word	0x50022000
340037e8:	50022300 	.word	0x50022300

340037ec <HAL_ADC_LevelOutOfWindowCallback>:
  * @brief  Analog watchdog 1 callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef *hadc)
{
340037ec:	b480      	push	{r7}
340037ee:	b083      	sub	sp, #12
340037f0:	af00      	add	r7, sp, #0
340037f2:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_LevelOutOfWindowCallback must be implemented in the user file.
  */
}
340037f4:	bf00      	nop
340037f6:	370c      	adds	r7, #12
340037f8:	46bd      	mov	sp, r7
340037fa:	f85d 7b04 	ldr.w	r7, [sp], #4
340037fe:	4770      	bx	lr

34003800 <HAL_ADC_ErrorCallback>:
  *           (this function is also clearing overrun flag)
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
{
34003800:	b480      	push	{r7}
34003802:	b083      	sub	sp, #12
34003804:	af00      	add	r7, sp, #0
34003806:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_ErrorCallback must be implemented in the user file.
  */
}
34003808:	bf00      	nop
3400380a:	370c      	adds	r7, #12
3400380c:	46bd      	mov	sp, r7
3400380e:	f85d 7b04 	ldr.w	r7, [sp], #4
34003812:	4770      	bx	lr

34003814 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param pConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, const ADC_ChannelConfTypeDef *pConfig)
{
34003814:	b590      	push	{r4, r7, lr}
34003816:	b089      	sub	sp, #36	@ 0x24
34003818:	af00      	add	r7, sp, #0
3400381a:	6078      	str	r0, [r7, #4]
3400381c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
3400381e:	2300      	movs	r3, #0
34003820:	77fb      	strb	r3, [r7, #31]
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, pConfig->Channel));
  }

  /* ADC must be disabled to set configuration bits                           */
  if (LL_ADC_IsEnabled(hadc->Instance) != 0UL)
34003822:	687b      	ldr	r3, [r7, #4]
34003824:	681b      	ldr	r3, [r3, #0]
34003826:	4618      	mov	r0, r3
34003828:	f7ff fa56 	bl	34002cd8 <LL_ADC_IsEnabled>
3400382c:	4603      	mov	r3, r0
3400382e:	2b00      	cmp	r3, #0
34003830:	d001      	beq.n	34003836 <HAL_ADC_ConfigChannel+0x22>
  {
    return HAL_ERROR;
34003832:	2301      	movs	r3, #1
34003834:	e1db      	b.n	34003bee <HAL_ADC_ConfigChannel+0x3da>
  }

  /* Process locked */
  __HAL_LOCK(hadc);
34003836:	687b      	ldr	r3, [r7, #4]
34003838:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
3400383c:	2b01      	cmp	r3, #1
3400383e:	d101      	bne.n	34003844 <HAL_ADC_ConfigChannel+0x30>
34003840:	2302      	movs	r3, #2
34003842:	e1d4      	b.n	34003bee <HAL_ADC_ConfigChannel+0x3da>
34003844:	687b      	ldr	r3, [r7, #4]
34003846:	2201      	movs	r2, #1
34003848:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
3400384c:	687b      	ldr	r3, [r7, #4]
3400384e:	681b      	ldr	r3, [r3, #0]
34003850:	4618      	mov	r0, r3
34003852:	f7ff fa8b 	bl	34002d6c <LL_ADC_REG_IsConversionOngoing>
34003856:	4603      	mov	r3, r0
34003858:	2b00      	cmp	r3, #0
3400385a:	f040 81bb 	bne.w	34003bd4 <HAL_ADC_ConfigChannel+0x3c0>
  {
    /* ADC channels preselection */
    LL_ADC_SetChannelPreselection(hadc->Instance, pConfig->Channel);
3400385e:	687b      	ldr	r3, [r7, #4]
34003860:	681a      	ldr	r2, [r3, #0]
34003862:	683b      	ldr	r3, [r7, #0]
34003864:	681b      	ldr	r3, [r3, #0]
34003866:	4619      	mov	r1, r3
34003868:	4610      	mov	r0, r2
3400386a:	f7fe ffae 	bl	340027ca <LL_ADC_SetChannelPreselection>

    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, pConfig->Rank, pConfig->Channel);
3400386e:	687b      	ldr	r3, [r7, #4]
34003870:	6818      	ldr	r0, [r3, #0]
34003872:	683b      	ldr	r3, [r7, #0]
34003874:	6859      	ldr	r1, [r3, #4]
34003876:	683b      	ldr	r3, [r7, #0]
34003878:	681b      	ldr	r3, [r3, #0]
3400387a:	461a      	mov	r2, r3
3400387c:	f7fe ff7a 	bl	34002774 <LL_ADC_REG_SetSequencerRanks>
    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated when ADC is disabled or enabled without   */
    /* conversion on going on regular group:                                    */
    /*  - Channel sampling time                                                 */
    /*  - Channel offset                                                        */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
34003880:	687b      	ldr	r3, [r7, #4]
34003882:	681b      	ldr	r3, [r3, #0]
34003884:	4618      	mov	r0, r3
34003886:	f7ff fa71 	bl	34002d6c <LL_ADC_REG_IsConversionOngoing>
3400388a:	61b8      	str	r0, [r7, #24]
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
3400388c:	687b      	ldr	r3, [r7, #4]
3400388e:	681b      	ldr	r3, [r3, #0]
34003890:	4618      	mov	r0, r3
34003892:	f7ff fa90 	bl	34002db6 <LL_ADC_INJ_IsConversionOngoing>
34003896:	6178      	str	r0, [r7, #20]
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
34003898:	69bb      	ldr	r3, [r7, #24]
3400389a:	2b00      	cmp	r3, #0
3400389c:	f040 80aa 	bne.w	340039f4 <HAL_ADC_ConfigChannel+0x1e0>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
340038a0:	697b      	ldr	r3, [r7, #20]
340038a2:	2b00      	cmp	r3, #0
340038a4:	f040 80a6 	bne.w	340039f4 <HAL_ADC_ConfigChannel+0x1e0>
       )
    {
      /* Set sampling time of the selected ADC channel */
      LL_ADC_SetChannelSamplingTime(hadc->Instance, pConfig->Channel, pConfig->SamplingTime);
340038a8:	687b      	ldr	r3, [r7, #4]
340038aa:	6818      	ldr	r0, [r3, #0]
340038ac:	683b      	ldr	r3, [r7, #0]
340038ae:	6819      	ldr	r1, [r3, #0]
340038b0:	683b      	ldr	r3, [r7, #0]
340038b2:	689b      	ldr	r3, [r3, #8]
340038b4:	461a      	mov	r2, r3
340038b6:	f7fe ffb3 	bl	34002820 <LL_ADC_SetChannelSamplingTime>

      /* Configure the offset: offset enable/disable, channel, offset value */

      /* Shift the offset with respect to the selected ADC resolution. */
      /* Offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0 */
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)pConfig->Offset);
340038ba:	683b      	ldr	r3, [r7, #0]
340038bc:	695a      	ldr	r2, [r3, #20]
340038be:	687b      	ldr	r3, [r7, #4]
340038c0:	681b      	ldr	r3, [r3, #0]
340038c2:	68db      	ldr	r3, [r3, #12]
340038c4:	089b      	lsrs	r3, r3, #2
340038c6:	f003 0303 	and.w	r3, r3, #3
340038ca:	005b      	lsls	r3, r3, #1
340038cc:	fa02 f303 	lsl.w	r3, r2, r3
340038d0:	613b      	str	r3, [r7, #16]

      if (pConfig->OffsetNumber != ADC_OFFSET_NONE)
340038d2:	683b      	ldr	r3, [r7, #0]
340038d4:	691b      	ldr	r3, [r3, #16]
340038d6:	2b04      	cmp	r3, #4
340038d8:	d038      	beq.n	3400394c <HAL_ADC_ConfigChannel+0x138>
      {
        /* Set ADC selected offset number */
        LL_ADC_SetOffsetChannel(hadc->Instance, pConfig->OffsetNumber, pConfig->Channel);
340038da:	687b      	ldr	r3, [r7, #4]
340038dc:	6818      	ldr	r0, [r3, #0]
340038de:	683b      	ldr	r3, [r7, #0]
340038e0:	6919      	ldr	r1, [r3, #16]
340038e2:	683b      	ldr	r3, [r7, #0]
340038e4:	681b      	ldr	r3, [r3, #0]
340038e6:	461a      	mov	r2, r3
340038e8:	f7fe fe6f 	bl	340025ca <LL_ADC_SetOffsetChannel>
        LL_ADC_SetOffsetLevel(hadc->Instance, pConfig->OffsetNumber, tmpOffsetShifted);
340038ec:	687b      	ldr	r3, [r7, #4]
340038ee:	6818      	ldr	r0, [r3, #0]
340038f0:	683b      	ldr	r3, [r7, #0]
340038f2:	691b      	ldr	r3, [r3, #16]
340038f4:	693a      	ldr	r2, [r7, #16]
340038f6:	4619      	mov	r1, r3
340038f8:	f7fe fe9a 	bl	34002630 <LL_ADC_SetOffsetLevel>
        /* Signed and unsigned saturation cannot be set at the same time */
        assert_param(!((pConfig->OffsetSignedSaturation == ENABLE) && (pConfig->OffsetSaturation == ENABLE)));


        /* Set ADC offset sign */
        LL_ADC_SetOffsetSign(hadc->Instance, pConfig->OffsetNumber, pConfig->OffsetSign);
340038fc:	687b      	ldr	r3, [r7, #4]
340038fe:	6818      	ldr	r0, [r3, #0]
34003900:	683b      	ldr	r3, [r7, #0]
34003902:	6919      	ldr	r1, [r3, #16]
34003904:	683b      	ldr	r3, [r7, #0]
34003906:	69db      	ldr	r3, [r3, #28]
34003908:	461a      	mov	r2, r3
3400390a:	f7fe feac 	bl	34002666 <LL_ADC_SetOffsetSign>
        /* Set ADC offset signed saturation */
        LL_ADC_SetOffsetSignedSaturation(hadc->Instance, pConfig->OffsetNumber,      \
3400390e:	687b      	ldr	r3, [r7, #4]
34003910:	6818      	ldr	r0, [r3, #0]
34003912:	683b      	ldr	r3, [r7, #0]
34003914:	6919      	ldr	r1, [r3, #16]
                                         (pConfig->OffsetSignedSaturation == ENABLE) \
34003916:	683b      	ldr	r3, [r7, #0]
34003918:	7e1b      	ldrb	r3, [r3, #24]
        LL_ADC_SetOffsetSignedSaturation(hadc->Instance, pConfig->OffsetNumber,      \
3400391a:	2b01      	cmp	r3, #1
3400391c:	d102      	bne.n	34003924 <HAL_ADC_ConfigChannel+0x110>
3400391e:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
34003922:	e000      	b.n	34003926 <HAL_ADC_ConfigChannel+0x112>
34003924:	2300      	movs	r3, #0
34003926:	461a      	mov	r2, r3
34003928:	f7fe feb8 	bl	3400269c <LL_ADC_SetOffsetSignedSaturation>
                                         ? LL_ADC_OFFSET_SIGNED_SAT_ENABLE           \
                                         : LL_ADC_OFFSET_SIGNED_SAT_DISABLE);
        /* Set ADC offset unsigned saturation */
        LL_ADC_SetOffsetUnsignedSaturation(hadc->Instance, pConfig->OffsetNumber,    \
3400392c:	687b      	ldr	r3, [r7, #4]
3400392e:	6818      	ldr	r0, [r3, #0]
34003930:	683b      	ldr	r3, [r7, #0]
34003932:	6919      	ldr	r1, [r3, #16]
                                           (pConfig->OffsetSaturation == ENABLE)     \
34003934:	683b      	ldr	r3, [r7, #0]
34003936:	7e5b      	ldrb	r3, [r3, #25]
        LL_ADC_SetOffsetUnsignedSaturation(hadc->Instance, pConfig->OffsetNumber,    \
34003938:	2b01      	cmp	r3, #1
3400393a:	d102      	bne.n	34003942 <HAL_ADC_ConfigChannel+0x12e>
3400393c:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34003940:	e000      	b.n	34003944 <HAL_ADC_ConfigChannel+0x130>
34003942:	2300      	movs	r3, #0
34003944:	461a      	mov	r2, r3
34003946:	f7fe fec4 	bl	340026d2 <LL_ADC_SetOffsetUnsignedSaturation>
3400394a:	e053      	b.n	340039f4 <HAL_ADC_ConfigChannel+0x1e0>
      }
      else
      {
        /* Scan each offset register to check if the selected channel is targeted.
           If this is the case, the corresponding offset number is disabled.       */
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
3400394c:	687b      	ldr	r3, [r7, #4]
3400394e:	681b      	ldr	r3, [r3, #0]
34003950:	2100      	movs	r1, #0
34003952:	4618      	mov	r0, r3
34003954:	f7fe fe55 	bl	34002602 <LL_ADC_GetOffsetChannel>
34003958:	4602      	mov	r2, r0
            == __HAL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
3400395a:	683b      	ldr	r3, [r7, #0]
3400395c:	681b      	ldr	r3, [r3, #0]
3400395e:	4053      	eors	r3, r2
34003960:	f003 031f 	and.w	r3, r3, #31
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
34003964:	2b00      	cmp	r3, #0
34003966:	d106      	bne.n	34003976 <HAL_ADC_ConfigChannel+0x162>
        {
          LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_1, 0UL);
34003968:	687b      	ldr	r3, [r7, #4]
3400396a:	681b      	ldr	r3, [r3, #0]
3400396c:	2200      	movs	r2, #0
3400396e:	2100      	movs	r1, #0
34003970:	4618      	mov	r0, r3
34003972:	f7fe fe5d 	bl	34002630 <LL_ADC_SetOffsetLevel>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
34003976:	687b      	ldr	r3, [r7, #4]
34003978:	681b      	ldr	r3, [r3, #0]
3400397a:	2101      	movs	r1, #1
3400397c:	4618      	mov	r0, r3
3400397e:	f7fe fe40 	bl	34002602 <LL_ADC_GetOffsetChannel>
34003982:	4602      	mov	r2, r0
            == __HAL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
34003984:	683b      	ldr	r3, [r7, #0]
34003986:	681b      	ldr	r3, [r3, #0]
34003988:	4053      	eors	r3, r2
3400398a:	f003 031f 	and.w	r3, r3, #31
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
3400398e:	2b00      	cmp	r3, #0
34003990:	d106      	bne.n	340039a0 <HAL_ADC_ConfigChannel+0x18c>
        {
          LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_2, 0UL);
34003992:	687b      	ldr	r3, [r7, #4]
34003994:	681b      	ldr	r3, [r3, #0]
34003996:	2200      	movs	r2, #0
34003998:	2101      	movs	r1, #1
3400399a:	4618      	mov	r0, r3
3400399c:	f7fe fe48 	bl	34002630 <LL_ADC_SetOffsetLevel>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
340039a0:	687b      	ldr	r3, [r7, #4]
340039a2:	681b      	ldr	r3, [r3, #0]
340039a4:	2102      	movs	r1, #2
340039a6:	4618      	mov	r0, r3
340039a8:	f7fe fe2b 	bl	34002602 <LL_ADC_GetOffsetChannel>
340039ac:	4602      	mov	r2, r0
            == __HAL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
340039ae:	683b      	ldr	r3, [r7, #0]
340039b0:	681b      	ldr	r3, [r3, #0]
340039b2:	4053      	eors	r3, r2
340039b4:	f003 031f 	and.w	r3, r3, #31
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
340039b8:	2b00      	cmp	r3, #0
340039ba:	d106      	bne.n	340039ca <HAL_ADC_ConfigChannel+0x1b6>
        {
          LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_3, 0UL);
340039bc:	687b      	ldr	r3, [r7, #4]
340039be:	681b      	ldr	r3, [r3, #0]
340039c0:	2200      	movs	r2, #0
340039c2:	2102      	movs	r1, #2
340039c4:	4618      	mov	r0, r3
340039c6:	f7fe fe33 	bl	34002630 <LL_ADC_SetOffsetLevel>
        }
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
340039ca:	687b      	ldr	r3, [r7, #4]
340039cc:	681b      	ldr	r3, [r3, #0]
340039ce:	2103      	movs	r1, #3
340039d0:	4618      	mov	r0, r3
340039d2:	f7fe fe16 	bl	34002602 <LL_ADC_GetOffsetChannel>
340039d6:	4602      	mov	r2, r0
            == __HAL_ADC_CHANNEL_TO_DECIMAL_NB(pConfig->Channel))
340039d8:	683b      	ldr	r3, [r7, #0]
340039da:	681b      	ldr	r3, [r3, #0]
340039dc:	4053      	eors	r3, r2
340039de:	f003 031f 	and.w	r3, r3, #31
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
340039e2:	2b00      	cmp	r3, #0
340039e4:	d106      	bne.n	340039f4 <HAL_ADC_ConfigChannel+0x1e0>
        {
          LL_ADC_SetOffsetLevel(hadc->Instance, LL_ADC_OFFSET_4, 0UL);
340039e6:	687b      	ldr	r3, [r7, #4]
340039e8:	681b      	ldr	r3, [r3, #0]
340039ea:	2200      	movs	r2, #0
340039ec:	2103      	movs	r1, #3
340039ee:	4618      	mov	r0, r3
340039f0:	f7fe fe1e 	bl	34002630 <LL_ADC_SetOffsetLevel>

    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    /*  - Internal measurement channels: Vbat/VrefInt/TempSensor                */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
340039f4:	687b      	ldr	r3, [r7, #4]
340039f6:	681b      	ldr	r3, [r3, #0]
340039f8:	4618      	mov	r0, r3
340039fa:	f7ff f96d 	bl	34002cd8 <LL_ADC_IsEnabled>
340039fe:	4603      	mov	r3, r0
34003a00:	2b00      	cmp	r3, #0
34003a02:	f040 8090 	bne.w	34003b26 <HAL_ADC_ConfigChannel+0x312>
    {
      /* Set mode single-ended or differential input of the selected ADC channel */
      LL_ADC_SetChannelSingleDiff(hadc->Instance, pConfig->Channel, pConfig->SingleDiff);
34003a06:	687b      	ldr	r3, [r7, #4]
34003a08:	6818      	ldr	r0, [r3, #0]
34003a0a:	683b      	ldr	r3, [r7, #0]
34003a0c:	6819      	ldr	r1, [r3, #0]
34003a0e:	683b      	ldr	r3, [r7, #0]
34003a10:	68db      	ldr	r3, [r3, #12]
34003a12:	461a      	mov	r2, r3
34003a14:	f7fe ffca 	bl	340029ac <LL_ADC_SetChannelSingleDiff>

      /* Configuration of differential mode */
      if (pConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
34003a18:	683b      	ldr	r3, [r7, #0]
34003a1a:	68db      	ldr	r3, [r3, #12]
34003a1c:	4a76      	ldr	r2, [pc, #472]	@ (34003bf8 <HAL_ADC_ConfigChannel+0x3e4>)
34003a1e:	4293      	cmp	r3, r2
34003a20:	f040 8081 	bne.w	34003b26 <HAL_ADC_ConfigChannel+0x312>
      {
        /* Set ADC channel preselection of corresponding negative channel */
        LL_ADC_SetChannelPreselection(hadc->Instance,
34003a24:	687b      	ldr	r3, [r7, #4]
34003a26:	681a      	ldr	r2, [r3, #0]
                                      __HAL_ADC_CHANNEL_DIFF_NEG_INPUT(hadc, pConfig->Channel));
34003a28:	683b      	ldr	r3, [r7, #0]
34003a2a:	681b      	ldr	r3, [r3, #0]
34003a2c:	2b00      	cmp	r3, #0
34003a2e:	d05a      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003a30:	683b      	ldr	r3, [r7, #0]
34003a32:	681b      	ldr	r3, [r3, #0]
34003a34:	2b01      	cmp	r3, #1
34003a36:	d056      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003a38:	683b      	ldr	r3, [r7, #0]
34003a3a:	681b      	ldr	r3, [r3, #0]
34003a3c:	2b02      	cmp	r3, #2
34003a3e:	d052      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003a40:	683b      	ldr	r3, [r7, #0]
34003a42:	681b      	ldr	r3, [r3, #0]
34003a44:	2b03      	cmp	r3, #3
34003a46:	d04e      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003a48:	683b      	ldr	r3, [r7, #0]
34003a4a:	681b      	ldr	r3, [r3, #0]
34003a4c:	2b04      	cmp	r3, #4
34003a4e:	d04a      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003a50:	683b      	ldr	r3, [r7, #0]
34003a52:	681b      	ldr	r3, [r3, #0]
34003a54:	2b05      	cmp	r3, #5
34003a56:	d046      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003a58:	683b      	ldr	r3, [r7, #0]
34003a5a:	681b      	ldr	r3, [r3, #0]
34003a5c:	2b06      	cmp	r3, #6
34003a5e:	d042      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003a60:	683b      	ldr	r3, [r7, #0]
34003a62:	681b      	ldr	r3, [r3, #0]
34003a64:	2b07      	cmp	r3, #7
34003a66:	d03e      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003a68:	683b      	ldr	r3, [r7, #0]
34003a6a:	681b      	ldr	r3, [r3, #0]
34003a6c:	2b08      	cmp	r3, #8
34003a6e:	d03a      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003a70:	683b      	ldr	r3, [r7, #0]
34003a72:	681b      	ldr	r3, [r3, #0]
34003a74:	2b09      	cmp	r3, #9
34003a76:	d036      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003a78:	683b      	ldr	r3, [r7, #0]
34003a7a:	681b      	ldr	r3, [r3, #0]
34003a7c:	2b0a      	cmp	r3, #10
34003a7e:	d032      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003a80:	683b      	ldr	r3, [r7, #0]
34003a82:	681b      	ldr	r3, [r3, #0]
34003a84:	2b0b      	cmp	r3, #11
34003a86:	d02e      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003a88:	683b      	ldr	r3, [r7, #0]
34003a8a:	681b      	ldr	r3, [r3, #0]
34003a8c:	2b0c      	cmp	r3, #12
34003a8e:	d02a      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003a90:	683b      	ldr	r3, [r7, #0]
34003a92:	681b      	ldr	r3, [r3, #0]
34003a94:	2b0d      	cmp	r3, #13
34003a96:	d026      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003a98:	683b      	ldr	r3, [r7, #0]
34003a9a:	681b      	ldr	r3, [r3, #0]
34003a9c:	2b0e      	cmp	r3, #14
34003a9e:	d022      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003aa0:	683b      	ldr	r3, [r7, #0]
34003aa2:	681b      	ldr	r3, [r3, #0]
34003aa4:	2b0f      	cmp	r3, #15
34003aa6:	d01e      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003aa8:	683b      	ldr	r3, [r7, #0]
34003aaa:	681b      	ldr	r3, [r3, #0]
34003aac:	2b10      	cmp	r3, #16
34003aae:	d01a      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003ab0:	683b      	ldr	r3, [r7, #0]
34003ab2:	681b      	ldr	r3, [r3, #0]
34003ab4:	2b11      	cmp	r3, #17
34003ab6:	d016      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003ab8:	683b      	ldr	r3, [r7, #0]
34003aba:	681b      	ldr	r3, [r3, #0]
34003abc:	2b12      	cmp	r3, #18
34003abe:	d012      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003ac0:	683b      	ldr	r3, [r7, #0]
34003ac2:	681b      	ldr	r3, [r3, #0]
34003ac4:	2b13      	cmp	r3, #19
34003ac6:	d00e      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003ac8:	683b      	ldr	r3, [r7, #0]
34003aca:	681b      	ldr	r3, [r3, #0]
34003acc:	494b      	ldr	r1, [pc, #300]	@ (34003bfc <HAL_ADC_ConfigChannel+0x3e8>)
34003ace:	428b      	cmp	r3, r1
34003ad0:	d009      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003ad2:	683b      	ldr	r3, [r7, #0]
34003ad4:	681b      	ldr	r3, [r3, #0]
34003ad6:	494a      	ldr	r1, [pc, #296]	@ (34003c00 <HAL_ADC_ConfigChannel+0x3ec>)
34003ad8:	428b      	cmp	r3, r1
34003ada:	d004      	beq.n	34003ae6 <HAL_ADC_ConfigChannel+0x2d2>
34003adc:	683b      	ldr	r3, [r7, #0]
34003ade:	681b      	ldr	r3, [r3, #0]
34003ae0:	4948      	ldr	r1, [pc, #288]	@ (34003c04 <HAL_ADC_ConfigChannel+0x3f0>)
34003ae2:	428b      	cmp	r3, r1
34003ae4:	d101      	bne.n	34003aea <HAL_ADC_ConfigChannel+0x2d6>
34003ae6:	2301      	movs	r3, #1
34003ae8:	e000      	b.n	34003aec <HAL_ADC_ConfigChannel+0x2d8>
34003aea:	2300      	movs	r3, #0
        LL_ADC_SetChannelPreselection(hadc->Instance,
34003aec:	2b00      	cmp	r3, #0
34003aee:	d015      	beq.n	34003b1c <HAL_ADC_ConfigChannel+0x308>
                                      __HAL_ADC_CHANNEL_DIFF_NEG_INPUT(hadc, pConfig->Channel));
34003af0:	687b      	ldr	r3, [r7, #4]
34003af2:	681b      	ldr	r3, [r3, #0]
34003af4:	4944      	ldr	r1, [pc, #272]	@ (34003c08 <HAL_ADC_ConfigChannel+0x3f4>)
34003af6:	428b      	cmp	r3, r1
34003af8:	bf14      	ite	ne
34003afa:	2301      	movne	r3, #1
34003afc:	2300      	moveq	r3, #0
34003afe:	b2db      	uxtb	r3, r3
34003b00:	4618      	mov	r0, r3
34003b02:	683b      	ldr	r3, [r7, #0]
34003b04:	681b      	ldr	r3, [r3, #0]
34003b06:	b2db      	uxtb	r3, r3
34003b08:	461c      	mov	r4, r3
34003b0a:	4940      	ldr	r1, [pc, #256]	@ (34003c0c <HAL_ADC_ConfigChannel+0x3f8>)
34003b0c:	4603      	mov	r3, r0
34003b0e:	009b      	lsls	r3, r3, #2
34003b10:	4403      	add	r3, r0
34003b12:	009b      	lsls	r3, r3, #2
34003b14:	440b      	add	r3, r1
34003b16:	4423      	add	r3, r4
34003b18:	781b      	ldrb	r3, [r3, #0]
34003b1a:	e000      	b.n	34003b1e <HAL_ADC_ConfigChannel+0x30a>
        LL_ADC_SetChannelPreselection(hadc->Instance,
34003b1c:	23ff      	movs	r3, #255	@ 0xff
34003b1e:	4619      	mov	r1, r3
34003b20:	4610      	mov	r0, r2
34003b22:	f7fe fe52 	bl	340027ca <LL_ADC_SetChannelPreselection>
    /* If internal channel selected, enable dedicated internal buffers and    */
    /* paths.                                                                 */
    /* Note: these internal measurement paths can be disabled using           */
    /* HAL_ADC_DeInit().                                                      */

    if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
34003b26:	683b      	ldr	r3, [r7, #0]
34003b28:	681b      	ldr	r3, [r3, #0]
34003b2a:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
34003b2e:	2b00      	cmp	r3, #0
34003b30:	d058      	beq.n	34003be4 <HAL_ADC_ConfigChannel+0x3d0>
    {
      tmp_config_common_path_internal_channel =
        LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
34003b32:	4837      	ldr	r0, [pc, #220]	@ (34003c10 <HAL_ADC_ConfigChannel+0x3fc>)
34003b34:	f7fe fd07 	bl	34002546 <LL_ADC_GetCommonPathInternalCh>
34003b38:	60f8      	str	r0, [r7, #12]
      tmp_config_path_internal_channel = LL_ADC_GetPathInternalCh(hadc->Instance);
34003b3a:	687b      	ldr	r3, [r7, #4]
34003b3c:	681b      	ldr	r3, [r3, #0]
34003b3e:	4618      	mov	r0, r3
34003b40:	f7fe fd25 	bl	3400258e <LL_ADC_GetPathInternalCh>
34003b44:	60b8      	str	r0, [r7, #8]
      /* If the requested internal measurement path has already been enabled, */
      /* bypass the configuration processing.                                 */
      if ((pConfig->Channel == ADC_CHANNEL_VREFINT)
34003b46:	683b      	ldr	r3, [r7, #0]
34003b48:	681b      	ldr	r3, [r3, #0]
34003b4a:	4a2e      	ldr	r2, [pc, #184]	@ (34003c04 <HAL_ADC_ConfigChannel+0x3f0>)
34003b4c:	4293      	cmp	r3, r2
34003b4e:	d111      	bne.n	34003b74 <HAL_ADC_ConfigChannel+0x360>
          && ((tmp_config_common_path_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
34003b50:	68fb      	ldr	r3, [r7, #12]
34003b52:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
34003b56:	2b00      	cmp	r3, #0
34003b58:	d10c      	bne.n	34003b74 <HAL_ADC_ConfigChannel+0x360>
      {
        if (ADC_VREFINT_INSTANCE(hadc))
34003b5a:	687b      	ldr	r3, [r7, #4]
34003b5c:	681b      	ldr	r3, [r3, #0]
34003b5e:	4a2a      	ldr	r2, [pc, #168]	@ (34003c08 <HAL_ADC_ConfigChannel+0x3f4>)
34003b60:	4293      	cmp	r3, r2
34003b62:	d13f      	bne.n	34003be4 <HAL_ADC_ConfigChannel+0x3d0>
        {
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
34003b64:	68fb      	ldr	r3, [r7, #12]
34003b66:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
34003b6a:	4619      	mov	r1, r3
34003b6c:	4828      	ldr	r0, [pc, #160]	@ (34003c10 <HAL_ADC_ConfigChannel+0x3fc>)
34003b6e:	f7fe fcd7 	bl	34002520 <LL_ADC_SetCommonPathInternalCh>
        if (ADC_VREFINT_INSTANCE(hadc))
34003b72:	e037      	b.n	34003be4 <HAL_ADC_ConfigChannel+0x3d0>
                                         LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_common_path_internal_channel);
        }
      }
      else if ((pConfig->Channel == ADC_CHANNEL_VBAT)
34003b74:	683b      	ldr	r3, [r7, #0]
34003b76:	681b      	ldr	r3, [r3, #0]
34003b78:	4a20      	ldr	r2, [pc, #128]	@ (34003bfc <HAL_ADC_ConfigChannel+0x3e8>)
34003b7a:	4293      	cmp	r3, r2
34003b7c:	d111      	bne.n	34003ba2 <HAL_ADC_ConfigChannel+0x38e>
               && ((tmp_config_common_path_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
34003b7e:	68fb      	ldr	r3, [r7, #12]
34003b80:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34003b84:	2b00      	cmp	r3, #0
34003b86:	d10c      	bne.n	34003ba2 <HAL_ADC_ConfigChannel+0x38e>
      {
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
34003b88:	687b      	ldr	r3, [r7, #4]
34003b8a:	681b      	ldr	r3, [r3, #0]
34003b8c:	4a21      	ldr	r2, [pc, #132]	@ (34003c14 <HAL_ADC_ConfigChannel+0x400>)
34003b8e:	4293      	cmp	r3, r2
34003b90:	d128      	bne.n	34003be4 <HAL_ADC_ConfigChannel+0x3d0>
        {
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
34003b92:	68fb      	ldr	r3, [r7, #12]
34003b94:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
34003b98:	4619      	mov	r1, r3
34003b9a:	481d      	ldr	r0, [pc, #116]	@ (34003c10 <HAL_ADC_ConfigChannel+0x3fc>)
34003b9c:	f7fe fcc0 	bl	34002520 <LL_ADC_SetCommonPathInternalCh>
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
34003ba0:	e020      	b.n	34003be4 <HAL_ADC_ConfigChannel+0x3d0>
                                         LL_ADC_PATH_INTERNAL_VBAT | tmp_config_common_path_internal_channel);
        }
      }
      else if (((pConfig->Channel == ADC_CHANNEL_VDDCORE)
34003ba2:	683b      	ldr	r3, [r7, #0]
34003ba4:	681b      	ldr	r3, [r3, #0]
34003ba6:	4a16      	ldr	r2, [pc, #88]	@ (34003c00 <HAL_ADC_ConfigChannel+0x3ec>)
34003ba8:	4293      	cmp	r3, r2
34003baa:	d11b      	bne.n	34003be4 <HAL_ADC_ConfigChannel+0x3d0>
                && ((tmp_config_path_internal_channel & LL_ADC_PATH_INTERNAL_VDDCORE) == 0UL)))
34003bac:	68bb      	ldr	r3, [r7, #8]
34003bae:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
34003bb2:	2b00      	cmp	r3, #0
34003bb4:	d116      	bne.n	34003be4 <HAL_ADC_ConfigChannel+0x3d0>
      {
        if (ADC_VDDCORE_INSTANCE(hadc))
34003bb6:	687b      	ldr	r3, [r7, #4]
34003bb8:	681b      	ldr	r3, [r3, #0]
34003bba:	4a16      	ldr	r2, [pc, #88]	@ (34003c14 <HAL_ADC_ConfigChannel+0x400>)
34003bbc:	4293      	cmp	r3, r2
34003bbe:	d111      	bne.n	34003be4 <HAL_ADC_ConfigChannel+0x3d0>
        {
          LL_ADC_SetPathInternalCh(hadc->Instance, LL_ADC_PATH_INTERNAL_VDDCORE | tmp_config_path_internal_channel);
34003bc0:	687b      	ldr	r3, [r7, #4]
34003bc2:	681a      	ldr	r2, [r3, #0]
34003bc4:	68bb      	ldr	r3, [r7, #8]
34003bc6:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
34003bca:	4619      	mov	r1, r3
34003bcc:	4610      	mov	r0, r2
34003bce:	f7fe fcc8 	bl	34002562 <LL_ADC_SetPathInternalCh>
34003bd2:	e007      	b.n	34003be4 <HAL_ADC_ConfigChannel+0x3d0>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
34003bd4:	687b      	ldr	r3, [r7, #4]
34003bd6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003bd8:	f043 0220 	orr.w	r2, r3, #32
34003bdc:	687b      	ldr	r3, [r7, #4]
34003bde:	659a      	str	r2, [r3, #88]	@ 0x58

    tmp_hal_status = HAL_ERROR;
34003be0:	2301      	movs	r3, #1
34003be2:	77fb      	strb	r3, [r7, #31]
  }

  __HAL_UNLOCK(hadc);
34003be4:	687b      	ldr	r3, [r7, #4]
34003be6:	2200      	movs	r2, #0
34003be8:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  return tmp_hal_status;
34003bec:	7ffb      	ldrb	r3, [r7, #31]
}
34003bee:	4618      	mov	r0, r3
34003bf0:	3724      	adds	r7, #36	@ 0x24
34003bf2:	46bd      	mov	sp, r7
34003bf4:	bd90      	pop	{r4, r7, pc}
34003bf6:	bf00      	nop
34003bf8:	43ff0000 	.word	0x43ff0000
34003bfc:	01000810 	.word	0x01000810
34003c00:	00040811 	.word	0x00040811
34003c04:	00400411 	.word	0x00400411
34003c08:	50022000 	.word	0x50022000
34003c0c:	34010050 	.word	0x34010050
34003c10:	50022300 	.word	0x50022300
34003c14:	50022100 	.word	0x50022100

34003c18 <HAL_ADC_AnalogWDGConfig>:
  * @param hadc ADC handle
  * @param pAnalogWDGConfig Structure of ADC analog watchdog configuration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef *hadc, const ADC_AnalogWDGConfTypeDef *pAnalogWDGConfig)
{
34003c18:	b580      	push	{r7, lr}
34003c1a:	b088      	sub	sp, #32
34003c1c:	af00      	add	r7, sp, #0
34003c1e:	6078      	str	r0, [r7, #4]
34003c20:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
34003c22:	2300      	movs	r3, #0
34003c24:	77fb      	strb	r3, [r7, #31]
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_ANALOG_WATCHDOG_NUMBER(pAnalogWDGConfig->WatchdogNumber));
  assert_param(IS_ADC_ANALOG_WATCHDOG_MODE(pAnalogWDGConfig->WatchdogMode));
  assert_param(IS_FUNCTIONAL_STATE(pAnalogWDGConfig->ITMode));

  if ((pAnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REG)     ||
34003c26:	683b      	ldr	r3, [r7, #0]
34003c28:	685b      	ldr	r3, [r3, #4]
34003c2a:	f5b3 0f40 	cmp.w	r3, #12582912	@ 0xc00000
34003c2e:	d003      	beq.n	34003c38 <HAL_ADC_AnalogWDGConfig+0x20>
      (pAnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_INJEC)   ||
34003c30:	683b      	ldr	r3, [r7, #0]
34003c32:	685b      	ldr	r3, [r3, #4]
  if ((pAnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REG)     ||
34003c34:	f1b3 7fa0 	cmp.w	r3, #20971520	@ 0x1400000
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), pAnalogWDGConfig->HighThreshold));
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), pAnalogWDGConfig->LowThreshold));
  }

  /* ADC must be disabled to set configuration bits                           */
  if (LL_ADC_IsEnabled(hadc->Instance) != 0UL)
34003c38:	687b      	ldr	r3, [r7, #4]
34003c3a:	681b      	ldr	r3, [r3, #0]
34003c3c:	4618      	mov	r0, r3
34003c3e:	f7ff f84b 	bl	34002cd8 <LL_ADC_IsEnabled>
34003c42:	4603      	mov	r3, r0
34003c44:	2b00      	cmp	r3, #0
34003c46:	d001      	beq.n	34003c4c <HAL_ADC_AnalogWDGConfig+0x34>
  {
    return HAL_ERROR;
34003c48:	2301      	movs	r3, #1
34003c4a:	e1f4      	b.n	34004036 <HAL_ADC_AnalogWDGConfig+0x41e>
  }

  /* Process locked */
  __HAL_LOCK(hadc);
34003c4c:	687b      	ldr	r3, [r7, #4]
34003c4e:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34003c52:	2b01      	cmp	r3, #1
34003c54:	d101      	bne.n	34003c5a <HAL_ADC_AnalogWDGConfig+0x42>
34003c56:	2302      	movs	r3, #2
34003c58:	e1ed      	b.n	34004036 <HAL_ADC_AnalogWDGConfig+0x41e>
34003c5a:	687b      	ldr	r3, [r7, #4]
34003c5c:	2201      	movs	r2, #1
34003c5e:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on ADC groups regular and injected:                  */
  /*  - Analog watchdog channels                                              */
  /*  - Analog watchdog thresholds                                            */
  tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
34003c62:	687b      	ldr	r3, [r7, #4]
34003c64:	681b      	ldr	r3, [r3, #0]
34003c66:	4618      	mov	r0, r3
34003c68:	f7ff f880 	bl	34002d6c <LL_ADC_REG_IsConversionOngoing>
34003c6c:	61b8      	str	r0, [r7, #24]
  tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
34003c6e:	687b      	ldr	r3, [r7, #4]
34003c70:	681b      	ldr	r3, [r3, #0]
34003c72:	4618      	mov	r0, r3
34003c74:	f7ff f89f 	bl	34002db6 <LL_ADC_INJ_IsConversionOngoing>
34003c78:	6178      	str	r0, [r7, #20]

  if ((tmp_adc_is_conversion_on_going_regular == 0UL)
34003c7a:	69bb      	ldr	r3, [r7, #24]
34003c7c:	2b00      	cmp	r3, #0
34003c7e:	f040 81cd 	bne.w	3400401c <HAL_ADC_AnalogWDGConfig+0x404>
      && (tmp_adc_is_conversion_on_going_injected == 0UL)
34003c82:	697b      	ldr	r3, [r7, #20]
34003c84:	2b00      	cmp	r3, #0
34003c86:	f040 81c9 	bne.w	3400401c <HAL_ADC_AnalogWDGConfig+0x404>
     )
  {
    /* Format analog watchdog thresholds data in function of the selected ADC resolution */
    tmp_adc_resolution = LL_ADC_GetResolution(hadc->Instance);
34003c8a:	687b      	ldr	r3, [r7, #4]
34003c8c:	681b      	ldr	r3, [r3, #0]
34003c8e:	4618      	mov	r0, r3
34003c90:	f7fe fc8d 	bl	340025ae <LL_ADC_GetResolution>
34003c94:	6138      	str	r0, [r7, #16]
    tmp_awd_high_threshold_shifted = __LL_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION(tmp_adc_resolution,
34003c96:	683b      	ldr	r3, [r7, #0]
34003c98:	691a      	ldr	r2, [r3, #16]
34003c9a:	693b      	ldr	r3, [r7, #16]
34003c9c:	085b      	lsrs	r3, r3, #1
34003c9e:	fa02 f303 	lsl.w	r3, r2, r3
34003ca2:	60fb      	str	r3, [r7, #12]
                                                                                pAnalogWDGConfig->HighThreshold);
    tmp_awd_low_threshold_shifted = __LL_ADC_ANALOGWD_SET_THRESHOLD_RESOLUTION(tmp_adc_resolution,
34003ca4:	683b      	ldr	r3, [r7, #0]
34003ca6:	695a      	ldr	r2, [r3, #20]
34003ca8:	693b      	ldr	r3, [r7, #16]
34003caa:	085b      	lsrs	r3, r3, #1
34003cac:	fa02 f303 	lsl.w	r3, r2, r3
34003cb0:	60bb      	str	r3, [r7, #8]
                                                                               pAnalogWDGConfig->LowThreshold);

    /* Analog watchdog configuration */
    if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_1)
34003cb2:	683b      	ldr	r3, [r7, #0]
34003cb4:	681b      	ldr	r3, [r3, #0]
34003cb6:	4a96      	ldr	r2, [pc, #600]	@ (34003f10 <HAL_ADC_AnalogWDGConfig+0x2f8>)
34003cb8:	4293      	cmp	r3, r2
34003cba:	f040 80be 	bne.w	34003e3a <HAL_ADC_AnalogWDGConfig+0x222>
    {
      /* Configuration of analog watchdog:                                    */
      /*  - Set the analog watchdog enable mode: one or overall group of      */
      /*    channels, on groups regular and-or injected.                      */
      switch (pAnalogWDGConfig->WatchdogMode)
34003cbe:	683b      	ldr	r3, [r7, #0]
34003cc0:	685b      	ldr	r3, [r3, #4]
34003cc2:	f1b3 7fe0 	cmp.w	r3, #29360128	@ 0x1c00000
34003cc6:	d04a      	beq.n	34003d5e <HAL_ADC_AnalogWDGConfig+0x146>
34003cc8:	f1b3 7fe0 	cmp.w	r3, #29360128	@ 0x1c00000
34003ccc:	d877      	bhi.n	34003dbe <HAL_ADC_AnalogWDGConfig+0x1a6>
34003cce:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
34003cd2:	d06c      	beq.n	34003dae <HAL_ADC_AnalogWDGConfig+0x196>
34003cd4:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
34003cd8:	d871      	bhi.n	34003dbe <HAL_ADC_AnalogWDGConfig+0x1a6>
34003cda:	f1b3 7fa0 	cmp.w	r3, #20971520	@ 0x1400000
34003cde:	d026      	beq.n	34003d2e <HAL_ADC_AnalogWDGConfig+0x116>
34003ce0:	f1b3 7fa0 	cmp.w	r3, #20971520	@ 0x1400000
34003ce4:	d86b      	bhi.n	34003dbe <HAL_ADC_AnalogWDGConfig+0x1a6>
34003ce6:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34003cea:	d058      	beq.n	34003d9e <HAL_ADC_AnalogWDGConfig+0x186>
34003cec:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34003cf0:	d865      	bhi.n	34003dbe <HAL_ADC_AnalogWDGConfig+0x1a6>
34003cf2:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
34003cf6:	d04a      	beq.n	34003d8e <HAL_ADC_AnalogWDGConfig+0x176>
34003cf8:	f5b3 0f40 	cmp.w	r3, #12582912	@ 0xc00000
34003cfc:	d15f      	bne.n	34003dbe <HAL_ADC_AnalogWDGConfig+0x1a6>
      {
        case ADC_ANALOGWATCHDOG_SINGLE_REG:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1,
34003cfe:	687b      	ldr	r3, [r7, #4]
34003d00:	6818      	ldr	r0, [r3, #0]
                                          __LL_ADC_ANALOGWD_CHANNEL_GROUP(pAnalogWDGConfig->Channel,
34003d02:	683b      	ldr	r3, [r7, #0]
34003d04:	689b      	ldr	r3, [r3, #8]
34003d06:	069b      	lsls	r3, r3, #26
34003d08:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
34003d0c:	683b      	ldr	r3, [r7, #0]
34003d0e:	689b      	ldr	r3, [r3, #8]
34003d10:	b2db      	uxtb	r3, r3
34003d12:	4619      	mov	r1, r3
34003d14:	4b7f      	ldr	r3, [pc, #508]	@ (34003f14 <HAL_ADC_AnalogWDGConfig+0x2fc>)
34003d16:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
34003d1a:	f3c3 0313 	ubfx	r3, r3, #0, #20
34003d1e:	4313      	orrs	r3, r2
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1,
34003d20:	f443 0340 	orr.w	r3, r3, #12582912	@ 0xc00000
34003d24:	461a      	mov	r2, r3
34003d26:	497a      	ldr	r1, [pc, #488]	@ (34003f10 <HAL_ADC_AnalogWDGConfig+0x2f8>)
34003d28:	f7fe fefc 	bl	34002b24 <LL_ADC_SetAnalogWDMonitChannels>
                                                                          LL_ADC_GROUP_REGULAR));
          break;
34003d2c:	e04f      	b.n	34003dce <HAL_ADC_AnalogWDGConfig+0x1b6>

        case ADC_ANALOGWATCHDOG_SINGLE_INJEC:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1,
34003d2e:	687b      	ldr	r3, [r7, #4]
34003d30:	6818      	ldr	r0, [r3, #0]
                                          __LL_ADC_ANALOGWD_CHANNEL_GROUP(pAnalogWDGConfig->Channel,
34003d32:	683b      	ldr	r3, [r7, #0]
34003d34:	689b      	ldr	r3, [r3, #8]
34003d36:	069b      	lsls	r3, r3, #26
34003d38:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
34003d3c:	683b      	ldr	r3, [r7, #0]
34003d3e:	689b      	ldr	r3, [r3, #8]
34003d40:	b2db      	uxtb	r3, r3
34003d42:	4619      	mov	r1, r3
34003d44:	4b73      	ldr	r3, [pc, #460]	@ (34003f14 <HAL_ADC_AnalogWDGConfig+0x2fc>)
34003d46:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
34003d4a:	f3c3 0313 	ubfx	r3, r3, #0, #20
34003d4e:	4313      	orrs	r3, r2
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1,
34003d50:	f043 73a0 	orr.w	r3, r3, #20971520	@ 0x1400000
34003d54:	461a      	mov	r2, r3
34003d56:	496e      	ldr	r1, [pc, #440]	@ (34003f10 <HAL_ADC_AnalogWDGConfig+0x2f8>)
34003d58:	f7fe fee4 	bl	34002b24 <LL_ADC_SetAnalogWDMonitChannels>
                                                                          LL_ADC_GROUP_INJECTED));
          break;
34003d5c:	e037      	b.n	34003dce <HAL_ADC_AnalogWDGConfig+0x1b6>

        case ADC_ANALOGWATCHDOG_SINGLE_REGINJEC:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1,
34003d5e:	687b      	ldr	r3, [r7, #4]
34003d60:	6818      	ldr	r0, [r3, #0]
                                          __LL_ADC_ANALOGWD_CHANNEL_GROUP(pAnalogWDGConfig->Channel,
34003d62:	683b      	ldr	r3, [r7, #0]
34003d64:	689b      	ldr	r3, [r3, #8]
34003d66:	069b      	lsls	r3, r3, #26
34003d68:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
34003d6c:	683b      	ldr	r3, [r7, #0]
34003d6e:	689b      	ldr	r3, [r3, #8]
34003d70:	b2db      	uxtb	r3, r3
34003d72:	4619      	mov	r1, r3
34003d74:	4b67      	ldr	r3, [pc, #412]	@ (34003f14 <HAL_ADC_AnalogWDGConfig+0x2fc>)
34003d76:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
34003d7a:	f3c3 0313 	ubfx	r3, r3, #0, #20
34003d7e:	4313      	orrs	r3, r2
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1,
34003d80:	f043 73e0 	orr.w	r3, r3, #29360128	@ 0x1c00000
34003d84:	461a      	mov	r2, r3
34003d86:	4962      	ldr	r1, [pc, #392]	@ (34003f10 <HAL_ADC_AnalogWDGConfig+0x2f8>)
34003d88:	f7fe fecc 	bl	34002b24 <LL_ADC_SetAnalogWDMonitChannels>
                                                                          LL_ADC_GROUP_REGULAR_INJECTED));
          break;
34003d8c:	e01f      	b.n	34003dce <HAL_ADC_AnalogWDGConfig+0x1b6>

        case ADC_ANALOGWATCHDOG_ALL_REG:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, LL_ADC_AWD_ALL_CHANNELS_REG);
34003d8e:	687b      	ldr	r3, [r7, #4]
34003d90:	681b      	ldr	r3, [r3, #0]
34003d92:	4a61      	ldr	r2, [pc, #388]	@ (34003f18 <HAL_ADC_AnalogWDGConfig+0x300>)
34003d94:	495e      	ldr	r1, [pc, #376]	@ (34003f10 <HAL_ADC_AnalogWDGConfig+0x2f8>)
34003d96:	4618      	mov	r0, r3
34003d98:	f7fe fec4 	bl	34002b24 <LL_ADC_SetAnalogWDMonitChannels>
          break;
34003d9c:	e017      	b.n	34003dce <HAL_ADC_AnalogWDGConfig+0x1b6>

        case ADC_ANALOGWATCHDOG_ALL_INJEC:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, LL_ADC_AWD_ALL_CHANNELS_INJ);
34003d9e:	687b      	ldr	r3, [r7, #4]
34003da0:	681b      	ldr	r3, [r3, #0]
34003da2:	4a5e      	ldr	r2, [pc, #376]	@ (34003f1c <HAL_ADC_AnalogWDGConfig+0x304>)
34003da4:	495a      	ldr	r1, [pc, #360]	@ (34003f10 <HAL_ADC_AnalogWDGConfig+0x2f8>)
34003da6:	4618      	mov	r0, r3
34003da8:	f7fe febc 	bl	34002b24 <LL_ADC_SetAnalogWDMonitChannels>
          break;
34003dac:	e00f      	b.n	34003dce <HAL_ADC_AnalogWDGConfig+0x1b6>

        case ADC_ANALOGWATCHDOG_ALL_REGINJEC:
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, LL_ADC_AWD_ALL_CHANNELS_REG_INJ);
34003dae:	687b      	ldr	r3, [r7, #4]
34003db0:	681b      	ldr	r3, [r3, #0]
34003db2:	4a5b      	ldr	r2, [pc, #364]	@ (34003f20 <HAL_ADC_AnalogWDGConfig+0x308>)
34003db4:	4956      	ldr	r1, [pc, #344]	@ (34003f10 <HAL_ADC_AnalogWDGConfig+0x2f8>)
34003db6:	4618      	mov	r0, r3
34003db8:	f7fe feb4 	bl	34002b24 <LL_ADC_SetAnalogWDMonitChannels>
          break;
34003dbc:	e007      	b.n	34003dce <HAL_ADC_AnalogWDGConfig+0x1b6>

        default: /* ADC_ANALOGWATCHDOG_NONE */
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, LL_ADC_AWD1, LL_ADC_AWD_DISABLE);
34003dbe:	687b      	ldr	r3, [r7, #4]
34003dc0:	681b      	ldr	r3, [r3, #0]
34003dc2:	2200      	movs	r2, #0
34003dc4:	4952      	ldr	r1, [pc, #328]	@ (34003f10 <HAL_ADC_AnalogWDGConfig+0x2f8>)
34003dc6:	4618      	mov	r0, r3
34003dc8:	f7fe feac 	bl	34002b24 <LL_ADC_SetAnalogWDMonitChannels>
          break;
34003dcc:	bf00      	nop
      }

      /* Set the filtering configuration */
      assert_param(IS_ADC_ANALOG_WATCHDOG_FILTERING_MODE(pAnalogWDGConfig->FilteringConfig));
      LL_ADC_SetAWDFilteringConfiguration(hadc->Instance, hadc->Instance->AWD1HTR, pAnalogWDGConfig->FilteringConfig);
34003dce:	687b      	ldr	r3, [r7, #4]
34003dd0:	6818      	ldr	r0, [r3, #0]
34003dd2:	687b      	ldr	r3, [r7, #4]
34003dd4:	681b      	ldr	r3, [r3, #0]
34003dd6:	f8d3 10ac 	ldr.w	r1, [r3, #172]	@ 0xac
34003dda:	683b      	ldr	r3, [r7, #0]
34003ddc:	699b      	ldr	r3, [r3, #24]
34003dde:	461a      	mov	r2, r3
34003de0:	f7fe fefe 	bl	34002be0 <LL_ADC_SetAWDFilteringConfiguration>

      /* Set ADC analog watchdog thresholds value of both thresholds high and low */
      LL_ADC_SetAnalogWDThresholds(hadc->Instance, pAnalogWDGConfig->WatchdogNumber,
34003de4:	687b      	ldr	r3, [r7, #4]
34003de6:	6818      	ldr	r0, [r3, #0]
34003de8:	683b      	ldr	r3, [r7, #0]
34003dea:	6819      	ldr	r1, [r3, #0]
34003dec:	68fb      	ldr	r3, [r7, #12]
34003dee:	2201      	movs	r2, #1
34003df0:	f7fe fec6 	bl	34002b80 <LL_ADC_SetAnalogWDThresholds>
                                   LL_ADC_AWD_THRESHOLD_HIGH, tmp_awd_high_threshold_shifted);
      LL_ADC_SetAnalogWDThresholds(hadc->Instance, pAnalogWDGConfig->WatchdogNumber,
34003df4:	687b      	ldr	r3, [r7, #4]
34003df6:	6818      	ldr	r0, [r3, #0]
34003df8:	683b      	ldr	r3, [r7, #0]
34003dfa:	6819      	ldr	r1, [r3, #0]
34003dfc:	68bb      	ldr	r3, [r7, #8]
34003dfe:	2200      	movs	r2, #0
34003e00:	f7fe febe 	bl	34002b80 <LL_ADC_SetAnalogWDThresholds>
                                   LL_ADC_AWD_THRESHOLD_LOW, tmp_awd_low_threshold_shifted);

      /* Update state, clear previous result related to AWD1 */
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_AWD1);
34003e04:	687b      	ldr	r3, [r7, #4]
34003e06:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003e08:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
34003e0c:	687b      	ldr	r3, [r7, #4]
34003e0e:	659a      	str	r2, [r3, #88]	@ 0x58

      /* Clear flag ADC analog watchdog */
      /* Note: Flag cleared Clear the ADC Analog watchdog flag to be ready  */
      /* to use for HAL_ADC_IRQHandler() or HAL_ADC_PollForEvent()          */
      /* (in case left enabled by previous ADC operations).                 */
      LL_ADC_ClearFlag_AWD1(hadc->Instance);
34003e10:	687b      	ldr	r3, [r7, #4]
34003e12:	681b      	ldr	r3, [r3, #0]
34003e14:	4618      	mov	r0, r3
34003e16:	f7fe ffe1 	bl	34002ddc <LL_ADC_ClearFlag_AWD1>

      /* Configure ADC analog watchdog interrupt */
      if (pAnalogWDGConfig->ITMode == ENABLE)
34003e1a:	683b      	ldr	r3, [r7, #0]
34003e1c:	7b1b      	ldrb	r3, [r3, #12]
34003e1e:	2b01      	cmp	r3, #1
34003e20:	d105      	bne.n	34003e2e <HAL_ADC_AnalogWDGConfig+0x216>
      {
        LL_ADC_EnableIT_AWD1(hadc->Instance);
34003e22:	687b      	ldr	r3, [r7, #4]
34003e24:	681b      	ldr	r3, [r3, #0]
34003e26:	4618      	mov	r0, r3
34003e28:	f7ff f801 	bl	34002e2e <LL_ADC_EnableIT_AWD1>
    if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_1)
34003e2c:	e0fe      	b.n	3400402c <HAL_ADC_AnalogWDGConfig+0x414>
      }
      else
      {
        LL_ADC_DisableIT_AWD1(hadc->Instance);
34003e2e:	687b      	ldr	r3, [r7, #4]
34003e30:	681b      	ldr	r3, [r3, #0]
34003e32:	4618      	mov	r0, r3
34003e34:	f7ff f82b 	bl	34002e8e <LL_ADC_DisableIT_AWD1>
    if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_1)
34003e38:	e0f8      	b.n	3400402c <HAL_ADC_AnalogWDGConfig+0x414>
      }
    }
    /* Case of ADC_ANALOGWATCHDOG_2 or ADC_ANALOGWATCHDOG_3 */
    else
    {
      switch (pAnalogWDGConfig->WatchdogMode)
34003e3a:	683b      	ldr	r3, [r7, #0]
34003e3c:	685b      	ldr	r3, [r3, #4]
34003e3e:	f1b3 7fe0 	cmp.w	r3, #29360128	@ 0x1c00000
34003e42:	d01a      	beq.n	34003e7a <HAL_ADC_AnalogWDGConfig+0x262>
34003e44:	f1b3 7fe0 	cmp.w	r3, #29360128	@ 0x1c00000
34003e48:	d86e      	bhi.n	34003f28 <HAL_ADC_AnalogWDGConfig+0x310>
34003e4a:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
34003e4e:	d039      	beq.n	34003ec4 <HAL_ADC_AnalogWDGConfig+0x2ac>
34003e50:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
34003e54:	d868      	bhi.n	34003f28 <HAL_ADC_AnalogWDGConfig+0x310>
34003e56:	f1b3 7fa0 	cmp.w	r3, #20971520	@ 0x1400000
34003e5a:	d00e      	beq.n	34003e7a <HAL_ADC_AnalogWDGConfig+0x262>
34003e5c:	f1b3 7fa0 	cmp.w	r3, #20971520	@ 0x1400000
34003e60:	d862      	bhi.n	34003f28 <HAL_ADC_AnalogWDGConfig+0x310>
34003e62:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34003e66:	d02d      	beq.n	34003ec4 <HAL_ADC_AnalogWDGConfig+0x2ac>
34003e68:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34003e6c:	d85c      	bhi.n	34003f28 <HAL_ADC_AnalogWDGConfig+0x310>
34003e6e:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
34003e72:	d027      	beq.n	34003ec4 <HAL_ADC_AnalogWDGConfig+0x2ac>
34003e74:	f5b3 0f40 	cmp.w	r3, #12582912	@ 0xc00000
34003e78:	d156      	bne.n	34003f28 <HAL_ADC_AnalogWDGConfig+0x310>
        case ADC_ANALOGWATCHDOG_SINGLE_REG:
        case ADC_ANALOGWATCHDOG_SINGLE_INJEC:
        case ADC_ANALOGWATCHDOG_SINGLE_REGINJEC:
          /* Update AWD by bitfield to keep the possibility to monitor        */
          /* several channels by successive calls of this function.           */
          if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_2)
34003e7a:	683b      	ldr	r3, [r7, #0]
34003e7c:	681b      	ldr	r3, [r3, #0]
34003e7e:	4a29      	ldr	r2, [pc, #164]	@ (34003f24 <HAL_ADC_AnalogWDGConfig+0x30c>)
34003e80:	4293      	cmp	r3, r2
34003e82:	d10f      	bne.n	34003ea4 <HAL_ADC_AnalogWDGConfig+0x28c>
          {
            SET_BIT(hadc->Instance->AWD2CR, (1UL                                                       \
34003e84:	687b      	ldr	r3, [r7, #4]
34003e86:	681b      	ldr	r3, [r3, #0]
34003e88:	f8d3 10a0 	ldr.w	r1, [r3, #160]	@ 0xa0
34003e8c:	683b      	ldr	r3, [r7, #0]
34003e8e:	689b      	ldr	r3, [r3, #8]
34003e90:	f003 031f 	and.w	r3, r3, #31
34003e94:	2201      	movs	r2, #1
34003e96:	409a      	lsls	r2, r3
34003e98:	687b      	ldr	r3, [r7, #4]
34003e9a:	681b      	ldr	r3, [r3, #0]
34003e9c:	430a      	orrs	r2, r1
34003e9e:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
          else
          {
            SET_BIT(hadc->Instance->AWD3CR, (1UL                                                      \
                                             << (__LL_ADC_CHANNEL_TO_DECIMAL_NB(pAnalogWDGConfig->Channel) & 0x1FUL)));
          }
          break;
34003ea2:	e04a      	b.n	34003f3a <HAL_ADC_AnalogWDGConfig+0x322>
            SET_BIT(hadc->Instance->AWD3CR, (1UL                                                      \
34003ea4:	687b      	ldr	r3, [r7, #4]
34003ea6:	681b      	ldr	r3, [r3, #0]
34003ea8:	f8d3 10a4 	ldr.w	r1, [r3, #164]	@ 0xa4
34003eac:	683b      	ldr	r3, [r7, #0]
34003eae:	689b      	ldr	r3, [r3, #8]
34003eb0:	f003 031f 	and.w	r3, r3, #31
34003eb4:	2201      	movs	r2, #1
34003eb6:	409a      	lsls	r2, r3
34003eb8:	687b      	ldr	r3, [r7, #4]
34003eba:	681b      	ldr	r3, [r3, #0]
34003ebc:	430a      	orrs	r2, r1
34003ebe:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
          break;
34003ec2:	e03a      	b.n	34003f3a <HAL_ADC_AnalogWDGConfig+0x322>
        case ADC_ANALOGWATCHDOG_ALL_REG:
        case ADC_ANALOGWATCHDOG_ALL_INJEC:
        case ADC_ANALOGWATCHDOG_ALL_REGINJEC:
          /* Update AWD by bitfield to keep the possibility to monitor        */
          /* several channels by successive calls of this function.           */
          if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_2)
34003ec4:	683b      	ldr	r3, [r7, #0]
34003ec6:	681b      	ldr	r3, [r3, #0]
34003ec8:	4a16      	ldr	r2, [pc, #88]	@ (34003f24 <HAL_ADC_AnalogWDGConfig+0x30c>)
34003eca:	4293      	cmp	r3, r2
34003ecc:	d10f      	bne.n	34003eee <HAL_ADC_AnalogWDGConfig+0x2d6>
          {
            SET_BIT(hadc->Instance->AWD2CR, (1UL                                                           \
34003ece:	687b      	ldr	r3, [r7, #4]
34003ed0:	681b      	ldr	r3, [r3, #0]
34003ed2:	f8d3 10a0 	ldr.w	r1, [r3, #160]	@ 0xa0
34003ed6:	683b      	ldr	r3, [r7, #0]
34003ed8:	689b      	ldr	r3, [r3, #8]
34003eda:	f003 031f 	and.w	r3, r3, #31
34003ede:	2201      	movs	r2, #1
34003ee0:	409a      	lsls	r2, r3
34003ee2:	687b      	ldr	r3, [r7, #4]
34003ee4:	681b      	ldr	r3, [r3, #0]
34003ee6:	430a      	orrs	r2, r1
34003ee8:	f8c3 20a0 	str.w	r2, [r3, #160]	@ 0xa0
          else
          {
            SET_BIT(hadc->Instance->AWD3CR, (1UL                                                        \
                                             << (__LL_ADC_CHANNEL_TO_DECIMAL_NB(pAnalogWDGConfig->Channel) & 0x1FUL)));
          }
          break;
34003eec:	e025      	b.n	34003f3a <HAL_ADC_AnalogWDGConfig+0x322>
            SET_BIT(hadc->Instance->AWD3CR, (1UL                                                        \
34003eee:	687b      	ldr	r3, [r7, #4]
34003ef0:	681b      	ldr	r3, [r3, #0]
34003ef2:	f8d3 10a4 	ldr.w	r1, [r3, #164]	@ 0xa4
34003ef6:	683b      	ldr	r3, [r7, #0]
34003ef8:	689b      	ldr	r3, [r3, #8]
34003efa:	f003 031f 	and.w	r3, r3, #31
34003efe:	2201      	movs	r2, #1
34003f00:	409a      	lsls	r2, r3
34003f02:	687b      	ldr	r3, [r7, #4]
34003f04:	681b      	ldr	r3, [r3, #0]
34003f06:	430a      	orrs	r2, r1
34003f08:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4
          break;
34003f0c:	e015      	b.n	34003f3a <HAL_ADC_AnalogWDGConfig+0x322>
34003f0e:	bf00      	nop
34003f10:	7dc00000 	.word	0x7dc00000
34003f14:	34010000 	.word	0x34010000
34003f18:	008fffff 	.word	0x008fffff
34003f1c:	010fffff 	.word	0x010fffff
34003f20:	018fffff 	.word	0x018fffff
34003f24:	001fffff 	.word	0x001fffff

        default: /* ADC_ANALOGWATCHDOG_NONE */
          LL_ADC_SetAnalogWDMonitChannels(hadc->Instance, pAnalogWDGConfig->WatchdogNumber, LL_ADC_AWD_DISABLE);
34003f28:	687b      	ldr	r3, [r7, #4]
34003f2a:	6818      	ldr	r0, [r3, #0]
34003f2c:	683b      	ldr	r3, [r7, #0]
34003f2e:	681b      	ldr	r3, [r3, #0]
34003f30:	2200      	movs	r2, #0
34003f32:	4619      	mov	r1, r3
34003f34:	f7fe fdf6 	bl	34002b24 <LL_ADC_SetAnalogWDMonitChannels>
          break;
34003f38:	bf00      	nop
      }

      if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_2)
34003f3a:	683b      	ldr	r3, [r7, #0]
34003f3c:	681b      	ldr	r3, [r3, #0]
34003f3e:	4a40      	ldr	r2, [pc, #256]	@ (34004040 <HAL_ADC_AnalogWDGConfig+0x428>)
34003f40:	4293      	cmp	r3, r2
34003f42:	d118      	bne.n	34003f76 <HAL_ADC_AnalogWDGConfig+0x35e>
      {
        /* Set ADC analog watchdog thresholds value of both thresholds high and low */
        MODIFY_REG(hadc->Instance->AWD2LTR, ADC_AWD2LTR_LTR, tmp_awd_low_threshold_shifted);
34003f44:	687b      	ldr	r3, [r7, #4]
34003f46:	681b      	ldr	r3, [r3, #0]
34003f48:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34003f4c:	0ddb      	lsrs	r3, r3, #23
34003f4e:	05db      	lsls	r3, r3, #23
34003f50:	687a      	ldr	r2, [r7, #4]
34003f52:	6812      	ldr	r2, [r2, #0]
34003f54:	68b9      	ldr	r1, [r7, #8]
34003f56:	430b      	orrs	r3, r1
34003f58:	f8c2 30b0 	str.w	r3, [r2, #176]	@ 0xb0
        MODIFY_REG(hadc->Instance->AWD2HTR, ADC_AWD2HTR_HTR, tmp_awd_high_threshold_shifted);
34003f5c:	687b      	ldr	r3, [r7, #4]
34003f5e:	681b      	ldr	r3, [r3, #0]
34003f60:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
34003f64:	0ddb      	lsrs	r3, r3, #23
34003f66:	05db      	lsls	r3, r3, #23
34003f68:	687a      	ldr	r2, [r7, #4]
34003f6a:	6812      	ldr	r2, [r2, #0]
34003f6c:	68f9      	ldr	r1, [r7, #12]
34003f6e:	430b      	orrs	r3, r1
34003f70:	f8c2 30b4 	str.w	r3, [r2, #180]	@ 0xb4
34003f74:	e017      	b.n	34003fa6 <HAL_ADC_AnalogWDGConfig+0x38e>
      }
      else
      {
        /* Set ADC analog watchdog thresholds value of both thresholds high and low */
        MODIFY_REG(hadc->Instance->AWD3LTR, ADC_AWD3LTR_LTR, tmp_awd_low_threshold_shifted);
34003f76:	687b      	ldr	r3, [r7, #4]
34003f78:	681b      	ldr	r3, [r3, #0]
34003f7a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34003f7e:	0ddb      	lsrs	r3, r3, #23
34003f80:	05db      	lsls	r3, r3, #23
34003f82:	687a      	ldr	r2, [r7, #4]
34003f84:	6812      	ldr	r2, [r2, #0]
34003f86:	68b9      	ldr	r1, [r7, #8]
34003f88:	430b      	orrs	r3, r1
34003f8a:	f8c2 30b8 	str.w	r3, [r2, #184]	@ 0xb8
        MODIFY_REG(hadc->Instance->AWD3HTR, ADC_AWD3HTR_HTR, tmp_awd_high_threshold_shifted);
34003f8e:	687b      	ldr	r3, [r7, #4]
34003f90:	681b      	ldr	r3, [r3, #0]
34003f92:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34003f96:	0ddb      	lsrs	r3, r3, #23
34003f98:	05db      	lsls	r3, r3, #23
34003f9a:	687a      	ldr	r2, [r7, #4]
34003f9c:	6812      	ldr	r2, [r2, #0]
34003f9e:	68f9      	ldr	r1, [r7, #12]
34003fa0:	430b      	orrs	r3, r1
34003fa2:	f8c2 30bc 	str.w	r3, [r2, #188]	@ 0xbc
      }

      if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_2)
34003fa6:	683b      	ldr	r3, [r7, #0]
34003fa8:	681b      	ldr	r3, [r3, #0]
34003faa:	4a25      	ldr	r2, [pc, #148]	@ (34004040 <HAL_ADC_AnalogWDGConfig+0x428>)
34003fac:	4293      	cmp	r3, r2
34003fae:	d11a      	bne.n	34003fe6 <HAL_ADC_AnalogWDGConfig+0x3ce>
      {
        /* Update state, clear previous result related to AWD2 */
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_AWD2);
34003fb0:	687b      	ldr	r3, [r7, #4]
34003fb2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003fb4:	f423 3200 	bic.w	r2, r3, #131072	@ 0x20000
34003fb8:	687b      	ldr	r3, [r7, #4]
34003fba:	659a      	str	r2, [r3, #88]	@ 0x58

        /* Clear flag ADC analog watchdog */
        /* Note: Flag cleared Clear the ADC Analog watchdog flag to be ready  */
        /* to use for HAL_ADC_IRQHandler() or HAL_ADC_PollForEvent()          */
        /* (in case left enabled by previous ADC operations).                 */
        LL_ADC_ClearFlag_AWD2(hadc->Instance);
34003fbc:	687b      	ldr	r3, [r7, #4]
34003fbe:	681b      	ldr	r3, [r3, #0]
34003fc0:	4618      	mov	r0, r3
34003fc2:	f7fe ff18 	bl	34002df6 <LL_ADC_ClearFlag_AWD2>

        /* Configure ADC analog watchdog interrupt */
        if (pAnalogWDGConfig->ITMode == ENABLE)
34003fc6:	683b      	ldr	r3, [r7, #0]
34003fc8:	7b1b      	ldrb	r3, [r3, #12]
34003fca:	2b01      	cmp	r3, #1
34003fcc:	d105      	bne.n	34003fda <HAL_ADC_AnalogWDGConfig+0x3c2>
        {
          LL_ADC_EnableIT_AWD2(hadc->Instance);
34003fce:	687b      	ldr	r3, [r7, #4]
34003fd0:	681b      	ldr	r3, [r3, #0]
34003fd2:	4618      	mov	r0, r3
34003fd4:	f7fe ff3b 	bl	34002e4e <LL_ADC_EnableIT_AWD2>
    if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_1)
34003fd8:	e028      	b.n	3400402c <HAL_ADC_AnalogWDGConfig+0x414>
        }
        else
        {
          LL_ADC_DisableIT_AWD2(hadc->Instance);
34003fda:	687b      	ldr	r3, [r7, #4]
34003fdc:	681b      	ldr	r3, [r3, #0]
34003fde:	4618      	mov	r0, r3
34003fe0:	f7fe ff65 	bl	34002eae <LL_ADC_DisableIT_AWD2>
    if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_1)
34003fe4:	e022      	b.n	3400402c <HAL_ADC_AnalogWDGConfig+0x414>
      }
      /* (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_3) */
      else
      {
        /* Update state, clear previous result related to AWD3 */
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_AWD3);
34003fe6:	687b      	ldr	r3, [r7, #4]
34003fe8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34003fea:	f423 2280 	bic.w	r2, r3, #262144	@ 0x40000
34003fee:	687b      	ldr	r3, [r7, #4]
34003ff0:	659a      	str	r2, [r3, #88]	@ 0x58

        /* Clear flag ADC analog watchdog */
        /* Note: Flag cleared Clear the ADC Analog watchdog flag to be ready  */
        /* to use for HAL_ADC_IRQHandler() or HAL_ADC_PollForEvent()          */
        /* (in case left enabled by previous ADC operations).                 */
        LL_ADC_ClearFlag_AWD3(hadc->Instance);
34003ff2:	687b      	ldr	r3, [r7, #4]
34003ff4:	681b      	ldr	r3, [r3, #0]
34003ff6:	4618      	mov	r0, r3
34003ff8:	f7fe ff0b 	bl	34002e12 <LL_ADC_ClearFlag_AWD3>

        /* Configure ADC analog watchdog interrupt */
        if (pAnalogWDGConfig->ITMode == ENABLE)
34003ffc:	683b      	ldr	r3, [r7, #0]
34003ffe:	7b1b      	ldrb	r3, [r3, #12]
34004000:	2b01      	cmp	r3, #1
34004002:	d105      	bne.n	34004010 <HAL_ADC_AnalogWDGConfig+0x3f8>
        {
          LL_ADC_EnableIT_AWD3(hadc->Instance);
34004004:	687b      	ldr	r3, [r7, #4]
34004006:	681b      	ldr	r3, [r3, #0]
34004008:	4618      	mov	r0, r3
3400400a:	f7fe ff30 	bl	34002e6e <LL_ADC_EnableIT_AWD3>
    if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_1)
3400400e:	e00d      	b.n	3400402c <HAL_ADC_AnalogWDGConfig+0x414>
        }
        else
        {
          LL_ADC_DisableIT_AWD3(hadc->Instance);
34004010:	687b      	ldr	r3, [r7, #4]
34004012:	681b      	ldr	r3, [r3, #0]
34004014:	4618      	mov	r0, r3
34004016:	f7fe ff5a 	bl	34002ece <LL_ADC_DisableIT_AWD3>
    if (pAnalogWDGConfig->WatchdogNumber == ADC_ANALOGWATCHDOG_1)
3400401a:	e007      	b.n	3400402c <HAL_ADC_AnalogWDGConfig+0x414>
  /* If a conversion is on going on ADC group regular or injected, no update  */
  /* could be done on neither of the AWD configuration structure parameters.  */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
3400401c:	687b      	ldr	r3, [r7, #4]
3400401e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34004020:	f043 0220 	orr.w	r2, r3, #32
34004024:	687b      	ldr	r3, [r7, #4]
34004026:	659a      	str	r2, [r3, #88]	@ 0x58

    tmp_hal_status = HAL_ERROR;
34004028:	2301      	movs	r3, #1
3400402a:	77fb      	strb	r3, [r7, #31]
  }

  __HAL_UNLOCK(hadc);
3400402c:	687b      	ldr	r3, [r7, #4]
3400402e:	2200      	movs	r2, #0
34004030:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  return tmp_hal_status;
34004034:	7ffb      	ldrb	r3, [r7, #31]
}
34004036:	4618      	mov	r0, r3
34004038:	3720      	adds	r7, #32
3400403a:	46bd      	mov	sp, r7
3400403c:	bd80      	pop	{r7, pc}
3400403e:	bf00      	nop
34004040:	001fffff 	.word	0x001fffff

34004044 <ADC_ConversionStop>:
  *            @arg @ref ADC_INJECTED_GROUP          ADC injected conversion type.
  *            @arg @ref ADC_REGULAR_INJECTED_GROUP  ADC regular and injected conversion type.
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_ConversionStop(ADC_HandleTypeDef *hadc, uint32_t ConversionGroup)
{
34004044:	b580      	push	{r7, lr}
34004046:	b088      	sub	sp, #32
34004048:	af00      	add	r7, sp, #0
3400404a:	6078      	str	r0, [r7, #4]
3400404c:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  uint32_t conversion_timeout_cpu_cycles = 0UL;
3400404e:	2300      	movs	r3, #0
34004050:	61fb      	str	r3, [r7, #28]
  uint32_t conversion_group_reassigned = ConversionGroup;
34004052:	683b      	ldr	r3, [r7, #0]
34004054:	61bb      	str	r3, [r7, #24]
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_CONVERSION_GROUP(ConversionGroup));

  /* Verification if ADC is not already stopped (on regular and injected      */
  /* groups) to bypass this function if not needed.                           */
  tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
34004056:	687b      	ldr	r3, [r7, #4]
34004058:	681b      	ldr	r3, [r3, #0]
3400405a:	4618      	mov	r0, r3
3400405c:	f7fe fe86 	bl	34002d6c <LL_ADC_REG_IsConversionOngoing>
34004060:	6138      	str	r0, [r7, #16]
  tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
34004062:	687b      	ldr	r3, [r7, #4]
34004064:	681b      	ldr	r3, [r3, #0]
34004066:	4618      	mov	r0, r3
34004068:	f7fe fea5 	bl	34002db6 <LL_ADC_INJ_IsConversionOngoing>
3400406c:	60f8      	str	r0, [r7, #12]
  if ((tmp_adc_is_conversion_on_going_regular != 0UL)
3400406e:	693b      	ldr	r3, [r7, #16]
34004070:	2b00      	cmp	r3, #0
34004072:	d103      	bne.n	3400407c <ADC_ConversionStop+0x38>
      || (tmp_adc_is_conversion_on_going_injected != 0UL)
34004074:	68fb      	ldr	r3, [r7, #12]
34004076:	2b00      	cmp	r3, #0
34004078:	f000 8098 	beq.w	340041ac <ADC_ConversionStop+0x168>
    /* auto-delay mode.                                                       */
    /* In auto-injection mode, regular group stop ADC_CR_ADSTP is used (not   */
    /* injected group stop ADC_CR_JADSTP).                                    */
    /* Procedure to be followed: Wait until JEOS=1, clear JEOS, set ADSTP=1   */
    /* (see reference manual).                                                */
    if (((hadc->Instance->CFGR1 & ADC_CFGR1_JAUTO) != 0UL)
3400407c:	687b      	ldr	r3, [r7, #4]
3400407e:	681b      	ldr	r3, [r3, #0]
34004080:	68db      	ldr	r3, [r3, #12]
34004082:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34004086:	2b00      	cmp	r3, #0
34004088:	d02a      	beq.n	340040e0 <ADC_ConversionStop+0x9c>
        && (hadc->Init.ContinuousConvMode == ENABLE)
3400408a:	687b      	ldr	r3, [r7, #4]
3400408c:	7d5b      	ldrb	r3, [r3, #21]
3400408e:	2b01      	cmp	r3, #1
34004090:	d126      	bne.n	340040e0 <ADC_ConversionStop+0x9c>
        && (hadc->Init.LowPowerAutoWait == ENABLE)
34004092:	687b      	ldr	r3, [r7, #4]
34004094:	7d1b      	ldrb	r3, [r3, #20]
34004096:	2b01      	cmp	r3, #1
34004098:	d122      	bne.n	340040e0 <ADC_ConversionStop+0x9c>
       )
    {
      /* Use stop of regular group */
      conversion_group_reassigned = ADC_REGULAR_GROUP;
3400409a:	2301      	movs	r3, #1
3400409c:	61bb      	str	r3, [r7, #24]

      /* Wait until JEOS=1 (maximum Timeout: 4 injected conversions) */
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS) == 0UL)
3400409e:	e014      	b.n	340040ca <ADC_ConversionStop+0x86>
      {
        if (conversion_timeout_cpu_cycles >= (ADC_CONVERSION_TIME_MAX_CPU_CYCLES * 4UL))
340040a0:	69fb      	ldr	r3, [r7, #28]
340040a2:	4a45      	ldr	r2, [pc, #276]	@ (340041b8 <ADC_ConversionStop+0x174>)
340040a4:	4293      	cmp	r3, r2
340040a6:	d90d      	bls.n	340040c4 <ADC_ConversionStop+0x80>
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
340040a8:	687b      	ldr	r3, [r7, #4]
340040aa:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340040ac:	f043 0210 	orr.w	r2, r3, #16
340040b0:	687b      	ldr	r3, [r7, #4]
340040b2:	659a      	str	r2, [r3, #88]	@ 0x58

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
340040b4:	687b      	ldr	r3, [r7, #4]
340040b6:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
340040b8:	f043 0201 	orr.w	r2, r3, #1
340040bc:	687b      	ldr	r3, [r7, #4]
340040be:	65da      	str	r2, [r3, #92]	@ 0x5c

          return HAL_ERROR;
340040c0:	2301      	movs	r3, #1
340040c2:	e074      	b.n	340041ae <ADC_ConversionStop+0x16a>
        }
        conversion_timeout_cpu_cycles ++;
340040c4:	69fb      	ldr	r3, [r7, #28]
340040c6:	3301      	adds	r3, #1
340040c8:	61fb      	str	r3, [r7, #28]
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS) == 0UL)
340040ca:	687b      	ldr	r3, [r7, #4]
340040cc:	681b      	ldr	r3, [r3, #0]
340040ce:	681b      	ldr	r3, [r3, #0]
340040d0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
340040d4:	2b40      	cmp	r3, #64	@ 0x40
340040d6:	d1e3      	bne.n	340040a0 <ADC_ConversionStop+0x5c>
      }

      /* Clear JEOS */
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOS);
340040d8:	687b      	ldr	r3, [r7, #4]
340040da:	681b      	ldr	r3, [r3, #0]
340040dc:	2240      	movs	r2, #64	@ 0x40
340040de:	601a      	str	r2, [r3, #0]
    }

    /* Stop potential conversion on going on ADC group regular */
    if (conversion_group_reassigned != ADC_INJECTED_GROUP)
340040e0:	69bb      	ldr	r3, [r7, #24]
340040e2:	2b02      	cmp	r3, #2
340040e4:	d014      	beq.n	34004110 <ADC_ConversionStop+0xcc>
    {
      /* Software is allowed to set ADSTP only when ADSTART=1 and ADDIS=0 */
      if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) != 0UL)
340040e6:	687b      	ldr	r3, [r7, #4]
340040e8:	681b      	ldr	r3, [r3, #0]
340040ea:	4618      	mov	r0, r3
340040ec:	f7fe fe3e 	bl	34002d6c <LL_ADC_REG_IsConversionOngoing>
340040f0:	4603      	mov	r3, r0
340040f2:	2b00      	cmp	r3, #0
340040f4:	d00c      	beq.n	34004110 <ADC_ConversionStop+0xcc>
      {
        if (LL_ADC_IsDisableOngoing(hadc->Instance) == 0UL)
340040f6:	687b      	ldr	r3, [r7, #4]
340040f8:	681b      	ldr	r3, [r3, #0]
340040fa:	4618      	mov	r0, r3
340040fc:	f7fe fdff 	bl	34002cfe <LL_ADC_IsDisableOngoing>
34004100:	4603      	mov	r3, r0
34004102:	2b00      	cmp	r3, #0
34004104:	d104      	bne.n	34004110 <ADC_ConversionStop+0xcc>
        {
          /* Stop ADC group regular conversion */
          LL_ADC_REG_StopConversion(hadc->Instance);
34004106:	687b      	ldr	r3, [r7, #4]
34004108:	681b      	ldr	r3, [r3, #0]
3400410a:	4618      	mov	r0, r3
3400410c:	f7fe fe1c 	bl	34002d48 <LL_ADC_REG_StopConversion>
        }
      }
    }

    /* Stop potential conversion on going on ADC group injected */
    if (conversion_group_reassigned != ADC_REGULAR_GROUP)
34004110:	69bb      	ldr	r3, [r7, #24]
34004112:	2b01      	cmp	r3, #1
34004114:	d014      	beq.n	34004140 <ADC_ConversionStop+0xfc>
    {
      /* Software is allowed to set JADSTP only when JADSTART=1 and ADDIS=0 */
      if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) != 0UL)
34004116:	687b      	ldr	r3, [r7, #4]
34004118:	681b      	ldr	r3, [r3, #0]
3400411a:	4618      	mov	r0, r3
3400411c:	f7fe fe4b 	bl	34002db6 <LL_ADC_INJ_IsConversionOngoing>
34004120:	4603      	mov	r3, r0
34004122:	2b00      	cmp	r3, #0
34004124:	d00c      	beq.n	34004140 <ADC_ConversionStop+0xfc>
      {
        if (LL_ADC_IsDisableOngoing(hadc->Instance) == 0UL)
34004126:	687b      	ldr	r3, [r7, #4]
34004128:	681b      	ldr	r3, [r3, #0]
3400412a:	4618      	mov	r0, r3
3400412c:	f7fe fde7 	bl	34002cfe <LL_ADC_IsDisableOngoing>
34004130:	4603      	mov	r3, r0
34004132:	2b00      	cmp	r3, #0
34004134:	d104      	bne.n	34004140 <ADC_ConversionStop+0xfc>
        {
          /* Stop ADC group injected conversion */
          LL_ADC_INJ_StopConversion(hadc->Instance);
34004136:	687b      	ldr	r3, [r7, #4]
34004138:	681b      	ldr	r3, [r3, #0]
3400413a:	4618      	mov	r0, r3
3400413c:	f7fe fe29 	bl	34002d92 <LL_ADC_INJ_StopConversion>
        }
      }
    }

    /* Selection of start and stop bits with respect to the regular or injected group */
    switch (conversion_group_reassigned)
34004140:	69bb      	ldr	r3, [r7, #24]
34004142:	2b02      	cmp	r3, #2
34004144:	d005      	beq.n	34004152 <ADC_ConversionStop+0x10e>
34004146:	69bb      	ldr	r3, [r7, #24]
34004148:	2b03      	cmp	r3, #3
3400414a:	d105      	bne.n	34004158 <ADC_ConversionStop+0x114>
    {
      case ADC_REGULAR_INJECTED_GROUP:
        tmp_ADC_CR_ADSTART_JADSTART = (ADC_CR_ADSTART | ADC_CR_JADSTART);
3400414c:	230c      	movs	r3, #12
3400414e:	617b      	str	r3, [r7, #20]
        break;
34004150:	e005      	b.n	3400415e <ADC_ConversionStop+0x11a>
      case ADC_INJECTED_GROUP:
        tmp_ADC_CR_ADSTART_JADSTART = ADC_CR_JADSTART;
34004152:	2308      	movs	r3, #8
34004154:	617b      	str	r3, [r7, #20]
        break;
34004156:	e002      	b.n	3400415e <ADC_ConversionStop+0x11a>
      /* Case ADC_REGULAR_GROUP only*/
      default:
        tmp_ADC_CR_ADSTART_JADSTART = ADC_CR_ADSTART;
34004158:	2304      	movs	r3, #4
3400415a:	617b      	str	r3, [r7, #20]
        break;
3400415c:	bf00      	nop
    }

    /* Wait for conversion effectively stopped */
    tickstart = HAL_GetTick();
3400415e:	f7fe f9d3 	bl	34002508 <HAL_GetTick>
34004162:	60b8      	str	r0, [r7, #8]

    while ((hadc->Instance->CR & tmp_ADC_CR_ADSTART_JADSTART) != 0UL)
34004164:	e01b      	b.n	3400419e <ADC_ConversionStop+0x15a>
    {
      if ((HAL_GetTick() - tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
34004166:	f7fe f9cf 	bl	34002508 <HAL_GetTick>
3400416a:	4602      	mov	r2, r0
3400416c:	68bb      	ldr	r3, [r7, #8]
3400416e:	1ad3      	subs	r3, r2, r3
34004170:	2b05      	cmp	r3, #5
34004172:	d914      	bls.n	3400419e <ADC_ConversionStop+0x15a>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if ((hadc->Instance->CR & tmp_ADC_CR_ADSTART_JADSTART) != 0UL)
34004174:	687b      	ldr	r3, [r7, #4]
34004176:	681b      	ldr	r3, [r3, #0]
34004178:	689a      	ldr	r2, [r3, #8]
3400417a:	697b      	ldr	r3, [r7, #20]
3400417c:	4013      	ands	r3, r2
3400417e:	2b00      	cmp	r3, #0
34004180:	d00d      	beq.n	3400419e <ADC_ConversionStop+0x15a>
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
34004182:	687b      	ldr	r3, [r7, #4]
34004184:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34004186:	f043 0210 	orr.w	r2, r3, #16
3400418a:	687b      	ldr	r3, [r7, #4]
3400418c:	659a      	str	r2, [r3, #88]	@ 0x58

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
3400418e:	687b      	ldr	r3, [r7, #4]
34004190:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34004192:	f043 0201 	orr.w	r2, r3, #1
34004196:	687b      	ldr	r3, [r7, #4]
34004198:	65da      	str	r2, [r3, #92]	@ 0x5c

          return HAL_ERROR;
3400419a:	2301      	movs	r3, #1
3400419c:	e007      	b.n	340041ae <ADC_ConversionStop+0x16a>
    while ((hadc->Instance->CR & tmp_ADC_CR_ADSTART_JADSTART) != 0UL)
3400419e:	687b      	ldr	r3, [r7, #4]
340041a0:	681b      	ldr	r3, [r3, #0]
340041a2:	689a      	ldr	r2, [r3, #8]
340041a4:	697b      	ldr	r3, [r7, #20]
340041a6:	4013      	ands	r3, r2
340041a8:	2b00      	cmp	r3, #0
340041aa:	d1dc      	bne.n	34004166 <ADC_ConversionStop+0x122>
    }

  }

  /* Return HAL status */
  return HAL_OK;
340041ac:	2300      	movs	r3, #0
}
340041ae:	4618      	mov	r0, r3
340041b0:	3720      	adds	r7, #32
340041b2:	46bd      	mov	sp, r7
340041b4:	bd80      	pop	{r7, pc}
340041b6:	bf00      	nop
340041b8:	a33fffff 	.word	0xa33fffff

340041bc <ADC_Enable>:
  *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef *hadc)
{
340041bc:	b580      	push	{r7, lr}
340041be:	b084      	sub	sp, #16
340041c0:	af00      	add	r7, sp, #0
340041c2:	6078      	str	r0, [r7, #4]

  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
340041c4:	687b      	ldr	r3, [r7, #4]
340041c6:	681b      	ldr	r3, [r3, #0]
340041c8:	4618      	mov	r0, r3
340041ca:	f7fe fd85 	bl	34002cd8 <LL_ADC_IsEnabled>
340041ce:	4603      	mov	r3, r0
340041d0:	2b00      	cmp	r3, #0
340041d2:	d14d      	bne.n	34004270 <ADC_Enable+0xb4>
  {
    /* Check if conditions to enable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_JADSTP | ADC_CR_ADSTP | ADC_CR_JADSTART | ADC_CR_ADSTART
340041d4:	687b      	ldr	r3, [r7, #4]
340041d6:	681b      	ldr	r3, [r3, #0]
340041d8:	689a      	ldr	r2, [r3, #8]
340041da:	4b28      	ldr	r3, [pc, #160]	@ (3400427c <ADC_Enable+0xc0>)
340041dc:	4013      	ands	r3, r2
340041de:	2b00      	cmp	r3, #0
340041e0:	d00d      	beq.n	340041fe <ADC_Enable+0x42>
                               | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
340041e2:	687b      	ldr	r3, [r7, #4]
340041e4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340041e6:	f043 0210 	orr.w	r2, r3, #16
340041ea:	687b      	ldr	r3, [r7, #4]
340041ec:	659a      	str	r2, [r3, #88]	@ 0x58

      /* Set ADC error code to ADC peripheral internal error */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
340041ee:	687b      	ldr	r3, [r7, #4]
340041f0:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
340041f2:	f043 0201 	orr.w	r2, r3, #1
340041f6:	687b      	ldr	r3, [r7, #4]
340041f8:	65da      	str	r2, [r3, #92]	@ 0x5c

      return HAL_ERROR;
340041fa:	2301      	movs	r3, #1
340041fc:	e039      	b.n	34004272 <ADC_Enable+0xb6>
    }

    /* Enable the ADC peripheral */
    LL_ADC_Enable(hadc->Instance);
340041fe:	687b      	ldr	r3, [r7, #4]
34004200:	681b      	ldr	r3, [r3, #0]
34004202:	4618      	mov	r0, r3
34004204:	f7fe fd44 	bl	34002c90 <LL_ADC_Enable>

    /* Wait for ADC effectively enabled */
    tickstart = HAL_GetTick();
34004208:	f7fe f97e 	bl	34002508 <HAL_GetTick>
3400420c:	60f8      	str	r0, [r7, #12]

    while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
3400420e:	e028      	b.n	34004262 <ADC_Enable+0xa6>
          The workaround is to continue setting ADEN until ADRDY is becomes 1.
          Additionally, ADC_ENABLE_TIMEOUT is defined to encompass this
          4 ADC clock cycle duration */
      /* Note: Test of ADC enabled required due to hardware constraint to     */
      /*       not enable ADC if already enabled.                             */
      if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
34004210:	687b      	ldr	r3, [r7, #4]
34004212:	681b      	ldr	r3, [r3, #0]
34004214:	4618      	mov	r0, r3
34004216:	f7fe fd5f 	bl	34002cd8 <LL_ADC_IsEnabled>
3400421a:	4603      	mov	r3, r0
3400421c:	2b00      	cmp	r3, #0
3400421e:	d104      	bne.n	3400422a <ADC_Enable+0x6e>
      {
        LL_ADC_Enable(hadc->Instance);
34004220:	687b      	ldr	r3, [r7, #4]
34004222:	681b      	ldr	r3, [r3, #0]
34004224:	4618      	mov	r0, r3
34004226:	f7fe fd33 	bl	34002c90 <LL_ADC_Enable>
      }

      if ((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
3400422a:	f7fe f96d 	bl	34002508 <HAL_GetTick>
3400422e:	4602      	mov	r2, r0
34004230:	68fb      	ldr	r3, [r7, #12]
34004232:	1ad3      	subs	r3, r2, r3
34004234:	2b02      	cmp	r3, #2
34004236:	d914      	bls.n	34004262 <ADC_Enable+0xa6>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
34004238:	687b      	ldr	r3, [r7, #4]
3400423a:	681b      	ldr	r3, [r3, #0]
3400423c:	681b      	ldr	r3, [r3, #0]
3400423e:	f003 0301 	and.w	r3, r3, #1
34004242:	2b01      	cmp	r3, #1
34004244:	d00d      	beq.n	34004262 <ADC_Enable+0xa6>
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
34004246:	687b      	ldr	r3, [r7, #4]
34004248:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400424a:	f043 0210 	orr.w	r2, r3, #16
3400424e:	687b      	ldr	r3, [r7, #4]
34004250:	659a      	str	r2, [r3, #88]	@ 0x58

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
34004252:	687b      	ldr	r3, [r7, #4]
34004254:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
34004256:	f043 0201 	orr.w	r2, r3, #1
3400425a:	687b      	ldr	r3, [r7, #4]
3400425c:	65da      	str	r2, [r3, #92]	@ 0x5c

          return HAL_ERROR;
3400425e:	2301      	movs	r3, #1
34004260:	e007      	b.n	34004272 <ADC_Enable+0xb6>
    while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
34004262:	687b      	ldr	r3, [r7, #4]
34004264:	681b      	ldr	r3, [r3, #0]
34004266:	681b      	ldr	r3, [r3, #0]
34004268:	f003 0301 	and.w	r3, r3, #1
3400426c:	2b01      	cmp	r3, #1
3400426e:	d1cf      	bne.n	34004210 <ADC_Enable+0x54>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
34004270:	2300      	movs	r3, #0
}
34004272:	4618      	mov	r0, r3
34004274:	3710      	adds	r7, #16
34004276:	46bd      	mov	sp, r7
34004278:	bd80      	pop	{r7, pc}
3400427a:	bf00      	nop
3400427c:	8000003f 	.word	0x8000003f

34004280 <ADC_Disable>:
  *         stopped.
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef *hadc)
{
34004280:	b580      	push	{r7, lr}
34004282:	b084      	sub	sp, #16
34004284:	af00      	add	r7, sp, #0
34004286:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
34004288:	687b      	ldr	r3, [r7, #4]
3400428a:	681b      	ldr	r3, [r3, #0]
3400428c:	4618      	mov	r0, r3
3400428e:	f7fe fd36 	bl	34002cfe <LL_ADC_IsDisableOngoing>
34004292:	60f8      	str	r0, [r7, #12]

  /* Verification if ADC is not already disabled:                             */
  /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */
  /*       disabled.                                                          */
  if ((LL_ADC_IsEnabled(hadc->Instance) != 0UL)
34004294:	687b      	ldr	r3, [r7, #4]
34004296:	681b      	ldr	r3, [r3, #0]
34004298:	4618      	mov	r0, r3
3400429a:	f7fe fd1d 	bl	34002cd8 <LL_ADC_IsEnabled>
3400429e:	4603      	mov	r3, r0
340042a0:	2b00      	cmp	r3, #0
340042a2:	d047      	beq.n	34004334 <ADC_Disable+0xb4>
      && (tmp_adc_is_disable_on_going == 0UL)
340042a4:	68fb      	ldr	r3, [r7, #12]
340042a6:	2b00      	cmp	r3, #0
340042a8:	d144      	bne.n	34004334 <ADC_Disable+0xb4>
     )
  {
    /* Check if conditions to disable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
340042aa:	687b      	ldr	r3, [r7, #4]
340042ac:	681b      	ldr	r3, [r3, #0]
340042ae:	689b      	ldr	r3, [r3, #8]
340042b0:	f003 030d 	and.w	r3, r3, #13
340042b4:	2b01      	cmp	r3, #1
340042b6:	d10c      	bne.n	340042d2 <ADC_Disable+0x52>
    {
      /* Disable the ADC peripheral */
      LL_ADC_Disable(hadc->Instance);
340042b8:	687b      	ldr	r3, [r7, #4]
340042ba:	681b      	ldr	r3, [r3, #0]
340042bc:	4618      	mov	r0, r3
340042be:	f7fe fcf9 	bl	34002cb4 <LL_ADC_Disable>
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
340042c2:	687b      	ldr	r3, [r7, #4]
340042c4:	681b      	ldr	r3, [r3, #0]
340042c6:	2203      	movs	r2, #3
340042c8:	601a      	str	r2, [r3, #0]
      return HAL_ERROR;
    }

    /* Wait for ADC effectively disabled */
    /* Get tick count */
    tickstart = HAL_GetTick();
340042ca:	f7fe f91d 	bl	34002508 <HAL_GetTick>
340042ce:	60b8      	str	r0, [r7, #8]

    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
340042d0:	e029      	b.n	34004326 <ADC_Disable+0xa6>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
340042d2:	687b      	ldr	r3, [r7, #4]
340042d4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
340042d6:	f043 0210 	orr.w	r2, r3, #16
340042da:	687b      	ldr	r3, [r7, #4]
340042dc:	659a      	str	r2, [r3, #88]	@ 0x58
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
340042de:	687b      	ldr	r3, [r7, #4]
340042e0:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
340042e2:	f043 0201 	orr.w	r2, r3, #1
340042e6:	687b      	ldr	r3, [r7, #4]
340042e8:	65da      	str	r2, [r3, #92]	@ 0x5c
      return HAL_ERROR;
340042ea:	2301      	movs	r3, #1
340042ec:	e023      	b.n	34004336 <ADC_Disable+0xb6>
    {
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
340042ee:	f7fe f90b 	bl	34002508 <HAL_GetTick>
340042f2:	4602      	mov	r2, r0
340042f4:	68bb      	ldr	r3, [r7, #8]
340042f6:	1ad3      	subs	r3, r2, r3
340042f8:	2b02      	cmp	r3, #2
340042fa:	d914      	bls.n	34004326 <ADC_Disable+0xa6>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
340042fc:	687b      	ldr	r3, [r7, #4]
340042fe:	681b      	ldr	r3, [r3, #0]
34004300:	689b      	ldr	r3, [r3, #8]
34004302:	f003 0301 	and.w	r3, r3, #1
34004306:	2b00      	cmp	r3, #0
34004308:	d00d      	beq.n	34004326 <ADC_Disable+0xa6>
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
3400430a:	687b      	ldr	r3, [r7, #4]
3400430c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
3400430e:	f043 0210 	orr.w	r2, r3, #16
34004312:	687b      	ldr	r3, [r7, #4]
34004314:	659a      	str	r2, [r3, #88]	@ 0x58

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
34004316:	687b      	ldr	r3, [r7, #4]
34004318:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
3400431a:	f043 0201 	orr.w	r2, r3, #1
3400431e:	687b      	ldr	r3, [r7, #4]
34004320:	65da      	str	r2, [r3, #92]	@ 0x5c

          return HAL_ERROR;
34004322:	2301      	movs	r3, #1
34004324:	e007      	b.n	34004336 <ADC_Disable+0xb6>
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
34004326:	687b      	ldr	r3, [r7, #4]
34004328:	681b      	ldr	r3, [r3, #0]
3400432a:	689b      	ldr	r3, [r3, #8]
3400432c:	f003 0301 	and.w	r3, r3, #1
34004330:	2b00      	cmp	r3, #0
34004332:	d1dc      	bne.n	340042ee <ADC_Disable+0x6e>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
34004334:	2300      	movs	r3, #0
}
34004336:	4618      	mov	r0, r3
34004338:	3710      	adds	r7, #16
3400433a:	46bd      	mov	sp, r7
3400433c:	bd80      	pop	{r7, pc}

3400433e <LL_ADC_IsEnabled>:
{
3400433e:	b480      	push	{r7}
34004340:	b083      	sub	sp, #12
34004342:	af00      	add	r7, sp, #0
34004344:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
34004346:	687b      	ldr	r3, [r7, #4]
34004348:	689b      	ldr	r3, [r3, #8]
3400434a:	f003 0301 	and.w	r3, r3, #1
3400434e:	2b01      	cmp	r3, #1
34004350:	d101      	bne.n	34004356 <LL_ADC_IsEnabled+0x18>
34004352:	2301      	movs	r3, #1
34004354:	e000      	b.n	34004358 <LL_ADC_IsEnabled+0x1a>
34004356:	2300      	movs	r3, #0
}
34004358:	4618      	mov	r0, r3
3400435a:	370c      	adds	r7, #12
3400435c:	46bd      	mov	sp, r7
3400435e:	f85d 7b04 	ldr.w	r7, [sp], #4
34004362:	4770      	bx	lr

34004364 <LL_ADC_REG_IsConversionOngoing>:
{
34004364:	b480      	push	{r7}
34004366:	b083      	sub	sp, #12
34004368:	af00      	add	r7, sp, #0
3400436a:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
3400436c:	687b      	ldr	r3, [r7, #4]
3400436e:	689b      	ldr	r3, [r3, #8]
34004370:	f003 0304 	and.w	r3, r3, #4
34004374:	2b04      	cmp	r3, #4
34004376:	d101      	bne.n	3400437c <LL_ADC_REG_IsConversionOngoing+0x18>
34004378:	2301      	movs	r3, #1
3400437a:	e000      	b.n	3400437e <LL_ADC_REG_IsConversionOngoing+0x1a>
3400437c:	2300      	movs	r3, #0
}
3400437e:	4618      	mov	r0, r3
34004380:	370c      	adds	r7, #12
34004382:	46bd      	mov	sp, r7
34004384:	f85d 7b04 	ldr.w	r7, [sp], #4
34004388:	4770      	bx	lr

3400438a <HAL_ADCEx_InjectedConvCpltCallback>:
  * @brief  Injected conversion complete callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef *hadc)
{
3400438a:	b480      	push	{r7}
3400438c:	b083      	sub	sp, #12
3400438e:	af00      	add	r7, sp, #0
34004390:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_InjectedConvCpltCallback must be implemented in the user file.
  */
}
34004392:	bf00      	nop
34004394:	370c      	adds	r7, #12
34004396:	46bd      	mov	sp, r7
34004398:	f85d 7b04 	ldr.w	r7, [sp], #4
3400439c:	4770      	bx	lr

3400439e <HAL_ADCEx_LevelOutOfWindow2Callback>:
  * @brief  Analog watchdog 2 callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_LevelOutOfWindow2Callback(ADC_HandleTypeDef *hadc)
{
3400439e:	b480      	push	{r7}
340043a0:	b083      	sub	sp, #12
340043a2:	af00      	add	r7, sp, #0
340043a4:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_LevelOutOfWindow2Callback must be implemented in the user file.
  */
}
340043a6:	bf00      	nop
340043a8:	370c      	adds	r7, #12
340043aa:	46bd      	mov	sp, r7
340043ac:	f85d 7b04 	ldr.w	r7, [sp], #4
340043b0:	4770      	bx	lr

340043b2 <HAL_ADCEx_LevelOutOfWindow3Callback>:
  * @brief  Analog watchdog 3 callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_LevelOutOfWindow3Callback(ADC_HandleTypeDef *hadc)
{
340043b2:	b480      	push	{r7}
340043b4:	b083      	sub	sp, #12
340043b6:	af00      	add	r7, sp, #0
340043b8:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_LevelOutOfWindow3Callback must be implemented in the user file.
  */
}
340043ba:	bf00      	nop
340043bc:	370c      	adds	r7, #12
340043be:	46bd      	mov	sp, r7
340043c0:	f85d 7b04 	ldr.w	r7, [sp], #4
340043c4:	4770      	bx	lr

340043c6 <HAL_ADCEx_EndOfSamplingCallback>:
  * @brief  End Of Sampling callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_EndOfSamplingCallback(ADC_HandleTypeDef *hadc)
{
340043c6:	b480      	push	{r7}
340043c8:	b083      	sub	sp, #12
340043ca:	af00      	add	r7, sp, #0
340043cc:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_EndOfSamplingCallback must be implemented in the user file.
  */
}
340043ce:	bf00      	nop
340043d0:	370c      	adds	r7, #12
340043d2:	46bd      	mov	sp, r7
340043d4:	f85d 7b04 	ldr.w	r7, [sp], #4
340043d8:	4770      	bx	lr
	...

340043dc <HAL_ADCEx_MultiModeConfigChannel>:
  * @param pMultimode Structure of ADC multimode configuration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef *hadc,
                                                   const ADC_MultiModeTypeDef *pMultimode)
{
340043dc:	b590      	push	{r4, r7, lr}
340043de:	b09f      	sub	sp, #124	@ 0x7c
340043e0:	af00      	add	r7, sp, #0
340043e2:	6078      	str	r0, [r7, #4]
340043e4:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
340043e6:	2300      	movs	r3, #0
340043e8:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
    assert_param(IS_ADC_DUAL_DATA_MODE(pMultimode->DualModeData));
    assert_param(IS_ADC_SAMPLING_DELAY(pMultimode->TwoSamplingDelay));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
340043ec:	687b      	ldr	r3, [r7, #4]
340043ee:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
340043f2:	2b01      	cmp	r3, #1
340043f4:	d101      	bne.n	340043fa <HAL_ADCEx_MultiModeConfigChannel+0x1e>
340043f6:	2302      	movs	r3, #2
340043f8:	e095      	b.n	34004526 <HAL_ADCEx_MultiModeConfigChannel+0x14a>
340043fa:	687b      	ldr	r3, [r7, #4]
340043fc:	2201      	movs	r2, #1
340043fe:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  /* Temporary handle minimum initialization */
  __HAL_ADC_RESET_HANDLE_STATE(&tmphadcSlave);
34004402:	2300      	movs	r3, #0
34004404:	667b      	str	r3, [r7, #100]	@ 0x64
  ADC_CLEAR_ERRORCODE(&tmphadcSlave);
34004406:	2300      	movs	r3, #0
34004408:	66bb      	str	r3, [r7, #104]	@ 0x68

  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
3400440a:	687b      	ldr	r3, [r7, #4]
3400440c:	681b      	ldr	r3, [r3, #0]
3400440e:	4a48      	ldr	r2, [pc, #288]	@ (34004530 <HAL_ADCEx_MultiModeConfigChannel+0x154>)
34004410:	4293      	cmp	r3, r2
34004412:	d102      	bne.n	3400441a <HAL_ADCEx_MultiModeConfigChannel+0x3e>
34004414:	4b47      	ldr	r3, [pc, #284]	@ (34004534 <HAL_ADCEx_MultiModeConfigChannel+0x158>)
34004416:	60fb      	str	r3, [r7, #12]
34004418:	e001      	b.n	3400441e <HAL_ADCEx_MultiModeConfigChannel+0x42>
3400441a:	2300      	movs	r3, #0
3400441c:	60fb      	str	r3, [r7, #12]

  if (tmphadcSlave.Instance == NULL)
3400441e:	68fb      	ldr	r3, [r7, #12]
34004420:	2b00      	cmp	r3, #0
34004422:	d10b      	bne.n	3400443c <HAL_ADCEx_MultiModeConfigChannel+0x60>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
34004424:	687b      	ldr	r3, [r7, #4]
34004426:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34004428:	f043 0220 	orr.w	r2, r3, #32
3400442c:	687b      	ldr	r3, [r7, #4]
3400442e:	659a      	str	r2, [r3, #88]	@ 0x58

    __HAL_UNLOCK(hadc);
34004430:	687b      	ldr	r3, [r7, #4]
34004432:	2200      	movs	r2, #0
34004434:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    return HAL_ERROR;
34004438:	2301      	movs	r3, #1
3400443a:	e074      	b.n	34004526 <HAL_ADCEx_MultiModeConfigChannel+0x14a>
  }

  /* ADC must be disabled to set configuration bits */
  if (LL_ADC_IsEnabled(hadc->Instance) != 0UL)
3400443c:	687b      	ldr	r3, [r7, #4]
3400443e:	681b      	ldr	r3, [r3, #0]
34004440:	4618      	mov	r0, r3
34004442:	f7ff ff7c 	bl	3400433e <LL_ADC_IsEnabled>
34004446:	4603      	mov	r3, r0
34004448:	2b00      	cmp	r3, #0
3400444a:	d008      	beq.n	3400445e <HAL_ADCEx_MultiModeConfigChannel+0x82>
  {
    if (LL_ADC_IsEnabled(tmphadcSlave.Instance) != 0UL)
3400444c:	68fb      	ldr	r3, [r7, #12]
3400444e:	4618      	mov	r0, r3
34004450:	f7ff ff75 	bl	3400433e <LL_ADC_IsEnabled>
34004454:	4603      	mov	r3, r0
34004456:	2b00      	cmp	r3, #0
34004458:	d001      	beq.n	3400445e <HAL_ADCEx_MultiModeConfigChannel+0x82>
    {
      return HAL_ERROR;
3400445a:	2301      	movs	r3, #1
3400445c:	e063      	b.n	34004526 <HAL_ADCEx_MultiModeConfigChannel+0x14a>
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Multimode DMA configuration                                           */
  /*  - Multimode DMA mode                                                    */
  tmphadcSlave_conversion_on_going = LL_ADC_REG_IsConversionOngoing((&tmphadcSlave)->Instance);
3400445e:	68fb      	ldr	r3, [r7, #12]
34004460:	4618      	mov	r0, r3
34004462:	f7ff ff7f 	bl	34004364 <LL_ADC_REG_IsConversionOngoing>
34004466:	6738      	str	r0, [r7, #112]	@ 0x70
  if ((LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
34004468:	687b      	ldr	r3, [r7, #4]
3400446a:	681b      	ldr	r3, [r3, #0]
3400446c:	4618      	mov	r0, r3
3400446e:	f7ff ff79 	bl	34004364 <LL_ADC_REG_IsConversionOngoing>
34004472:	4603      	mov	r3, r0
34004474:	2b00      	cmp	r3, #0
34004476:	d145      	bne.n	34004504 <HAL_ADCEx_MultiModeConfigChannel+0x128>
      && (tmphadcSlave_conversion_on_going == 0UL))
34004478:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
3400447a:	2b00      	cmp	r3, #0
3400447c:	d142      	bne.n	34004504 <HAL_ADCEx_MultiModeConfigChannel+0x128>
  {
    /* Pointer to the common control register */
    tmpADC_Common = __LL_ADC_COMMON_INSTANCE(hadc->Instance);
3400447e:	4b2e      	ldr	r3, [pc, #184]	@ (34004538 <HAL_ADCEx_MultiModeConfigChannel+0x15c>)
34004480:	66fb      	str	r3, [r7, #108]	@ 0x6c

    /* If multimode is selected, configure all multimode parameters.          */
    /* Otherwise, reset multimode parameters (can be used in case of          */
    /* transition from multimode to independent mode).                        */
    if (pMultimode->Mode != ADC_MODE_INDEPENDENT)
34004482:	683b      	ldr	r3, [r7, #0]
34004484:	681b      	ldr	r3, [r3, #0]
34004486:	2b00      	cmp	r3, #0
34004488:	d022      	beq.n	340044d0 <HAL_ADCEx_MultiModeConfigChannel+0xf4>
    {
      MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_DAMDF, pMultimode->DualModeData);
3400448a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400448c:	689b      	ldr	r3, [r3, #8]
3400448e:	f423 4240 	bic.w	r2, r3, #49152	@ 0xc000
34004492:	683b      	ldr	r3, [r7, #0]
34004494:	685b      	ldr	r3, [r3, #4]
34004496:	431a      	orrs	r2, r3
34004498:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
3400449a:	609a      	str	r2, [r3, #8]
      /*      from 1 to 10 clock cycles for 10 bits,                              */
      /*      from 1 to 8 clock cycles for 8 bits                                 */
      /*      from 1 to 6 clock cycles for 6 bits                                 */
      /*    If a higher delay is selected, it will be clipped to maximum delay    */
      /*    range                                                                 */
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
3400449c:	4824      	ldr	r0, [pc, #144]	@ (34004530 <HAL_ADCEx_MultiModeConfigChannel+0x154>)
3400449e:	f7ff ff4e 	bl	3400433e <LL_ADC_IsEnabled>
340044a2:	4604      	mov	r4, r0
340044a4:	4823      	ldr	r0, [pc, #140]	@ (34004534 <HAL_ADCEx_MultiModeConfigChannel+0x158>)
340044a6:	f7ff ff4a 	bl	3400433e <LL_ADC_IsEnabled>
340044aa:	4603      	mov	r3, r0
340044ac:	4323      	orrs	r3, r4
340044ae:	2b00      	cmp	r3, #0
340044b0:	d132      	bne.n	34004518 <HAL_ADCEx_MultiModeConfigChannel+0x13c>
      {
        MODIFY_REG(tmpADC_Common->CCR,
340044b2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
340044b4:	689b      	ldr	r3, [r3, #8]
340044b6:	f423 6371 	bic.w	r3, r3, #3856	@ 0xf10
340044ba:	f023 030f 	bic.w	r3, r3, #15
340044be:	683a      	ldr	r2, [r7, #0]
340044c0:	6811      	ldr	r1, [r2, #0]
340044c2:	683a      	ldr	r2, [r7, #0]
340044c4:	6892      	ldr	r2, [r2, #8]
340044c6:	430a      	orrs	r2, r1
340044c8:	431a      	orrs	r2, r3
340044ca:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
340044cc:	609a      	str	r2, [r3, #8]
    if (pMultimode->Mode != ADC_MODE_INDEPENDENT)
340044ce:	e023      	b.n	34004518 <HAL_ADCEx_MultiModeConfigChannel+0x13c>
                  );
      }
    }
    else /* ADC_MODE_INDEPENDENT */
    {
      CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DAMDF);
340044d0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
340044d2:	689b      	ldr	r3, [r3, #8]
340044d4:	f423 4240 	bic.w	r2, r3, #49152	@ 0xc000
340044d8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
340044da:	609a      	str	r2, [r3, #8]

      /* Parameters that can be updated only when ADC is disabled:                */
      /*  - Multimode mode selection                                              */
      /*  - Multimode delay                                                       */
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
340044dc:	4814      	ldr	r0, [pc, #80]	@ (34004530 <HAL_ADCEx_MultiModeConfigChannel+0x154>)
340044de:	f7ff ff2e 	bl	3400433e <LL_ADC_IsEnabled>
340044e2:	4604      	mov	r4, r0
340044e4:	4813      	ldr	r0, [pc, #76]	@ (34004534 <HAL_ADCEx_MultiModeConfigChannel+0x158>)
340044e6:	f7ff ff2a 	bl	3400433e <LL_ADC_IsEnabled>
340044ea:	4603      	mov	r3, r0
340044ec:	4323      	orrs	r3, r4
340044ee:	2b00      	cmp	r3, #0
340044f0:	d112      	bne.n	34004518 <HAL_ADCEx_MultiModeConfigChannel+0x13c>
      {
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
340044f2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
340044f4:	689b      	ldr	r3, [r3, #8]
340044f6:	f423 6371 	bic.w	r3, r3, #3856	@ 0xf10
340044fa:	f023 030f 	bic.w	r3, r3, #15
340044fe:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
34004500:	6093      	str	r3, [r2, #8]
    if (pMultimode->Mode != ADC_MODE_INDEPENDENT)
34004502:	e009      	b.n	34004518 <HAL_ADCEx_MultiModeConfigChannel+0x13c>
  /* If one of the ADC sharing the same common group is enabled, no update    */
  /* could be done on neither of the multimode structure parameters.          */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
34004504:	687b      	ldr	r3, [r7, #4]
34004506:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
34004508:	f043 0220 	orr.w	r2, r3, #32
3400450c:	687b      	ldr	r3, [r7, #4]
3400450e:	659a      	str	r2, [r3, #88]	@ 0x58

    tmp_hal_status = HAL_ERROR;
34004510:	2301      	movs	r3, #1
34004512:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
34004516:	e000      	b.n	3400451a <HAL_ADCEx_MultiModeConfigChannel+0x13e>
    if (pMultimode->Mode != ADC_MODE_INDEPENDENT)
34004518:	bf00      	nop
  }

  __HAL_UNLOCK(hadc);
3400451a:	687b      	ldr	r3, [r7, #4]
3400451c:	2200      	movs	r2, #0
3400451e:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

  return tmp_hal_status;
34004522:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
}
34004526:	4618      	mov	r0, r3
34004528:	377c      	adds	r7, #124	@ 0x7c
3400452a:	46bd      	mov	sp, r7
3400452c:	bd90      	pop	{r4, r7, pc}
3400452e:	bf00      	nop
34004530:	50022000 	.word	0x50022000
34004534:	50022100 	.word	0x50022100
34004538:	50022300 	.word	0x50022300

3400453c <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
3400453c:	b480      	push	{r7}
3400453e:	b085      	sub	sp, #20
34004540:	af00      	add	r7, sp, #0
34004542:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
34004544:	687b      	ldr	r3, [r7, #4]
34004546:	f003 0307 	and.w	r3, r3, #7
3400454a:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
3400454c:	4b0c      	ldr	r3, [pc, #48]	@ (34004580 <__NVIC_SetPriorityGrouping+0x44>)
3400454e:	68db      	ldr	r3, [r3, #12]
34004550:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
34004552:	68ba      	ldr	r2, [r7, #8]
34004554:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
34004558:	4013      	ands	r3, r2
3400455a:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
3400455c:	68fb      	ldr	r3, [r7, #12]
3400455e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
34004560:	68bb      	ldr	r3, [r7, #8]
34004562:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
34004564:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
34004568:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
3400456c:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
3400456e:	4a04      	ldr	r2, [pc, #16]	@ (34004580 <__NVIC_SetPriorityGrouping+0x44>)
34004570:	68bb      	ldr	r3, [r7, #8]
34004572:	60d3      	str	r3, [r2, #12]
}
34004574:	bf00      	nop
34004576:	3714      	adds	r7, #20
34004578:	46bd      	mov	sp, r7
3400457a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400457e:	4770      	bx	lr
34004580:	e000ed00 	.word	0xe000ed00

34004584 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
34004584:	b480      	push	{r7}
34004586:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
34004588:	4b04      	ldr	r3, [pc, #16]	@ (3400459c <__NVIC_GetPriorityGrouping+0x18>)
3400458a:	68db      	ldr	r3, [r3, #12]
3400458c:	0a1b      	lsrs	r3, r3, #8
3400458e:	f003 0307 	and.w	r3, r3, #7
}
34004592:	4618      	mov	r0, r3
34004594:	46bd      	mov	sp, r7
34004596:	f85d 7b04 	ldr.w	r7, [sp], #4
3400459a:	4770      	bx	lr
3400459c:	e000ed00 	.word	0xe000ed00

340045a0 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
340045a0:	b480      	push	{r7}
340045a2:	b083      	sub	sp, #12
340045a4:	af00      	add	r7, sp, #0
340045a6:	4603      	mov	r3, r0
340045a8:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
340045aa:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
340045ae:	2b00      	cmp	r3, #0
340045b0:	db0b      	blt.n	340045ca <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
340045b2:	88fb      	ldrh	r3, [r7, #6]
340045b4:	f003 021f 	and.w	r2, r3, #31
340045b8:	4907      	ldr	r1, [pc, #28]	@ (340045d8 <__NVIC_EnableIRQ+0x38>)
340045ba:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
340045be:	095b      	lsrs	r3, r3, #5
340045c0:	2001      	movs	r0, #1
340045c2:	fa00 f202 	lsl.w	r2, r0, r2
340045c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
340045ca:	bf00      	nop
340045cc:	370c      	adds	r7, #12
340045ce:	46bd      	mov	sp, r7
340045d0:	f85d 7b04 	ldr.w	r7, [sp], #4
340045d4:	4770      	bx	lr
340045d6:	bf00      	nop
340045d8:	e000e100 	.word	0xe000e100

340045dc <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
340045dc:	b480      	push	{r7}
340045de:	b083      	sub	sp, #12
340045e0:	af00      	add	r7, sp, #0
340045e2:	4603      	mov	r3, r0
340045e4:	6039      	str	r1, [r7, #0]
340045e6:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
340045e8:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
340045ec:	2b00      	cmp	r3, #0
340045ee:	db0a      	blt.n	34004606 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
340045f0:	683b      	ldr	r3, [r7, #0]
340045f2:	b2da      	uxtb	r2, r3
340045f4:	490c      	ldr	r1, [pc, #48]	@ (34004628 <__NVIC_SetPriority+0x4c>)
340045f6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
340045fa:	0112      	lsls	r2, r2, #4
340045fc:	b2d2      	uxtb	r2, r2
340045fe:	440b      	add	r3, r1
34004600:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
34004604:	e00a      	b.n	3400461c <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
34004606:	683b      	ldr	r3, [r7, #0]
34004608:	b2da      	uxtb	r2, r3
3400460a:	4908      	ldr	r1, [pc, #32]	@ (3400462c <__NVIC_SetPriority+0x50>)
3400460c:	88fb      	ldrh	r3, [r7, #6]
3400460e:	f003 030f 	and.w	r3, r3, #15
34004612:	3b04      	subs	r3, #4
34004614:	0112      	lsls	r2, r2, #4
34004616:	b2d2      	uxtb	r2, r2
34004618:	440b      	add	r3, r1
3400461a:	761a      	strb	r2, [r3, #24]
}
3400461c:	bf00      	nop
3400461e:	370c      	adds	r7, #12
34004620:	46bd      	mov	sp, r7
34004622:	f85d 7b04 	ldr.w	r7, [sp], #4
34004626:	4770      	bx	lr
34004628:	e000e100 	.word	0xe000e100
3400462c:	e000ed00 	.word	0xe000ed00

34004630 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
34004630:	b480      	push	{r7}
34004632:	b089      	sub	sp, #36	@ 0x24
34004634:	af00      	add	r7, sp, #0
34004636:	60f8      	str	r0, [r7, #12]
34004638:	60b9      	str	r1, [r7, #8]
3400463a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
3400463c:	68fb      	ldr	r3, [r7, #12]
3400463e:	f003 0307 	and.w	r3, r3, #7
34004642:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
34004644:	69fb      	ldr	r3, [r7, #28]
34004646:	f1c3 0307 	rsb	r3, r3, #7
3400464a:	2b04      	cmp	r3, #4
3400464c:	bf28      	it	cs
3400464e:	2304      	movcs	r3, #4
34004650:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
34004652:	69fb      	ldr	r3, [r7, #28]
34004654:	3304      	adds	r3, #4
34004656:	2b06      	cmp	r3, #6
34004658:	d902      	bls.n	34004660 <NVIC_EncodePriority+0x30>
3400465a:	69fb      	ldr	r3, [r7, #28]
3400465c:	3b03      	subs	r3, #3
3400465e:	e000      	b.n	34004662 <NVIC_EncodePriority+0x32>
34004660:	2300      	movs	r3, #0
34004662:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34004664:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
34004668:	69bb      	ldr	r3, [r7, #24]
3400466a:	fa02 f303 	lsl.w	r3, r2, r3
3400466e:	43da      	mvns	r2, r3
34004670:	68bb      	ldr	r3, [r7, #8]
34004672:	401a      	ands	r2, r3
34004674:	697b      	ldr	r3, [r7, #20]
34004676:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
34004678:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
3400467c:	697b      	ldr	r3, [r7, #20]
3400467e:	fa01 f303 	lsl.w	r3, r1, r3
34004682:	43d9      	mvns	r1, r3
34004684:	687b      	ldr	r3, [r7, #4]
34004686:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
34004688:	4313      	orrs	r3, r2
         );
}
3400468a:	4618      	mov	r0, r3
3400468c:	3724      	adds	r7, #36	@ 0x24
3400468e:	46bd      	mov	sp, r7
34004690:	f85d 7b04 	ldr.w	r7, [sp], #4
34004694:	4770      	bx	lr
	...

34004698 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
34004698:	b580      	push	{r7, lr}
3400469a:	b082      	sub	sp, #8
3400469c:	af00      	add	r7, sp, #0
3400469e:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
340046a0:	687b      	ldr	r3, [r7, #4]
340046a2:	3b01      	subs	r3, #1
340046a4:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
340046a8:	d301      	bcc.n	340046ae <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
340046aa:	2301      	movs	r3, #1
340046ac:	e00f      	b.n	340046ce <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
340046ae:	4a0a      	ldr	r2, [pc, #40]	@ (340046d8 <SysTick_Config+0x40>)
340046b0:	687b      	ldr	r3, [r7, #4]
340046b2:	3b01      	subs	r3, #1
340046b4:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
340046b6:	210f      	movs	r1, #15
340046b8:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
340046bc:	f7ff ff8e 	bl	340045dc <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
340046c0:	4b05      	ldr	r3, [pc, #20]	@ (340046d8 <SysTick_Config+0x40>)
340046c2:	2200      	movs	r2, #0
340046c4:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
340046c6:	4b04      	ldr	r3, [pc, #16]	@ (340046d8 <SysTick_Config+0x40>)
340046c8:	2207      	movs	r2, #7
340046ca:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
340046cc:	2300      	movs	r3, #0
}
340046ce:	4618      	mov	r0, r3
340046d0:	3708      	adds	r7, #8
340046d2:	46bd      	mov	sp, r7
340046d4:	bd80      	pop	{r7, pc}
340046d6:	bf00      	nop
340046d8:	e000e010 	.word	0xe000e010

340046dc <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
340046dc:	b580      	push	{r7, lr}
340046de:	b082      	sub	sp, #8
340046e0:	af00      	add	r7, sp, #0
340046e2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
340046e4:	6878      	ldr	r0, [r7, #4]
340046e6:	f7ff ff29 	bl	3400453c <__NVIC_SetPriorityGrouping>
}
340046ea:	bf00      	nop
340046ec:	3708      	adds	r7, #8
340046ee:	46bd      	mov	sp, r7
340046f0:	bd80      	pop	{r7, pc}

340046f2 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
340046f2:	b580      	push	{r7, lr}
340046f4:	b086      	sub	sp, #24
340046f6:	af00      	add	r7, sp, #0
340046f8:	4603      	mov	r3, r0
340046fa:	60b9      	str	r1, [r7, #8]
340046fc:	607a      	str	r2, [r7, #4]
340046fe:	81fb      	strh	r3, [r7, #14]
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_INTERRUPT(IRQn));

  prioritygroup = (NVIC_GetPriorityGrouping() & 0x7U);
34004700:	f7ff ff40 	bl	34004584 <__NVIC_GetPriorityGrouping>
34004704:	4603      	mov	r3, r0
34004706:	f003 0307 	and.w	r3, r3, #7
3400470a:	617b      	str	r3, [r7, #20]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
3400470c:	687a      	ldr	r2, [r7, #4]
3400470e:	68b9      	ldr	r1, [r7, #8]
34004710:	6978      	ldr	r0, [r7, #20]
34004712:	f7ff ff8d 	bl	34004630 <NVIC_EncodePriority>
34004716:	4602      	mov	r2, r0
34004718:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
3400471c:	4611      	mov	r1, r2
3400471e:	4618      	mov	r0, r3
34004720:	f7ff ff5c 	bl	340045dc <__NVIC_SetPriority>
}
34004724:	bf00      	nop
34004726:	3718      	adds	r7, #24
34004728:	46bd      	mov	sp, r7
3400472a:	bd80      	pop	{r7, pc}

3400472c <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer
  *         to the appropriate CMSIS device file (stm32n6xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
3400472c:	b580      	push	{r7, lr}
3400472e:	b082      	sub	sp, #8
34004730:	af00      	add	r7, sp, #0
34004732:	4603      	mov	r3, r0
34004734:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
34004736:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
3400473a:	4618      	mov	r0, r3
3400473c:	f7ff ff30 	bl	340045a0 <__NVIC_EnableIRQ>
}
34004740:	bf00      	nop
34004742:	3708      	adds	r7, #8
34004744:	46bd      	mov	sp, r7
34004746:	bd80      	pop	{r7, pc}

34004748 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
34004748:	b580      	push	{r7, lr}
3400474a:	b082      	sub	sp, #8
3400474c:	af00      	add	r7, sp, #0
3400474e:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
34004750:	6878      	ldr	r0, [r7, #4]
34004752:	f7ff ffa1 	bl	34004698 <SysTick_Config>
34004756:	4603      	mov	r3, r0
}
34004758:	4618      	mov	r0, r3
3400475a:	3708      	adds	r7, #8
3400475c:	46bd      	mov	sp, r7
3400475e:	bd80      	pop	{r7, pc}

34004760 <HAL_DMA_Abort_IT>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *const hdma)
{
34004760:	b480      	push	{r7}
34004762:	b083      	sub	sp, #12
34004764:	af00      	add	r7, sp, #0
34004766:	6078      	str	r0, [r7, #4]
  /* Check the DMA peripheral handle parameter */
  if (hdma == NULL)
34004768:	687b      	ldr	r3, [r7, #4]
3400476a:	2b00      	cmp	r3, #0
3400476c:	d101      	bne.n	34004772 <HAL_DMA_Abort_IT+0x12>
  {
    return HAL_ERROR;
3400476e:	2301      	movs	r3, #1
34004770:	e019      	b.n	340047a6 <HAL_DMA_Abort_IT+0x46>
  }

  /* Check DMA channel state */
  if (hdma->State != HAL_DMA_STATE_BUSY)
34004772:	687b      	ldr	r3, [r7, #4]
34004774:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
34004778:	b2db      	uxtb	r3, r3
3400477a:	2b02      	cmp	r3, #2
3400477c:	d004      	beq.n	34004788 <HAL_DMA_Abort_IT+0x28>
  {
    /* Update the DMA channel error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
3400477e:	687b      	ldr	r3, [r7, #4]
34004780:	2220      	movs	r2, #32
34004782:	659a      	str	r2, [r3, #88]	@ 0x58

    return HAL_ERROR;
34004784:	2301      	movs	r3, #1
34004786:	e00e      	b.n	340047a6 <HAL_DMA_Abort_IT+0x46>
  }
  else
  {
    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_ABORT;
34004788:	687b      	ldr	r3, [r7, #4]
3400478a:	2204      	movs	r2, #4
3400478c:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Suspend the channel and activate suspend interrupt */
    hdma->Instance->CCR |= (DMA_CCR_SUSP | DMA_CCR_SUSPIE);
34004790:	687b      	ldr	r3, [r7, #4]
34004792:	681b      	ldr	r3, [r3, #0]
34004794:	695b      	ldr	r3, [r3, #20]
34004796:	687a      	ldr	r2, [r7, #4]
34004798:	6812      	ldr	r2, [r2, #0]
3400479a:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
3400479e:	f043 0304 	orr.w	r3, r3, #4
340047a2:	6153      	str	r3, [r2, #20]
  }

  return HAL_OK;
340047a4:	2300      	movs	r3, #0
}
340047a6:	4618      	mov	r0, r3
340047a8:	370c      	adds	r7, #12
340047aa:	46bd      	mov	sp, r7
340047ac:	f85d 7b04 	ldr.w	r7, [sp], #4
340047b0:	4770      	bx	lr

340047b2 <HAL_DMA_GetState>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval DMA state.
  */
HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef const *const hdma)
{
340047b2:	b480      	push	{r7}
340047b4:	b083      	sub	sp, #12
340047b6:	af00      	add	r7, sp, #0
340047b8:	6078      	str	r0, [r7, #4]
  /* Return the DMA channel state */
  return hdma->State;
340047ba:	687b      	ldr	r3, [r7, #4]
340047bc:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
340047c0:	b2db      	uxtb	r3, r3
}
340047c2:	4618      	mov	r0, r3
340047c4:	370c      	adds	r7, #12
340047c6:	46bd      	mov	sp, r7
340047c8:	f85d 7b04 	ldr.w	r7, [sp], #4
340047cc:	4770      	bx	lr

340047ce <HAL_DMA2D_Init>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
{
340047ce:	b580      	push	{r7, lr}
340047d0:	b082      	sub	sp, #8
340047d2:	af00      	add	r7, sp, #0
340047d4:	6078      	str	r0, [r7, #4]
  /* Check the DMA2D peripheral state */
  if (hdma2d == NULL)
340047d6:	687b      	ldr	r3, [r7, #4]
340047d8:	2b00      	cmp	r3, #0
340047da:	d101      	bne.n	340047e0 <HAL_DMA2D_Init+0x12>
  {
    return HAL_ERROR;
340047dc:	2301      	movs	r3, #1
340047de:	e053      	b.n	34004888 <HAL_DMA2D_Init+0xba>

    /* Init the low level hardware */
    hdma2d->MspInitCallback(hdma2d);
  }
#else
  if (hdma2d->State == HAL_DMA2D_STATE_RESET)
340047e0:	687b      	ldr	r3, [r7, #4]
340047e2:	f893 3061 	ldrb.w	r3, [r3, #97]	@ 0x61
340047e6:	b2db      	uxtb	r3, r3
340047e8:	2b00      	cmp	r3, #0
340047ea:	d106      	bne.n	340047fa <HAL_DMA2D_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hdma2d->Lock = HAL_UNLOCKED;
340047ec:	687b      	ldr	r3, [r7, #4]
340047ee:	2200      	movs	r2, #0
340047f0:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
    /* Init the low level hardware */
    HAL_DMA2D_MspInit(hdma2d);
340047f4:	6878      	ldr	r0, [r7, #4]
340047f6:	f000 f84b 	bl	34004890 <HAL_DMA2D_MspInit>
  }
#endif /* (USE_HAL_DMA2D_REGISTER_CALLBACKS) */

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
340047fa:	687b      	ldr	r3, [r7, #4]
340047fc:	2202      	movs	r2, #2
340047fe:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* DMA2D CR register configuration -------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE | DMA2D_CR_LOM, hdma2d->Init.Mode | hdma2d->Init.LineOffsetMode);
34004802:	687b      	ldr	r3, [r7, #4]
34004804:	681b      	ldr	r3, [r3, #0]
34004806:	681b      	ldr	r3, [r3, #0]
34004808:	f423 23e0 	bic.w	r3, r3, #458752	@ 0x70000
3400480c:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
34004810:	687a      	ldr	r2, [r7, #4]
34004812:	6851      	ldr	r1, [r2, #4]
34004814:	687a      	ldr	r2, [r7, #4]
34004816:	69d2      	ldr	r2, [r2, #28]
34004818:	4311      	orrs	r1, r2
3400481a:	687a      	ldr	r2, [r7, #4]
3400481c:	6812      	ldr	r2, [r2, #0]
3400481e:	430b      	orrs	r3, r1
34004820:	6013      	str	r3, [r2, #0]

  /* DMA2D OPFCCR register configuration ---------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM | DMA2D_OPFCCR_SB,
34004822:	687b      	ldr	r3, [r7, #4]
34004824:	681b      	ldr	r3, [r3, #0]
34004826:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34004828:	f423 7383 	bic.w	r3, r3, #262	@ 0x106
3400482c:	f023 0301 	bic.w	r3, r3, #1
34004830:	687a      	ldr	r2, [r7, #4]
34004832:	6891      	ldr	r1, [r2, #8]
34004834:	687a      	ldr	r2, [r7, #4]
34004836:	6992      	ldr	r2, [r2, #24]
34004838:	4311      	orrs	r1, r2
3400483a:	687a      	ldr	r2, [r7, #4]
3400483c:	6812      	ldr	r2, [r2, #0]
3400483e:	430b      	orrs	r3, r1
34004840:	6353      	str	r3, [r2, #52]	@ 0x34
             hdma2d->Init.ColorMode | hdma2d->Init.BytesSwap);

  /* DMA2D OOR register configuration ------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
34004842:	687b      	ldr	r3, [r7, #4]
34004844:	681b      	ldr	r3, [r3, #0]
34004846:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
34004848:	0c1b      	lsrs	r3, r3, #16
3400484a:	041b      	lsls	r3, r3, #16
3400484c:	687a      	ldr	r2, [r7, #4]
3400484e:	68d1      	ldr	r1, [r2, #12]
34004850:	687a      	ldr	r2, [r7, #4]
34004852:	6812      	ldr	r2, [r2, #0]
34004854:	430b      	orrs	r3, r1
34004856:	6413      	str	r3, [r2, #64]	@ 0x40
  /* DMA2D OPFCCR AI and RBS fields setting (Output Alpha Inversion)*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, (DMA2D_OPFCCR_AI | DMA2D_OPFCCR_RBS),
34004858:	687b      	ldr	r3, [r7, #4]
3400485a:	681b      	ldr	r3, [r3, #0]
3400485c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400485e:	f423 1140 	bic.w	r1, r3, #3145728	@ 0x300000
34004862:	687b      	ldr	r3, [r7, #4]
34004864:	691b      	ldr	r3, [r3, #16]
34004866:	051a      	lsls	r2, r3, #20
34004868:	687b      	ldr	r3, [r7, #4]
3400486a:	695b      	ldr	r3, [r3, #20]
3400486c:	055b      	lsls	r3, r3, #21
3400486e:	431a      	orrs	r2, r3
34004870:	687b      	ldr	r3, [r7, #4]
34004872:	681b      	ldr	r3, [r3, #0]
34004874:	430a      	orrs	r2, r1
34004876:	635a      	str	r2, [r3, #52]	@ 0x34
             ((hdma2d->Init.AlphaInverted << DMA2D_OPFCCR_AI_Pos) | \
              (hdma2d->Init.RedBlueSwap << DMA2D_OPFCCR_RBS_Pos)));


  /* Update error code */
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
34004878:	687b      	ldr	r3, [r7, #4]
3400487a:	2200      	movs	r2, #0
3400487c:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Initialize the DMA2D state*/
  hdma2d->State  = HAL_DMA2D_STATE_READY;
3400487e:	687b      	ldr	r3, [r7, #4]
34004880:	2201      	movs	r2, #1
34004882:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  return HAL_OK;
34004886:	2300      	movs	r3, #0
}
34004888:	4618      	mov	r0, r3
3400488a:	3708      	adds	r7, #8
3400488c:	46bd      	mov	sp, r7
3400488e:	bd80      	pop	{r7, pc}

34004890 <HAL_DMA2D_MspInit>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  */
__weak void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef *hdma2d)
{
34004890:	b480      	push	{r7}
34004892:	b083      	sub	sp, #12
34004894:	af00      	add	r7, sp, #0
34004896:	6078      	str	r0, [r7, #4]
  UNUSED(hdma2d);

  /* NOTE : This function should not be modified; when the callback is needed,
            the HAL_DMA2D_MspInit can be implemented in the user file.
   */
}
34004898:	bf00      	nop
3400489a:	370c      	adds	r7, #12
3400489c:	46bd      	mov	sp, r7
3400489e:	f85d 7b04 	ldr.w	r7, [sp], #4
340048a2:	4770      	bx	lr

340048a4 <HAL_DMA2D_Start>:
  * @param  Height     The height of data to be transferred from source to destination (expressed in number of lines).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Start(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                                  uint32_t Height)
{
340048a4:	b580      	push	{r7, lr}
340048a6:	b086      	sub	sp, #24
340048a8:	af02      	add	r7, sp, #8
340048aa:	60f8      	str	r0, [r7, #12]
340048ac:	60b9      	str	r1, [r7, #8]
340048ae:	607a      	str	r2, [r7, #4]
340048b0:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA2D_LINE(Height));
  assert_param(IS_DMA2D_PIXEL(Width));

  /* Process locked */
  __HAL_LOCK(hdma2d);
340048b2:	68fb      	ldr	r3, [r7, #12]
340048b4:	f893 3060 	ldrb.w	r3, [r3, #96]	@ 0x60
340048b8:	2b01      	cmp	r3, #1
340048ba:	d101      	bne.n	340048c0 <HAL_DMA2D_Start+0x1c>
340048bc:	2302      	movs	r3, #2
340048be:	e018      	b.n	340048f2 <HAL_DMA2D_Start+0x4e>
340048c0:	68fb      	ldr	r3, [r7, #12]
340048c2:	2201      	movs	r2, #1
340048c4:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
340048c8:	68fb      	ldr	r3, [r7, #12]
340048ca:	2202      	movs	r2, #2
340048cc:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* Configure the source, destination address and the data size */
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
340048d0:	69bb      	ldr	r3, [r7, #24]
340048d2:	9300      	str	r3, [sp, #0]
340048d4:	683b      	ldr	r3, [r7, #0]
340048d6:	687a      	ldr	r2, [r7, #4]
340048d8:	68b9      	ldr	r1, [r7, #8]
340048da:	68f8      	ldr	r0, [r7, #12]
340048dc:	f000 f8f6 	bl	34004acc <DMA2D_SetConfig>

  /* Enable the Peripheral */
  __HAL_DMA2D_ENABLE(hdma2d);
340048e0:	68fb      	ldr	r3, [r7, #12]
340048e2:	681b      	ldr	r3, [r3, #0]
340048e4:	681a      	ldr	r2, [r3, #0]
340048e6:	68fb      	ldr	r3, [r7, #12]
340048e8:	681b      	ldr	r3, [r3, #0]
340048ea:	f042 0201 	orr.w	r2, r2, #1
340048ee:	601a      	str	r2, [r3, #0]

  return HAL_OK;
340048f0:	2300      	movs	r3, #0
}
340048f2:	4618      	mov	r0, r3
340048f4:	3710      	adds	r7, #16
340048f6:	46bd      	mov	sp, r7
340048f8:	bd80      	pop	{r7, pc}

340048fa <HAL_DMA2D_PollForTransfer>:
  *                 the configuration information for the DMA2D.
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_PollForTransfer(DMA2D_HandleTypeDef *hdma2d, uint32_t Timeout)
{
340048fa:	b580      	push	{r7, lr}
340048fc:	b086      	sub	sp, #24
340048fe:	af00      	add	r7, sp, #0
34004900:	6078      	str	r0, [r7, #4]
34004902:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  uint32_t layer_start;
  __IO uint32_t isrflags = 0x0U;
34004904:	2300      	movs	r3, #0
34004906:	60fb      	str	r3, [r7, #12]

  /* Polling for DMA2D transfer */
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
34004908:	687b      	ldr	r3, [r7, #4]
3400490a:	681b      	ldr	r3, [r3, #0]
3400490c:	681b      	ldr	r3, [r3, #0]
3400490e:	f003 0301 	and.w	r3, r3, #1
34004912:	2b00      	cmp	r3, #0
34004914:	d056      	beq.n	340049c4 <HAL_DMA2D_PollForTransfer+0xca>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
34004916:	f7fd fdf7 	bl	34002508 <HAL_GetTick>
3400491a:	6178      	str	r0, [r7, #20]

    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
3400491c:	e04b      	b.n	340049b6 <HAL_DMA2D_PollForTransfer+0xbc>
    {
      isrflags = READ_REG(hdma2d->Instance->ISR);
3400491e:	687b      	ldr	r3, [r7, #4]
34004920:	681b      	ldr	r3, [r3, #0]
34004922:	685b      	ldr	r3, [r3, #4]
34004924:	60fb      	str	r3, [r7, #12]
      if ((isrflags & (DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
34004926:	68fb      	ldr	r3, [r7, #12]
34004928:	f003 0321 	and.w	r3, r3, #33	@ 0x21
3400492c:	2b00      	cmp	r3, #0
3400492e:	d023      	beq.n	34004978 <HAL_DMA2D_PollForTransfer+0x7e>
      {
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
34004930:	68fb      	ldr	r3, [r7, #12]
34004932:	f003 0320 	and.w	r3, r3, #32
34004936:	2b00      	cmp	r3, #0
34004938:	d005      	beq.n	34004946 <HAL_DMA2D_PollForTransfer+0x4c>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
3400493a:	687b      	ldr	r3, [r7, #4]
3400493c:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3400493e:	f043 0202 	orr.w	r2, r3, #2
34004942:	687b      	ldr	r3, [r7, #4]
34004944:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
34004946:	68fb      	ldr	r3, [r7, #12]
34004948:	f003 0301 	and.w	r3, r3, #1
3400494c:	2b00      	cmp	r3, #0
3400494e:	d005      	beq.n	3400495c <HAL_DMA2D_PollForTransfer+0x62>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
34004950:	687b      	ldr	r3, [r7, #4]
34004952:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34004954:	f043 0201 	orr.w	r2, r3, #1
34004958:	687b      	ldr	r3, [r7, #4]
3400495a:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        /* Clear the transfer and configuration error flags */
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE | DMA2D_FLAG_TE);
3400495c:	687b      	ldr	r3, [r7, #4]
3400495e:	681b      	ldr	r3, [r3, #0]
34004960:	2221      	movs	r2, #33	@ 0x21
34004962:	609a      	str	r2, [r3, #8]

        /* Change DMA2D state */
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
34004964:	687b      	ldr	r3, [r7, #4]
34004966:	2204      	movs	r2, #4
34004968:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

        /* Process unlocked */
        __HAL_UNLOCK(hdma2d);
3400496c:	687b      	ldr	r3, [r7, #4]
3400496e:	2200      	movs	r2, #0
34004970:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

        return HAL_ERROR;
34004974:	2301      	movs	r3, #1
34004976:	e0a5      	b.n	34004ac4 <HAL_DMA2D_PollForTransfer+0x1ca>
      }
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
34004978:	683b      	ldr	r3, [r7, #0]
3400497a:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
3400497e:	d01a      	beq.n	340049b6 <HAL_DMA2D_PollForTransfer+0xbc>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
34004980:	f7fd fdc2 	bl	34002508 <HAL_GetTick>
34004984:	4602      	mov	r2, r0
34004986:	697b      	ldr	r3, [r7, #20]
34004988:	1ad3      	subs	r3, r2, r3
3400498a:	683a      	ldr	r2, [r7, #0]
3400498c:	429a      	cmp	r2, r3
3400498e:	d302      	bcc.n	34004996 <HAL_DMA2D_PollForTransfer+0x9c>
34004990:	683b      	ldr	r3, [r7, #0]
34004992:	2b00      	cmp	r3, #0
34004994:	d10f      	bne.n	340049b6 <HAL_DMA2D_PollForTransfer+0xbc>
        {
          /* Update error code */
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
34004996:	687b      	ldr	r3, [r7, #4]
34004998:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
3400499a:	f043 0220 	orr.w	r2, r3, #32
3400499e:	687b      	ldr	r3, [r7, #4]
340049a0:	665a      	str	r2, [r3, #100]	@ 0x64

          /* Change the DMA2D state */
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
340049a2:	687b      	ldr	r3, [r7, #4]
340049a4:	2203      	movs	r2, #3
340049a6:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

          /* Process unlocked */
          __HAL_UNLOCK(hdma2d);
340049aa:	687b      	ldr	r3, [r7, #4]
340049ac:	2200      	movs	r2, #0
340049ae:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

          return HAL_TIMEOUT;
340049b2:	2303      	movs	r3, #3
340049b4:	e086      	b.n	34004ac4 <HAL_DMA2D_PollForTransfer+0x1ca>
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
340049b6:	687b      	ldr	r3, [r7, #4]
340049b8:	681b      	ldr	r3, [r3, #0]
340049ba:	685b      	ldr	r3, [r3, #4]
340049bc:	f003 0302 	and.w	r3, r3, #2
340049c0:	2b00      	cmp	r3, #0
340049c2:	d0ac      	beq.n	3400491e <HAL_DMA2D_PollForTransfer+0x24>
        }
      }
    }
  }
  /* Polling for CLUT loading (foreground or background) */
  layer_start = hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START;
340049c4:	687b      	ldr	r3, [r7, #4]
340049c6:	681b      	ldr	r3, [r3, #0]
340049c8:	69db      	ldr	r3, [r3, #28]
340049ca:	f003 0320 	and.w	r3, r3, #32
340049ce:	613b      	str	r3, [r7, #16]
  layer_start |= hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START;
340049d0:	687b      	ldr	r3, [r7, #4]
340049d2:	681b      	ldr	r3, [r3, #0]
340049d4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340049d6:	f003 0320 	and.w	r3, r3, #32
340049da:	693a      	ldr	r2, [r7, #16]
340049dc:	4313      	orrs	r3, r2
340049de:	613b      	str	r3, [r7, #16]
  if (layer_start != 0U)
340049e0:	693b      	ldr	r3, [r7, #16]
340049e2:	2b00      	cmp	r3, #0
340049e4:	d061      	beq.n	34004aaa <HAL_DMA2D_PollForTransfer+0x1b0>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
340049e6:	f7fd fd8f 	bl	34002508 <HAL_GetTick>
340049ea:	6178      	str	r0, [r7, #20]

    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
340049ec:	e056      	b.n	34004a9c <HAL_DMA2D_PollForTransfer+0x1a2>
    {
      isrflags = READ_REG(hdma2d->Instance->ISR);
340049ee:	687b      	ldr	r3, [r7, #4]
340049f0:	681b      	ldr	r3, [r3, #0]
340049f2:	685b      	ldr	r3, [r3, #4]
340049f4:	60fb      	str	r3, [r7, #12]
      if ((isrflags & (DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
340049f6:	68fb      	ldr	r3, [r7, #12]
340049f8:	f003 0329 	and.w	r3, r3, #41	@ 0x29
340049fc:	2b00      	cmp	r3, #0
340049fe:	d02e      	beq.n	34004a5e <HAL_DMA2D_PollForTransfer+0x164>
      {
        if ((isrflags & DMA2D_FLAG_CAE) != 0U)
34004a00:	68fb      	ldr	r3, [r7, #12]
34004a02:	f003 0308 	and.w	r3, r3, #8
34004a06:	2b00      	cmp	r3, #0
34004a08:	d005      	beq.n	34004a16 <HAL_DMA2D_PollForTransfer+0x11c>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
34004a0a:	687b      	ldr	r3, [r7, #4]
34004a0c:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34004a0e:	f043 0204 	orr.w	r2, r3, #4
34004a12:	687b      	ldr	r3, [r7, #4]
34004a14:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
34004a16:	68fb      	ldr	r3, [r7, #12]
34004a18:	f003 0320 	and.w	r3, r3, #32
34004a1c:	2b00      	cmp	r3, #0
34004a1e:	d005      	beq.n	34004a2c <HAL_DMA2D_PollForTransfer+0x132>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
34004a20:	687b      	ldr	r3, [r7, #4]
34004a22:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34004a24:	f043 0202 	orr.w	r2, r3, #2
34004a28:	687b      	ldr	r3, [r7, #4]
34004a2a:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
34004a2c:	68fb      	ldr	r3, [r7, #12]
34004a2e:	f003 0301 	and.w	r3, r3, #1
34004a32:	2b00      	cmp	r3, #0
34004a34:	d005      	beq.n	34004a42 <HAL_DMA2D_PollForTransfer+0x148>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
34004a36:	687b      	ldr	r3, [r7, #4]
34004a38:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34004a3a:	f043 0201 	orr.w	r2, r3, #1
34004a3e:	687b      	ldr	r3, [r7, #4]
34004a40:	665a      	str	r2, [r3, #100]	@ 0x64
        }
        /* Clear the CLUT Access Error, Configuration Error and Transfer Error flags */
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
34004a42:	687b      	ldr	r3, [r7, #4]
34004a44:	681b      	ldr	r3, [r3, #0]
34004a46:	2229      	movs	r2, #41	@ 0x29
34004a48:	609a      	str	r2, [r3, #8]

        /* Change DMA2D state */
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
34004a4a:	687b      	ldr	r3, [r7, #4]
34004a4c:	2204      	movs	r2, #4
34004a4e:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

        /* Process unlocked */
        __HAL_UNLOCK(hdma2d);
34004a52:	687b      	ldr	r3, [r7, #4]
34004a54:	2200      	movs	r2, #0
34004a56:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

        return HAL_ERROR;
34004a5a:	2301      	movs	r3, #1
34004a5c:	e032      	b.n	34004ac4 <HAL_DMA2D_PollForTransfer+0x1ca>
      }
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
34004a5e:	683b      	ldr	r3, [r7, #0]
34004a60:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
34004a64:	d01a      	beq.n	34004a9c <HAL_DMA2D_PollForTransfer+0x1a2>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
34004a66:	f7fd fd4f 	bl	34002508 <HAL_GetTick>
34004a6a:	4602      	mov	r2, r0
34004a6c:	697b      	ldr	r3, [r7, #20]
34004a6e:	1ad3      	subs	r3, r2, r3
34004a70:	683a      	ldr	r2, [r7, #0]
34004a72:	429a      	cmp	r2, r3
34004a74:	d302      	bcc.n	34004a7c <HAL_DMA2D_PollForTransfer+0x182>
34004a76:	683b      	ldr	r3, [r7, #0]
34004a78:	2b00      	cmp	r3, #0
34004a7a:	d10f      	bne.n	34004a9c <HAL_DMA2D_PollForTransfer+0x1a2>
        {
          /* Update error code */
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
34004a7c:	687b      	ldr	r3, [r7, #4]
34004a7e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34004a80:	f043 0220 	orr.w	r2, r3, #32
34004a84:	687b      	ldr	r3, [r7, #4]
34004a86:	665a      	str	r2, [r3, #100]	@ 0x64

          /* Change the DMA2D state */
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
34004a88:	687b      	ldr	r3, [r7, #4]
34004a8a:	2203      	movs	r2, #3
34004a8c:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

          /* Process unlocked */
          __HAL_UNLOCK(hdma2d);
34004a90:	687b      	ldr	r3, [r7, #4]
34004a92:	2200      	movs	r2, #0
34004a94:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

          return HAL_TIMEOUT;
34004a98:	2303      	movs	r3, #3
34004a9a:	e013      	b.n	34004ac4 <HAL_DMA2D_PollForTransfer+0x1ca>
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
34004a9c:	687b      	ldr	r3, [r7, #4]
34004a9e:	681b      	ldr	r3, [r3, #0]
34004aa0:	685b      	ldr	r3, [r3, #4]
34004aa2:	f003 0310 	and.w	r3, r3, #16
34004aa6:	2b00      	cmp	r3, #0
34004aa8:	d0a1      	beq.n	340049ee <HAL_DMA2D_PollForTransfer+0xf4>
      }
    }
  }

  /* Clear the transfer complete and CLUT loading flags */
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC | DMA2D_FLAG_CTC);
34004aaa:	687b      	ldr	r3, [r7, #4]
34004aac:	681b      	ldr	r3, [r3, #0]
34004aae:	2212      	movs	r2, #18
34004ab0:	609a      	str	r2, [r3, #8]

  /* Change DMA2D state */
  hdma2d->State = HAL_DMA2D_STATE_READY;
34004ab2:	687b      	ldr	r3, [r7, #4]
34004ab4:	2201      	movs	r2, #1
34004ab6:	f883 2061 	strb.w	r2, [r3, #97]	@ 0x61

  /* Process unlocked */
  __HAL_UNLOCK(hdma2d);
34004aba:	687b      	ldr	r3, [r7, #4]
34004abc:	2200      	movs	r2, #0
34004abe:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

  return HAL_OK;
34004ac2:	2300      	movs	r3, #0
}
34004ac4:	4618      	mov	r0, r3
34004ac6:	3718      	adds	r7, #24
34004ac8:	46bd      	mov	sp, r7
34004aca:	bd80      	pop	{r7, pc}

34004acc <DMA2D_SetConfig>:
  * @param  Height     The height of data to be transferred from source to destination.
  * @retval HAL status
  */
static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                            uint32_t Height)
{
34004acc:	b480      	push	{r7}
34004ace:	b08b      	sub	sp, #44	@ 0x2c
34004ad0:	af00      	add	r7, sp, #0
34004ad2:	60f8      	str	r0, [r7, #12]
34004ad4:	60b9      	str	r1, [r7, #8]
34004ad6:	607a      	str	r2, [r7, #4]
34004ad8:	603b      	str	r3, [r7, #0]
  uint32_t tmp2;
  uint32_t tmp3;
  uint32_t tmp4;

  /* Configure DMA2D data size */
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
34004ada:	68fb      	ldr	r3, [r7, #12]
34004adc:	681b      	ldr	r3, [r3, #0]
34004ade:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34004ae0:	f003 4140 	and.w	r1, r3, #3221225472	@ 0xc0000000
34004ae4:	683b      	ldr	r3, [r7, #0]
34004ae6:	041a      	lsls	r2, r3, #16
34004ae8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
34004aea:	431a      	orrs	r2, r3
34004aec:	68fb      	ldr	r3, [r7, #12]
34004aee:	681b      	ldr	r3, [r3, #0]
34004af0:	430a      	orrs	r2, r1
34004af2:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Configure DMA2D destination address */
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
34004af4:	68fb      	ldr	r3, [r7, #12]
34004af6:	681b      	ldr	r3, [r3, #0]
34004af8:	687a      	ldr	r2, [r7, #4]
34004afa:	63da      	str	r2, [r3, #60]	@ 0x3c

  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
34004afc:	68fb      	ldr	r3, [r7, #12]
34004afe:	685b      	ldr	r3, [r3, #4]
34004b00:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34004b04:	d174      	bne.n	34004bf0 <DMA2D_SetConfig+0x124>
  {
    tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
34004b06:	68bb      	ldr	r3, [r7, #8]
34004b08:	f003 437f 	and.w	r3, r3, #4278190080	@ 0xff000000
34004b0c:	623b      	str	r3, [r7, #32]
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
34004b0e:	68bb      	ldr	r3, [r7, #8]
34004b10:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
34004b14:	61fb      	str	r3, [r7, #28]
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
34004b16:	68bb      	ldr	r3, [r7, #8]
34004b18:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
34004b1c:	61bb      	str	r3, [r7, #24]
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
34004b1e:	68bb      	ldr	r3, [r7, #8]
34004b20:	b2db      	uxtb	r3, r3
34004b22:	617b      	str	r3, [r7, #20]

    /* Prepare the value to be written to the OCOLR register according to the color mode */
    if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB8888)
34004b24:	68fb      	ldr	r3, [r7, #12]
34004b26:	689b      	ldr	r3, [r3, #8]
34004b28:	2b00      	cmp	r3, #0
34004b2a:	d108      	bne.n	34004b3e <DMA2D_SetConfig+0x72>
    {
      tmp = (tmp3 | tmp2 | tmp1 | tmp4);
34004b2c:	69ba      	ldr	r2, [r7, #24]
34004b2e:	69fb      	ldr	r3, [r7, #28]
34004b30:	431a      	orrs	r2, r3
34004b32:	6a3b      	ldr	r3, [r7, #32]
34004b34:	4313      	orrs	r3, r2
34004b36:	697a      	ldr	r2, [r7, #20]
34004b38:	4313      	orrs	r3, r2
34004b3a:	627b      	str	r3, [r7, #36]	@ 0x24
34004b3c:	e053      	b.n	34004be6 <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB888)
34004b3e:	68fb      	ldr	r3, [r7, #12]
34004b40:	689b      	ldr	r3, [r3, #8]
34004b42:	2b01      	cmp	r3, #1
34004b44:	d106      	bne.n	34004b54 <DMA2D_SetConfig+0x88>
    {
      tmp = (tmp3 | tmp2 | tmp4);
34004b46:	69ba      	ldr	r2, [r7, #24]
34004b48:	69fb      	ldr	r3, [r7, #28]
34004b4a:	4313      	orrs	r3, r2
34004b4c:	697a      	ldr	r2, [r7, #20]
34004b4e:	4313      	orrs	r3, r2
34004b50:	627b      	str	r3, [r7, #36]	@ 0x24
34004b52:	e048      	b.n	34004be6 <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB565)
34004b54:	68fb      	ldr	r3, [r7, #12]
34004b56:	689b      	ldr	r3, [r3, #8]
34004b58:	2b02      	cmp	r3, #2
34004b5a:	d111      	bne.n	34004b80 <DMA2D_SetConfig+0xb4>
    {
      tmp2 = (tmp2 >> 19U);
34004b5c:	69fb      	ldr	r3, [r7, #28]
34004b5e:	0cdb      	lsrs	r3, r3, #19
34004b60:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 10U);
34004b62:	69bb      	ldr	r3, [r7, #24]
34004b64:	0a9b      	lsrs	r3, r3, #10
34004b66:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 3U);
34004b68:	697b      	ldr	r3, [r7, #20]
34004b6a:	08db      	lsrs	r3, r3, #3
34004b6c:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 5U) | (tmp2 << 11U) | tmp4);
34004b6e:	69bb      	ldr	r3, [r7, #24]
34004b70:	015a      	lsls	r2, r3, #5
34004b72:	69fb      	ldr	r3, [r7, #28]
34004b74:	02db      	lsls	r3, r3, #11
34004b76:	4313      	orrs	r3, r2
34004b78:	697a      	ldr	r2, [r7, #20]
34004b7a:	4313      	orrs	r3, r2
34004b7c:	627b      	str	r3, [r7, #36]	@ 0x24
34004b7e:	e032      	b.n	34004be6 <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB1555)
34004b80:	68fb      	ldr	r3, [r7, #12]
34004b82:	689b      	ldr	r3, [r3, #8]
34004b84:	2b03      	cmp	r3, #3
34004b86:	d117      	bne.n	34004bb8 <DMA2D_SetConfig+0xec>
    {
      tmp1 = (tmp1 >> 31U);
34004b88:	6a3b      	ldr	r3, [r7, #32]
34004b8a:	0fdb      	lsrs	r3, r3, #31
34004b8c:	623b      	str	r3, [r7, #32]
      tmp2 = (tmp2 >> 19U);
34004b8e:	69fb      	ldr	r3, [r7, #28]
34004b90:	0cdb      	lsrs	r3, r3, #19
34004b92:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 11U);
34004b94:	69bb      	ldr	r3, [r7, #24]
34004b96:	0adb      	lsrs	r3, r3, #11
34004b98:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 3U);
34004b9a:	697b      	ldr	r3, [r7, #20]
34004b9c:	08db      	lsrs	r3, r3, #3
34004b9e:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
34004ba0:	69bb      	ldr	r3, [r7, #24]
34004ba2:	015a      	lsls	r2, r3, #5
34004ba4:	69fb      	ldr	r3, [r7, #28]
34004ba6:	029b      	lsls	r3, r3, #10
34004ba8:	431a      	orrs	r2, r3
34004baa:	6a3b      	ldr	r3, [r7, #32]
34004bac:	03db      	lsls	r3, r3, #15
34004bae:	4313      	orrs	r3, r2
34004bb0:	697a      	ldr	r2, [r7, #20]
34004bb2:	4313      	orrs	r3, r2
34004bb4:	627b      	str	r3, [r7, #36]	@ 0x24
34004bb6:	e016      	b.n	34004be6 <DMA2D_SetConfig+0x11a>
    }
    else /* Dhdma2d->Init.ColorMode = DMA2D_OUTPUT_ARGB4444 */
    {
      tmp1 = (tmp1 >> 28U);
34004bb8:	6a3b      	ldr	r3, [r7, #32]
34004bba:	0f1b      	lsrs	r3, r3, #28
34004bbc:	623b      	str	r3, [r7, #32]
      tmp2 = (tmp2 >> 20U);
34004bbe:	69fb      	ldr	r3, [r7, #28]
34004bc0:	0d1b      	lsrs	r3, r3, #20
34004bc2:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 12U);
34004bc4:	69bb      	ldr	r3, [r7, #24]
34004bc6:	0b1b      	lsrs	r3, r3, #12
34004bc8:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 4U);
34004bca:	697b      	ldr	r3, [r7, #20]
34004bcc:	091b      	lsrs	r3, r3, #4
34004bce:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
34004bd0:	69bb      	ldr	r3, [r7, #24]
34004bd2:	011a      	lsls	r2, r3, #4
34004bd4:	69fb      	ldr	r3, [r7, #28]
34004bd6:	021b      	lsls	r3, r3, #8
34004bd8:	431a      	orrs	r2, r3
34004bda:	6a3b      	ldr	r3, [r7, #32]
34004bdc:	031b      	lsls	r3, r3, #12
34004bde:	4313      	orrs	r3, r2
34004be0:	697a      	ldr	r2, [r7, #20]
34004be2:	4313      	orrs	r3, r2
34004be4:	627b      	str	r3, [r7, #36]	@ 0x24
    }
    /* Write to DMA2D OCOLR register */
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);
34004be6:	68fb      	ldr	r3, [r7, #12]
34004be8:	681b      	ldr	r3, [r3, #0]
34004bea:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
34004bec:	639a      	str	r2, [r3, #56]	@ 0x38
  else /* M2M, M2M_PFC,M2M_Blending or M2M_blending with fixed color BG DMA2D Mode */
  {
    /* Configure DMA2D source address */
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
  }
}
34004bee:	e00d      	b.n	34004c0c <DMA2D_SetConfig+0x140>
  else if (hdma2d->Init.Mode == DMA2D_M2M_BLEND_FG) /*M2M_blending with fixed color FG DMA2D Mode selected*/
34004bf0:	68fb      	ldr	r3, [r7, #12]
34004bf2:	685b      	ldr	r3, [r3, #4]
34004bf4:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
34004bf8:	d104      	bne.n	34004c04 <DMA2D_SetConfig+0x138>
    WRITE_REG(hdma2d->Instance->BGMAR, pdata);
34004bfa:	68fb      	ldr	r3, [r7, #12]
34004bfc:	681b      	ldr	r3, [r3, #0]
34004bfe:	68ba      	ldr	r2, [r7, #8]
34004c00:	615a      	str	r2, [r3, #20]
}
34004c02:	e003      	b.n	34004c0c <DMA2D_SetConfig+0x140>
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
34004c04:	68fb      	ldr	r3, [r7, #12]
34004c06:	681b      	ldr	r3, [r3, #0]
34004c08:	68ba      	ldr	r2, [r7, #8]
34004c0a:	60da      	str	r2, [r3, #12]
}
34004c0c:	bf00      	nop
34004c0e:	372c      	adds	r7, #44	@ 0x2c
34004c10:	46bd      	mov	sp, r7
34004c12:	f85d 7b04 	ldr.w	r7, [sp], #4
34004c16:	4770      	bx	lr

34004c18 <HAL_DMAEx_GetFifoLevel>:
  * @param  hdma : Pointer to a DMA_HandleTypeDef structure that contains the configuration information for the
  *                specified DMA Channel.
  * @retval Returns the number of available beats in FIFO.
  */
uint32_t HAL_DMAEx_GetFifoLevel(DMA_HandleTypeDef const *const hdma)
{
34004c18:	b480      	push	{r7}
34004c1a:	b083      	sub	sp, #12
34004c1c:	af00      	add	r7, sp, #0
34004c1e:	6078      	str	r0, [r7, #4]
  return ((hdma->Instance->CSR & DMA_CSR_FIFOL) >> DMA_CSR_FIFOL_Pos);
34004c20:	687b      	ldr	r3, [r7, #4]
34004c22:	681b      	ldr	r3, [r3, #0]
34004c24:	691b      	ldr	r3, [r3, #16]
34004c26:	0c1b      	lsrs	r3, r3, #16
34004c28:	b2db      	uxtb	r3, r3
}
34004c2a:	4618      	mov	r0, r3
34004c2c:	370c      	adds	r7, #12
34004c2e:	46bd      	mov	sp, r7
34004c30:	f85d 7b04 	ldr.w	r7, [sp], #4
34004c34:	4770      	bx	lr
	...

34004c38 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
34004c38:	b480      	push	{r7}
34004c3a:	b087      	sub	sp, #28
34004c3c:	af00      	add	r7, sp, #0
34004c3e:	6078      	str	r0, [r7, #4]
34004c40:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
34004c42:	2300      	movs	r3, #0
34004c44:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
34004c46:	e180      	b.n	34004f4a <HAL_GPIO_Init+0x312>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
34004c48:	683b      	ldr	r3, [r7, #0]
34004c4a:	681a      	ldr	r2, [r3, #0]
34004c4c:	2101      	movs	r1, #1
34004c4e:	697b      	ldr	r3, [r7, #20]
34004c50:	fa01 f303 	lsl.w	r3, r1, r3
34004c54:	4013      	ands	r3, r2
34004c56:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
34004c58:	68fb      	ldr	r3, [r7, #12]
34004c5a:	2b00      	cmp	r3, #0
34004c5c:	f000 8172 	beq.w	34004f44 <HAL_GPIO_Init+0x30c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
34004c60:	683b      	ldr	r3, [r7, #0]
34004c62:	685b      	ldr	r3, [r3, #4]
34004c64:	f003 0303 	and.w	r3, r3, #3
34004c68:	2b01      	cmp	r3, #1
34004c6a:	d005      	beq.n	34004c78 <HAL_GPIO_Init+0x40>
34004c6c:	683b      	ldr	r3, [r7, #0]
34004c6e:	685b      	ldr	r3, [r3, #4]
34004c70:	f003 0303 	and.w	r3, r3, #3
34004c74:	2b02      	cmp	r3, #2
34004c76:	d130      	bne.n	34004cda <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
34004c78:	687b      	ldr	r3, [r7, #4]
34004c7a:	689b      	ldr	r3, [r3, #8]
34004c7c:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34004c7e:	697b      	ldr	r3, [r7, #20]
34004c80:	005b      	lsls	r3, r3, #1
34004c82:	2203      	movs	r2, #3
34004c84:	fa02 f303 	lsl.w	r3, r2, r3
34004c88:	43db      	mvns	r3, r3
34004c8a:	693a      	ldr	r2, [r7, #16]
34004c8c:	4013      	ands	r3, r2
34004c8e:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
34004c90:	683b      	ldr	r3, [r7, #0]
34004c92:	68da      	ldr	r2, [r3, #12]
34004c94:	697b      	ldr	r3, [r7, #20]
34004c96:	005b      	lsls	r3, r3, #1
34004c98:	fa02 f303 	lsl.w	r3, r2, r3
34004c9c:	693a      	ldr	r2, [r7, #16]
34004c9e:	4313      	orrs	r3, r2
34004ca0:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
34004ca2:	687b      	ldr	r3, [r7, #4]
34004ca4:	693a      	ldr	r2, [r7, #16]
34004ca6:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
34004ca8:	687b      	ldr	r3, [r7, #4]
34004caa:	685b      	ldr	r3, [r3, #4]
34004cac:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
34004cae:	2201      	movs	r2, #1
34004cb0:	697b      	ldr	r3, [r7, #20]
34004cb2:	fa02 f303 	lsl.w	r3, r2, r3
34004cb6:	43db      	mvns	r3, r3
34004cb8:	693a      	ldr	r2, [r7, #16]
34004cba:	4013      	ands	r3, r2
34004cbc:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
34004cbe:	683b      	ldr	r3, [r7, #0]
34004cc0:	685b      	ldr	r3, [r3, #4]
34004cc2:	091b      	lsrs	r3, r3, #4
34004cc4:	f003 0201 	and.w	r2, r3, #1
34004cc8:	697b      	ldr	r3, [r7, #20]
34004cca:	fa02 f303 	lsl.w	r3, r2, r3
34004cce:	693a      	ldr	r2, [r7, #16]
34004cd0:	4313      	orrs	r3, r2
34004cd2:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
34004cd4:	687b      	ldr	r3, [r7, #4]
34004cd6:	693a      	ldr	r2, [r7, #16]
34004cd8:	605a      	str	r2, [r3, #4]
      }

      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
34004cda:	683b      	ldr	r3, [r7, #0]
34004cdc:	685b      	ldr	r3, [r3, #4]
34004cde:	f003 0303 	and.w	r3, r3, #3
34004ce2:	2b03      	cmp	r3, #3
34004ce4:	d109      	bne.n	34004cfa <HAL_GPIO_Init+0xc2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
34004ce6:	683b      	ldr	r3, [r7, #0]
34004ce8:	685b      	ldr	r3, [r3, #4]
34004cea:	f003 0303 	and.w	r3, r3, #3
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
34004cee:	2b03      	cmp	r3, #3
34004cf0:	d11b      	bne.n	34004d2a <HAL_GPIO_Init+0xf2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
34004cf2:	683b      	ldr	r3, [r7, #0]
34004cf4:	689b      	ldr	r3, [r3, #8]
34004cf6:	2b01      	cmp	r3, #1
34004cf8:	d017      	beq.n	34004d2a <HAL_GPIO_Init+0xf2>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
34004cfa:	687b      	ldr	r3, [r7, #4]
34004cfc:	68db      	ldr	r3, [r3, #12]
34004cfe:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
34004d00:	697b      	ldr	r3, [r7, #20]
34004d02:	005b      	lsls	r3, r3, #1
34004d04:	2203      	movs	r2, #3
34004d06:	fa02 f303 	lsl.w	r3, r2, r3
34004d0a:	43db      	mvns	r3, r3
34004d0c:	693a      	ldr	r2, [r7, #16]
34004d0e:	4013      	ands	r3, r2
34004d10:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
34004d12:	683b      	ldr	r3, [r7, #0]
34004d14:	689a      	ldr	r2, [r3, #8]
34004d16:	697b      	ldr	r3, [r7, #20]
34004d18:	005b      	lsls	r3, r3, #1
34004d1a:	fa02 f303 	lsl.w	r3, r2, r3
34004d1e:	693a      	ldr	r2, [r7, #16]
34004d20:	4313      	orrs	r3, r2
34004d22:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
34004d24:	687b      	ldr	r3, [r7, #4]
34004d26:	693a      	ldr	r2, [r7, #16]
34004d28:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
34004d2a:	683b      	ldr	r3, [r7, #0]
34004d2c:	685b      	ldr	r3, [r3, #4]
34004d2e:	f003 0303 	and.w	r3, r3, #3
34004d32:	2b02      	cmp	r3, #2
34004d34:	d123      	bne.n	34004d7e <HAL_GPIO_Init+0x146>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
34004d36:	697b      	ldr	r3, [r7, #20]
34004d38:	08da      	lsrs	r2, r3, #3
34004d3a:	687b      	ldr	r3, [r7, #4]
34004d3c:	3208      	adds	r2, #8
34004d3e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
34004d42:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34004d44:	697b      	ldr	r3, [r7, #20]
34004d46:	f003 0307 	and.w	r3, r3, #7
34004d4a:	009b      	lsls	r3, r3, #2
34004d4c:	220f      	movs	r2, #15
34004d4e:	fa02 f303 	lsl.w	r3, r2, r3
34004d52:	43db      	mvns	r3, r3
34004d54:	693a      	ldr	r2, [r7, #16]
34004d56:	4013      	ands	r3, r2
34004d58:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * GPIO_AFRL_AFSEL1_Pos));
34004d5a:	683b      	ldr	r3, [r7, #0]
34004d5c:	691a      	ldr	r2, [r3, #16]
34004d5e:	697b      	ldr	r3, [r7, #20]
34004d60:	f003 0307 	and.w	r3, r3, #7
34004d64:	009b      	lsls	r3, r3, #2
34004d66:	fa02 f303 	lsl.w	r3, r2, r3
34004d6a:	693a      	ldr	r2, [r7, #16]
34004d6c:	4313      	orrs	r3, r2
34004d6e:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
34004d70:	697b      	ldr	r3, [r7, #20]
34004d72:	08da      	lsrs	r2, r3, #3
34004d74:	687b      	ldr	r3, [r7, #4]
34004d76:	3208      	adds	r2, #8
34004d78:	6939      	ldr	r1, [r7, #16]
34004d7a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
34004d7e:	687b      	ldr	r3, [r7, #4]
34004d80:	681b      	ldr	r3, [r3, #0]
34004d82:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
34004d84:	697b      	ldr	r3, [r7, #20]
34004d86:	005b      	lsls	r3, r3, #1
34004d88:	2203      	movs	r2, #3
34004d8a:	fa02 f303 	lsl.w	r3, r2, r3
34004d8e:	43db      	mvns	r3, r3
34004d90:	693a      	ldr	r2, [r7, #16]
34004d92:	4013      	ands	r3, r2
34004d94:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
34004d96:	683b      	ldr	r3, [r7, #0]
34004d98:	685b      	ldr	r3, [r3, #4]
34004d9a:	f003 0203 	and.w	r2, r3, #3
34004d9e:	697b      	ldr	r3, [r7, #20]
34004da0:	005b      	lsls	r3, r3, #1
34004da2:	fa02 f303 	lsl.w	r3, r2, r3
34004da6:	693a      	ldr	r2, [r7, #16]
34004da8:	4313      	orrs	r3, r2
34004daa:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
34004dac:	687b      	ldr	r3, [r7, #4]
34004dae:	693a      	ldr	r2, [r7, #16]
34004db0:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
34004db2:	683b      	ldr	r3, [r7, #0]
34004db4:	685b      	ldr	r3, [r3, #4]
34004db6:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
34004dba:	2b00      	cmp	r3, #0
34004dbc:	f000 80c2 	beq.w	34004f44 <HAL_GPIO_Init+0x30c>
      {
        temp = EXTI->EXTICR[position >> 2u];
34004dc0:	4a69      	ldr	r2, [pc, #420]	@ (34004f68 <HAL_GPIO_Init+0x330>)
34004dc2:	697b      	ldr	r3, [r7, #20]
34004dc4:	089b      	lsrs	r3, r3, #2
34004dc6:	3318      	adds	r3, #24
34004dc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
34004dcc:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34004dce:	697b      	ldr	r3, [r7, #20]
34004dd0:	f003 0303 	and.w	r3, r3, #3
34004dd4:	00db      	lsls	r3, r3, #3
34004dd6:	220f      	movs	r2, #15
34004dd8:	fa02 f303 	lsl.w	r3, r2, r3
34004ddc:	43db      	mvns	r3, r3
34004dde:	693a      	ldr	r2, [r7, #16]
34004de0:	4013      	ands	r3, r2
34004de2:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03u) * EXTI_EXTICR1_EXTI1_Pos));
34004de4:	687b      	ldr	r3, [r7, #4]
34004de6:	4a61      	ldr	r2, [pc, #388]	@ (34004f6c <HAL_GPIO_Init+0x334>)
34004de8:	4293      	cmp	r3, r2
34004dea:	d043      	beq.n	34004e74 <HAL_GPIO_Init+0x23c>
34004dec:	687b      	ldr	r3, [r7, #4]
34004dee:	4a60      	ldr	r2, [pc, #384]	@ (34004f70 <HAL_GPIO_Init+0x338>)
34004df0:	4293      	cmp	r3, r2
34004df2:	d03d      	beq.n	34004e70 <HAL_GPIO_Init+0x238>
34004df4:	687b      	ldr	r3, [r7, #4]
34004df6:	4a5f      	ldr	r2, [pc, #380]	@ (34004f74 <HAL_GPIO_Init+0x33c>)
34004df8:	4293      	cmp	r3, r2
34004dfa:	d037      	beq.n	34004e6c <HAL_GPIO_Init+0x234>
34004dfc:	687b      	ldr	r3, [r7, #4]
34004dfe:	4a5e      	ldr	r2, [pc, #376]	@ (34004f78 <HAL_GPIO_Init+0x340>)
34004e00:	4293      	cmp	r3, r2
34004e02:	d031      	beq.n	34004e68 <HAL_GPIO_Init+0x230>
34004e04:	687b      	ldr	r3, [r7, #4]
34004e06:	4a5d      	ldr	r2, [pc, #372]	@ (34004f7c <HAL_GPIO_Init+0x344>)
34004e08:	4293      	cmp	r3, r2
34004e0a:	d02b      	beq.n	34004e64 <HAL_GPIO_Init+0x22c>
34004e0c:	687b      	ldr	r3, [r7, #4]
34004e0e:	4a5c      	ldr	r2, [pc, #368]	@ (34004f80 <HAL_GPIO_Init+0x348>)
34004e10:	4293      	cmp	r3, r2
34004e12:	d025      	beq.n	34004e60 <HAL_GPIO_Init+0x228>
34004e14:	687b      	ldr	r3, [r7, #4]
34004e16:	4a5b      	ldr	r2, [pc, #364]	@ (34004f84 <HAL_GPIO_Init+0x34c>)
34004e18:	4293      	cmp	r3, r2
34004e1a:	d01f      	beq.n	34004e5c <HAL_GPIO_Init+0x224>
34004e1c:	687b      	ldr	r3, [r7, #4]
34004e1e:	4a5a      	ldr	r2, [pc, #360]	@ (34004f88 <HAL_GPIO_Init+0x350>)
34004e20:	4293      	cmp	r3, r2
34004e22:	d019      	beq.n	34004e58 <HAL_GPIO_Init+0x220>
34004e24:	687b      	ldr	r3, [r7, #4]
34004e26:	4a59      	ldr	r2, [pc, #356]	@ (34004f8c <HAL_GPIO_Init+0x354>)
34004e28:	4293      	cmp	r3, r2
34004e2a:	d013      	beq.n	34004e54 <HAL_GPIO_Init+0x21c>
34004e2c:	687b      	ldr	r3, [r7, #4]
34004e2e:	4a58      	ldr	r2, [pc, #352]	@ (34004f90 <HAL_GPIO_Init+0x358>)
34004e30:	4293      	cmp	r3, r2
34004e32:	d00d      	beq.n	34004e50 <HAL_GPIO_Init+0x218>
34004e34:	687b      	ldr	r3, [r7, #4]
34004e36:	4a57      	ldr	r2, [pc, #348]	@ (34004f94 <HAL_GPIO_Init+0x35c>)
34004e38:	4293      	cmp	r3, r2
34004e3a:	d007      	beq.n	34004e4c <HAL_GPIO_Init+0x214>
34004e3c:	687b      	ldr	r3, [r7, #4]
34004e3e:	4a56      	ldr	r2, [pc, #344]	@ (34004f98 <HAL_GPIO_Init+0x360>)
34004e40:	4293      	cmp	r3, r2
34004e42:	d101      	bne.n	34004e48 <HAL_GPIO_Init+0x210>
34004e44:	230b      	movs	r3, #11
34004e46:	e016      	b.n	34004e76 <HAL_GPIO_Init+0x23e>
34004e48:	2310      	movs	r3, #16
34004e4a:	e014      	b.n	34004e76 <HAL_GPIO_Init+0x23e>
34004e4c:	230a      	movs	r3, #10
34004e4e:	e012      	b.n	34004e76 <HAL_GPIO_Init+0x23e>
34004e50:	2309      	movs	r3, #9
34004e52:	e010      	b.n	34004e76 <HAL_GPIO_Init+0x23e>
34004e54:	2308      	movs	r3, #8
34004e56:	e00e      	b.n	34004e76 <HAL_GPIO_Init+0x23e>
34004e58:	2307      	movs	r3, #7
34004e5a:	e00c      	b.n	34004e76 <HAL_GPIO_Init+0x23e>
34004e5c:	2306      	movs	r3, #6
34004e5e:	e00a      	b.n	34004e76 <HAL_GPIO_Init+0x23e>
34004e60:	2305      	movs	r3, #5
34004e62:	e008      	b.n	34004e76 <HAL_GPIO_Init+0x23e>
34004e64:	2304      	movs	r3, #4
34004e66:	e006      	b.n	34004e76 <HAL_GPIO_Init+0x23e>
34004e68:	2303      	movs	r3, #3
34004e6a:	e004      	b.n	34004e76 <HAL_GPIO_Init+0x23e>
34004e6c:	2302      	movs	r3, #2
34004e6e:	e002      	b.n	34004e76 <HAL_GPIO_Init+0x23e>
34004e70:	2301      	movs	r3, #1
34004e72:	e000      	b.n	34004e76 <HAL_GPIO_Init+0x23e>
34004e74:	2300      	movs	r3, #0
34004e76:	697a      	ldr	r2, [r7, #20]
34004e78:	f002 0203 	and.w	r2, r2, #3
34004e7c:	00d2      	lsls	r2, r2, #3
34004e7e:	4093      	lsls	r3, r2
34004e80:	693a      	ldr	r2, [r7, #16]
34004e82:	4313      	orrs	r3, r2
34004e84:	613b      	str	r3, [r7, #16]
        EXTI->EXTICR[position >> 2u] = temp;
34004e86:	4938      	ldr	r1, [pc, #224]	@ (34004f68 <HAL_GPIO_Init+0x330>)
34004e88:	697b      	ldr	r3, [r7, #20]
34004e8a:	089b      	lsrs	r3, r3, #2
34004e8c:	3318      	adds	r3, #24
34004e8e:	693a      	ldr	r2, [r7, #16]
34004e90:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
34004e94:	4b34      	ldr	r3, [pc, #208]	@ (34004f68 <HAL_GPIO_Init+0x330>)
34004e96:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
34004e9a:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34004e9c:	68fb      	ldr	r3, [r7, #12]
34004e9e:	43db      	mvns	r3, r3
34004ea0:	693a      	ldr	r2, [r7, #16]
34004ea2:	4013      	ands	r3, r2
34004ea4:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
34004ea6:	683b      	ldr	r3, [r7, #0]
34004ea8:	685b      	ldr	r3, [r3, #4]
34004eaa:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34004eae:	2b00      	cmp	r3, #0
34004eb0:	d003      	beq.n	34004eba <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
34004eb2:	693a      	ldr	r2, [r7, #16]
34004eb4:	68fb      	ldr	r3, [r7, #12]
34004eb6:	4313      	orrs	r3, r2
34004eb8:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
34004eba:	4a2b      	ldr	r2, [pc, #172]	@ (34004f68 <HAL_GPIO_Init+0x330>)
34004ebc:	693b      	ldr	r3, [r7, #16]
34004ebe:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80

        temp = EXTI->EMR1;
34004ec2:	4b29      	ldr	r3, [pc, #164]	@ (34004f68 <HAL_GPIO_Init+0x330>)
34004ec4:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34004ec8:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34004eca:	68fb      	ldr	r3, [r7, #12]
34004ecc:	43db      	mvns	r3, r3
34004ece:	693a      	ldr	r2, [r7, #16]
34004ed0:	4013      	ands	r3, r2
34004ed2:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
34004ed4:	683b      	ldr	r3, [r7, #0]
34004ed6:	685b      	ldr	r3, [r3, #4]
34004ed8:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
34004edc:	2b00      	cmp	r3, #0
34004ede:	d003      	beq.n	34004ee8 <HAL_GPIO_Init+0x2b0>
        {
          temp |= iocurrent;
34004ee0:	693a      	ldr	r2, [r7, #16]
34004ee2:	68fb      	ldr	r3, [r7, #12]
34004ee4:	4313      	orrs	r3, r2
34004ee6:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
34004ee8:	4a1f      	ldr	r2, [pc, #124]	@ (34004f68 <HAL_GPIO_Init+0x330>)
34004eea:	693b      	ldr	r3, [r7, #16]
34004eec:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
34004ef0:	4b1d      	ldr	r3, [pc, #116]	@ (34004f68 <HAL_GPIO_Init+0x330>)
34004ef2:	681b      	ldr	r3, [r3, #0]
34004ef4:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34004ef6:	68fb      	ldr	r3, [r7, #12]
34004ef8:	43db      	mvns	r3, r3
34004efa:	693a      	ldr	r2, [r7, #16]
34004efc:	4013      	ands	r3, r2
34004efe:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
34004f00:	683b      	ldr	r3, [r7, #0]
34004f02:	685b      	ldr	r3, [r3, #4]
34004f04:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
34004f08:	2b00      	cmp	r3, #0
34004f0a:	d003      	beq.n	34004f14 <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
34004f0c:	693a      	ldr	r2, [r7, #16]
34004f0e:	68fb      	ldr	r3, [r7, #12]
34004f10:	4313      	orrs	r3, r2
34004f12:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
34004f14:	4a14      	ldr	r2, [pc, #80]	@ (34004f68 <HAL_GPIO_Init+0x330>)
34004f16:	693b      	ldr	r3, [r7, #16]
34004f18:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
34004f1a:	4b13      	ldr	r3, [pc, #76]	@ (34004f68 <HAL_GPIO_Init+0x330>)
34004f1c:	685b      	ldr	r3, [r3, #4]
34004f1e:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
34004f20:	68fb      	ldr	r3, [r7, #12]
34004f22:	43db      	mvns	r3, r3
34004f24:	693a      	ldr	r2, [r7, #16]
34004f26:	4013      	ands	r3, r2
34004f28:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
34004f2a:	683b      	ldr	r3, [r7, #0]
34004f2c:	685b      	ldr	r3, [r3, #4]
34004f2e:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
34004f32:	2b00      	cmp	r3, #0
34004f34:	d003      	beq.n	34004f3e <HAL_GPIO_Init+0x306>
        {
          temp |= iocurrent;
34004f36:	693a      	ldr	r2, [r7, #16]
34004f38:	68fb      	ldr	r3, [r7, #12]
34004f3a:	4313      	orrs	r3, r2
34004f3c:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
34004f3e:	4a0a      	ldr	r2, [pc, #40]	@ (34004f68 <HAL_GPIO_Init+0x330>)
34004f40:	693b      	ldr	r3, [r7, #16]
34004f42:	6053      	str	r3, [r2, #4]
      }
    }

    position++;
34004f44:	697b      	ldr	r3, [r7, #20]
34004f46:	3301      	adds	r3, #1
34004f48:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
34004f4a:	683b      	ldr	r3, [r7, #0]
34004f4c:	681a      	ldr	r2, [r3, #0]
34004f4e:	697b      	ldr	r3, [r7, #20]
34004f50:	fa22 f303 	lsr.w	r3, r2, r3
34004f54:	2b00      	cmp	r3, #0
34004f56:	f47f ae77 	bne.w	34004c48 <HAL_GPIO_Init+0x10>
  }
}
34004f5a:	bf00      	nop
34004f5c:	bf00      	nop
34004f5e:	371c      	adds	r7, #28
34004f60:	46bd      	mov	sp, r7
34004f62:	f85d 7b04 	ldr.w	r7, [sp], #4
34004f66:	4770      	bx	lr
34004f68:	56025000 	.word	0x56025000
34004f6c:	56020000 	.word	0x56020000
34004f70:	56020400 	.word	0x56020400
34004f74:	56020800 	.word	0x56020800
34004f78:	56020c00 	.word	0x56020c00
34004f7c:	56021000 	.word	0x56021000
34004f80:	56021400 	.word	0x56021400
34004f84:	56021800 	.word	0x56021800
34004f88:	56021c00 	.word	0x56021c00
34004f8c:	56023400 	.word	0x56023400
34004f90:	56023800 	.word	0x56023800
34004f94:	56023c00 	.word	0x56023c00
34004f98:	56024000 	.word	0x56024000

34004f9c <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
34004f9c:	b480      	push	{r7}
34004f9e:	b083      	sub	sp, #12
34004fa0:	af00      	add	r7, sp, #0
34004fa2:	6078      	str	r0, [r7, #4]
34004fa4:	460b      	mov	r3, r1
34004fa6:	807b      	strh	r3, [r7, #2]
34004fa8:	4613      	mov	r3, r2
34004faa:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
34004fac:	787b      	ldrb	r3, [r7, #1]
34004fae:	2b00      	cmp	r3, #0
34004fb0:	d003      	beq.n	34004fba <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
34004fb2:	887a      	ldrh	r2, [r7, #2]
34004fb4:	687b      	ldr	r3, [r7, #4]
34004fb6:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
34004fb8:	e002      	b.n	34004fc0 <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
34004fba:	887a      	ldrh	r2, [r7, #2]
34004fbc:	687b      	ldr	r3, [r7, #4]
34004fbe:	629a      	str	r2, [r3, #40]	@ 0x28
}
34004fc0:	bf00      	nop
34004fc2:	370c      	adds	r7, #12
34004fc4:	46bd      	mov	sp, r7
34004fc6:	f85d 7b04 	ldr.w	r7, [sp], #4
34004fca:	4770      	bx	lr

34004fcc <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
34004fcc:	b580      	push	{r7, lr}
34004fce:	b082      	sub	sp, #8
34004fd0:	af00      	add	r7, sp, #0
34004fd2:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
34004fd4:	687b      	ldr	r3, [r7, #4]
34004fd6:	2b00      	cmp	r3, #0
34004fd8:	d101      	bne.n	34004fde <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
34004fda:	2301      	movs	r3, #1
34004fdc:	e08d      	b.n	340050fa <HAL_I2C_Init+0x12e>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
34004fde:	687b      	ldr	r3, [r7, #4]
34004fe0:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34004fe4:	b2db      	uxtb	r3, r3
34004fe6:	2b00      	cmp	r3, #0
34004fe8:	d106      	bne.n	34004ff8 <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
34004fea:	687b      	ldr	r3, [r7, #4]
34004fec:	2200      	movs	r2, #0
34004fee:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
34004ff2:	6878      	ldr	r0, [r7, #4]
34004ff4:	f7fc fa3e 	bl	34001474 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
34004ff8:	687b      	ldr	r3, [r7, #4]
34004ffa:	2224      	movs	r2, #36	@ 0x24
34004ffc:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
34005000:	687b      	ldr	r3, [r7, #4]
34005002:	681b      	ldr	r3, [r3, #0]
34005004:	681a      	ldr	r2, [r3, #0]
34005006:	687b      	ldr	r3, [r7, #4]
34005008:	681b      	ldr	r3, [r3, #0]
3400500a:	f022 0201 	bic.w	r2, r2, #1
3400500e:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
34005010:	687b      	ldr	r3, [r7, #4]
34005012:	685a      	ldr	r2, [r3, #4]
34005014:	687b      	ldr	r3, [r7, #4]
34005016:	681b      	ldr	r3, [r3, #0]
34005018:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
3400501c:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
3400501e:	687b      	ldr	r3, [r7, #4]
34005020:	681b      	ldr	r3, [r3, #0]
34005022:	689a      	ldr	r2, [r3, #8]
34005024:	687b      	ldr	r3, [r7, #4]
34005026:	681b      	ldr	r3, [r3, #0]
34005028:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
3400502c:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
3400502e:	687b      	ldr	r3, [r7, #4]
34005030:	68db      	ldr	r3, [r3, #12]
34005032:	2b01      	cmp	r3, #1
34005034:	d107      	bne.n	34005046 <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
34005036:	687b      	ldr	r3, [r7, #4]
34005038:	689a      	ldr	r2, [r3, #8]
3400503a:	687b      	ldr	r3, [r7, #4]
3400503c:	681b      	ldr	r3, [r3, #0]
3400503e:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34005042:	609a      	str	r2, [r3, #8]
34005044:	e006      	b.n	34005054 <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
34005046:	687b      	ldr	r3, [r7, #4]
34005048:	689a      	ldr	r2, [r3, #8]
3400504a:	687b      	ldr	r3, [r7, #4]
3400504c:	681b      	ldr	r3, [r3, #0]
3400504e:	f442 4204 	orr.w	r2, r2, #33792	@ 0x8400
34005052:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
34005054:	687b      	ldr	r3, [r7, #4]
34005056:	68db      	ldr	r3, [r3, #12]
34005058:	2b02      	cmp	r3, #2
3400505a:	d108      	bne.n	3400506e <HAL_I2C_Init+0xa2>
  {
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
3400505c:	687b      	ldr	r3, [r7, #4]
3400505e:	681b      	ldr	r3, [r3, #0]
34005060:	685a      	ldr	r2, [r3, #4]
34005062:	687b      	ldr	r3, [r7, #4]
34005064:	681b      	ldr	r3, [r3, #0]
34005066:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
3400506a:	605a      	str	r2, [r3, #4]
3400506c:	e007      	b.n	3400507e <HAL_I2C_Init+0xb2>
  }
  else
  {
    /* Clear the I2C ADD10 bit */
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
3400506e:	687b      	ldr	r3, [r7, #4]
34005070:	681b      	ldr	r3, [r3, #0]
34005072:	685a      	ldr	r2, [r3, #4]
34005074:	687b      	ldr	r3, [r7, #4]
34005076:	681b      	ldr	r3, [r3, #0]
34005078:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
3400507c:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
3400507e:	687b      	ldr	r3, [r7, #4]
34005080:	681b      	ldr	r3, [r3, #0]
34005082:	685b      	ldr	r3, [r3, #4]
34005084:	687a      	ldr	r2, [r7, #4]
34005086:	6812      	ldr	r2, [r2, #0]
34005088:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
3400508c:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
34005090:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
34005092:	687b      	ldr	r3, [r7, #4]
34005094:	681b      	ldr	r3, [r3, #0]
34005096:	68da      	ldr	r2, [r3, #12]
34005098:	687b      	ldr	r3, [r7, #4]
3400509a:	681b      	ldr	r3, [r3, #0]
3400509c:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
340050a0:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
340050a2:	687b      	ldr	r3, [r7, #4]
340050a4:	691a      	ldr	r2, [r3, #16]
340050a6:	687b      	ldr	r3, [r7, #4]
340050a8:	695b      	ldr	r3, [r3, #20]
340050aa:	ea42 0103 	orr.w	r1, r2, r3
                          (hi2c->Init.OwnAddress2Masks << 8));
340050ae:	687b      	ldr	r3, [r7, #4]
340050b0:	699b      	ldr	r3, [r3, #24]
340050b2:	021a      	lsls	r2, r3, #8
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
340050b4:	687b      	ldr	r3, [r7, #4]
340050b6:	681b      	ldr	r3, [r3, #0]
340050b8:	430a      	orrs	r2, r1
340050ba:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
340050bc:	687b      	ldr	r3, [r7, #4]
340050be:	69d9      	ldr	r1, [r3, #28]
340050c0:	687b      	ldr	r3, [r7, #4]
340050c2:	6a1a      	ldr	r2, [r3, #32]
340050c4:	687b      	ldr	r3, [r7, #4]
340050c6:	681b      	ldr	r3, [r3, #0]
340050c8:	430a      	orrs	r2, r1
340050ca:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
340050cc:	687b      	ldr	r3, [r7, #4]
340050ce:	681b      	ldr	r3, [r3, #0]
340050d0:	681a      	ldr	r2, [r3, #0]
340050d2:	687b      	ldr	r3, [r7, #4]
340050d4:	681b      	ldr	r3, [r3, #0]
340050d6:	f042 0201 	orr.w	r2, r2, #1
340050da:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
340050dc:	687b      	ldr	r3, [r7, #4]
340050de:	2200      	movs	r2, #0
340050e0:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
340050e2:	687b      	ldr	r3, [r7, #4]
340050e4:	2220      	movs	r2, #32
340050e6:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
340050ea:	687b      	ldr	r3, [r7, #4]
340050ec:	2200      	movs	r2, #0
340050ee:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
340050f0:	687b      	ldr	r3, [r7, #4]
340050f2:	2200      	movs	r2, #0
340050f4:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  return HAL_OK;
340050f8:	2300      	movs	r3, #0
}
340050fa:	4618      	mov	r0, r3
340050fc:	3708      	adds	r7, #8
340050fe:	46bd      	mov	sp, r7
34005100:	bd80      	pop	{r7, pc}
	...

34005104 <HAL_I2C_Master_Transmit_IT>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                             uint16_t Size)
{
34005104:	b580      	push	{r7, lr}
34005106:	b088      	sub	sp, #32
34005108:	af02      	add	r7, sp, #8
3400510a:	60f8      	str	r0, [r7, #12]
3400510c:	607a      	str	r2, [r7, #4]
3400510e:	461a      	mov	r2, r3
34005110:	460b      	mov	r3, r1
34005112:	817b      	strh	r3, [r7, #10]
34005114:	4613      	mov	r3, r2
34005116:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;

  if (hi2c->State == HAL_I2C_STATE_READY)
34005118:	68fb      	ldr	r3, [r7, #12]
3400511a:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400511e:	b2db      	uxtb	r3, r3
34005120:	2b20      	cmp	r3, #32
34005122:	d153      	bne.n	340051cc <HAL_I2C_Master_Transmit_IT+0xc8>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
34005124:	68fb      	ldr	r3, [r7, #12]
34005126:	681b      	ldr	r3, [r3, #0]
34005128:	699b      	ldr	r3, [r3, #24]
3400512a:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
3400512e:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
34005132:	d101      	bne.n	34005138 <HAL_I2C_Master_Transmit_IT+0x34>
    {
      return HAL_BUSY;
34005134:	2302      	movs	r3, #2
34005136:	e04a      	b.n	340051ce <HAL_I2C_Master_Transmit_IT+0xca>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
34005138:	68fb      	ldr	r3, [r7, #12]
3400513a:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
3400513e:	2b01      	cmp	r3, #1
34005140:	d101      	bne.n	34005146 <HAL_I2C_Master_Transmit_IT+0x42>
34005142:	2302      	movs	r3, #2
34005144:	e043      	b.n	340051ce <HAL_I2C_Master_Transmit_IT+0xca>
34005146:	68fb      	ldr	r3, [r7, #12]
34005148:	2201      	movs	r2, #1
3400514a:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
3400514e:	68fb      	ldr	r3, [r7, #12]
34005150:	2221      	movs	r2, #33	@ 0x21
34005152:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
34005156:	68fb      	ldr	r3, [r7, #12]
34005158:	2210      	movs	r2, #16
3400515a:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
3400515e:	68fb      	ldr	r3, [r7, #12]
34005160:	2200      	movs	r2, #0
34005162:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
34005164:	68fb      	ldr	r3, [r7, #12]
34005166:	687a      	ldr	r2, [r7, #4]
34005168:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount   = Size;
3400516a:	68fb      	ldr	r3, [r7, #12]
3400516c:	893a      	ldrh	r2, [r7, #8]
3400516e:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
34005170:	68fb      	ldr	r3, [r7, #12]
34005172:	4a19      	ldr	r2, [pc, #100]	@ (340051d8 <HAL_I2C_Master_Transmit_IT+0xd4>)
34005174:	62da      	str	r2, [r3, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
34005176:	68fb      	ldr	r3, [r7, #12]
34005178:	4a18      	ldr	r2, [pc, #96]	@ (340051dc <HAL_I2C_Master_Transmit_IT+0xd8>)
3400517a:	635a      	str	r2, [r3, #52]	@ 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
3400517c:	68fb      	ldr	r3, [r7, #12]
3400517e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005180:	b29b      	uxth	r3, r3
34005182:	2bff      	cmp	r3, #255	@ 0xff
34005184:	d906      	bls.n	34005194 <HAL_I2C_Master_Transmit_IT+0x90>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
34005186:	68fb      	ldr	r3, [r7, #12]
34005188:	22ff      	movs	r2, #255	@ 0xff
3400518a:	851a      	strh	r2, [r3, #40]	@ 0x28
      xfermode = I2C_RELOAD_MODE;
3400518c:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34005190:	617b      	str	r3, [r7, #20]
34005192:	e007      	b.n	340051a4 <HAL_I2C_Master_Transmit_IT+0xa0>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
34005194:	68fb      	ldr	r3, [r7, #12]
34005196:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005198:	b29a      	uxth	r2, r3
3400519a:	68fb      	ldr	r3, [r7, #12]
3400519c:	851a      	strh	r2, [r3, #40]	@ 0x28
      xfermode = I2C_AUTOEND_MODE;
3400519e:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
340051a2:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
340051a4:	68fb      	ldr	r3, [r7, #12]
340051a6:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
340051a8:	b2da      	uxtb	r2, r3
340051aa:	8979      	ldrh	r1, [r7, #10]
340051ac:	4b0c      	ldr	r3, [pc, #48]	@ (340051e0 <HAL_I2C_Master_Transmit_IT+0xdc>)
340051ae:	9300      	str	r3, [sp, #0]
340051b0:	697b      	ldr	r3, [r7, #20]
340051b2:	68f8      	ldr	r0, [r7, #12]
340051b4:	f001 fc2e 	bl	34006a14 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
340051b8:	68fb      	ldr	r3, [r7, #12]
340051ba:	2200      	movs	r2, #0
340051bc:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT);
340051c0:	2101      	movs	r1, #1
340051c2:	68f8      	ldr	r0, [r7, #12]
340051c4:	f001 fc58 	bl	34006a78 <I2C_Enable_IRQ>

    return HAL_OK;
340051c8:	2300      	movs	r3, #0
340051ca:	e000      	b.n	340051ce <HAL_I2C_Master_Transmit_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
340051cc:	2302      	movs	r3, #2
  }
}
340051ce:	4618      	mov	r0, r3
340051d0:	3718      	adds	r7, #24
340051d2:	46bd      	mov	sp, r7
340051d4:	bd80      	pop	{r7, pc}
340051d6:	bf00      	nop
340051d8:	ffff0000 	.word	0xffff0000
340051dc:	34005567 	.word	0x34005567
340051e0:	80002000 	.word	0x80002000

340051e4 <HAL_I2C_Master_Receive_IT>:
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData,
                                            uint16_t Size)
{
340051e4:	b580      	push	{r7, lr}
340051e6:	b088      	sub	sp, #32
340051e8:	af02      	add	r7, sp, #8
340051ea:	60f8      	str	r0, [r7, #12]
340051ec:	607a      	str	r2, [r7, #4]
340051ee:	461a      	mov	r2, r3
340051f0:	460b      	mov	r3, r1
340051f2:	817b      	strh	r3, [r7, #10]
340051f4:	4613      	mov	r3, r2
340051f6:	813b      	strh	r3, [r7, #8]
  uint32_t xfermode;

  if (hi2c->State == HAL_I2C_STATE_READY)
340051f8:	68fb      	ldr	r3, [r7, #12]
340051fa:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
340051fe:	b2db      	uxtb	r3, r3
34005200:	2b20      	cmp	r3, #32
34005202:	d153      	bne.n	340052ac <HAL_I2C_Master_Receive_IT+0xc8>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
34005204:	68fb      	ldr	r3, [r7, #12]
34005206:	681b      	ldr	r3, [r3, #0]
34005208:	699b      	ldr	r3, [r3, #24]
3400520a:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
3400520e:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
34005212:	d101      	bne.n	34005218 <HAL_I2C_Master_Receive_IT+0x34>
    {
      return HAL_BUSY;
34005214:	2302      	movs	r3, #2
34005216:	e04a      	b.n	340052ae <HAL_I2C_Master_Receive_IT+0xca>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
34005218:	68fb      	ldr	r3, [r7, #12]
3400521a:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
3400521e:	2b01      	cmp	r3, #1
34005220:	d101      	bne.n	34005226 <HAL_I2C_Master_Receive_IT+0x42>
34005222:	2302      	movs	r3, #2
34005224:	e043      	b.n	340052ae <HAL_I2C_Master_Receive_IT+0xca>
34005226:	68fb      	ldr	r3, [r7, #12]
34005228:	2201      	movs	r2, #1
3400522a:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
3400522e:	68fb      	ldr	r3, [r7, #12]
34005230:	2222      	movs	r2, #34	@ 0x22
34005232:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
34005236:	68fb      	ldr	r3, [r7, #12]
34005238:	2210      	movs	r2, #16
3400523a:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
3400523e:	68fb      	ldr	r3, [r7, #12]
34005240:	2200      	movs	r2, #0
34005242:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
34005244:	68fb      	ldr	r3, [r7, #12]
34005246:	687a      	ldr	r2, [r7, #4]
34005248:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount   = Size;
3400524a:	68fb      	ldr	r3, [r7, #12]
3400524c:	893a      	ldrh	r2, [r7, #8]
3400524e:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
34005250:	68fb      	ldr	r3, [r7, #12]
34005252:	4a19      	ldr	r2, [pc, #100]	@ (340052b8 <HAL_I2C_Master_Receive_IT+0xd4>)
34005254:	62da      	str	r2, [r3, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Master_ISR_IT;
34005256:	68fb      	ldr	r3, [r7, #12]
34005258:	4a18      	ldr	r2, [pc, #96]	@ (340052bc <HAL_I2C_Master_Receive_IT+0xd8>)
3400525a:	635a      	str	r2, [r3, #52]	@ 0x34

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
3400525c:	68fb      	ldr	r3, [r7, #12]
3400525e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005260:	b29b      	uxth	r3, r3
34005262:	2bff      	cmp	r3, #255	@ 0xff
34005264:	d906      	bls.n	34005274 <HAL_I2C_Master_Receive_IT+0x90>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
34005266:	68fb      	ldr	r3, [r7, #12]
34005268:	22ff      	movs	r2, #255	@ 0xff
3400526a:	851a      	strh	r2, [r3, #40]	@ 0x28
      xfermode = I2C_RELOAD_MODE;
3400526c:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34005270:	617b      	str	r3, [r7, #20]
34005272:	e007      	b.n	34005284 <HAL_I2C_Master_Receive_IT+0xa0>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
34005274:	68fb      	ldr	r3, [r7, #12]
34005276:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005278:	b29a      	uxth	r2, r3
3400527a:	68fb      	ldr	r3, [r7, #12]
3400527c:	851a      	strh	r2, [r3, #40]	@ 0x28
      xfermode = I2C_AUTOEND_MODE;
3400527e:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34005282:	617b      	str	r3, [r7, #20]
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_READ);
34005284:	68fb      	ldr	r3, [r7, #12]
34005286:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34005288:	b2da      	uxtb	r2, r3
3400528a:	8979      	ldrh	r1, [r7, #10]
3400528c:	4b0c      	ldr	r3, [pc, #48]	@ (340052c0 <HAL_I2C_Master_Receive_IT+0xdc>)
3400528e:	9300      	str	r3, [sp, #0]
34005290:	697b      	ldr	r3, [r7, #20]
34005292:	68f8      	ldr	r0, [r7, #12]
34005294:	f001 fbbe 	bl	34006a14 <I2C_TransferConfig>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34005298:	68fb      	ldr	r3, [r7, #12]
3400529a:	2200      	movs	r2, #0
3400529c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT);
340052a0:	2102      	movs	r1, #2
340052a2:	68f8      	ldr	r0, [r7, #12]
340052a4:	f001 fbe8 	bl	34006a78 <I2C_Enable_IRQ>

    return HAL_OK;
340052a8:	2300      	movs	r3, #0
340052aa:	e000      	b.n	340052ae <HAL_I2C_Master_Receive_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
340052ac:	2302      	movs	r3, #2
  }
}
340052ae:	4618      	mov	r0, r3
340052b0:	3718      	adds	r7, #24
340052b2:	46bd      	mov	sp, r7
340052b4:	bd80      	pop	{r7, pc}
340052b6:	bf00      	nop
340052b8:	ffff0000 	.word	0xffff0000
340052bc:	34005567 	.word	0x34005567
340052c0:	80002400 	.word	0x80002400

340052c4 <HAL_I2C_Slave_Transmit_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
340052c4:	b580      	push	{r7, lr}
340052c6:	b084      	sub	sp, #16
340052c8:	af00      	add	r7, sp, #0
340052ca:	60f8      	str	r0, [r7, #12]
340052cc:	60b9      	str	r1, [r7, #8]
340052ce:	4613      	mov	r3, r2
340052d0:	80fb      	strh	r3, [r7, #6]
  if (hi2c->State == HAL_I2C_STATE_READY)
340052d2:	68fb      	ldr	r3, [r7, #12]
340052d4:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
340052d8:	b2db      	uxtb	r3, r3
340052da:	2b20      	cmp	r3, #32
340052dc:	d156      	bne.n	3400538c <HAL_I2C_Slave_Transmit_IT+0xc8>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
340052de:	68fb      	ldr	r3, [r7, #12]
340052e0:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
340052e4:	2b01      	cmp	r3, #1
340052e6:	d101      	bne.n	340052ec <HAL_I2C_Slave_Transmit_IT+0x28>
340052e8:	2302      	movs	r3, #2
340052ea:	e050      	b.n	3400538e <HAL_I2C_Slave_Transmit_IT+0xca>
340052ec:	68fb      	ldr	r3, [r7, #12]
340052ee:	2201      	movs	r2, #1
340052f0:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
340052f4:	68fb      	ldr	r3, [r7, #12]
340052f6:	2221      	movs	r2, #33	@ 0x21
340052f8:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
340052fc:	68fb      	ldr	r3, [r7, #12]
340052fe:	2220      	movs	r2, #32
34005300:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
34005304:	68fb      	ldr	r3, [r7, #12]
34005306:	2200      	movs	r2, #0
34005308:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
3400530a:	68fb      	ldr	r3, [r7, #12]
3400530c:	681b      	ldr	r3, [r3, #0]
3400530e:	685a      	ldr	r2, [r3, #4]
34005310:	68fb      	ldr	r3, [r7, #12]
34005312:	681b      	ldr	r3, [r3, #0]
34005314:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
34005318:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
3400531a:	68fb      	ldr	r3, [r7, #12]
3400531c:	68ba      	ldr	r2, [r7, #8]
3400531e:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount   = Size;
34005320:	68fb      	ldr	r3, [r7, #12]
34005322:	88fa      	ldrh	r2, [r7, #6]
34005324:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferSize    = hi2c->XferCount;
34005326:	68fb      	ldr	r3, [r7, #12]
34005328:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400532a:	b29a      	uxth	r2, r3
3400532c:	68fb      	ldr	r3, [r7, #12]
3400532e:	851a      	strh	r2, [r3, #40]	@ 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
34005330:	68fb      	ldr	r3, [r7, #12]
34005332:	4a19      	ldr	r2, [pc, #100]	@ (34005398 <HAL_I2C_Slave_Transmit_IT+0xd4>)
34005334:	62da      	str	r2, [r3, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
34005336:	68fb      	ldr	r3, [r7, #12]
34005338:	4a18      	ldr	r2, [pc, #96]	@ (3400539c <HAL_I2C_Slave_Transmit_IT+0xd8>)
3400533a:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Preload TX data if no stretch enable */
    if (hi2c->Init.NoStretchMode == I2C_NOSTRETCH_ENABLE)
3400533c:	68fb      	ldr	r3, [r7, #12]
3400533e:	6a1b      	ldr	r3, [r3, #32]
34005340:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34005344:	d117      	bne.n	34005376 <HAL_I2C_Slave_Transmit_IT+0xb2>
    {
      /* Preload TX register */
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
34005346:	68fb      	ldr	r3, [r7, #12]
34005348:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400534a:	781a      	ldrb	r2, [r3, #0]
3400534c:	68fb      	ldr	r3, [r7, #12]
3400534e:	681b      	ldr	r3, [r3, #0]
34005350:	629a      	str	r2, [r3, #40]	@ 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
34005352:	68fb      	ldr	r3, [r7, #12]
34005354:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34005356:	1c5a      	adds	r2, r3, #1
34005358:	68fb      	ldr	r3, [r7, #12]
3400535a:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferCount--;
3400535c:	68fb      	ldr	r3, [r7, #12]
3400535e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005360:	b29b      	uxth	r3, r3
34005362:	3b01      	subs	r3, #1
34005364:	b29a      	uxth	r2, r3
34005366:	68fb      	ldr	r3, [r7, #12]
34005368:	855a      	strh	r2, [r3, #42]	@ 0x2a
      hi2c->XferSize--;
3400536a:	68fb      	ldr	r3, [r7, #12]
3400536c:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3400536e:	3b01      	subs	r3, #1
34005370:	b29a      	uxth	r2, r3
34005372:	68fb      	ldr	r3, [r7, #12]
34005374:	851a      	strh	r2, [r3, #40]	@ 0x28
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34005376:	68fb      	ldr	r3, [r7, #12]
34005378:	2200      	movs	r2, #0
3400537a:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Enable ERR, TC, STOP, NACK, TXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_TX_IT | I2C_XFER_LISTEN_IT);
3400537e:	f248 0101 	movw	r1, #32769	@ 0x8001
34005382:	68f8      	ldr	r0, [r7, #12]
34005384:	f001 fb78 	bl	34006a78 <I2C_Enable_IRQ>

    return HAL_OK;
34005388:	2300      	movs	r3, #0
3400538a:	e000      	b.n	3400538e <HAL_I2C_Slave_Transmit_IT+0xca>
  }
  else
  {
    return HAL_BUSY;
3400538c:	2302      	movs	r3, #2
  }
}
3400538e:	4618      	mov	r0, r3
34005390:	3710      	adds	r7, #16
34005392:	46bd      	mov	sp, r7
34005394:	bd80      	pop	{r7, pc}
34005396:	bf00      	nop
34005398:	ffff0000 	.word	0xffff0000
3400539c:	340057b7 	.word	0x340057b7

340053a0 <HAL_I2C_Slave_Receive_IT>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
{
340053a0:	b580      	push	{r7, lr}
340053a2:	b084      	sub	sp, #16
340053a4:	af00      	add	r7, sp, #0
340053a6:	60f8      	str	r0, [r7, #12]
340053a8:	60b9      	str	r1, [r7, #8]
340053aa:	4613      	mov	r3, r2
340053ac:	80fb      	strh	r3, [r7, #6]
  if (hi2c->State == HAL_I2C_STATE_READY)
340053ae:	68fb      	ldr	r3, [r7, #12]
340053b0:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
340053b4:	b2db      	uxtb	r3, r3
340053b6:	2b20      	cmp	r3, #32
340053b8:	d139      	bne.n	3400542e <HAL_I2C_Slave_Receive_IT+0x8e>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
340053ba:	68fb      	ldr	r3, [r7, #12]
340053bc:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
340053c0:	2b01      	cmp	r3, #1
340053c2:	d101      	bne.n	340053c8 <HAL_I2C_Slave_Receive_IT+0x28>
340053c4:	2302      	movs	r3, #2
340053c6:	e033      	b.n	34005430 <HAL_I2C_Slave_Receive_IT+0x90>
340053c8:	68fb      	ldr	r3, [r7, #12]
340053ca:	2201      	movs	r2, #1
340053cc:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State       = HAL_I2C_STATE_BUSY_RX;
340053d0:	68fb      	ldr	r3, [r7, #12]
340053d2:	2222      	movs	r2, #34	@ 0x22
340053d4:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode        = HAL_I2C_MODE_SLAVE;
340053d8:	68fb      	ldr	r3, [r7, #12]
340053da:	2220      	movs	r2, #32
340053dc:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
340053e0:	68fb      	ldr	r3, [r7, #12]
340053e2:	2200      	movs	r2, #0
340053e4:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Enable Address Acknowledge */
    hi2c->Instance->CR2 &= ~I2C_CR2_NACK;
340053e6:	68fb      	ldr	r3, [r7, #12]
340053e8:	681b      	ldr	r3, [r3, #0]
340053ea:	685a      	ldr	r2, [r3, #4]
340053ec:	68fb      	ldr	r3, [r7, #12]
340053ee:	681b      	ldr	r3, [r3, #0]
340053f0:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
340053f4:	605a      	str	r2, [r3, #4]

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
340053f6:	68fb      	ldr	r3, [r7, #12]
340053f8:	68ba      	ldr	r2, [r7, #8]
340053fa:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount   = Size;
340053fc:	68fb      	ldr	r3, [r7, #12]
340053fe:	88fa      	ldrh	r2, [r7, #6]
34005400:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferSize    = hi2c->XferCount;
34005402:	68fb      	ldr	r3, [r7, #12]
34005404:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005406:	b29a      	uxth	r2, r3
34005408:	68fb      	ldr	r3, [r7, #12]
3400540a:	851a      	strh	r2, [r3, #40]	@ 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
3400540c:	68fb      	ldr	r3, [r7, #12]
3400540e:	4a0a      	ldr	r2, [pc, #40]	@ (34005438 <HAL_I2C_Slave_Receive_IT+0x98>)
34005410:	62da      	str	r2, [r3, #44]	@ 0x2c
    hi2c->XferISR     = I2C_Slave_ISR_IT;
34005412:	68fb      	ldr	r3, [r7, #12]
34005414:	4a09      	ldr	r2, [pc, #36]	@ (3400543c <HAL_I2C_Slave_Receive_IT+0x9c>)
34005416:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34005418:	68fb      	ldr	r3, [r7, #12]
3400541a:	2200      	movs	r2, #0
3400541c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Enable ERR, TC, STOP, NACK, RXI interrupt */
    /* possible to enable all of these */
    /* I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI |
      I2C_IT_ADDRI | I2C_IT_RXI | I2C_IT_TXI */
    I2C_Enable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_LISTEN_IT);
34005420:	f248 0102 	movw	r1, #32770	@ 0x8002
34005424:	68f8      	ldr	r0, [r7, #12]
34005426:	f001 fb27 	bl	34006a78 <I2C_Enable_IRQ>

    return HAL_OK;
3400542a:	2300      	movs	r3, #0
3400542c:	e000      	b.n	34005430 <HAL_I2C_Slave_Receive_IT+0x90>
  }
  else
  {
    return HAL_BUSY;
3400542e:	2302      	movs	r3, #2
  }
}
34005430:	4618      	mov	r0, r3
34005432:	3710      	adds	r7, #16
34005434:	46bd      	mov	sp, r7
34005436:	bd80      	pop	{r7, pc}
34005438:	ffff0000 	.word	0xffff0000
3400543c:	340057b7 	.word	0x340057b7

34005440 <HAL_I2C_EV_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c) /* Derogation MISRAC2012-Rule-8.13 */
{
34005440:	b580      	push	{r7, lr}
34005442:	b084      	sub	sp, #16
34005444:	af00      	add	r7, sp, #0
34005446:	6078      	str	r0, [r7, #4]
  /* Get current IT Flags and IT sources value */
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
34005448:	687b      	ldr	r3, [r7, #4]
3400544a:	681b      	ldr	r3, [r3, #0]
3400544c:	699b      	ldr	r3, [r3, #24]
3400544e:	60fb      	str	r3, [r7, #12]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
34005450:	687b      	ldr	r3, [r7, #4]
34005452:	681b      	ldr	r3, [r3, #0]
34005454:	681b      	ldr	r3, [r3, #0]
34005456:	60bb      	str	r3, [r7, #8]

  /* I2C events treatment -------------------------------------*/
  if (hi2c->XferISR != NULL)
34005458:	687b      	ldr	r3, [r7, #4]
3400545a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400545c:	2b00      	cmp	r3, #0
3400545e:	d005      	beq.n	3400546c <HAL_I2C_EV_IRQHandler+0x2c>
  {
    hi2c->XferISR(hi2c, itflags, itsources);
34005460:	687b      	ldr	r3, [r7, #4]
34005462:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34005464:	68ba      	ldr	r2, [r7, #8]
34005466:	68f9      	ldr	r1, [r7, #12]
34005468:	6878      	ldr	r0, [r7, #4]
3400546a:	4798      	blx	r3
  }
}
3400546c:	bf00      	nop
3400546e:	3710      	adds	r7, #16
34005470:	46bd      	mov	sp, r7
34005472:	bd80      	pop	{r7, pc}

34005474 <HAL_I2C_ER_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
{
34005474:	b580      	push	{r7, lr}
34005476:	b086      	sub	sp, #24
34005478:	af00      	add	r7, sp, #0
3400547a:	6078      	str	r0, [r7, #4]
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
3400547c:	687b      	ldr	r3, [r7, #4]
3400547e:	681b      	ldr	r3, [r3, #0]
34005480:	699b      	ldr	r3, [r3, #24]
34005482:	617b      	str	r3, [r7, #20]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
34005484:	687b      	ldr	r3, [r7, #4]
34005486:	681b      	ldr	r3, [r3, #0]
34005488:	681b      	ldr	r3, [r3, #0]
3400548a:	613b      	str	r3, [r7, #16]
  uint32_t tmperror;

  /* I2C Bus error interrupt occurred ------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && \
3400548c:	697b      	ldr	r3, [r7, #20]
3400548e:	0a1b      	lsrs	r3, r3, #8
34005490:	f003 0301 	and.w	r3, r3, #1
34005494:	2b00      	cmp	r3, #0
34005496:	d010      	beq.n	340054ba <HAL_I2C_ER_IRQHandler+0x46>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
34005498:	693b      	ldr	r3, [r7, #16]
3400549a:	09db      	lsrs	r3, r3, #7
3400549c:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && \
340054a0:	2b00      	cmp	r3, #0
340054a2:	d00a      	beq.n	340054ba <HAL_I2C_ER_IRQHandler+0x46>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
340054a4:	687b      	ldr	r3, [r7, #4]
340054a6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340054a8:	f043 0201 	orr.w	r2, r3, #1
340054ac:	687b      	ldr	r3, [r7, #4]
340054ae:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
340054b0:	687b      	ldr	r3, [r7, #4]
340054b2:	681b      	ldr	r3, [r3, #0]
340054b4:	f44f 7280 	mov.w	r2, #256	@ 0x100
340054b8:	61da      	str	r2, [r3, #28]
  }

  /* I2C Over-Run/Under-Run interrupt occurred ----------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && \
340054ba:	697b      	ldr	r3, [r7, #20]
340054bc:	0a9b      	lsrs	r3, r3, #10
340054be:	f003 0301 	and.w	r3, r3, #1
340054c2:	2b00      	cmp	r3, #0
340054c4:	d010      	beq.n	340054e8 <HAL_I2C_ER_IRQHandler+0x74>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
340054c6:	693b      	ldr	r3, [r7, #16]
340054c8:	09db      	lsrs	r3, r3, #7
340054ca:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && \
340054ce:	2b00      	cmp	r3, #0
340054d0:	d00a      	beq.n	340054e8 <HAL_I2C_ER_IRQHandler+0x74>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
340054d2:	687b      	ldr	r3, [r7, #4]
340054d4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340054d6:	f043 0208 	orr.w	r2, r3, #8
340054da:	687b      	ldr	r3, [r7, #4]
340054dc:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
340054de:	687b      	ldr	r3, [r7, #4]
340054e0:	681b      	ldr	r3, [r3, #0]
340054e2:	f44f 6280 	mov.w	r2, #1024	@ 0x400
340054e6:	61da      	str	r2, [r3, #28]
  }

  /* I2C Arbitration Loss error interrupt occurred -------------------------------------*/
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && \
340054e8:	697b      	ldr	r3, [r7, #20]
340054ea:	0a5b      	lsrs	r3, r3, #9
340054ec:	f003 0301 	and.w	r3, r3, #1
340054f0:	2b00      	cmp	r3, #0
340054f2:	d010      	beq.n	34005516 <HAL_I2C_ER_IRQHandler+0xa2>
      (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
340054f4:	693b      	ldr	r3, [r7, #16]
340054f6:	09db      	lsrs	r3, r3, #7
340054f8:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && \
340054fc:	2b00      	cmp	r3, #0
340054fe:	d00a      	beq.n	34005516 <HAL_I2C_ER_IRQHandler+0xa2>
  {
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
34005500:	687b      	ldr	r3, [r7, #4]
34005502:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34005504:	f043 0202 	orr.w	r2, r3, #2
34005508:	687b      	ldr	r3, [r7, #4]
3400550a:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
3400550c:	687b      	ldr	r3, [r7, #4]
3400550e:	681b      	ldr	r3, [r3, #0]
34005510:	f44f 7200 	mov.w	r2, #512	@ 0x200
34005514:	61da      	str	r2, [r3, #28]
  }

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
34005516:	687b      	ldr	r3, [r7, #4]
34005518:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400551a:	60fb      	str	r3, [r7, #12]

  /* Call the Error Callback in case of Error detected */
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
3400551c:	68fb      	ldr	r3, [r7, #12]
3400551e:	f003 030b 	and.w	r3, r3, #11
34005522:	2b00      	cmp	r3, #0
34005524:	d003      	beq.n	3400552e <HAL_I2C_ER_IRQHandler+0xba>
  {
    I2C_ITError(hi2c, tmperror);
34005526:	68f9      	ldr	r1, [r7, #12]
34005528:	6878      	ldr	r0, [r7, #4]
3400552a:	f001 f919 	bl	34006760 <I2C_ITError>
  }
}
3400552e:	bf00      	nop
34005530:	3718      	adds	r7, #24
34005532:	46bd      	mov	sp, r7
34005534:	bd80      	pop	{r7, pc}

34005536 <HAL_I2C_AddrCallback>:
  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XFERDIRECTION
  * @param  AddrMatchCode Address Match Code
  * @retval None
  */
__weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
{
34005536:	b480      	push	{r7}
34005538:	b083      	sub	sp, #12
3400553a:	af00      	add	r7, sp, #0
3400553c:	6078      	str	r0, [r7, #4]
3400553e:	460b      	mov	r3, r1
34005540:	70fb      	strb	r3, [r7, #3]
34005542:	4613      	mov	r3, r2
34005544:	803b      	strh	r3, [r7, #0]
  UNUSED(AddrMatchCode);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AddrCallback() could be implemented in the user file
   */
}
34005546:	bf00      	nop
34005548:	370c      	adds	r7, #12
3400554a:	46bd      	mov	sp, r7
3400554c:	f85d 7b04 	ldr.w	r7, [sp], #4
34005550:	4770      	bx	lr

34005552 <HAL_I2C_ListenCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
34005552:	b480      	push	{r7}
34005554:	b083      	sub	sp, #12
34005556:	af00      	add	r7, sp, #0
34005558:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ListenCpltCallback() could be implemented in the user file
   */
}
3400555a:	bf00      	nop
3400555c:	370c      	adds	r7, #12
3400555e:	46bd      	mov	sp, r7
34005560:	f85d 7b04 	ldr.w	r7, [sp], #4
34005564:	4770      	bx	lr

34005566 <I2C_Master_ISR_IT>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Master_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                           uint32_t ITSources)
{
34005566:	b580      	push	{r7, lr}
34005568:	b088      	sub	sp, #32
3400556a:	af02      	add	r7, sp, #8
3400556c:	60f8      	str	r0, [r7, #12]
3400556e:	60b9      	str	r1, [r7, #8]
34005570:	607a      	str	r2, [r7, #4]
  uint16_t devaddress;
  uint32_t tmpITFlags = ITFlags;
34005572:	68bb      	ldr	r3, [r7, #8]
34005574:	617b      	str	r3, [r7, #20]

  /* Process Locked */
  __HAL_LOCK(hi2c);
34005576:	68fb      	ldr	r3, [r7, #12]
34005578:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
3400557c:	2b01      	cmp	r3, #1
3400557e:	d101      	bne.n	34005584 <I2C_Master_ISR_IT+0x1e>
34005580:	2302      	movs	r3, #2
34005582:	e114      	b.n	340057ae <I2C_Master_ISR_IT+0x248>
34005584:	68fb      	ldr	r3, [r7, #12]
34005586:	2201      	movs	r2, #1
34005588:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
3400558c:	697b      	ldr	r3, [r7, #20]
3400558e:	091b      	lsrs	r3, r3, #4
34005590:	f003 0301 	and.w	r3, r3, #1
34005594:	2b00      	cmp	r3, #0
34005596:	d013      	beq.n	340055c0 <I2C_Master_ISR_IT+0x5a>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
34005598:	687b      	ldr	r3, [r7, #4]
3400559a:	091b      	lsrs	r3, r3, #4
3400559c:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
340055a0:	2b00      	cmp	r3, #0
340055a2:	d00d      	beq.n	340055c0 <I2C_Master_ISR_IT+0x5a>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
340055a4:	68fb      	ldr	r3, [r7, #12]
340055a6:	681b      	ldr	r3, [r3, #0]
340055a8:	2210      	movs	r2, #16
340055aa:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    /* No need to generate STOP, it is automatically done */
    /* Error callback will be send during stop flag treatment */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
340055ac:	68fb      	ldr	r3, [r7, #12]
340055ae:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340055b0:	f043 0204 	orr.w	r2, r3, #4
340055b4:	68fb      	ldr	r3, [r7, #12]
340055b6:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
340055b8:	68f8      	ldr	r0, [r7, #12]
340055ba:	f001 f9e8 	bl	3400698e <I2C_Flush_TXDR>
340055be:	e0e1      	b.n	34005784 <I2C_Master_ISR_IT+0x21e>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
340055c0:	697b      	ldr	r3, [r7, #20]
340055c2:	089b      	lsrs	r3, r3, #2
340055c4:	f003 0301 	and.w	r3, r3, #1
340055c8:	2b00      	cmp	r3, #0
340055ca:	d023      	beq.n	34005614 <I2C_Master_ISR_IT+0xae>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
340055cc:	687b      	ldr	r3, [r7, #4]
340055ce:	089b      	lsrs	r3, r3, #2
340055d0:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
340055d4:	2b00      	cmp	r3, #0
340055d6:	d01d      	beq.n	34005614 <I2C_Master_ISR_IT+0xae>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
340055d8:	697b      	ldr	r3, [r7, #20]
340055da:	f023 0304 	bic.w	r3, r3, #4
340055de:	617b      	str	r3, [r7, #20]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
340055e0:	68fb      	ldr	r3, [r7, #12]
340055e2:	681b      	ldr	r3, [r3, #0]
340055e4:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
340055e6:	68fb      	ldr	r3, [r7, #12]
340055e8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340055ea:	b2d2      	uxtb	r2, r2
340055ec:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
340055ee:	68fb      	ldr	r3, [r7, #12]
340055f0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340055f2:	1c5a      	adds	r2, r3, #1
340055f4:	68fb      	ldr	r3, [r7, #12]
340055f6:	625a      	str	r2, [r3, #36]	@ 0x24

    hi2c->XferSize--;
340055f8:	68fb      	ldr	r3, [r7, #12]
340055fa:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
340055fc:	3b01      	subs	r3, #1
340055fe:	b29a      	uxth	r2, r3
34005600:	68fb      	ldr	r3, [r7, #12]
34005602:	851a      	strh	r2, [r3, #40]	@ 0x28
    hi2c->XferCount--;
34005604:	68fb      	ldr	r3, [r7, #12]
34005606:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005608:	b29b      	uxth	r3, r3
3400560a:	3b01      	subs	r3, #1
3400560c:	b29a      	uxth	r2, r3
3400560e:	68fb      	ldr	r3, [r7, #12]
34005610:	855a      	strh	r2, [r3, #42]	@ 0x2a
34005612:	e0b7      	b.n	34005784 <I2C_Master_ISR_IT+0x21e>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
34005614:	697b      	ldr	r3, [r7, #20]
34005616:	085b      	lsrs	r3, r3, #1
34005618:	f003 0301 	and.w	r3, r3, #1
3400561c:	2b00      	cmp	r3, #0
3400561e:	d01e      	beq.n	3400565e <I2C_Master_ISR_IT+0xf8>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
34005620:	687b      	ldr	r3, [r7, #4]
34005622:	085b      	lsrs	r3, r3, #1
34005624:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
34005628:	2b00      	cmp	r3, #0
3400562a:	d018      	beq.n	3400565e <I2C_Master_ISR_IT+0xf8>
  {
    /* Write data to TXDR */
    hi2c->Instance->TXDR = *hi2c->pBuffPtr;
3400562c:	68fb      	ldr	r3, [r7, #12]
3400562e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34005630:	781a      	ldrb	r2, [r3, #0]
34005632:	68fb      	ldr	r3, [r7, #12]
34005634:	681b      	ldr	r3, [r3, #0]
34005636:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
34005638:	68fb      	ldr	r3, [r7, #12]
3400563a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400563c:	1c5a      	adds	r2, r3, #1
3400563e:	68fb      	ldr	r3, [r7, #12]
34005640:	625a      	str	r2, [r3, #36]	@ 0x24

    hi2c->XferSize--;
34005642:	68fb      	ldr	r3, [r7, #12]
34005644:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34005646:	3b01      	subs	r3, #1
34005648:	b29a      	uxth	r2, r3
3400564a:	68fb      	ldr	r3, [r7, #12]
3400564c:	851a      	strh	r2, [r3, #40]	@ 0x28
    hi2c->XferCount--;
3400564e:	68fb      	ldr	r3, [r7, #12]
34005650:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005652:	b29b      	uxth	r3, r3
34005654:	3b01      	subs	r3, #1
34005656:	b29a      	uxth	r2, r3
34005658:	68fb      	ldr	r3, [r7, #12]
3400565a:	855a      	strh	r2, [r3, #42]	@ 0x2a
3400565c:	e092      	b.n	34005784 <I2C_Master_ISR_IT+0x21e>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && \
3400565e:	697b      	ldr	r3, [r7, #20]
34005660:	09db      	lsrs	r3, r3, #7
34005662:	f003 0301 	and.w	r3, r3, #1
34005666:	2b00      	cmp	r3, #0
34005668:	d05d      	beq.n	34005726 <I2C_Master_ISR_IT+0x1c0>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
3400566a:	687b      	ldr	r3, [r7, #4]
3400566c:	099b      	lsrs	r3, r3, #6
3400566e:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && \
34005672:	2b00      	cmp	r3, #0
34005674:	d057      	beq.n	34005726 <I2C_Master_ISR_IT+0x1c0>
  {
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
34005676:	68fb      	ldr	r3, [r7, #12]
34005678:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400567a:	b29b      	uxth	r3, r3
3400567c:	2b00      	cmp	r3, #0
3400567e:	d040      	beq.n	34005702 <I2C_Master_ISR_IT+0x19c>
34005680:	68fb      	ldr	r3, [r7, #12]
34005682:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34005684:	2b00      	cmp	r3, #0
34005686:	d13c      	bne.n	34005702 <I2C_Master_ISR_IT+0x19c>
    {
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
34005688:	68fb      	ldr	r3, [r7, #12]
3400568a:	681b      	ldr	r3, [r3, #0]
3400568c:	685b      	ldr	r3, [r3, #4]
3400568e:	b29b      	uxth	r3, r3
34005690:	f3c3 0309 	ubfx	r3, r3, #0, #10
34005694:	827b      	strh	r3, [r7, #18]

      if (hi2c->XferCount > MAX_NBYTE_SIZE)
34005696:	68fb      	ldr	r3, [r7, #12]
34005698:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400569a:	b29b      	uxth	r3, r3
3400569c:	2bff      	cmp	r3, #255	@ 0xff
3400569e:	d90e      	bls.n	340056be <I2C_Master_ISR_IT+0x158>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
340056a0:	68fb      	ldr	r3, [r7, #12]
340056a2:	22ff      	movs	r2, #255	@ 0xff
340056a4:	851a      	strh	r2, [r3, #40]	@ 0x28
        I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
340056a6:	68fb      	ldr	r3, [r7, #12]
340056a8:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
340056aa:	b2da      	uxtb	r2, r3
340056ac:	8a79      	ldrh	r1, [r7, #18]
340056ae:	2300      	movs	r3, #0
340056b0:	9300      	str	r3, [sp, #0]
340056b2:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
340056b6:	68f8      	ldr	r0, [r7, #12]
340056b8:	f001 f9ac 	bl	34006a14 <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
340056bc:	e032      	b.n	34005724 <I2C_Master_ISR_IT+0x1be>
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
340056be:	68fb      	ldr	r3, [r7, #12]
340056c0:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
340056c2:	b29a      	uxth	r2, r3
340056c4:	68fb      	ldr	r3, [r7, #12]
340056c6:	851a      	strh	r2, [r3, #40]	@ 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
340056c8:	68fb      	ldr	r3, [r7, #12]
340056ca:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340056cc:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
340056d0:	d00b      	beq.n	340056ea <I2C_Master_ISR_IT+0x184>
        {
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize,
340056d2:	68fb      	ldr	r3, [r7, #12]
340056d4:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
340056d6:	b2da      	uxtb	r2, r3
                             hi2c->XferOptions, I2C_NO_STARTSTOP);
340056d8:	68fb      	ldr	r3, [r7, #12]
340056da:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize,
340056dc:	8a79      	ldrh	r1, [r7, #18]
340056de:	2000      	movs	r0, #0
340056e0:	9000      	str	r0, [sp, #0]
340056e2:	68f8      	ldr	r0, [r7, #12]
340056e4:	f001 f996 	bl	34006a14 <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
340056e8:	e01c      	b.n	34005724 <I2C_Master_ISR_IT+0x1be>
        }
        else
        {
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize,
340056ea:	68fb      	ldr	r3, [r7, #12]
340056ec:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
340056ee:	b2da      	uxtb	r2, r3
340056f0:	8a79      	ldrh	r1, [r7, #18]
340056f2:	2300      	movs	r3, #0
340056f4:	9300      	str	r3, [sp, #0]
340056f6:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
340056fa:	68f8      	ldr	r0, [r7, #12]
340056fc:	f001 f98a 	bl	34006a14 <I2C_TransferConfig>
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
34005700:	e010      	b.n	34005724 <I2C_Master_ISR_IT+0x1be>
      }
    }
    else
    {
      /* Call TxCpltCallback() if no stop mode is set */
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
34005702:	68fb      	ldr	r3, [r7, #12]
34005704:	681b      	ldr	r3, [r3, #0]
34005706:	685b      	ldr	r3, [r3, #4]
34005708:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
3400570c:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34005710:	d003      	beq.n	3400571a <I2C_Master_ISR_IT+0x1b4>
      {
        /* Call I2C Master Sequential complete process */
        I2C_ITMasterSeqCplt(hi2c);
34005712:	68f8      	ldr	r0, [r7, #12]
34005714:	f000 fcec 	bl	340060f0 <I2C_ITMasterSeqCplt>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
34005718:	e034      	b.n	34005784 <I2C_Master_ISR_IT+0x21e>
      }
      else
      {
        /* Wrong size Status regarding TCR flag event */
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
3400571a:	2140      	movs	r1, #64	@ 0x40
3400571c:	68f8      	ldr	r0, [r7, #12]
3400571e:	f001 f81f 	bl	34006760 <I2C_ITError>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
34005722:	e02f      	b.n	34005784 <I2C_Master_ISR_IT+0x21e>
34005724:	e02e      	b.n	34005784 <I2C_Master_ISR_IT+0x21e>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && \
34005726:	697b      	ldr	r3, [r7, #20]
34005728:	099b      	lsrs	r3, r3, #6
3400572a:	f003 0301 	and.w	r3, r3, #1
3400572e:	2b00      	cmp	r3, #0
34005730:	d028      	beq.n	34005784 <I2C_Master_ISR_IT+0x21e>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
34005732:	687b      	ldr	r3, [r7, #4]
34005734:	099b      	lsrs	r3, r3, #6
34005736:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && \
3400573a:	2b00      	cmp	r3, #0
3400573c:	d022      	beq.n	34005784 <I2C_Master_ISR_IT+0x21e>
  {
    if (hi2c->XferCount == 0U)
3400573e:	68fb      	ldr	r3, [r7, #12]
34005740:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005742:	b29b      	uxth	r3, r3
34005744:	2b00      	cmp	r3, #0
34005746:	d119      	bne.n	3400577c <I2C_Master_ISR_IT+0x216>
    {
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
34005748:	68fb      	ldr	r3, [r7, #12]
3400574a:	681b      	ldr	r3, [r3, #0]
3400574c:	685b      	ldr	r3, [r3, #4]
3400574e:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34005752:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34005756:	d015      	beq.n	34005784 <I2C_Master_ISR_IT+0x21e>
      {
        /* Generate a stop condition in case of no transfer option */
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
34005758:	68fb      	ldr	r3, [r7, #12]
3400575a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400575c:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
34005760:	d108      	bne.n	34005774 <I2C_Master_ISR_IT+0x20e>
        {
          /* Generate Stop */
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
34005762:	68fb      	ldr	r3, [r7, #12]
34005764:	681b      	ldr	r3, [r3, #0]
34005766:	685a      	ldr	r2, [r3, #4]
34005768:	68fb      	ldr	r3, [r7, #12]
3400576a:	681b      	ldr	r3, [r3, #0]
3400576c:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
34005770:	605a      	str	r2, [r3, #4]
34005772:	e007      	b.n	34005784 <I2C_Master_ISR_IT+0x21e>
        }
        else
        {
          /* Call I2C Master Sequential complete process */
          I2C_ITMasterSeqCplt(hi2c);
34005774:	68f8      	ldr	r0, [r7, #12]
34005776:	f000 fcbb 	bl	340060f0 <I2C_ITMasterSeqCplt>
3400577a:	e003      	b.n	34005784 <I2C_Master_ISR_IT+0x21e>
    }
    else
    {
      /* Wrong size Status regarding TC flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
3400577c:	2140      	movs	r1, #64	@ 0x40
3400577e:	68f8      	ldr	r0, [r7, #12]
34005780:	f000 ffee 	bl	34006760 <I2C_ITError>
  else
  {
    /* Nothing to do */
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
34005784:	697b      	ldr	r3, [r7, #20]
34005786:	095b      	lsrs	r3, r3, #5
34005788:	f003 0301 	and.w	r3, r3, #1
3400578c:	2b00      	cmp	r3, #0
3400578e:	d009      	beq.n	340057a4 <I2C_Master_ISR_IT+0x23e>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
34005790:	687b      	ldr	r3, [r7, #4]
34005792:	095b      	lsrs	r3, r3, #5
34005794:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
34005798:	2b00      	cmp	r3, #0
3400579a:	d003      	beq.n	340057a4 <I2C_Master_ISR_IT+0x23e>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, tmpITFlags);
3400579c:	6979      	ldr	r1, [r7, #20]
3400579e:	68f8      	ldr	r0, [r7, #12]
340057a0:	f000 fd42 	bl	34006228 <I2C_ITMasterCplt>
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
340057a4:	68fb      	ldr	r3, [r7, #12]
340057a6:	2200      	movs	r2, #0
340057a8:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  return HAL_OK;
340057ac:	2300      	movs	r3, #0
}
340057ae:	4618      	mov	r0, r3
340057b0:	3718      	adds	r7, #24
340057b2:	46bd      	mov	sp, r7
340057b4:	bd80      	pop	{r7, pc}

340057b6 <I2C_Slave_ISR_IT>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_IT(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                          uint32_t ITSources)
{
340057b6:	b580      	push	{r7, lr}
340057b8:	b086      	sub	sp, #24
340057ba:	af00      	add	r7, sp, #0
340057bc:	60f8      	str	r0, [r7, #12]
340057be:	60b9      	str	r1, [r7, #8]
340057c0:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
340057c2:	68fb      	ldr	r3, [r7, #12]
340057c4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340057c6:	617b      	str	r3, [r7, #20]
  uint32_t tmpITFlags = ITFlags;
340057c8:	68bb      	ldr	r3, [r7, #8]
340057ca:	613b      	str	r3, [r7, #16]

  /* Process locked */
  __HAL_LOCK(hi2c);
340057cc:	68fb      	ldr	r3, [r7, #12]
340057ce:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
340057d2:	2b01      	cmp	r3, #1
340057d4:	d101      	bne.n	340057da <I2C_Slave_ISR_IT+0x24>
340057d6:	2302      	movs	r3, #2
340057d8:	e0ed      	b.n	340059b6 <I2C_Slave_ISR_IT+0x200>
340057da:	68fb      	ldr	r3, [r7, #12]
340057dc:	2201      	movs	r2, #1
340057de:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
340057e2:	693b      	ldr	r3, [r7, #16]
340057e4:	095b      	lsrs	r3, r3, #5
340057e6:	f003 0301 	and.w	r3, r3, #1
340057ea:	2b00      	cmp	r3, #0
340057ec:	d00a      	beq.n	34005804 <I2C_Slave_ISR_IT+0x4e>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
340057ee:	687b      	ldr	r3, [r7, #4]
340057f0:	095b      	lsrs	r3, r3, #5
340057f2:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && \
340057f6:	2b00      	cmp	r3, #0
340057f8:	d004      	beq.n	34005804 <I2C_Slave_ISR_IT+0x4e>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
340057fa:	6939      	ldr	r1, [r7, #16]
340057fc:	68f8      	ldr	r0, [r7, #12]
340057fe:	f000 fddd 	bl	340063bc <I2C_ITSlaveCplt>
34005802:	e0d3      	b.n	340059ac <I2C_Slave_ISR_IT+0x1f6>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
34005804:	693b      	ldr	r3, [r7, #16]
34005806:	091b      	lsrs	r3, r3, #4
34005808:	f003 0301 	and.w	r3, r3, #1
3400580c:	2b00      	cmp	r3, #0
3400580e:	d04d      	beq.n	340058ac <I2C_Slave_ISR_IT+0xf6>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
34005810:	687b      	ldr	r3, [r7, #4]
34005812:	091b      	lsrs	r3, r3, #4
34005814:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
34005818:	2b00      	cmp	r3, #0
3400581a:	d047      	beq.n	340058ac <I2C_Slave_ISR_IT+0xf6>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0*/
    /* So clear Flag NACKF only */
    if (hi2c->XferCount == 0U)
3400581c:	68fb      	ldr	r3, [r7, #12]
3400581e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005820:	b29b      	uxth	r3, r3
34005822:	2b00      	cmp	r3, #0
34005824:	d128      	bne.n	34005878 <I2C_Slave_ISR_IT+0xc2>
    {
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))
34005826:	68fb      	ldr	r3, [r7, #12]
34005828:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400582c:	b2db      	uxtb	r3, r3
3400582e:	2b28      	cmp	r3, #40	@ 0x28
34005830:	d108      	bne.n	34005844 <I2C_Slave_ISR_IT+0x8e>
34005832:	697b      	ldr	r3, [r7, #20]
34005834:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34005838:	d104      	bne.n	34005844 <I2C_Slave_ISR_IT+0x8e>
        /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for
           Warning[Pa134]: left and right operands are identical */
      {
        /* Call I2C Listen complete process */
        I2C_ITListenCplt(hi2c, tmpITFlags);
3400583a:	6939      	ldr	r1, [r7, #16]
3400583c:	68f8      	ldr	r0, [r7, #12]
3400583e:	f000 ff39 	bl	340066b4 <I2C_ITListenCplt>
34005842:	e032      	b.n	340058aa <I2C_Slave_ISR_IT+0xf4>
      }
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
34005844:	68fb      	ldr	r3, [r7, #12]
34005846:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400584a:	b2db      	uxtb	r3, r3
3400584c:	2b29      	cmp	r3, #41	@ 0x29
3400584e:	d10e      	bne.n	3400586e <I2C_Slave_ISR_IT+0xb8>
34005850:	697b      	ldr	r3, [r7, #20]
34005852:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
34005856:	d00a      	beq.n	3400586e <I2C_Slave_ISR_IT+0xb8>
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34005858:	68fb      	ldr	r3, [r7, #12]
3400585a:	681b      	ldr	r3, [r3, #0]
3400585c:	2210      	movs	r2, #16
3400585e:	61da      	str	r2, [r3, #28]

        /* Flush TX register */
        I2C_Flush_TXDR(hi2c);
34005860:	68f8      	ldr	r0, [r7, #12]
34005862:	f001 f894 	bl	3400698e <I2C_Flush_TXDR>

        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
34005866:	68f8      	ldr	r0, [r7, #12]
34005868:	f000 fc7f 	bl	3400616a <I2C_ITSlaveSeqCplt>
3400586c:	e01d      	b.n	340058aa <I2C_Slave_ISR_IT+0xf4>
      }
      else
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
3400586e:	68fb      	ldr	r3, [r7, #12]
34005870:	681b      	ldr	r3, [r3, #0]
34005872:	2210      	movs	r2, #16
34005874:	61da      	str	r2, [r3, #28]
    if (hi2c->XferCount == 0U)
34005876:	e096      	b.n	340059a6 <I2C_Slave_ISR_IT+0x1f0>
    }
    else
    {
      /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
      /* Clear NACK Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34005878:	68fb      	ldr	r3, [r7, #12]
3400587a:	681b      	ldr	r3, [r3, #0]
3400587c:	2210      	movs	r2, #16
3400587e:	61da      	str	r2, [r3, #28]

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
34005880:	68fb      	ldr	r3, [r7, #12]
34005882:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34005884:	f043 0204 	orr.w	r2, r3, #4
34005888:	68fb      	ldr	r3, [r7, #12]
3400588a:	645a      	str	r2, [r3, #68]	@ 0x44

      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
3400588c:	697b      	ldr	r3, [r7, #20]
3400588e:	2b00      	cmp	r3, #0
34005890:	d004      	beq.n	3400589c <I2C_Slave_ISR_IT+0xe6>
34005892:	697b      	ldr	r3, [r7, #20]
34005894:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34005898:	f040 8085 	bne.w	340059a6 <I2C_Slave_ISR_IT+0x1f0>
      {
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, hi2c->ErrorCode);
3400589c:	68fb      	ldr	r3, [r7, #12]
3400589e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340058a0:	4619      	mov	r1, r3
340058a2:	68f8      	ldr	r0, [r7, #12]
340058a4:	f000 ff5c 	bl	34006760 <I2C_ITError>
    if (hi2c->XferCount == 0U)
340058a8:	e07d      	b.n	340059a6 <I2C_Slave_ISR_IT+0x1f0>
340058aa:	e07c      	b.n	340059a6 <I2C_Slave_ISR_IT+0x1f0>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
340058ac:	693b      	ldr	r3, [r7, #16]
340058ae:	089b      	lsrs	r3, r3, #2
340058b0:	f003 0301 	and.w	r3, r3, #1
340058b4:	2b00      	cmp	r3, #0
340058b6:	d030      	beq.n	3400591a <I2C_Slave_ISR_IT+0x164>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
340058b8:	687b      	ldr	r3, [r7, #4]
340058ba:	089b      	lsrs	r3, r3, #2
340058bc:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && \
340058c0:	2b00      	cmp	r3, #0
340058c2:	d02a      	beq.n	3400591a <I2C_Slave_ISR_IT+0x164>
  {
    if (hi2c->XferCount > 0U)
340058c4:	68fb      	ldr	r3, [r7, #12]
340058c6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
340058c8:	b29b      	uxth	r3, r3
340058ca:	2b00      	cmp	r3, #0
340058cc:	d018      	beq.n	34005900 <I2C_Slave_ISR_IT+0x14a>
    {
      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
340058ce:	68fb      	ldr	r3, [r7, #12]
340058d0:	681b      	ldr	r3, [r3, #0]
340058d2:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
340058d4:	68fb      	ldr	r3, [r7, #12]
340058d6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340058d8:	b2d2      	uxtb	r2, r2
340058da:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
340058dc:	68fb      	ldr	r3, [r7, #12]
340058de:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340058e0:	1c5a      	adds	r2, r3, #1
340058e2:	68fb      	ldr	r3, [r7, #12]
340058e4:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferSize--;
340058e6:	68fb      	ldr	r3, [r7, #12]
340058e8:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
340058ea:	3b01      	subs	r3, #1
340058ec:	b29a      	uxth	r2, r3
340058ee:	68fb      	ldr	r3, [r7, #12]
340058f0:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
340058f2:	68fb      	ldr	r3, [r7, #12]
340058f4:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
340058f6:	b29b      	uxth	r3, r3
340058f8:	3b01      	subs	r3, #1
340058fa:	b29a      	uxth	r2, r3
340058fc:	68fb      	ldr	r3, [r7, #12]
340058fe:	855a      	strh	r2, [r3, #42]	@ 0x2a
    }

    if ((hi2c->XferCount == 0U) && \
34005900:	68fb      	ldr	r3, [r7, #12]
34005902:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005904:	b29b      	uxth	r3, r3
34005906:	2b00      	cmp	r3, #0
34005908:	d14f      	bne.n	340059aa <I2C_Slave_ISR_IT+0x1f4>
3400590a:	697b      	ldr	r3, [r7, #20]
3400590c:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
34005910:	d04b      	beq.n	340059aa <I2C_Slave_ISR_IT+0x1f4>
        (tmpoptions != I2C_NO_OPTION_FRAME))
    {
      /* Call I2C Slave Sequential complete process */
      I2C_ITSlaveSeqCplt(hi2c);
34005912:	68f8      	ldr	r0, [r7, #12]
34005914:	f000 fc29 	bl	3400616a <I2C_ITSlaveSeqCplt>
    if ((hi2c->XferCount == 0U) && \
34005918:	e047      	b.n	340059aa <I2C_Slave_ISR_IT+0x1f4>
    }
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && \
3400591a:	693b      	ldr	r3, [r7, #16]
3400591c:	08db      	lsrs	r3, r3, #3
3400591e:	f003 0301 	and.w	r3, r3, #1
34005922:	2b00      	cmp	r3, #0
34005924:	d00a      	beq.n	3400593c <I2C_Slave_ISR_IT+0x186>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
34005926:	687b      	ldr	r3, [r7, #4]
34005928:	08db      	lsrs	r3, r3, #3
3400592a:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && \
3400592e:	2b00      	cmp	r3, #0
34005930:	d004      	beq.n	3400593c <I2C_Slave_ISR_IT+0x186>
  {
    I2C_ITAddrCplt(hi2c, tmpITFlags);
34005932:	6939      	ldr	r1, [r7, #16]
34005934:	68f8      	ldr	r0, [r7, #12]
34005936:	f000 fb57 	bl	34005fe8 <I2C_ITAddrCplt>
3400593a:	e037      	b.n	340059ac <I2C_Slave_ISR_IT+0x1f6>
  }
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
3400593c:	693b      	ldr	r3, [r7, #16]
3400593e:	085b      	lsrs	r3, r3, #1
34005940:	f003 0301 	and.w	r3, r3, #1
34005944:	2b00      	cmp	r3, #0
34005946:	d031      	beq.n	340059ac <I2C_Slave_ISR_IT+0x1f6>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
34005948:	687b      	ldr	r3, [r7, #4]
3400594a:	085b      	lsrs	r3, r3, #1
3400594c:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && \
34005950:	2b00      	cmp	r3, #0
34005952:	d02b      	beq.n	340059ac <I2C_Slave_ISR_IT+0x1f6>
  {
    /* Write data to TXDR only if XferCount not reach "0" */
    /* A TXIS flag can be set, during STOP treatment      */
    /* Check if all Data have already been sent */
    /* If it is the case, this last write in TXDR is not sent, correspond to a dummy TXIS event */
    if (hi2c->XferCount > 0U)
34005954:	68fb      	ldr	r3, [r7, #12]
34005956:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005958:	b29b      	uxth	r3, r3
3400595a:	2b00      	cmp	r3, #0
3400595c:	d018      	beq.n	34005990 <I2C_Slave_ISR_IT+0x1da>
    {
      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
3400595e:	68fb      	ldr	r3, [r7, #12]
34005960:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34005962:	781a      	ldrb	r2, [r3, #0]
34005964:	68fb      	ldr	r3, [r7, #12]
34005966:	681b      	ldr	r3, [r3, #0]
34005968:	629a      	str	r2, [r3, #40]	@ 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
3400596a:	68fb      	ldr	r3, [r7, #12]
3400596c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
3400596e:	1c5a      	adds	r2, r3, #1
34005970:	68fb      	ldr	r3, [r7, #12]
34005972:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferCount--;
34005974:	68fb      	ldr	r3, [r7, #12]
34005976:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005978:	b29b      	uxth	r3, r3
3400597a:	3b01      	subs	r3, #1
3400597c:	b29a      	uxth	r2, r3
3400597e:	68fb      	ldr	r3, [r7, #12]
34005980:	855a      	strh	r2, [r3, #42]	@ 0x2a
      hi2c->XferSize--;
34005982:	68fb      	ldr	r3, [r7, #12]
34005984:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34005986:	3b01      	subs	r3, #1
34005988:	b29a      	uxth	r2, r3
3400598a:	68fb      	ldr	r3, [r7, #12]
3400598c:	851a      	strh	r2, [r3, #40]	@ 0x28
3400598e:	e00d      	b.n	340059ac <I2C_Slave_ISR_IT+0x1f6>
    }
    else
    {
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
34005990:	697b      	ldr	r3, [r7, #20]
34005992:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34005996:	d002      	beq.n	3400599e <I2C_Slave_ISR_IT+0x1e8>
34005998:	697b      	ldr	r3, [r7, #20]
3400599a:	2b00      	cmp	r3, #0
3400599c:	d106      	bne.n	340059ac <I2C_Slave_ISR_IT+0x1f6>
      {
        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
3400599e:	68f8      	ldr	r0, [r7, #12]
340059a0:	f000 fbe3 	bl	3400616a <I2C_ITSlaveSeqCplt>
340059a4:	e002      	b.n	340059ac <I2C_Slave_ISR_IT+0x1f6>
    if (hi2c->XferCount == 0U)
340059a6:	bf00      	nop
340059a8:	e000      	b.n	340059ac <I2C_Slave_ISR_IT+0x1f6>
    if ((hi2c->XferCount == 0U) && \
340059aa:	bf00      	nop
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
340059ac:	68fb      	ldr	r3, [r7, #12]
340059ae:	2200      	movs	r2, #0
340059b0:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  return HAL_OK;
340059b4:	2300      	movs	r3, #0
}
340059b6:	4618      	mov	r0, r3
340059b8:	3718      	adds	r7, #24
340059ba:	46bd      	mov	sp, r7
340059bc:	bd80      	pop	{r7, pc}

340059be <I2C_Master_ISR_DMA>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Master_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                            uint32_t ITSources)
{
340059be:	b580      	push	{r7, lr}
340059c0:	b088      	sub	sp, #32
340059c2:	af02      	add	r7, sp, #8
340059c4:	60f8      	str	r0, [r7, #12]
340059c6:	60b9      	str	r1, [r7, #8]
340059c8:	607a      	str	r2, [r7, #4]
  uint16_t devaddress;
  uint32_t xfermode;

  /* Process Locked */
  __HAL_LOCK(hi2c);
340059ca:	68fb      	ldr	r3, [r7, #12]
340059cc:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
340059d0:	2b01      	cmp	r3, #1
340059d2:	d101      	bne.n	340059d8 <I2C_Master_ISR_DMA+0x1a>
340059d4:	2302      	movs	r3, #2
340059d6:	e0e1      	b.n	34005b9c <I2C_Master_ISR_DMA+0x1de>
340059d8:	68fb      	ldr	r3, [r7, #12]
340059da:	2201      	movs	r2, #1
340059dc:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
340059e0:	68bb      	ldr	r3, [r7, #8]
340059e2:	091b      	lsrs	r3, r3, #4
340059e4:	f003 0301 	and.w	r3, r3, #1
340059e8:	2b00      	cmp	r3, #0
340059ea:	d017      	beq.n	34005a1c <I2C_Master_ISR_DMA+0x5e>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
340059ec:	687b      	ldr	r3, [r7, #4]
340059ee:	091b      	lsrs	r3, r3, #4
340059f0:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
340059f4:	2b00      	cmp	r3, #0
340059f6:	d011      	beq.n	34005a1c <I2C_Master_ISR_DMA+0x5e>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
340059f8:	68fb      	ldr	r3, [r7, #12]
340059fa:	681b      	ldr	r3, [r3, #0]
340059fc:	2210      	movs	r2, #16
340059fe:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
34005a00:	68fb      	ldr	r3, [r7, #12]
34005a02:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34005a04:	f043 0204 	orr.w	r2, r3, #4
34005a08:	68fb      	ldr	r3, [r7, #12]
34005a0a:	645a      	str	r2, [r3, #68]	@ 0x44

    /* No need to generate STOP, it is automatically done */
    /* But enable STOP interrupt, to treat it */
    /* Error callback will be send during stop flag treatment */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
34005a0c:	2120      	movs	r1, #32
34005a0e:	68f8      	ldr	r0, [r7, #12]
34005a10:	f001 f832 	bl	34006a78 <I2C_Enable_IRQ>

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
34005a14:	68f8      	ldr	r0, [r7, #12]
34005a16:	f000 ffba 	bl	3400698e <I2C_Flush_TXDR>
34005a1a:	e0ba      	b.n	34005b92 <I2C_Master_ISR_DMA+0x1d4>
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && \
34005a1c:	68bb      	ldr	r3, [r7, #8]
34005a1e:	09db      	lsrs	r3, r3, #7
34005a20:	f003 0301 	and.w	r3, r3, #1
34005a24:	2b00      	cmp	r3, #0
34005a26:	d072      	beq.n	34005b0e <I2C_Master_ISR_DMA+0x150>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
34005a28:	687b      	ldr	r3, [r7, #4]
34005a2a:	099b      	lsrs	r3, r3, #6
34005a2c:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && \
34005a30:	2b00      	cmp	r3, #0
34005a32:	d06c      	beq.n	34005b0e <I2C_Master_ISR_DMA+0x150>
  {
    /* Disable TC interrupt */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
34005a34:	68fb      	ldr	r3, [r7, #12]
34005a36:	681b      	ldr	r3, [r3, #0]
34005a38:	681a      	ldr	r2, [r3, #0]
34005a3a:	68fb      	ldr	r3, [r7, #12]
34005a3c:	681b      	ldr	r3, [r3, #0]
34005a3e:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
34005a42:	601a      	str	r2, [r3, #0]

    if (hi2c->XferCount != 0U)
34005a44:	68fb      	ldr	r3, [r7, #12]
34005a46:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005a48:	b29b      	uxth	r3, r3
34005a4a:	2b00      	cmp	r3, #0
34005a4c:	d04e      	beq.n	34005aec <I2C_Master_ISR_DMA+0x12e>
    {
      /* Recover Slave address */
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
34005a4e:	68fb      	ldr	r3, [r7, #12]
34005a50:	681b      	ldr	r3, [r3, #0]
34005a52:	685b      	ldr	r3, [r3, #4]
34005a54:	b29b      	uxth	r3, r3
34005a56:	f3c3 0309 	ubfx	r3, r3, #0, #10
34005a5a:	827b      	strh	r3, [r7, #18]

      /* Prepare the new XferSize to transfer */
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
34005a5c:	68fb      	ldr	r3, [r7, #12]
34005a5e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005a60:	b29b      	uxth	r3, r3
34005a62:	2bff      	cmp	r3, #255	@ 0xff
34005a64:	d906      	bls.n	34005a74 <I2C_Master_ISR_DMA+0xb6>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
34005a66:	68fb      	ldr	r3, [r7, #12]
34005a68:	22ff      	movs	r2, #255	@ 0xff
34005a6a:	851a      	strh	r2, [r3, #40]	@ 0x28
        xfermode = I2C_RELOAD_MODE;
34005a6c:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34005a70:	617b      	str	r3, [r7, #20]
34005a72:	e010      	b.n	34005a96 <I2C_Master_ISR_DMA+0xd8>
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
34005a74:	68fb      	ldr	r3, [r7, #12]
34005a76:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005a78:	b29a      	uxth	r2, r3
34005a7a:	68fb      	ldr	r3, [r7, #12]
34005a7c:	851a      	strh	r2, [r3, #40]	@ 0x28
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
34005a7e:	68fb      	ldr	r3, [r7, #12]
34005a80:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34005a82:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
34005a86:	d003      	beq.n	34005a90 <I2C_Master_ISR_DMA+0xd2>
        {
          xfermode = hi2c->XferOptions;
34005a88:	68fb      	ldr	r3, [r7, #12]
34005a8a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34005a8c:	617b      	str	r3, [r7, #20]
34005a8e:	e002      	b.n	34005a96 <I2C_Master_ISR_DMA+0xd8>
        }
        else
        {
          xfermode = I2C_AUTOEND_MODE;
34005a90:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34005a94:	617b      	str	r3, [r7, #20]
        }
      }

      /* Set the new XferSize in Nbytes register */
      I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, xfermode, I2C_NO_STARTSTOP);
34005a96:	68fb      	ldr	r3, [r7, #12]
34005a98:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34005a9a:	b2da      	uxtb	r2, r3
34005a9c:	8a79      	ldrh	r1, [r7, #18]
34005a9e:	2300      	movs	r3, #0
34005aa0:	9300      	str	r3, [sp, #0]
34005aa2:	697b      	ldr	r3, [r7, #20]
34005aa4:	68f8      	ldr	r0, [r7, #12]
34005aa6:	f000 ffb5 	bl	34006a14 <I2C_TransferConfig>

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
34005aaa:	68fb      	ldr	r3, [r7, #12]
34005aac:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005aae:	b29a      	uxth	r2, r3
34005ab0:	68fb      	ldr	r3, [r7, #12]
34005ab2:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34005ab4:	1ad3      	subs	r3, r2, r3
34005ab6:	b29a      	uxth	r2, r3
34005ab8:	68fb      	ldr	r3, [r7, #12]
34005aba:	855a      	strh	r2, [r3, #42]	@ 0x2a

      /* Enable DMA Request */
      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
34005abc:	68fb      	ldr	r3, [r7, #12]
34005abe:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005ac2:	b2db      	uxtb	r3, r3
34005ac4:	2b22      	cmp	r3, #34	@ 0x22
34005ac6:	d108      	bne.n	34005ada <I2C_Master_ISR_DMA+0x11c>
      {
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
34005ac8:	68fb      	ldr	r3, [r7, #12]
34005aca:	681b      	ldr	r3, [r3, #0]
34005acc:	681a      	ldr	r2, [r3, #0]
34005ace:	68fb      	ldr	r3, [r7, #12]
34005ad0:	681b      	ldr	r3, [r3, #0]
34005ad2:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34005ad6:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
34005ad8:	e05b      	b.n	34005b92 <I2C_Master_ISR_DMA+0x1d4>
      }
      else
      {
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
34005ada:	68fb      	ldr	r3, [r7, #12]
34005adc:	681b      	ldr	r3, [r3, #0]
34005ade:	681a      	ldr	r2, [r3, #0]
34005ae0:	68fb      	ldr	r3, [r7, #12]
34005ae2:	681b      	ldr	r3, [r3, #0]
34005ae4:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
34005ae8:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
34005aea:	e052      	b.n	34005b92 <I2C_Master_ISR_DMA+0x1d4>
      }
    }
    else
    {
      /* Call TxCpltCallback() if no stop mode is set */
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
34005aec:	68fb      	ldr	r3, [r7, #12]
34005aee:	681b      	ldr	r3, [r3, #0]
34005af0:	685b      	ldr	r3, [r3, #4]
34005af2:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34005af6:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34005afa:	d003      	beq.n	34005b04 <I2C_Master_ISR_DMA+0x146>
      {
        /* Call I2C Master Sequential complete process */
        I2C_ITMasterSeqCplt(hi2c);
34005afc:	68f8      	ldr	r0, [r7, #12]
34005afe:	f000 faf7 	bl	340060f0 <I2C_ITMasterSeqCplt>
    if (hi2c->XferCount != 0U)
34005b02:	e046      	b.n	34005b92 <I2C_Master_ISR_DMA+0x1d4>
      }
      else
      {
        /* Wrong size Status regarding TCR flag event */
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
34005b04:	2140      	movs	r1, #64	@ 0x40
34005b06:	68f8      	ldr	r0, [r7, #12]
34005b08:	f000 fe2a 	bl	34006760 <I2C_ITError>
    if (hi2c->XferCount != 0U)
34005b0c:	e041      	b.n	34005b92 <I2C_Master_ISR_DMA+0x1d4>
      }
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && \
34005b0e:	68bb      	ldr	r3, [r7, #8]
34005b10:	099b      	lsrs	r3, r3, #6
34005b12:	f003 0301 	and.w	r3, r3, #1
34005b16:	2b00      	cmp	r3, #0
34005b18:	d029      	beq.n	34005b6e <I2C_Master_ISR_DMA+0x1b0>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
34005b1a:	687b      	ldr	r3, [r7, #4]
34005b1c:	099b      	lsrs	r3, r3, #6
34005b1e:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && \
34005b22:	2b00      	cmp	r3, #0
34005b24:	d023      	beq.n	34005b6e <I2C_Master_ISR_DMA+0x1b0>
  {
    if (hi2c->XferCount == 0U)
34005b26:	68fb      	ldr	r3, [r7, #12]
34005b28:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005b2a:	b29b      	uxth	r3, r3
34005b2c:	2b00      	cmp	r3, #0
34005b2e:	d119      	bne.n	34005b64 <I2C_Master_ISR_DMA+0x1a6>
    {
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
34005b30:	68fb      	ldr	r3, [r7, #12]
34005b32:	681b      	ldr	r3, [r3, #0]
34005b34:	685b      	ldr	r3, [r3, #4]
34005b36:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
34005b3a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34005b3e:	d027      	beq.n	34005b90 <I2C_Master_ISR_DMA+0x1d2>
      {
        /* Generate a stop condition in case of no transfer option */
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
34005b40:	68fb      	ldr	r3, [r7, #12]
34005b42:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34005b44:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
34005b48:	d108      	bne.n	34005b5c <I2C_Master_ISR_DMA+0x19e>
        {
          /* Generate Stop */
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
34005b4a:	68fb      	ldr	r3, [r7, #12]
34005b4c:	681b      	ldr	r3, [r3, #0]
34005b4e:	685a      	ldr	r2, [r3, #4]
34005b50:	68fb      	ldr	r3, [r7, #12]
34005b52:	681b      	ldr	r3, [r3, #0]
34005b54:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
34005b58:	605a      	str	r2, [r3, #4]
    if (hi2c->XferCount == 0U)
34005b5a:	e019      	b.n	34005b90 <I2C_Master_ISR_DMA+0x1d2>
        }
        else
        {
          /* Call I2C Master Sequential complete process */
          I2C_ITMasterSeqCplt(hi2c);
34005b5c:	68f8      	ldr	r0, [r7, #12]
34005b5e:	f000 fac7 	bl	340060f0 <I2C_ITMasterSeqCplt>
    if (hi2c->XferCount == 0U)
34005b62:	e015      	b.n	34005b90 <I2C_Master_ISR_DMA+0x1d2>
    }
    else
    {
      /* Wrong size Status regarding TC flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
34005b64:	2140      	movs	r1, #64	@ 0x40
34005b66:	68f8      	ldr	r0, [r7, #12]
34005b68:	f000 fdfa 	bl	34006760 <I2C_ITError>
    if (hi2c->XferCount == 0U)
34005b6c:	e010      	b.n	34005b90 <I2C_Master_ISR_DMA+0x1d2>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
34005b6e:	68bb      	ldr	r3, [r7, #8]
34005b70:	095b      	lsrs	r3, r3, #5
34005b72:	f003 0301 	and.w	r3, r3, #1
34005b76:	2b00      	cmp	r3, #0
34005b78:	d00b      	beq.n	34005b92 <I2C_Master_ISR_DMA+0x1d4>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
34005b7a:	687b      	ldr	r3, [r7, #4]
34005b7c:	095b      	lsrs	r3, r3, #5
34005b7e:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
34005b82:	2b00      	cmp	r3, #0
34005b84:	d005      	beq.n	34005b92 <I2C_Master_ISR_DMA+0x1d4>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, ITFlags);
34005b86:	68b9      	ldr	r1, [r7, #8]
34005b88:	68f8      	ldr	r0, [r7, #12]
34005b8a:	f000 fb4d 	bl	34006228 <I2C_ITMasterCplt>
34005b8e:	e000      	b.n	34005b92 <I2C_Master_ISR_DMA+0x1d4>
    if (hi2c->XferCount == 0U)
34005b90:	bf00      	nop
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
34005b92:	68fb      	ldr	r3, [r7, #12]
34005b94:	2200      	movs	r2, #0
34005b96:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  return HAL_OK;
34005b9a:	2300      	movs	r3, #0
}
34005b9c:	4618      	mov	r0, r3
34005b9e:	3718      	adds	r7, #24
34005ba0:	46bd      	mov	sp, r7
34005ba2:	bd80      	pop	{r7, pc}

34005ba4 <I2C_Mem_ISR_DMA>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Mem_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                         uint32_t ITSources)
{
34005ba4:	b580      	push	{r7, lr}
34005ba6:	b088      	sub	sp, #32
34005ba8:	af02      	add	r7, sp, #8
34005baa:	60f8      	str	r0, [r7, #12]
34005bac:	60b9      	str	r1, [r7, #8]
34005bae:	607a      	str	r2, [r7, #4]
  uint32_t direction = I2C_GENERATE_START_WRITE;
34005bb0:	4b92      	ldr	r3, [pc, #584]	@ (34005dfc <I2C_Mem_ISR_DMA+0x258>)
34005bb2:	617b      	str	r3, [r7, #20]

  /* Process Locked */
  __HAL_LOCK(hi2c);
34005bb4:	68fb      	ldr	r3, [r7, #12]
34005bb6:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
34005bba:	2b01      	cmp	r3, #1
34005bbc:	d101      	bne.n	34005bc2 <I2C_Mem_ISR_DMA+0x1e>
34005bbe:	2302      	movs	r3, #2
34005bc0:	e118      	b.n	34005df4 <I2C_Mem_ISR_DMA+0x250>
34005bc2:	68fb      	ldr	r3, [r7, #12]
34005bc4:	2201      	movs	r2, #1
34005bc6:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
34005bca:	68bb      	ldr	r3, [r7, #8]
34005bcc:	091b      	lsrs	r3, r3, #4
34005bce:	f003 0301 	and.w	r3, r3, #1
34005bd2:	2b00      	cmp	r3, #0
34005bd4:	d017      	beq.n	34005c06 <I2C_Mem_ISR_DMA+0x62>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
34005bd6:	687b      	ldr	r3, [r7, #4]
34005bd8:	091b      	lsrs	r3, r3, #4
34005bda:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
34005bde:	2b00      	cmp	r3, #0
34005be0:	d011      	beq.n	34005c06 <I2C_Mem_ISR_DMA+0x62>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34005be2:	68fb      	ldr	r3, [r7, #12]
34005be4:	681b      	ldr	r3, [r3, #0]
34005be6:	2210      	movs	r2, #16
34005be8:	61da      	str	r2, [r3, #28]

    /* Set corresponding Error Code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
34005bea:	68fb      	ldr	r3, [r7, #12]
34005bec:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34005bee:	f043 0204 	orr.w	r2, r3, #4
34005bf2:	68fb      	ldr	r3, [r7, #12]
34005bf4:	645a      	str	r2, [r3, #68]	@ 0x44

    /* No need to generate STOP, it is automatically done */
    /* But enable STOP interrupt, to treat it */
    /* Error callback will be send during stop flag treatment */
    I2C_Enable_IRQ(hi2c, I2C_XFER_CPLT_IT);
34005bf6:	2120      	movs	r1, #32
34005bf8:	68f8      	ldr	r0, [r7, #12]
34005bfa:	f000 ff3d 	bl	34006a78 <I2C_Enable_IRQ>

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
34005bfe:	68f8      	ldr	r0, [r7, #12]
34005c00:	f000 fec5 	bl	3400698e <I2C_Flush_TXDR>
34005c04:	e0f1      	b.n	34005dea <I2C_Mem_ISR_DMA+0x246>
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TXIS) != RESET) && \
34005c06:	68bb      	ldr	r3, [r7, #8]
34005c08:	085b      	lsrs	r3, r3, #1
34005c0a:	f003 0301 	and.w	r3, r3, #1
34005c0e:	2b00      	cmp	r3, #0
34005c10:	d00f      	beq.n	34005c32 <I2C_Mem_ISR_DMA+0x8e>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
34005c12:	687b      	ldr	r3, [r7, #4]
34005c14:	085b      	lsrs	r3, r3, #1
34005c16:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TXIS) != RESET) && \
34005c1a:	2b00      	cmp	r3, #0
34005c1c:	d009      	beq.n	34005c32 <I2C_Mem_ISR_DMA+0x8e>
  {
    /* Write LSB part of Memory Address */
    hi2c->Instance->TXDR = hi2c->Memaddress;
34005c1e:	68fb      	ldr	r3, [r7, #12]
34005c20:	681b      	ldr	r3, [r3, #0]
34005c22:	68fa      	ldr	r2, [r7, #12]
34005c24:	6d12      	ldr	r2, [r2, #80]	@ 0x50
34005c26:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Reset Memaddress content */
    hi2c->Memaddress = 0xFFFFFFFFU;
34005c28:	68fb      	ldr	r3, [r7, #12]
34005c2a:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
34005c2e:	651a      	str	r2, [r3, #80]	@ 0x50
34005c30:	e0db      	b.n	34005dea <I2C_Mem_ISR_DMA+0x246>
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && \
34005c32:	68bb      	ldr	r3, [r7, #8]
34005c34:	09db      	lsrs	r3, r3, #7
34005c36:	f003 0301 	and.w	r3, r3, #1
34005c3a:	2b00      	cmp	r3, #0
34005c3c:	d060      	beq.n	34005d00 <I2C_Mem_ISR_DMA+0x15c>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
34005c3e:	687b      	ldr	r3, [r7, #4]
34005c40:	099b      	lsrs	r3, r3, #6
34005c42:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && \
34005c46:	2b00      	cmp	r3, #0
34005c48:	d05a      	beq.n	34005d00 <I2C_Mem_ISR_DMA+0x15c>
  {
    /* Disable Interrupt related to address step */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
34005c4a:	2101      	movs	r1, #1
34005c4c:	68f8      	ldr	r0, [r7, #12]
34005c4e:	f000 ff97 	bl	34006b80 <I2C_Disable_IRQ>

    /* Enable only Error interrupt */
    I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
34005c52:	2110      	movs	r1, #16
34005c54:	68f8      	ldr	r0, [r7, #12]
34005c56:	f000 ff0f 	bl	34006a78 <I2C_Enable_IRQ>

    if (hi2c->XferCount != 0U)
34005c5a:	68fb      	ldr	r3, [r7, #12]
34005c5c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005c5e:	b29b      	uxth	r3, r3
34005c60:	2b00      	cmp	r3, #0
34005c62:	d048      	beq.n	34005cf6 <I2C_Mem_ISR_DMA+0x152>
    {
      /* Prepare the new XferSize to transfer */
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
34005c64:	68fb      	ldr	r3, [r7, #12]
34005c66:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005c68:	b29b      	uxth	r3, r3
34005c6a:	2bff      	cmp	r3, #255	@ 0xff
34005c6c:	d910      	bls.n	34005c90 <I2C_Mem_ISR_DMA+0xec>
      {
        hi2c->XferSize = MAX_NBYTE_SIZE;
34005c6e:	68fb      	ldr	r3, [r7, #12]
34005c70:	22ff      	movs	r2, #255	@ 0xff
34005c72:	851a      	strh	r2, [r3, #40]	@ 0x28
        I2C_TransferConfig(hi2c, (uint16_t)hi2c->Devaddress, (uint8_t)hi2c->XferSize,
34005c74:	68fb      	ldr	r3, [r7, #12]
34005c76:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34005c78:	b299      	uxth	r1, r3
34005c7a:	68fb      	ldr	r3, [r7, #12]
34005c7c:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34005c7e:	b2da      	uxtb	r2, r3
34005c80:	2300      	movs	r3, #0
34005c82:	9300      	str	r3, [sp, #0]
34005c84:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34005c88:	68f8      	ldr	r0, [r7, #12]
34005c8a:	f000 fec3 	bl	34006a14 <I2C_TransferConfig>
34005c8e:	e011      	b.n	34005cb4 <I2C_Mem_ISR_DMA+0x110>
                           I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
      }
      else
      {
        hi2c->XferSize = hi2c->XferCount;
34005c90:	68fb      	ldr	r3, [r7, #12]
34005c92:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005c94:	b29a      	uxth	r2, r3
34005c96:	68fb      	ldr	r3, [r7, #12]
34005c98:	851a      	strh	r2, [r3, #40]	@ 0x28
        I2C_TransferConfig(hi2c, (uint16_t)hi2c->Devaddress, (uint8_t)hi2c->XferSize,
34005c9a:	68fb      	ldr	r3, [r7, #12]
34005c9c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34005c9e:	b299      	uxth	r1, r3
34005ca0:	68fb      	ldr	r3, [r7, #12]
34005ca2:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34005ca4:	b2da      	uxtb	r2, r3
34005ca6:	2300      	movs	r3, #0
34005ca8:	9300      	str	r3, [sp, #0]
34005caa:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34005cae:	68f8      	ldr	r0, [r7, #12]
34005cb0:	f000 feb0 	bl	34006a14 <I2C_TransferConfig>
                           I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
      }

      /* Update XferCount value */
      hi2c->XferCount -= hi2c->XferSize;
34005cb4:	68fb      	ldr	r3, [r7, #12]
34005cb6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005cb8:	b29a      	uxth	r2, r3
34005cba:	68fb      	ldr	r3, [r7, #12]
34005cbc:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34005cbe:	1ad3      	subs	r3, r2, r3
34005cc0:	b29a      	uxth	r2, r3
34005cc2:	68fb      	ldr	r3, [r7, #12]
34005cc4:	855a      	strh	r2, [r3, #42]	@ 0x2a

      /* Enable DMA Request */
      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
34005cc6:	68fb      	ldr	r3, [r7, #12]
34005cc8:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005ccc:	b2db      	uxtb	r3, r3
34005cce:	2b22      	cmp	r3, #34	@ 0x22
34005cd0:	d108      	bne.n	34005ce4 <I2C_Mem_ISR_DMA+0x140>
      {
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
34005cd2:	68fb      	ldr	r3, [r7, #12]
34005cd4:	681b      	ldr	r3, [r3, #0]
34005cd6:	681a      	ldr	r2, [r3, #0]
34005cd8:	68fb      	ldr	r3, [r7, #12]
34005cda:	681b      	ldr	r3, [r3, #0]
34005cdc:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34005ce0:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
34005ce2:	e082      	b.n	34005dea <I2C_Mem_ISR_DMA+0x246>
      }
      else
      {
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
34005ce4:	68fb      	ldr	r3, [r7, #12]
34005ce6:	681b      	ldr	r3, [r3, #0]
34005ce8:	681a      	ldr	r2, [r3, #0]
34005cea:	68fb      	ldr	r3, [r7, #12]
34005cec:	681b      	ldr	r3, [r3, #0]
34005cee:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
34005cf2:	601a      	str	r2, [r3, #0]
    if (hi2c->XferCount != 0U)
34005cf4:	e079      	b.n	34005dea <I2C_Mem_ISR_DMA+0x246>
    }
    else
    {
      /* Wrong size Status regarding TCR flag event */
      /* Call the corresponding callback to inform upper layer of End of Transfer */
      I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
34005cf6:	2140      	movs	r1, #64	@ 0x40
34005cf8:	68f8      	ldr	r0, [r7, #12]
34005cfa:	f000 fd31 	bl	34006760 <I2C_ITError>
    if (hi2c->XferCount != 0U)
34005cfe:	e074      	b.n	34005dea <I2C_Mem_ISR_DMA+0x246>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && \
34005d00:	68bb      	ldr	r3, [r7, #8]
34005d02:	099b      	lsrs	r3, r3, #6
34005d04:	f003 0301 	and.w	r3, r3, #1
34005d08:	2b00      	cmp	r3, #0
34005d0a:	d05e      	beq.n	34005dca <I2C_Mem_ISR_DMA+0x226>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
34005d0c:	687b      	ldr	r3, [r7, #4]
34005d0e:	099b      	lsrs	r3, r3, #6
34005d10:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && \
34005d14:	2b00      	cmp	r3, #0
34005d16:	d058      	beq.n	34005dca <I2C_Mem_ISR_DMA+0x226>
  {
    /* Disable Interrupt related to address step */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
34005d18:	2101      	movs	r1, #1
34005d1a:	68f8      	ldr	r0, [r7, #12]
34005d1c:	f000 ff30 	bl	34006b80 <I2C_Disable_IRQ>

    /* Enable only Error and NACK interrupt for data transfer */
    I2C_Enable_IRQ(hi2c, I2C_XFER_ERROR_IT);
34005d20:	2110      	movs	r1, #16
34005d22:	68f8      	ldr	r0, [r7, #12]
34005d24:	f000 fea8 	bl	34006a78 <I2C_Enable_IRQ>

    if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
34005d28:	68fb      	ldr	r3, [r7, #12]
34005d2a:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005d2e:	b2db      	uxtb	r3, r3
34005d30:	2b22      	cmp	r3, #34	@ 0x22
34005d32:	d101      	bne.n	34005d38 <I2C_Mem_ISR_DMA+0x194>
    {
      direction = I2C_GENERATE_START_READ;
34005d34:	4b32      	ldr	r3, [pc, #200]	@ (34005e00 <I2C_Mem_ISR_DMA+0x25c>)
34005d36:	617b      	str	r3, [r7, #20]
    }

    if (hi2c->XferCount > MAX_NBYTE_SIZE)
34005d38:	68fb      	ldr	r3, [r7, #12]
34005d3a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005d3c:	b29b      	uxth	r3, r3
34005d3e:	2bff      	cmp	r3, #255	@ 0xff
34005d40:	d910      	bls.n	34005d64 <I2C_Mem_ISR_DMA+0x1c0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
34005d42:	68fb      	ldr	r3, [r7, #12]
34005d44:	22ff      	movs	r2, #255	@ 0xff
34005d46:	851a      	strh	r2, [r3, #40]	@ 0x28

      /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
      I2C_TransferConfig(hi2c, (uint16_t)hi2c->Devaddress, (uint8_t)hi2c->XferSize,
34005d48:	68fb      	ldr	r3, [r7, #12]
34005d4a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34005d4c:	b299      	uxth	r1, r3
34005d4e:	68fb      	ldr	r3, [r7, #12]
34005d50:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34005d52:	b2da      	uxtb	r2, r3
34005d54:	697b      	ldr	r3, [r7, #20]
34005d56:	9300      	str	r3, [sp, #0]
34005d58:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
34005d5c:	68f8      	ldr	r0, [r7, #12]
34005d5e:	f000 fe59 	bl	34006a14 <I2C_TransferConfig>
34005d62:	e011      	b.n	34005d88 <I2C_Mem_ISR_DMA+0x1e4>
                         I2C_RELOAD_MODE, direction);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
34005d64:	68fb      	ldr	r3, [r7, #12]
34005d66:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005d68:	b29a      	uxth	r2, r3
34005d6a:	68fb      	ldr	r3, [r7, #12]
34005d6c:	851a      	strh	r2, [r3, #40]	@ 0x28

      /* Set NBYTES to write and generate RESTART */
      I2C_TransferConfig(hi2c, (uint16_t)hi2c->Devaddress, (uint8_t)hi2c->XferSize,
34005d6e:	68fb      	ldr	r3, [r7, #12]
34005d70:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34005d72:	b299      	uxth	r1, r3
34005d74:	68fb      	ldr	r3, [r7, #12]
34005d76:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34005d78:	b2da      	uxtb	r2, r3
34005d7a:	697b      	ldr	r3, [r7, #20]
34005d7c:	9300      	str	r3, [sp, #0]
34005d7e:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
34005d82:	68f8      	ldr	r0, [r7, #12]
34005d84:	f000 fe46 	bl	34006a14 <I2C_TransferConfig>
                         I2C_AUTOEND_MODE, direction);
    }

    /* Update XferCount value */
    hi2c->XferCount -= hi2c->XferSize;
34005d88:	68fb      	ldr	r3, [r7, #12]
34005d8a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
34005d8c:	b29a      	uxth	r2, r3
34005d8e:	68fb      	ldr	r3, [r7, #12]
34005d90:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34005d92:	1ad3      	subs	r3, r2, r3
34005d94:	b29a      	uxth	r2, r3
34005d96:	68fb      	ldr	r3, [r7, #12]
34005d98:	855a      	strh	r2, [r3, #42]	@ 0x2a

    /* Enable DMA Request */
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
34005d9a:	68fb      	ldr	r3, [r7, #12]
34005d9c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005da0:	b2db      	uxtb	r3, r3
34005da2:	2b22      	cmp	r3, #34	@ 0x22
34005da4:	d108      	bne.n	34005db8 <I2C_Mem_ISR_DMA+0x214>
    {
      hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
34005da6:	68fb      	ldr	r3, [r7, #12]
34005da8:	681b      	ldr	r3, [r3, #0]
34005daa:	681a      	ldr	r2, [r3, #0]
34005dac:	68fb      	ldr	r3, [r7, #12]
34005dae:	681b      	ldr	r3, [r3, #0]
34005db0:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34005db4:	601a      	str	r2, [r3, #0]
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
34005db6:	e018      	b.n	34005dea <I2C_Mem_ISR_DMA+0x246>
    }
    else
    {
      hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
34005db8:	68fb      	ldr	r3, [r7, #12]
34005dba:	681b      	ldr	r3, [r3, #0]
34005dbc:	681a      	ldr	r2, [r3, #0]
34005dbe:	68fb      	ldr	r3, [r7, #12]
34005dc0:	681b      	ldr	r3, [r3, #0]
34005dc2:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
34005dc6:	601a      	str	r2, [r3, #0]
    if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
34005dc8:	e00f      	b.n	34005dea <I2C_Mem_ISR_DMA+0x246>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
34005dca:	68bb      	ldr	r3, [r7, #8]
34005dcc:	095b      	lsrs	r3, r3, #5
34005dce:	f003 0301 	and.w	r3, r3, #1
34005dd2:	2b00      	cmp	r3, #0
34005dd4:	d009      	beq.n	34005dea <I2C_Mem_ISR_DMA+0x246>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
34005dd6:	687b      	ldr	r3, [r7, #4]
34005dd8:	095b      	lsrs	r3, r3, #5
34005dda:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
34005dde:	2b00      	cmp	r3, #0
34005de0:	d003      	beq.n	34005dea <I2C_Mem_ISR_DMA+0x246>
  {
    /* Call I2C Master complete process */
    I2C_ITMasterCplt(hi2c, ITFlags);
34005de2:	68b9      	ldr	r1, [r7, #8]
34005de4:	68f8      	ldr	r0, [r7, #12]
34005de6:	f000 fa1f 	bl	34006228 <I2C_ITMasterCplt>
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
34005dea:	68fb      	ldr	r3, [r7, #12]
34005dec:	2200      	movs	r2, #0
34005dee:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  return HAL_OK;
34005df2:	2300      	movs	r3, #0
}
34005df4:	4618      	mov	r0, r3
34005df6:	3718      	adds	r7, #24
34005df8:	46bd      	mov	sp, r7
34005dfa:	bd80      	pop	{r7, pc}
34005dfc:	80002000 	.word	0x80002000
34005e00:	80002400 	.word	0x80002400

34005e04 <I2C_Slave_ISR_DMA>:
  * @param  ITSources Interrupt sources enabled.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_Slave_ISR_DMA(struct __I2C_HandleTypeDef *hi2c, uint32_t ITFlags,
                                           uint32_t ITSources)
{
34005e04:	b590      	push	{r4, r7, lr}
34005e06:	b089      	sub	sp, #36	@ 0x24
34005e08:	af00      	add	r7, sp, #0
34005e0a:	60f8      	str	r0, [r7, #12]
34005e0c:	60b9      	str	r1, [r7, #8]
34005e0e:	607a      	str	r2, [r7, #4]
  uint32_t tmpoptions = hi2c->XferOptions;
34005e10:	68fb      	ldr	r3, [r7, #12]
34005e12:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34005e14:	61bb      	str	r3, [r7, #24]
  uint32_t treatdmanack = 0U;
34005e16:	2300      	movs	r3, #0
34005e18:	61fb      	str	r3, [r7, #28]
  HAL_I2C_StateTypeDef tmpstate;

  /* Process locked */
  __HAL_LOCK(hi2c);
34005e1a:	68fb      	ldr	r3, [r7, #12]
34005e1c:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
34005e20:	2b01      	cmp	r3, #1
34005e22:	d101      	bne.n	34005e28 <I2C_Slave_ISR_DMA+0x24>
34005e24:	2302      	movs	r3, #2
34005e26:	e0db      	b.n	34005fe0 <I2C_Slave_ISR_DMA+0x1dc>
34005e28:	68fb      	ldr	r3, [r7, #12]
34005e2a:	2201      	movs	r2, #1
34005e2c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  /* Check if STOPF is set */
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
34005e30:	68bb      	ldr	r3, [r7, #8]
34005e32:	095b      	lsrs	r3, r3, #5
34005e34:	f003 0301 	and.w	r3, r3, #1
34005e38:	2b00      	cmp	r3, #0
34005e3a:	d00a      	beq.n	34005e52 <I2C_Slave_ISR_DMA+0x4e>
      (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
34005e3c:	687b      	ldr	r3, [r7, #4]
34005e3e:	095b      	lsrs	r3, r3, #5
34005e40:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && \
34005e44:	2b00      	cmp	r3, #0
34005e46:	d004      	beq.n	34005e52 <I2C_Slave_ISR_DMA+0x4e>
  {
    /* Call I2C Slave complete process */
    I2C_ITSlaveCplt(hi2c, ITFlags);
34005e48:	68b9      	ldr	r1, [r7, #8]
34005e4a:	68f8      	ldr	r0, [r7, #12]
34005e4c:	f000 fab6 	bl	340063bc <I2C_ITSlaveCplt>
34005e50:	e0c1      	b.n	34005fd6 <I2C_Slave_ISR_DMA+0x1d2>
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
34005e52:	68bb      	ldr	r3, [r7, #8]
34005e54:	091b      	lsrs	r3, r3, #4
34005e56:	f003 0301 	and.w	r3, r3, #1
34005e5a:	2b00      	cmp	r3, #0
34005e5c:	f000 80ab 	beq.w	34005fb6 <I2C_Slave_ISR_DMA+0x1b2>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
34005e60:	687b      	ldr	r3, [r7, #4]
34005e62:	091b      	lsrs	r3, r3, #4
34005e64:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && \
34005e68:	2b00      	cmp	r3, #0
34005e6a:	f000 80a4 	beq.w	34005fb6 <I2C_Slave_ISR_DMA+0x1b2>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0 */
    /* So clear Flag NACKF only */
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
34005e6e:	687b      	ldr	r3, [r7, #4]
34005e70:	0b9b      	lsrs	r3, r3, #14
34005e72:	f003 0301 	and.w	r3, r3, #1
34005e76:	2b00      	cmp	r3, #0
34005e78:	d106      	bne.n	34005e88 <I2C_Slave_ISR_DMA+0x84>
        (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))
34005e7a:	687b      	ldr	r3, [r7, #4]
34005e7c:	0bdb      	lsrs	r3, r3, #15
34005e7e:	f003 0301 	and.w	r3, r3, #1
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
34005e82:	2b00      	cmp	r3, #0
34005e84:	f000 8090 	beq.w	34005fa8 <I2C_Slave_ISR_DMA+0x1a4>
    {
      /* Split check of hdmarx, for MISRA compliance */
      if (hi2c->hdmarx != NULL)
34005e88:	68fb      	ldr	r3, [r7, #12]
34005e8a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34005e8c:	2b00      	cmp	r3, #0
34005e8e:	d015      	beq.n	34005ebc <I2C_Slave_ISR_DMA+0xb8>
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
34005e90:	687b      	ldr	r3, [r7, #4]
34005e92:	0bdb      	lsrs	r3, r3, #15
34005e94:	f003 0301 	and.w	r3, r3, #1
34005e98:	2b00      	cmp	r3, #0
34005e9a:	d00f      	beq.n	34005ebc <I2C_Slave_ISR_DMA+0xb8>
        {
          if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx) == 0U)
34005e9c:	68fb      	ldr	r3, [r7, #12]
34005e9e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34005ea0:	681b      	ldr	r3, [r3, #0]
34005ea2:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34005ea4:	b29c      	uxth	r4, r3
34005ea6:	68fb      	ldr	r3, [r7, #12]
34005ea8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34005eaa:	4618      	mov	r0, r3
34005eac:	f7fe feb4 	bl	34004c18 <HAL_DMAEx_GetFifoLevel>
34005eb0:	4603      	mov	r3, r0
34005eb2:	4423      	add	r3, r4
34005eb4:	2b00      	cmp	r3, #0
34005eb6:	d101      	bne.n	34005ebc <I2C_Slave_ISR_DMA+0xb8>
          {
            treatdmanack = 1U;
34005eb8:	2301      	movs	r3, #1
34005eba:	61fb      	str	r3, [r7, #28]
          }
        }
      }

      /* Split check of hdmatx, for MISRA compliance  */
      if (hi2c->hdmatx != NULL)
34005ebc:	68fb      	ldr	r3, [r7, #12]
34005ebe:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34005ec0:	2b00      	cmp	r3, #0
34005ec2:	d015      	beq.n	34005ef0 <I2C_Slave_ISR_DMA+0xec>
      {
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
34005ec4:	687b      	ldr	r3, [r7, #4]
34005ec6:	0b9b      	lsrs	r3, r3, #14
34005ec8:	f003 0301 	and.w	r3, r3, #1
34005ecc:	2b00      	cmp	r3, #0
34005ece:	d00f      	beq.n	34005ef0 <I2C_Slave_ISR_DMA+0xec>
        {
          if (I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx) == 0U)
34005ed0:	68fb      	ldr	r3, [r7, #12]
34005ed2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34005ed4:	681b      	ldr	r3, [r3, #0]
34005ed6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34005ed8:	b29c      	uxth	r4, r3
34005eda:	68fb      	ldr	r3, [r7, #12]
34005edc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34005ede:	4618      	mov	r0, r3
34005ee0:	f7fe fe9a 	bl	34004c18 <HAL_DMAEx_GetFifoLevel>
34005ee4:	4603      	mov	r3, r0
34005ee6:	4423      	add	r3, r4
34005ee8:	2b00      	cmp	r3, #0
34005eea:	d101      	bne.n	34005ef0 <I2C_Slave_ISR_DMA+0xec>
          {
            treatdmanack = 1U;
34005eec:	2301      	movs	r3, #1
34005eee:	61fb      	str	r3, [r7, #28]
          }
        }
      }

      if (treatdmanack == 1U)
34005ef0:	69fb      	ldr	r3, [r7, #28]
34005ef2:	2b01      	cmp	r3, #1
34005ef4:	d128      	bne.n	34005f48 <I2C_Slave_ISR_DMA+0x144>
      {
        if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))
34005ef6:	68fb      	ldr	r3, [r7, #12]
34005ef8:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005efc:	b2db      	uxtb	r3, r3
34005efe:	2b28      	cmp	r3, #40	@ 0x28
34005f00:	d108      	bne.n	34005f14 <I2C_Slave_ISR_DMA+0x110>
34005f02:	69bb      	ldr	r3, [r7, #24]
34005f04:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34005f08:	d104      	bne.n	34005f14 <I2C_Slave_ISR_DMA+0x110>
          /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for
             Warning[Pa134]: left and right operands are identical */
        {
          /* Call I2C Listen complete process */
          I2C_ITListenCplt(hi2c, ITFlags);
34005f0a:	68b9      	ldr	r1, [r7, #8]
34005f0c:	68f8      	ldr	r0, [r7, #12]
34005f0e:	f000 fbd1 	bl	340066b4 <I2C_ITListenCplt>
34005f12:	e048      	b.n	34005fa6 <I2C_Slave_ISR_DMA+0x1a2>
        }
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
34005f14:	68fb      	ldr	r3, [r7, #12]
34005f16:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005f1a:	b2db      	uxtb	r3, r3
34005f1c:	2b29      	cmp	r3, #41	@ 0x29
34005f1e:	d10e      	bne.n	34005f3e <I2C_Slave_ISR_DMA+0x13a>
34005f20:	69bb      	ldr	r3, [r7, #24]
34005f22:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
34005f26:	d00a      	beq.n	34005f3e <I2C_Slave_ISR_DMA+0x13a>
        {
          /* Clear NACK Flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34005f28:	68fb      	ldr	r3, [r7, #12]
34005f2a:	681b      	ldr	r3, [r3, #0]
34005f2c:	2210      	movs	r2, #16
34005f2e:	61da      	str	r2, [r3, #28]

          /* Flush TX register */
          I2C_Flush_TXDR(hi2c);
34005f30:	68f8      	ldr	r0, [r7, #12]
34005f32:	f000 fd2c 	bl	3400698e <I2C_Flush_TXDR>

          /* Last Byte is Transmitted */
          /* Call I2C Slave Sequential complete process */
          I2C_ITSlaveSeqCplt(hi2c);
34005f36:	68f8      	ldr	r0, [r7, #12]
34005f38:	f000 f917 	bl	3400616a <I2C_ITSlaveSeqCplt>
34005f3c:	e033      	b.n	34005fa6 <I2C_Slave_ISR_DMA+0x1a2>
        }
        else
        {
          /* Clear NACK Flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34005f3e:	68fb      	ldr	r3, [r7, #12]
34005f40:	681b      	ldr	r3, [r3, #0]
34005f42:	2210      	movs	r2, #16
34005f44:	61da      	str	r2, [r3, #28]
      if (treatdmanack == 1U)
34005f46:	e034      	b.n	34005fb2 <I2C_Slave_ISR_DMA+0x1ae>
      }
      else
      {
        /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34005f48:	68fb      	ldr	r3, [r7, #12]
34005f4a:	681b      	ldr	r3, [r3, #0]
34005f4c:	2210      	movs	r2, #16
34005f4e:	61da      	str	r2, [r3, #28]

        /* Set ErrorCode corresponding to a Non-Acknowledge */
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
34005f50:	68fb      	ldr	r3, [r7, #12]
34005f52:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34005f54:	f043 0204 	orr.w	r2, r3, #4
34005f58:	68fb      	ldr	r3, [r7, #12]
34005f5a:	645a      	str	r2, [r3, #68]	@ 0x44

        /* Store current hi2c->State, solve MISRA2012-Rule-13.5 */
        tmpstate = hi2c->State;
34005f5c:	68fb      	ldr	r3, [r7, #12]
34005f5e:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005f62:	75fb      	strb	r3, [r7, #23]

        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
34005f64:	69bb      	ldr	r3, [r7, #24]
34005f66:	2b00      	cmp	r3, #0
34005f68:	d003      	beq.n	34005f72 <I2C_Slave_ISR_DMA+0x16e>
34005f6a:	69bb      	ldr	r3, [r7, #24]
34005f6c:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34005f70:	d11f      	bne.n	34005fb2 <I2C_Slave_ISR_DMA+0x1ae>
        {
          if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
34005f72:	7dfb      	ldrb	r3, [r7, #23]
34005f74:	2b21      	cmp	r3, #33	@ 0x21
34005f76:	d002      	beq.n	34005f7e <I2C_Slave_ISR_DMA+0x17a>
34005f78:	7dfb      	ldrb	r3, [r7, #23]
34005f7a:	2b29      	cmp	r3, #41	@ 0x29
34005f7c:	d103      	bne.n	34005f86 <I2C_Slave_ISR_DMA+0x182>
          {
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
34005f7e:	68fb      	ldr	r3, [r7, #12]
34005f80:	2221      	movs	r2, #33	@ 0x21
34005f82:	631a      	str	r2, [r3, #48]	@ 0x30
34005f84:	e008      	b.n	34005f98 <I2C_Slave_ISR_DMA+0x194>
          }
          else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
34005f86:	7dfb      	ldrb	r3, [r7, #23]
34005f88:	2b22      	cmp	r3, #34	@ 0x22
34005f8a:	d002      	beq.n	34005f92 <I2C_Slave_ISR_DMA+0x18e>
34005f8c:	7dfb      	ldrb	r3, [r7, #23]
34005f8e:	2b2a      	cmp	r3, #42	@ 0x2a
34005f90:	d102      	bne.n	34005f98 <I2C_Slave_ISR_DMA+0x194>
          {
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
34005f92:	68fb      	ldr	r3, [r7, #12]
34005f94:	2222      	movs	r2, #34	@ 0x22
34005f96:	631a      	str	r2, [r3, #48]	@ 0x30
          {
            /* Do nothing */
          }

          /* Call the corresponding callback to inform upper layer of End of Transfer */
          I2C_ITError(hi2c, hi2c->ErrorCode);
34005f98:	68fb      	ldr	r3, [r7, #12]
34005f9a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34005f9c:	4619      	mov	r1, r3
34005f9e:	68f8      	ldr	r0, [r7, #12]
34005fa0:	f000 fbde 	bl	34006760 <I2C_ITError>
      if (treatdmanack == 1U)
34005fa4:	e005      	b.n	34005fb2 <I2C_Slave_ISR_DMA+0x1ae>
34005fa6:	e004      	b.n	34005fb2 <I2C_Slave_ISR_DMA+0x1ae>
      }
    }
    else
    {
      /* Only Clear NACK Flag, no DMA treatment is pending */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
34005fa8:	68fb      	ldr	r3, [r7, #12]
34005faa:	681b      	ldr	r3, [r3, #0]
34005fac:	2210      	movs	r2, #16
34005fae:	61da      	str	r2, [r3, #28]
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
34005fb0:	e011      	b.n	34005fd6 <I2C_Slave_ISR_DMA+0x1d2>
      if (treatdmanack == 1U)
34005fb2:	bf00      	nop
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
34005fb4:	e00f      	b.n	34005fd6 <I2C_Slave_ISR_DMA+0x1d2>
    }
  }
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && \
34005fb6:	68bb      	ldr	r3, [r7, #8]
34005fb8:	08db      	lsrs	r3, r3, #3
34005fba:	f003 0301 	and.w	r3, r3, #1
34005fbe:	2b00      	cmp	r3, #0
34005fc0:	d009      	beq.n	34005fd6 <I2C_Slave_ISR_DMA+0x1d2>
           (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
34005fc2:	687b      	ldr	r3, [r7, #4]
34005fc4:	08db      	lsrs	r3, r3, #3
34005fc6:	f003 0301 	and.w	r3, r3, #1
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && \
34005fca:	2b00      	cmp	r3, #0
34005fcc:	d003      	beq.n	34005fd6 <I2C_Slave_ISR_DMA+0x1d2>
  {
    I2C_ITAddrCplt(hi2c, ITFlags);
34005fce:	68b9      	ldr	r1, [r7, #8]
34005fd0:	68f8      	ldr	r0, [r7, #12]
34005fd2:	f000 f809 	bl	34005fe8 <I2C_ITAddrCplt>
  {
    /* Nothing to do */
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
34005fd6:	68fb      	ldr	r3, [r7, #12]
34005fd8:	2200      	movs	r2, #0
34005fda:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  return HAL_OK;
34005fde:	2300      	movs	r3, #0
}
34005fe0:	4618      	mov	r0, r3
34005fe2:	3724      	adds	r7, #36	@ 0x24
34005fe4:	46bd      	mov	sp, r7
34005fe6:	bd90      	pop	{r4, r7, pc}

34005fe8 <I2C_ITAddrCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
34005fe8:	b580      	push	{r7, lr}
34005fea:	b084      	sub	sp, #16
34005fec:	af00      	add	r7, sp, #0
34005fee:	6078      	str	r0, [r7, #4]
34005ff0:	6039      	str	r1, [r7, #0]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(ITFlags);

  /* In case of Listen state, need to inform upper layer of address match code event */
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
34005ff2:	687b      	ldr	r3, [r7, #4]
34005ff4:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34005ff8:	b2db      	uxtb	r3, r3
34005ffa:	f003 0328 	and.w	r3, r3, #40	@ 0x28
34005ffe:	2b28      	cmp	r3, #40	@ 0x28
34006000:	d16a      	bne.n	340060d8 <I2C_ITAddrCplt+0xf0>
  {
    transferdirection = I2C_GET_DIR(hi2c);
34006002:	687b      	ldr	r3, [r7, #4]
34006004:	681b      	ldr	r3, [r3, #0]
34006006:	699b      	ldr	r3, [r3, #24]
34006008:	0c1b      	lsrs	r3, r3, #16
3400600a:	b2db      	uxtb	r3, r3
3400600c:	f003 0301 	and.w	r3, r3, #1
34006010:	73fb      	strb	r3, [r7, #15]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
34006012:	687b      	ldr	r3, [r7, #4]
34006014:	681b      	ldr	r3, [r3, #0]
34006016:	699b      	ldr	r3, [r3, #24]
34006018:	0c1b      	lsrs	r3, r3, #16
3400601a:	b29b      	uxth	r3, r3
3400601c:	f003 03fe 	and.w	r3, r3, #254	@ 0xfe
34006020:	81bb      	strh	r3, [r7, #12]
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
34006022:	687b      	ldr	r3, [r7, #4]
34006024:	681b      	ldr	r3, [r3, #0]
34006026:	689b      	ldr	r3, [r3, #8]
34006028:	b29b      	uxth	r3, r3
3400602a:	f3c3 0309 	ubfx	r3, r3, #0, #10
3400602e:	817b      	strh	r3, [r7, #10]
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
34006030:	687b      	ldr	r3, [r7, #4]
34006032:	681b      	ldr	r3, [r3, #0]
34006034:	68db      	ldr	r3, [r3, #12]
34006036:	b29b      	uxth	r3, r3
34006038:	f003 03fe 	and.w	r3, r3, #254	@ 0xfe
3400603c:	813b      	strh	r3, [r7, #8]

    /* If 10bits addressing mode is selected */
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
3400603e:	687b      	ldr	r3, [r7, #4]
34006040:	68db      	ldr	r3, [r3, #12]
34006042:	2b02      	cmp	r3, #2
34006044:	d138      	bne.n	340060b8 <I2C_ITAddrCplt+0xd0>
    {
      if ((slaveaddrcode & SLAVE_ADDR_MSK) == ((ownadd1code >> SLAVE_ADDR_SHIFT) & SLAVE_ADDR_MSK))
34006046:	897b      	ldrh	r3, [r7, #10]
34006048:	09db      	lsrs	r3, r3, #7
3400604a:	b29a      	uxth	r2, r3
3400604c:	89bb      	ldrh	r3, [r7, #12]
3400604e:	4053      	eors	r3, r2
34006050:	b29b      	uxth	r3, r3
34006052:	f003 0306 	and.w	r3, r3, #6
34006056:	2b00      	cmp	r3, #0
34006058:	d11c      	bne.n	34006094 <I2C_ITAddrCplt+0xac>
      {
        slaveaddrcode = ownadd1code;
3400605a:	897b      	ldrh	r3, [r7, #10]
3400605c:	81bb      	strh	r3, [r7, #12]
        hi2c->AddrEventCount++;
3400605e:	687b      	ldr	r3, [r7, #4]
34006060:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
34006062:	1c5a      	adds	r2, r3, #1
34006064:	687b      	ldr	r3, [r7, #4]
34006066:	649a      	str	r2, [r3, #72]	@ 0x48
        if (hi2c->AddrEventCount == 2U)
34006068:	687b      	ldr	r3, [r7, #4]
3400606a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400606c:	2b02      	cmp	r3, #2
3400606e:	d13b      	bne.n	340060e8 <I2C_ITAddrCplt+0x100>
        {
          /* Reset Address Event counter */
          hi2c->AddrEventCount = 0U;
34006070:	687b      	ldr	r3, [r7, #4]
34006072:	2200      	movs	r2, #0
34006074:	649a      	str	r2, [r3, #72]	@ 0x48

          /* Clear ADDR flag */
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
34006076:	687b      	ldr	r3, [r7, #4]
34006078:	681b      	ldr	r3, [r3, #0]
3400607a:	2208      	movs	r2, #8
3400607c:	61da      	str	r2, [r3, #28]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
3400607e:	687b      	ldr	r3, [r7, #4]
34006080:	2200      	movs	r2, #0
34006082:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

          /* Call Slave Addr callback */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
          hi2c->AddrCallback(hi2c, transferdirection, slaveaddrcode);
#else
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
34006086:	89ba      	ldrh	r2, [r7, #12]
34006088:	7bfb      	ldrb	r3, [r7, #15]
3400608a:	4619      	mov	r1, r3
3400608c:	6878      	ldr	r0, [r7, #4]
3400608e:	f7ff fa52 	bl	34005536 <HAL_I2C_AddrCallback>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
  }
}
34006092:	e029      	b.n	340060e8 <I2C_ITAddrCplt+0x100>
        slaveaddrcode = ownadd2code;
34006094:	893b      	ldrh	r3, [r7, #8]
34006096:	81bb      	strh	r3, [r7, #12]
        I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
34006098:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
3400609c:	6878      	ldr	r0, [r7, #4]
3400609e:	f000 fd6f 	bl	34006b80 <I2C_Disable_IRQ>
        __HAL_UNLOCK(hi2c);
340060a2:	687b      	ldr	r3, [r7, #4]
340060a4:	2200      	movs	r2, #0
340060a6:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
340060aa:	89ba      	ldrh	r2, [r7, #12]
340060ac:	7bfb      	ldrb	r3, [r7, #15]
340060ae:	4619      	mov	r1, r3
340060b0:	6878      	ldr	r0, [r7, #4]
340060b2:	f7ff fa40 	bl	34005536 <HAL_I2C_AddrCallback>
}
340060b6:	e017      	b.n	340060e8 <I2C_ITAddrCplt+0x100>
      I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT);
340060b8:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
340060bc:	6878      	ldr	r0, [r7, #4]
340060be:	f000 fd5f 	bl	34006b80 <I2C_Disable_IRQ>
      __HAL_UNLOCK(hi2c);
340060c2:	687b      	ldr	r3, [r7, #4]
340060c4:	2200      	movs	r2, #0
340060c6:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
340060ca:	89ba      	ldrh	r2, [r7, #12]
340060cc:	7bfb      	ldrb	r3, [r7, #15]
340060ce:	4619      	mov	r1, r3
340060d0:	6878      	ldr	r0, [r7, #4]
340060d2:	f7ff fa30 	bl	34005536 <HAL_I2C_AddrCallback>
}
340060d6:	e007      	b.n	340060e8 <I2C_ITAddrCplt+0x100>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
340060d8:	687b      	ldr	r3, [r7, #4]
340060da:	681b      	ldr	r3, [r3, #0]
340060dc:	2208      	movs	r2, #8
340060de:	61da      	str	r2, [r3, #28]
    __HAL_UNLOCK(hi2c);
340060e0:	687b      	ldr	r3, [r7, #4]
340060e2:	2200      	movs	r2, #0
340060e4:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
}
340060e8:	bf00      	nop
340060ea:	3710      	adds	r7, #16
340060ec:	46bd      	mov	sp, r7
340060ee:	bd80      	pop	{r7, pc}

340060f0 <I2C_ITMasterSeqCplt>:
  * @brief  I2C Master sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITMasterSeqCplt(I2C_HandleTypeDef *hi2c)
{
340060f0:	b580      	push	{r7, lr}
340060f2:	b082      	sub	sp, #8
340060f4:	af00      	add	r7, sp, #0
340060f6:	6078      	str	r0, [r7, #4]
  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
340060f8:	687b      	ldr	r3, [r7, #4]
340060fa:	2200      	movs	r2, #0
340060fc:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  /* No Generate Stop, to permit restart mode */
  /* The stop will be done at the end of transfer, when I2C_AUTOEND_MODE enable */
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
34006100:	687b      	ldr	r3, [r7, #4]
34006102:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34006106:	b2db      	uxtb	r3, r3
34006108:	2b21      	cmp	r3, #33	@ 0x21
3400610a:	d115      	bne.n	34006138 <I2C_ITMasterSeqCplt+0x48>
  {
    hi2c->State         = HAL_I2C_STATE_READY;
3400610c:	687b      	ldr	r3, [r7, #4]
3400610e:	2220      	movs	r2, #32
34006110:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
34006114:	687b      	ldr	r3, [r7, #4]
34006116:	2211      	movs	r2, #17
34006118:	631a      	str	r2, [r3, #48]	@ 0x30
    hi2c->XferISR       = NULL;
3400611a:	687b      	ldr	r3, [r7, #4]
3400611c:	2200      	movs	r2, #0
3400611e:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
34006120:	2101      	movs	r1, #1
34006122:	6878      	ldr	r0, [r7, #4]
34006124:	f000 fd2c 	bl	34006b80 <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34006128:	687b      	ldr	r3, [r7, #4]
3400612a:	2200      	movs	r2, #0
3400612c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->MasterTxCpltCallback(hi2c);
#else
    HAL_I2C_MasterTxCpltCallback(hi2c);
34006130:	6878      	ldr	r0, [r7, #4]
34006132:	f009 faa9 	bl	3400f688 <HAL_I2C_MasterTxCpltCallback>
    hi2c->MasterRxCpltCallback(hi2c);
#else
    HAL_I2C_MasterRxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
34006136:	e014      	b.n	34006162 <I2C_ITMasterSeqCplt+0x72>
    hi2c->State         = HAL_I2C_STATE_READY;
34006138:	687b      	ldr	r3, [r7, #4]
3400613a:	2220      	movs	r2, #32
3400613c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
34006140:	687b      	ldr	r3, [r7, #4]
34006142:	2212      	movs	r2, #18
34006144:	631a      	str	r2, [r3, #48]	@ 0x30
    hi2c->XferISR       = NULL;
34006146:	687b      	ldr	r3, [r7, #4]
34006148:	2200      	movs	r2, #0
3400614a:	635a      	str	r2, [r3, #52]	@ 0x34
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
3400614c:	2102      	movs	r1, #2
3400614e:	6878      	ldr	r0, [r7, #4]
34006150:	f000 fd16 	bl	34006b80 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
34006154:	687b      	ldr	r3, [r7, #4]
34006156:	2200      	movs	r2, #0
34006158:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
3400615c:	6878      	ldr	r0, [r7, #4]
3400615e:	f009 fa87 	bl	3400f670 <HAL_I2C_MasterRxCpltCallback>
}
34006162:	bf00      	nop
34006164:	3708      	adds	r7, #8
34006166:	46bd      	mov	sp, r7
34006168:	bd80      	pop	{r7, pc}

3400616a <I2C_ITSlaveSeqCplt>:
  * @brief  I2C Slave sequential complete process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITSlaveSeqCplt(I2C_HandleTypeDef *hi2c)
{
3400616a:	b580      	push	{r7, lr}
3400616c:	b084      	sub	sp, #16
3400616e:	af00      	add	r7, sp, #0
34006170:	6078      	str	r0, [r7, #4]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
34006172:	687b      	ldr	r3, [r7, #4]
34006174:	681b      	ldr	r3, [r3, #0]
34006176:	681b      	ldr	r3, [r3, #0]
34006178:	60fb      	str	r3, [r7, #12]

  /* Reset I2C handle mode */
  hi2c->Mode = HAL_I2C_MODE_NONE;
3400617a:	687b      	ldr	r3, [r7, #4]
3400617c:	2200      	movs	r2, #0
3400617e:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

#if defined(HAL_DMA_MODULE_ENABLED)
  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
34006182:	68fb      	ldr	r3, [r7, #12]
34006184:	0b9b      	lsrs	r3, r3, #14
34006186:	f003 0301 	and.w	r3, r3, #1
3400618a:	2b00      	cmp	r3, #0
3400618c:	d008      	beq.n	340061a0 <I2C_ITSlaveSeqCplt+0x36>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
3400618e:	687b      	ldr	r3, [r7, #4]
34006190:	681b      	ldr	r3, [r3, #0]
34006192:	681a      	ldr	r2, [r3, #0]
34006194:	687b      	ldr	r3, [r7, #4]
34006196:	681b      	ldr	r3, [r3, #0]
34006198:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
3400619c:	601a      	str	r2, [r3, #0]
3400619e:	e00d      	b.n	340061bc <I2C_ITSlaveSeqCplt+0x52>
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
340061a0:	68fb      	ldr	r3, [r7, #12]
340061a2:	0bdb      	lsrs	r3, r3, #15
340061a4:	f003 0301 	and.w	r3, r3, #1
340061a8:	2b00      	cmp	r3, #0
340061aa:	d007      	beq.n	340061bc <I2C_ITSlaveSeqCplt+0x52>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
340061ac:	687b      	ldr	r3, [r7, #4]
340061ae:	681b      	ldr	r3, [r3, #0]
340061b0:	681a      	ldr	r2, [r3, #0]
340061b2:	687b      	ldr	r3, [r7, #4]
340061b4:	681b      	ldr	r3, [r3, #0]
340061b6:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
340061ba:	601a      	str	r2, [r3, #0]
  {
    /* Do nothing */
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
340061bc:	687b      	ldr	r3, [r7, #4]
340061be:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
340061c2:	b2db      	uxtb	r3, r3
340061c4:	2b29      	cmp	r3, #41	@ 0x29
340061c6:	d112      	bne.n	340061ee <I2C_ITSlaveSeqCplt+0x84>
  {
    /* Remove HAL_I2C_STATE_SLAVE_BUSY_TX, keep only HAL_I2C_STATE_LISTEN */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
340061c8:	687b      	ldr	r3, [r7, #4]
340061ca:	2228      	movs	r2, #40	@ 0x28
340061cc:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
340061d0:	687b      	ldr	r3, [r7, #4]
340061d2:	2221      	movs	r2, #33	@ 0x21
340061d4:	631a      	str	r2, [r3, #48]	@ 0x30

    /* Disable Interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
340061d6:	2101      	movs	r1, #1
340061d8:	6878      	ldr	r0, [r7, #4]
340061da:	f000 fcd1 	bl	34006b80 <I2C_Disable_IRQ>

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
340061de:	687b      	ldr	r3, [r7, #4]
340061e0:	2200      	movs	r2, #0
340061e2:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
340061e6:	6878      	ldr	r0, [r7, #4]
340061e8:	f009 fa66 	bl	3400f6b8 <HAL_I2C_SlaveTxCpltCallback>
  }
  else
  {
    /* Nothing to do */
  }
}
340061ec:	e017      	b.n	3400621e <I2C_ITSlaveSeqCplt+0xb4>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
340061ee:	687b      	ldr	r3, [r7, #4]
340061f0:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
340061f4:	b2db      	uxtb	r3, r3
340061f6:	2b2a      	cmp	r3, #42	@ 0x2a
340061f8:	d111      	bne.n	3400621e <I2C_ITSlaveSeqCplt+0xb4>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
340061fa:	687b      	ldr	r3, [r7, #4]
340061fc:	2228      	movs	r2, #40	@ 0x28
340061fe:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
34006202:	687b      	ldr	r3, [r7, #4]
34006204:	2222      	movs	r2, #34	@ 0x22
34006206:	631a      	str	r2, [r3, #48]	@ 0x30
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
34006208:	2102      	movs	r1, #2
3400620a:	6878      	ldr	r0, [r7, #4]
3400620c:	f000 fcb8 	bl	34006b80 <I2C_Disable_IRQ>
    __HAL_UNLOCK(hi2c);
34006210:	687b      	ldr	r3, [r7, #4]
34006212:	2200      	movs	r2, #0
34006214:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
34006218:	6878      	ldr	r0, [r7, #4]
3400621a:	f009 fa41 	bl	3400f6a0 <HAL_I2C_SlaveRxCpltCallback>
}
3400621e:	bf00      	nop
34006220:	3710      	adds	r7, #16
34006222:	46bd      	mov	sp, r7
34006224:	bd80      	pop	{r7, pc}
	...

34006228 <I2C_ITMasterCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITMasterCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
34006228:	b580      	push	{r7, lr}
3400622a:	b086      	sub	sp, #24
3400622c:	af00      	add	r7, sp, #0
3400622e:	6078      	str	r0, [r7, #4]
34006230:	6039      	str	r1, [r7, #0]
  uint32_t tmperror;
  uint32_t tmpITFlags = ITFlags;
34006232:	683b      	ldr	r3, [r7, #0]
34006234:	617b      	str	r3, [r7, #20]
  __IO uint32_t tmpreg;

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
34006236:	687b      	ldr	r3, [r7, #4]
34006238:	681b      	ldr	r3, [r3, #0]
3400623a:	2220      	movs	r2, #32
3400623c:	61da      	str	r2, [r3, #28]

  /* Disable Interrupts and Store Previous state */
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
3400623e:	687b      	ldr	r3, [r7, #4]
34006240:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34006244:	b2db      	uxtb	r3, r3
34006246:	2b21      	cmp	r3, #33	@ 0x21
34006248:	d107      	bne.n	3400625a <I2C_ITMasterCplt+0x32>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_TX_IT);
3400624a:	2101      	movs	r1, #1
3400624c:	6878      	ldr	r0, [r7, #4]
3400624e:	f000 fc97 	bl	34006b80 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
34006252:	687b      	ldr	r3, [r7, #4]
34006254:	2211      	movs	r2, #17
34006256:	631a      	str	r2, [r3, #48]	@ 0x30
34006258:	e00c      	b.n	34006274 <I2C_ITMasterCplt+0x4c>
  }
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
3400625a:	687b      	ldr	r3, [r7, #4]
3400625c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34006260:	b2db      	uxtb	r3, r3
34006262:	2b22      	cmp	r3, #34	@ 0x22
34006264:	d106      	bne.n	34006274 <I2C_ITMasterCplt+0x4c>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT);
34006266:	2102      	movs	r1, #2
34006268:	6878      	ldr	r0, [r7, #4]
3400626a:	f000 fc89 	bl	34006b80 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
3400626e:	687b      	ldr	r3, [r7, #4]
34006270:	2212      	movs	r2, #18
34006272:	631a      	str	r2, [r3, #48]	@ 0x30
  {
    /* Do nothing */
  }

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
34006274:	687b      	ldr	r3, [r7, #4]
34006276:	681b      	ldr	r3, [r3, #0]
34006278:	6859      	ldr	r1, [r3, #4]
3400627a:	687b      	ldr	r3, [r7, #4]
3400627c:	681a      	ldr	r2, [r3, #0]
3400627e:	4b4d      	ldr	r3, [pc, #308]	@ (340063b4 <I2C_ITMasterCplt+0x18c>)
34006280:	400b      	ands	r3, r1
34006282:	6053      	str	r3, [r2, #4]

  /* Reset handle parameters */
  hi2c->XferISR       = NULL;
34006284:	687b      	ldr	r3, [r7, #4]
34006286:	2200      	movs	r2, #0
34006288:	635a      	str	r2, [r3, #52]	@ 0x34
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
3400628a:	687b      	ldr	r3, [r7, #4]
3400628c:	4a4a      	ldr	r2, [pc, #296]	@ (340063b8 <I2C_ITMasterCplt+0x190>)
3400628e:	62da      	str	r2, [r3, #44]	@ 0x2c

  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
34006290:	697b      	ldr	r3, [r7, #20]
34006292:	091b      	lsrs	r3, r3, #4
34006294:	f003 0301 	and.w	r3, r3, #1
34006298:	2b00      	cmp	r3, #0
3400629a:	d009      	beq.n	340062b0 <I2C_ITMasterCplt+0x88>
  {
    /* Clear NACK Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
3400629c:	687b      	ldr	r3, [r7, #4]
3400629e:	681b      	ldr	r3, [r3, #0]
340062a0:	2210      	movs	r2, #16
340062a2:	61da      	str	r2, [r3, #28]

    /* Set acknowledge error code */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
340062a4:	687b      	ldr	r3, [r7, #4]
340062a6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340062a8:	f043 0204 	orr.w	r2, r3, #4
340062ac:	687b      	ldr	r3, [r7, #4]
340062ae:	645a      	str	r2, [r3, #68]	@ 0x44
  }

  /* Fetch Last receive data if any */
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
340062b0:	687b      	ldr	r3, [r7, #4]
340062b2:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
340062b6:	b2db      	uxtb	r3, r3
340062b8:	2b60      	cmp	r3, #96	@ 0x60
340062ba:	d10b      	bne.n	340062d4 <I2C_ITMasterCplt+0xac>
340062bc:	697b      	ldr	r3, [r7, #20]
340062be:	089b      	lsrs	r3, r3, #2
340062c0:	f003 0301 	and.w	r3, r3, #1
340062c4:	2b00      	cmp	r3, #0
340062c6:	d005      	beq.n	340062d4 <I2C_ITMasterCplt+0xac>
  {
    /* Read data from RXDR */
    tmpreg = (uint8_t)hi2c->Instance->RXDR;
340062c8:	687b      	ldr	r3, [r7, #4]
340062ca:	681b      	ldr	r3, [r3, #0]
340062cc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340062ce:	b2db      	uxtb	r3, r3
340062d0:	60fb      	str	r3, [r7, #12]
    UNUSED(tmpreg);
340062d2:	68fb      	ldr	r3, [r7, #12]
  }

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
340062d4:	6878      	ldr	r0, [r7, #4]
340062d6:	f000 fb5a 	bl	3400698e <I2C_Flush_TXDR>

  /* Store current volatile hi2c->ErrorCode, misra rule */
  tmperror = hi2c->ErrorCode;
340062da:	687b      	ldr	r3, [r7, #4]
340062dc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340062de:	613b      	str	r3, [r7, #16]

  /* Call the corresponding callback to inform upper layer of End of Transfer */
  if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))
340062e0:	687b      	ldr	r3, [r7, #4]
340062e2:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
340062e6:	b2db      	uxtb	r3, r3
340062e8:	2b60      	cmp	r3, #96	@ 0x60
340062ea:	d002      	beq.n	340062f2 <I2C_ITMasterCplt+0xca>
340062ec:	693b      	ldr	r3, [r7, #16]
340062ee:	2b00      	cmp	r3, #0
340062f0:	d006      	beq.n	34006300 <I2C_ITMasterCplt+0xd8>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
340062f2:	687b      	ldr	r3, [r7, #4]
340062f4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340062f6:	4619      	mov	r1, r3
340062f8:	6878      	ldr	r0, [r7, #4]
340062fa:	f000 fa31 	bl	34006760 <I2C_ITError>
  }
  else
  {
    /* Nothing to do */
  }
}
340062fe:	e054      	b.n	340063aa <I2C_ITMasterCplt+0x182>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
34006300:	687b      	ldr	r3, [r7, #4]
34006302:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34006306:	b2db      	uxtb	r3, r3
34006308:	2b21      	cmp	r3, #33	@ 0x21
3400630a:	d124      	bne.n	34006356 <I2C_ITMasterCplt+0x12e>
    hi2c->State = HAL_I2C_STATE_READY;
3400630c:	687b      	ldr	r3, [r7, #4]
3400630e:	2220      	movs	r2, #32
34006310:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
34006314:	687b      	ldr	r3, [r7, #4]
34006316:	2200      	movs	r2, #0
34006318:	631a      	str	r2, [r3, #48]	@ 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
3400631a:	687b      	ldr	r3, [r7, #4]
3400631c:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
34006320:	b2db      	uxtb	r3, r3
34006322:	2b40      	cmp	r3, #64	@ 0x40
34006324:	d10b      	bne.n	3400633e <I2C_ITMasterCplt+0x116>
      hi2c->Mode = HAL_I2C_MODE_NONE;
34006326:	687b      	ldr	r3, [r7, #4]
34006328:	2200      	movs	r2, #0
3400632a:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
      __HAL_UNLOCK(hi2c);
3400632e:	687b      	ldr	r3, [r7, #4]
34006330:	2200      	movs	r2, #0
34006332:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      HAL_I2C_MemTxCpltCallback(hi2c);
34006336:	6878      	ldr	r0, [r7, #4]
34006338:	f009 f9d6 	bl	3400f6e8 <HAL_I2C_MemTxCpltCallback>
}
3400633c:	e035      	b.n	340063aa <I2C_ITMasterCplt+0x182>
      hi2c->Mode = HAL_I2C_MODE_NONE;
3400633e:	687b      	ldr	r3, [r7, #4]
34006340:	2200      	movs	r2, #0
34006342:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
      __HAL_UNLOCK(hi2c);
34006346:	687b      	ldr	r3, [r7, #4]
34006348:	2200      	movs	r2, #0
3400634a:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      HAL_I2C_MasterTxCpltCallback(hi2c);
3400634e:	6878      	ldr	r0, [r7, #4]
34006350:	f009 f99a 	bl	3400f688 <HAL_I2C_MasterTxCpltCallback>
}
34006354:	e029      	b.n	340063aa <I2C_ITMasterCplt+0x182>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
34006356:	687b      	ldr	r3, [r7, #4]
34006358:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400635c:	b2db      	uxtb	r3, r3
3400635e:	2b22      	cmp	r3, #34	@ 0x22
34006360:	d123      	bne.n	340063aa <I2C_ITMasterCplt+0x182>
    hi2c->State = HAL_I2C_STATE_READY;
34006362:	687b      	ldr	r3, [r7, #4]
34006364:	2220      	movs	r2, #32
34006366:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
3400636a:	687b      	ldr	r3, [r7, #4]
3400636c:	2200      	movs	r2, #0
3400636e:	631a      	str	r2, [r3, #48]	@ 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
34006370:	687b      	ldr	r3, [r7, #4]
34006372:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
34006376:	b2db      	uxtb	r3, r3
34006378:	2b40      	cmp	r3, #64	@ 0x40
3400637a:	d10b      	bne.n	34006394 <I2C_ITMasterCplt+0x16c>
      hi2c->Mode = HAL_I2C_MODE_NONE;
3400637c:	687b      	ldr	r3, [r7, #4]
3400637e:	2200      	movs	r2, #0
34006380:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
      __HAL_UNLOCK(hi2c);
34006384:	687b      	ldr	r3, [r7, #4]
34006386:	2200      	movs	r2, #0
34006388:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      HAL_I2C_MemRxCpltCallback(hi2c);
3400638c:	6878      	ldr	r0, [r7, #4]
3400638e:	f009 f99f 	bl	3400f6d0 <HAL_I2C_MemRxCpltCallback>
}
34006392:	e00a      	b.n	340063aa <I2C_ITMasterCplt+0x182>
      hi2c->Mode = HAL_I2C_MODE_NONE;
34006394:	687b      	ldr	r3, [r7, #4]
34006396:	2200      	movs	r2, #0
34006398:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
      __HAL_UNLOCK(hi2c);
3400639c:	687b      	ldr	r3, [r7, #4]
3400639e:	2200      	movs	r2, #0
340063a0:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      HAL_I2C_MasterRxCpltCallback(hi2c);
340063a4:	6878      	ldr	r0, [r7, #4]
340063a6:	f009 f963 	bl	3400f670 <HAL_I2C_MasterRxCpltCallback>
}
340063aa:	bf00      	nop
340063ac:	3718      	adds	r7, #24
340063ae:	46bd      	mov	sp, r7
340063b0:	bd80      	pop	{r7, pc}
340063b2:	bf00      	nop
340063b4:	fe00e800 	.word	0xfe00e800
340063b8:	ffff0000 	.word	0xffff0000

340063bc <I2C_ITSlaveCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITSlaveCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
340063bc:	b590      	push	{r4, r7, lr}
340063be:	b087      	sub	sp, #28
340063c0:	af00      	add	r7, sp, #0
340063c2:	6078      	str	r0, [r7, #4]
340063c4:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
340063c6:	687b      	ldr	r3, [r7, #4]
340063c8:	681b      	ldr	r3, [r3, #0]
340063ca:	681b      	ldr	r3, [r3, #0]
340063cc:	613b      	str	r3, [r7, #16]
  uint32_t tmpITFlags = ITFlags;
340063ce:	683b      	ldr	r3, [r7, #0]
340063d0:	617b      	str	r3, [r7, #20]
  uint32_t tmpoptions = hi2c->XferOptions;
340063d2:	687b      	ldr	r3, [r7, #4]
340063d4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
340063d6:	60fb      	str	r3, [r7, #12]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
340063d8:	687b      	ldr	r3, [r7, #4]
340063da:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
340063de:	72fb      	strb	r3, [r7, #11]

  /* Clear STOP Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
340063e0:	687b      	ldr	r3, [r7, #4]
340063e2:	681b      	ldr	r3, [r3, #0]
340063e4:	2220      	movs	r2, #32
340063e6:	61da      	str	r2, [r3, #28]

  /* Disable Interrupts and Store Previous state */
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
340063e8:	7afb      	ldrb	r3, [r7, #11]
340063ea:	2b21      	cmp	r3, #33	@ 0x21
340063ec:	d002      	beq.n	340063f4 <I2C_ITSlaveCplt+0x38>
340063ee:	7afb      	ldrb	r3, [r7, #11]
340063f0:	2b29      	cmp	r3, #41	@ 0x29
340063f2:	d108      	bne.n	34006406 <I2C_ITSlaveCplt+0x4a>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT);
340063f4:	f248 0101 	movw	r1, #32769	@ 0x8001
340063f8:	6878      	ldr	r0, [r7, #4]
340063fa:	f000 fbc1 	bl	34006b80 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
340063fe:	687b      	ldr	r3, [r7, #4]
34006400:	2221      	movs	r2, #33	@ 0x21
34006402:	631a      	str	r2, [r3, #48]	@ 0x30
34006404:	e019      	b.n	3400643a <I2C_ITSlaveCplt+0x7e>
  }
  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
34006406:	7afb      	ldrb	r3, [r7, #11]
34006408:	2b22      	cmp	r3, #34	@ 0x22
3400640a:	d002      	beq.n	34006412 <I2C_ITSlaveCplt+0x56>
3400640c:	7afb      	ldrb	r3, [r7, #11]
3400640e:	2b2a      	cmp	r3, #42	@ 0x2a
34006410:	d108      	bne.n	34006424 <I2C_ITSlaveCplt+0x68>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT);
34006412:	f248 0102 	movw	r1, #32770	@ 0x8002
34006416:	6878      	ldr	r0, [r7, #4]
34006418:	f000 fbb2 	bl	34006b80 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
3400641c:	687b      	ldr	r3, [r7, #4]
3400641e:	2222      	movs	r2, #34	@ 0x22
34006420:	631a      	str	r2, [r3, #48]	@ 0x30
34006422:	e00a      	b.n	3400643a <I2C_ITSlaveCplt+0x7e>
  }
  else if (tmpstate == HAL_I2C_STATE_LISTEN)
34006424:	7afb      	ldrb	r3, [r7, #11]
34006426:	2b28      	cmp	r3, #40	@ 0x28
34006428:	d107      	bne.n	3400643a <I2C_ITSlaveCplt+0x7e>
  {
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_TX_IT | I2C_XFER_RX_IT);
3400642a:	f248 0103 	movw	r1, #32771	@ 0x8003
3400642e:	6878      	ldr	r0, [r7, #4]
34006430:	f000 fba6 	bl	34006b80 <I2C_Disable_IRQ>
    hi2c->PreviousState = I2C_STATE_NONE;
34006434:	687b      	ldr	r3, [r7, #4]
34006436:	2200      	movs	r2, #0
34006438:	631a      	str	r2, [r3, #48]	@ 0x30
  {
    /* Do nothing */
  }

  /* Disable Address Acknowledge */
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
3400643a:	687b      	ldr	r3, [r7, #4]
3400643c:	681b      	ldr	r3, [r3, #0]
3400643e:	685a      	ldr	r2, [r3, #4]
34006440:	687b      	ldr	r3, [r7, #4]
34006442:	681b      	ldr	r3, [r3, #0]
34006444:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
34006448:	605a      	str	r2, [r3, #4]

  /* Clear Configuration Register 2 */
  I2C_RESET_CR2(hi2c);
3400644a:	687b      	ldr	r3, [r7, #4]
3400644c:	681b      	ldr	r3, [r3, #0]
3400644e:	6859      	ldr	r1, [r3, #4]
34006450:	687b      	ldr	r3, [r7, #4]
34006452:	681a      	ldr	r2, [r3, #0]
34006454:	4b95      	ldr	r3, [pc, #596]	@ (340066ac <I2C_ITSlaveCplt+0x2f0>)
34006456:	400b      	ands	r3, r1
34006458:	6053      	str	r3, [r2, #4]

  /* Flush TX register */
  I2C_Flush_TXDR(hi2c);
3400645a:	6878      	ldr	r0, [r7, #4]
3400645c:	f000 fa97 	bl	3400698e <I2C_Flush_TXDR>

#if defined(HAL_DMA_MODULE_ENABLED)
  /* If a DMA is ongoing, Update handle size context */
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
34006460:	693b      	ldr	r3, [r7, #16]
34006462:	0b9b      	lsrs	r3, r3, #14
34006464:	f003 0301 	and.w	r3, r3, #1
34006468:	2b00      	cmp	r3, #0
3400646a:	d01c      	beq.n	340064a6 <I2C_ITSlaveCplt+0xea>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
3400646c:	687b      	ldr	r3, [r7, #4]
3400646e:	681b      	ldr	r3, [r3, #0]
34006470:	681a      	ldr	r2, [r3, #0]
34006472:	687b      	ldr	r3, [r7, #4]
34006474:	681b      	ldr	r3, [r3, #0]
34006476:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
3400647a:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmatx != NULL)
3400647c:	687b      	ldr	r3, [r7, #4]
3400647e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34006480:	2b00      	cmp	r3, #0
34006482:	d032      	beq.n	340064ea <I2C_ITSlaveCplt+0x12e>
    {
      hi2c->XferCount = (uint16_t)I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx);
34006484:	687b      	ldr	r3, [r7, #4]
34006486:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34006488:	681b      	ldr	r3, [r3, #0]
3400648a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400648c:	b29c      	uxth	r4, r3
3400648e:	687b      	ldr	r3, [r7, #4]
34006490:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34006492:	4618      	mov	r0, r3
34006494:	f7fe fbc0 	bl	34004c18 <HAL_DMAEx_GetFifoLevel>
34006498:	4603      	mov	r3, r0
3400649a:	b29b      	uxth	r3, r3
3400649c:	4423      	add	r3, r4
3400649e:	b29a      	uxth	r2, r3
340064a0:	687b      	ldr	r3, [r7, #4]
340064a2:	855a      	strh	r2, [r3, #42]	@ 0x2a
340064a4:	e021      	b.n	340064ea <I2C_ITSlaveCplt+0x12e>
    }
  }
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
340064a6:	693b      	ldr	r3, [r7, #16]
340064a8:	0bdb      	lsrs	r3, r3, #15
340064aa:	f003 0301 	and.w	r3, r3, #1
340064ae:	2b00      	cmp	r3, #0
340064b0:	d01b      	beq.n	340064ea <I2C_ITSlaveCplt+0x12e>
  {
    /* Disable DMA Request */
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
340064b2:	687b      	ldr	r3, [r7, #4]
340064b4:	681b      	ldr	r3, [r3, #0]
340064b6:	681a      	ldr	r2, [r3, #0]
340064b8:	687b      	ldr	r3, [r7, #4]
340064ba:	681b      	ldr	r3, [r3, #0]
340064bc:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
340064c0:	601a      	str	r2, [r3, #0]

    if (hi2c->hdmarx != NULL)
340064c2:	687b      	ldr	r3, [r7, #4]
340064c4:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340064c6:	2b00      	cmp	r3, #0
340064c8:	d00f      	beq.n	340064ea <I2C_ITSlaveCplt+0x12e>
    {
      hi2c->XferCount = (uint16_t)I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx);
340064ca:	687b      	ldr	r3, [r7, #4]
340064cc:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340064ce:	681b      	ldr	r3, [r3, #0]
340064d0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
340064d2:	b29c      	uxth	r4, r3
340064d4:	687b      	ldr	r3, [r7, #4]
340064d6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340064d8:	4618      	mov	r0, r3
340064da:	f7fe fb9d 	bl	34004c18 <HAL_DMAEx_GetFifoLevel>
340064de:	4603      	mov	r3, r0
340064e0:	b29b      	uxth	r3, r3
340064e2:	4423      	add	r3, r4
340064e4:	b29a      	uxth	r2, r3
340064e6:	687b      	ldr	r3, [r7, #4]
340064e8:	855a      	strh	r2, [r3, #42]	@ 0x2a
    /* Do nothing */
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
340064ea:	697b      	ldr	r3, [r7, #20]
340064ec:	089b      	lsrs	r3, r3, #2
340064ee:	f003 0301 	and.w	r3, r3, #1
340064f2:	2b00      	cmp	r3, #0
340064f4:	d020      	beq.n	34006538 <I2C_ITSlaveCplt+0x17c>
  {
    /* Remove RXNE flag on temporary variable as read done */
    tmpITFlags &= ~I2C_FLAG_RXNE;
340064f6:	697b      	ldr	r3, [r7, #20]
340064f8:	f023 0304 	bic.w	r3, r3, #4
340064fc:	617b      	str	r3, [r7, #20]

    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
340064fe:	687b      	ldr	r3, [r7, #4]
34006500:	681b      	ldr	r3, [r3, #0]
34006502:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
34006504:	687b      	ldr	r3, [r7, #4]
34006506:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34006508:	b2d2      	uxtb	r2, r2
3400650a:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
3400650c:	687b      	ldr	r3, [r7, #4]
3400650e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34006510:	1c5a      	adds	r2, r3, #1
34006512:	687b      	ldr	r3, [r7, #4]
34006514:	625a      	str	r2, [r3, #36]	@ 0x24

    if (hi2c->XferSize > 0U)
34006516:	687b      	ldr	r3, [r7, #4]
34006518:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
3400651a:	2b00      	cmp	r3, #0
3400651c:	d00c      	beq.n	34006538 <I2C_ITSlaveCplt+0x17c>
    {
      hi2c->XferSize--;
3400651e:	687b      	ldr	r3, [r7, #4]
34006520:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34006522:	3b01      	subs	r3, #1
34006524:	b29a      	uxth	r2, r3
34006526:	687b      	ldr	r3, [r7, #4]
34006528:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
3400652a:	687b      	ldr	r3, [r7, #4]
3400652c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400652e:	b29b      	uxth	r3, r3
34006530:	3b01      	subs	r3, #1
34006532:	b29a      	uxth	r2, r3
34006534:	687b      	ldr	r3, [r7, #4]
34006536:	855a      	strh	r2, [r3, #42]	@ 0x2a
    }
  }

  /* All data are not transferred, so set error code accordingly */
  if (hi2c->XferCount != 0U)
34006538:	687b      	ldr	r3, [r7, #4]
3400653a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400653c:	b29b      	uxth	r3, r3
3400653e:	2b00      	cmp	r3, #0
34006540:	d005      	beq.n	3400654e <I2C_ITSlaveCplt+0x192>
  {
    /* Set ErrorCode corresponding to a Non-Acknowledge */
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
34006542:	687b      	ldr	r3, [r7, #4]
34006544:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34006546:	f043 0204 	orr.w	r2, r3, #4
3400654a:	687b      	ldr	r3, [r7, #4]
3400654c:	645a      	str	r2, [r3, #68]	@ 0x44
  }

  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
3400654e:	697b      	ldr	r3, [r7, #20]
34006550:	091b      	lsrs	r3, r3, #4
34006552:	f003 0301 	and.w	r3, r3, #1
34006556:	2b00      	cmp	r3, #0
34006558:	d04a      	beq.n	340065f0 <I2C_ITSlaveCplt+0x234>
      (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_IT_NACKI) != RESET))
3400655a:	693b      	ldr	r3, [r7, #16]
3400655c:	091b      	lsrs	r3, r3, #4
3400655e:	f003 0301 	and.w	r3, r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && \
34006562:	2b00      	cmp	r3, #0
34006564:	d044      	beq.n	340065f0 <I2C_ITSlaveCplt+0x234>
  {
    /* Check that I2C transfer finished */
    /* if yes, normal use case, a NACK is sent by the MASTER when Transfer is finished */
    /* Mean XferCount == 0*/
    /* So clear Flag NACKF only */
    if (hi2c->XferCount == 0U)
34006566:	687b      	ldr	r3, [r7, #4]
34006568:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400656a:	b29b      	uxth	r3, r3
3400656c:	2b00      	cmp	r3, #0
3400656e:	d128      	bne.n	340065c2 <I2C_ITSlaveCplt+0x206>
    {
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME))
34006570:	687b      	ldr	r3, [r7, #4]
34006572:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34006576:	b2db      	uxtb	r3, r3
34006578:	2b28      	cmp	r3, #40	@ 0x28
3400657a:	d108      	bne.n	3400658e <I2C_ITSlaveCplt+0x1d2>
3400657c:	68fb      	ldr	r3, [r7, #12]
3400657e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34006582:	d104      	bne.n	3400658e <I2C_ITSlaveCplt+0x1d2>
        /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for
           Warning[Pa134]: left and right operands are identical */
      {
        /* Call I2C Listen complete process */
        I2C_ITListenCplt(hi2c, tmpITFlags);
34006584:	6979      	ldr	r1, [r7, #20]
34006586:	6878      	ldr	r0, [r7, #4]
34006588:	f000 f894 	bl	340066b4 <I2C_ITListenCplt>
3400658c:	e030      	b.n	340065f0 <I2C_ITSlaveCplt+0x234>
      }
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
3400658e:	687b      	ldr	r3, [r7, #4]
34006590:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34006594:	b2db      	uxtb	r3, r3
34006596:	2b29      	cmp	r3, #41	@ 0x29
34006598:	d10e      	bne.n	340065b8 <I2C_ITSlaveCplt+0x1fc>
3400659a:	68fb      	ldr	r3, [r7, #12]
3400659c:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
340065a0:	d00a      	beq.n	340065b8 <I2C_ITSlaveCplt+0x1fc>
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
340065a2:	687b      	ldr	r3, [r7, #4]
340065a4:	681b      	ldr	r3, [r3, #0]
340065a6:	2210      	movs	r2, #16
340065a8:	61da      	str	r2, [r3, #28]

        /* Flush TX register */
        I2C_Flush_TXDR(hi2c);
340065aa:	6878      	ldr	r0, [r7, #4]
340065ac:	f000 f9ef 	bl	3400698e <I2C_Flush_TXDR>

        /* Last Byte is Transmitted */
        /* Call I2C Slave Sequential complete process */
        I2C_ITSlaveSeqCplt(hi2c);
340065b0:	6878      	ldr	r0, [r7, #4]
340065b2:	f7ff fdda 	bl	3400616a <I2C_ITSlaveSeqCplt>
340065b6:	e01b      	b.n	340065f0 <I2C_ITSlaveCplt+0x234>
      }
      else
      {
        /* Clear NACK Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
340065b8:	687b      	ldr	r3, [r7, #4]
340065ba:	681b      	ldr	r3, [r3, #0]
340065bc:	2210      	movs	r2, #16
340065be:	61da      	str	r2, [r3, #28]
340065c0:	e016      	b.n	340065f0 <I2C_ITSlaveCplt+0x234>
    }
    else
    {
      /* if no, error use case, a Non-Acknowledge of last Data is generated by the MASTER*/
      /* Clear NACK Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
340065c2:	687b      	ldr	r3, [r7, #4]
340065c4:	681b      	ldr	r3, [r3, #0]
340065c6:	2210      	movs	r2, #16
340065c8:	61da      	str	r2, [r3, #28]

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
340065ca:	687b      	ldr	r3, [r7, #4]
340065cc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340065ce:	f043 0204 	orr.w	r2, r3, #4
340065d2:	687b      	ldr	r3, [r7, #4]
340065d4:	645a      	str	r2, [r3, #68]	@ 0x44

      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
340065d6:	68fb      	ldr	r3, [r7, #12]
340065d8:	2b00      	cmp	r3, #0
340065da:	d003      	beq.n	340065e4 <I2C_ITSlaveCplt+0x228>
340065dc:	68fb      	ldr	r3, [r7, #12]
340065de:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
340065e2:	d105      	bne.n	340065f0 <I2C_ITSlaveCplt+0x234>
      {
        /* Call the corresponding callback to inform upper layer of End of Transfer */
        I2C_ITError(hi2c, hi2c->ErrorCode);
340065e4:	687b      	ldr	r3, [r7, #4]
340065e6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
340065e8:	4619      	mov	r1, r3
340065ea:	6878      	ldr	r0, [r7, #4]
340065ec:	f000 f8b8 	bl	34006760 <I2C_ITError>
      }
    }
  }

  hi2c->Mode = HAL_I2C_MODE_NONE;
340065f0:	687b      	ldr	r3, [r7, #4]
340065f2:	2200      	movs	r2, #0
340065f4:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
  hi2c->XferISR = NULL;
340065f8:	687b      	ldr	r3, [r7, #4]
340065fa:	2200      	movs	r2, #0
340065fc:	635a      	str	r2, [r3, #52]	@ 0x34

  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
340065fe:	687b      	ldr	r3, [r7, #4]
34006600:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34006602:	2b00      	cmp	r3, #0
34006604:	d010      	beq.n	34006628 <I2C_ITSlaveCplt+0x26c>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c, hi2c->ErrorCode);
34006606:	687b      	ldr	r3, [r7, #4]
34006608:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400660a:	4619      	mov	r1, r3
3400660c:	6878      	ldr	r0, [r7, #4]
3400660e:	f000 f8a7 	bl	34006760 <I2C_ITError>

    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
34006612:	687b      	ldr	r3, [r7, #4]
34006614:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34006618:	b2db      	uxtb	r3, r3
3400661a:	2b28      	cmp	r3, #40	@ 0x28
3400661c:	d141      	bne.n	340066a2 <I2C_ITSlaveCplt+0x2e6>
    {
      /* Call I2C Listen complete process */
      I2C_ITListenCplt(hi2c, tmpITFlags);
3400661e:	6979      	ldr	r1, [r7, #20]
34006620:	6878      	ldr	r0, [r7, #4]
34006622:	f000 f847 	bl	340066b4 <I2C_ITListenCplt>
    hi2c->SlaveTxCpltCallback(hi2c);
#else
    HAL_I2C_SlaveTxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
34006626:	e03c      	b.n	340066a2 <I2C_ITSlaveCplt+0x2e6>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
34006628:	687b      	ldr	r3, [r7, #4]
3400662a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400662c:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
34006630:	d014      	beq.n	3400665c <I2C_ITSlaveCplt+0x2a0>
    I2C_ITSlaveSeqCplt(hi2c);
34006632:	6878      	ldr	r0, [r7, #4]
34006634:	f7ff fd99 	bl	3400616a <I2C_ITSlaveSeqCplt>
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
34006638:	687b      	ldr	r3, [r7, #4]
3400663a:	4a1d      	ldr	r2, [pc, #116]	@ (340066b0 <I2C_ITSlaveCplt+0x2f4>)
3400663c:	62da      	str	r2, [r3, #44]	@ 0x2c
    hi2c->State = HAL_I2C_STATE_READY;
3400663e:	687b      	ldr	r3, [r7, #4]
34006640:	2220      	movs	r2, #32
34006642:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
34006646:	687b      	ldr	r3, [r7, #4]
34006648:	2200      	movs	r2, #0
3400664a:	631a      	str	r2, [r3, #48]	@ 0x30
    __HAL_UNLOCK(hi2c);
3400664c:	687b      	ldr	r3, [r7, #4]
3400664e:	2200      	movs	r2, #0
34006650:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    HAL_I2C_ListenCpltCallback(hi2c);
34006654:	6878      	ldr	r0, [r7, #4]
34006656:	f7fe ff7c 	bl	34005552 <HAL_I2C_ListenCpltCallback>
}
3400665a:	e022      	b.n	340066a2 <I2C_ITSlaveCplt+0x2e6>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
3400665c:	687b      	ldr	r3, [r7, #4]
3400665e:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34006662:	b2db      	uxtb	r3, r3
34006664:	2b22      	cmp	r3, #34	@ 0x22
34006666:	d10e      	bne.n	34006686 <I2C_ITSlaveCplt+0x2ca>
    hi2c->State = HAL_I2C_STATE_READY;
34006668:	687b      	ldr	r3, [r7, #4]
3400666a:	2220      	movs	r2, #32
3400666c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
34006670:	687b      	ldr	r3, [r7, #4]
34006672:	2200      	movs	r2, #0
34006674:	631a      	str	r2, [r3, #48]	@ 0x30
    __HAL_UNLOCK(hi2c);
34006676:	687b      	ldr	r3, [r7, #4]
34006678:	2200      	movs	r2, #0
3400667a:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
3400667e:	6878      	ldr	r0, [r7, #4]
34006680:	f009 f80e 	bl	3400f6a0 <HAL_I2C_SlaveRxCpltCallback>
}
34006684:	e00d      	b.n	340066a2 <I2C_ITSlaveCplt+0x2e6>
    hi2c->State = HAL_I2C_STATE_READY;
34006686:	687b      	ldr	r3, [r7, #4]
34006688:	2220      	movs	r2, #32
3400668a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
3400668e:	687b      	ldr	r3, [r7, #4]
34006690:	2200      	movs	r2, #0
34006692:	631a      	str	r2, [r3, #48]	@ 0x30
    __HAL_UNLOCK(hi2c);
34006694:	687b      	ldr	r3, [r7, #4]
34006696:	2200      	movs	r2, #0
34006698:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    HAL_I2C_SlaveTxCpltCallback(hi2c);
3400669c:	6878      	ldr	r0, [r7, #4]
3400669e:	f009 f80b 	bl	3400f6b8 <HAL_I2C_SlaveTxCpltCallback>
}
340066a2:	bf00      	nop
340066a4:	371c      	adds	r7, #28
340066a6:	46bd      	mov	sp, r7
340066a8:	bd90      	pop	{r4, r7, pc}
340066aa:	bf00      	nop
340066ac:	fe00e800 	.word	0xfe00e800
340066b0:	ffff0000 	.word	0xffff0000

340066b4 <I2C_ITListenCplt>:
  * @param  hi2c I2C handle.
  * @param  ITFlags Interrupt flags to handle.
  * @retval None
  */
static void I2C_ITListenCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
{
340066b4:	b580      	push	{r7, lr}
340066b6:	b082      	sub	sp, #8
340066b8:	af00      	add	r7, sp, #0
340066ba:	6078      	str	r0, [r7, #4]
340066bc:	6039      	str	r1, [r7, #0]
  /* Reset handle parameters */
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
340066be:	687b      	ldr	r3, [r7, #4]
340066c0:	4a26      	ldr	r2, [pc, #152]	@ (3400675c <I2C_ITListenCplt+0xa8>)
340066c2:	62da      	str	r2, [r3, #44]	@ 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
340066c4:	687b      	ldr	r3, [r7, #4]
340066c6:	2200      	movs	r2, #0
340066c8:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->State = HAL_I2C_STATE_READY;
340066ca:	687b      	ldr	r3, [r7, #4]
340066cc:	2220      	movs	r2, #32
340066ce:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
340066d2:	687b      	ldr	r3, [r7, #4]
340066d4:	2200      	movs	r2, #0
340066d6:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
  hi2c->XferISR = NULL;
340066da:	687b      	ldr	r3, [r7, #4]
340066dc:	2200      	movs	r2, #0
340066de:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Store Last receive data if any */
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
340066e0:	683b      	ldr	r3, [r7, #0]
340066e2:	089b      	lsrs	r3, r3, #2
340066e4:	f003 0301 	and.w	r3, r3, #1
340066e8:	2b00      	cmp	r3, #0
340066ea:	d022      	beq.n	34006732 <I2C_ITListenCplt+0x7e>
  {
    /* Read data from RXDR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
340066ec:	687b      	ldr	r3, [r7, #4]
340066ee:	681b      	ldr	r3, [r3, #0]
340066f0:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
340066f2:	687b      	ldr	r3, [r7, #4]
340066f4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340066f6:	b2d2      	uxtb	r2, r2
340066f8:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
340066fa:	687b      	ldr	r3, [r7, #4]
340066fc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340066fe:	1c5a      	adds	r2, r3, #1
34006700:	687b      	ldr	r3, [r7, #4]
34006702:	625a      	str	r2, [r3, #36]	@ 0x24

    if (hi2c->XferSize > 0U)
34006704:	687b      	ldr	r3, [r7, #4]
34006706:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34006708:	2b00      	cmp	r3, #0
3400670a:	d012      	beq.n	34006732 <I2C_ITListenCplt+0x7e>
    {
      hi2c->XferSize--;
3400670c:	687b      	ldr	r3, [r7, #4]
3400670e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
34006710:	3b01      	subs	r3, #1
34006712:	b29a      	uxth	r2, r3
34006714:	687b      	ldr	r3, [r7, #4]
34006716:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
34006718:	687b      	ldr	r3, [r7, #4]
3400671a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
3400671c:	b29b      	uxth	r3, r3
3400671e:	3b01      	subs	r3, #1
34006720:	b29a      	uxth	r2, r3
34006722:	687b      	ldr	r3, [r7, #4]
34006724:	855a      	strh	r2, [r3, #42]	@ 0x2a

      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
34006726:	687b      	ldr	r3, [r7, #4]
34006728:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400672a:	f043 0204 	orr.w	r2, r3, #4
3400672e:	687b      	ldr	r3, [r7, #4]
34006730:	645a      	str	r2, [r3, #68]	@ 0x44
    }
  }

  /* Disable all Interrupts*/
  I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
34006732:	f248 0103 	movw	r1, #32771	@ 0x8003
34006736:	6878      	ldr	r0, [r7, #4]
34006738:	f000 fa22 	bl	34006b80 <I2C_Disable_IRQ>

  /* Clear NACK Flag */
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
3400673c:	687b      	ldr	r3, [r7, #4]
3400673e:	681b      	ldr	r3, [r3, #0]
34006740:	2210      	movs	r2, #16
34006742:	61da      	str	r2, [r3, #28]

  /* Process Unlocked */
  __HAL_UNLOCK(hi2c);
34006744:	687b      	ldr	r3, [r7, #4]
34006746:	2200      	movs	r2, #0
34006748:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
  hi2c->ListenCpltCallback(hi2c);
#else
  HAL_I2C_ListenCpltCallback(hi2c);
3400674c:	6878      	ldr	r0, [r7, #4]
3400674e:	f7fe ff00 	bl	34005552 <HAL_I2C_ListenCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
}
34006752:	bf00      	nop
34006754:	3708      	adds	r7, #8
34006756:	46bd      	mov	sp, r7
34006758:	bd80      	pop	{r7, pc}
3400675a:	bf00      	nop
3400675c:	ffff0000 	.word	0xffff0000

34006760 <I2C_ITError>:
  * @param  hi2c I2C handle.
  * @param  ErrorCode Error code to handle.
  * @retval None
  */
static void I2C_ITError(I2C_HandleTypeDef *hi2c, uint32_t ErrorCode)
{
34006760:	b580      	push	{r7, lr}
34006762:	b084      	sub	sp, #16
34006764:	af00      	add	r7, sp, #0
34006766:	6078      	str	r0, [r7, #4]
34006768:	6039      	str	r1, [r7, #0]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
3400676a:	687b      	ldr	r3, [r7, #4]
3400676c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34006770:	73fb      	strb	r3, [r7, #15]
#if defined(HAL_DMA_MODULE_ENABLED)
  uint32_t tmppreviousstate;
#endif /* HAL_DMA_MODULE_ENABLED */

  /* Reset handle parameters */
  hi2c->Mode          = HAL_I2C_MODE_NONE;
34006772:	687b      	ldr	r3, [r7, #4]
34006774:	2200      	movs	r2, #0
34006776:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
3400677a:	687b      	ldr	r3, [r7, #4]
3400677c:	4a6d      	ldr	r2, [pc, #436]	@ (34006934 <I2C_ITError+0x1d4>)
3400677e:	62da      	str	r2, [r3, #44]	@ 0x2c
  hi2c->XferCount     = 0U;
34006780:	687b      	ldr	r3, [r7, #4]
34006782:	2200      	movs	r2, #0
34006784:	855a      	strh	r2, [r3, #42]	@ 0x2a

  /* Set new error code */
  hi2c->ErrorCode |= ErrorCode;
34006786:	687b      	ldr	r3, [r7, #4]
34006788:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
3400678a:	683b      	ldr	r3, [r7, #0]
3400678c:	431a      	orrs	r2, r3
3400678e:	687b      	ldr	r3, [r7, #4]
34006790:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Disable Interrupts */
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
34006792:	7bfb      	ldrb	r3, [r7, #15]
34006794:	2b28      	cmp	r3, #40	@ 0x28
34006796:	d005      	beq.n	340067a4 <I2C_ITError+0x44>
34006798:	7bfb      	ldrb	r3, [r7, #15]
3400679a:	2b29      	cmp	r3, #41	@ 0x29
3400679c:	d002      	beq.n	340067a4 <I2C_ITError+0x44>
      (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN) ||
3400679e:	7bfb      	ldrb	r3, [r7, #15]
340067a0:	2b2a      	cmp	r3, #42	@ 0x2a
340067a2:	d10b      	bne.n	340067bc <I2C_ITError+0x5c>
      (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
  {
    /* Disable all interrupts, except interrupts related to LISTEN state */
    I2C_Disable_IRQ(hi2c, I2C_XFER_RX_IT | I2C_XFER_TX_IT);
340067a4:	2103      	movs	r1, #3
340067a6:	6878      	ldr	r0, [r7, #4]
340067a8:	f000 f9ea 	bl	34006b80 <I2C_Disable_IRQ>

    /* keep HAL_I2C_STATE_LISTEN if set */
    hi2c->State         = HAL_I2C_STATE_LISTEN;
340067ac:	687b      	ldr	r3, [r7, #4]
340067ae:	2228      	movs	r2, #40	@ 0x28
340067b0:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
340067b4:	687b      	ldr	r3, [r7, #4]
340067b6:	4a60      	ldr	r2, [pc, #384]	@ (34006938 <I2C_ITError+0x1d8>)
340067b8:	635a      	str	r2, [r3, #52]	@ 0x34
340067ba:	e030      	b.n	3400681e <I2C_ITError+0xbe>
  }
  else
  {
    /* Disable all interrupts */
    I2C_Disable_IRQ(hi2c, I2C_XFER_LISTEN_IT | I2C_XFER_RX_IT | I2C_XFER_TX_IT);
340067bc:	f248 0103 	movw	r1, #32771	@ 0x8003
340067c0:	6878      	ldr	r0, [r7, #4]
340067c2:	f000 f9dd 	bl	34006b80 <I2C_Disable_IRQ>

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
340067c6:	6878      	ldr	r0, [r7, #4]
340067c8:	f000 f8e1 	bl	3400698e <I2C_Flush_TXDR>

    /* If state is an abort treatment on going, don't change state */
    /* This change will be do later */
    if (hi2c->State != HAL_I2C_STATE_ABORT)
340067cc:	687b      	ldr	r3, [r7, #4]
340067ce:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
340067d2:	b2db      	uxtb	r3, r3
340067d4:	2b60      	cmp	r3, #96	@ 0x60
340067d6:	d01f      	beq.n	34006818 <I2C_ITError+0xb8>
    {
      /* Set HAL_I2C_STATE_READY */
      hi2c->State         = HAL_I2C_STATE_READY;
340067d8:	687b      	ldr	r3, [r7, #4]
340067da:	2220      	movs	r2, #32
340067dc:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Check if a STOPF is detected */
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
340067e0:	687b      	ldr	r3, [r7, #4]
340067e2:	681b      	ldr	r3, [r3, #0]
340067e4:	699b      	ldr	r3, [r3, #24]
340067e6:	f003 0320 	and.w	r3, r3, #32
340067ea:	2b20      	cmp	r3, #32
340067ec:	d114      	bne.n	34006818 <I2C_ITError+0xb8>
      {
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
340067ee:	687b      	ldr	r3, [r7, #4]
340067f0:	681b      	ldr	r3, [r3, #0]
340067f2:	699b      	ldr	r3, [r3, #24]
340067f4:	f003 0310 	and.w	r3, r3, #16
340067f8:	2b10      	cmp	r3, #16
340067fa:	d109      	bne.n	34006810 <I2C_ITError+0xb0>
        {
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
340067fc:	687b      	ldr	r3, [r7, #4]
340067fe:	681b      	ldr	r3, [r3, #0]
34006800:	2210      	movs	r2, #16
34006802:	61da      	str	r2, [r3, #28]
          hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
34006804:	687b      	ldr	r3, [r7, #4]
34006806:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34006808:	f043 0204 	orr.w	r2, r3, #4
3400680c:	687b      	ldr	r3, [r7, #4]
3400680e:	645a      	str	r2, [r3, #68]	@ 0x44
        }

        /* Clear STOP Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
34006810:	687b      	ldr	r3, [r7, #4]
34006812:	681b      	ldr	r3, [r3, #0]
34006814:	2220      	movs	r2, #32
34006816:	61da      	str	r2, [r3, #28]
      }

    }
    hi2c->XferISR       = NULL;
34006818:	687b      	ldr	r3, [r7, #4]
3400681a:	2200      	movs	r2, #0
3400681c:	635a      	str	r2, [r3, #52]	@ 0x34
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  /* Abort DMA TX transfer if any */
  tmppreviousstate = hi2c->PreviousState;
3400681e:	687b      	ldr	r3, [r7, #4]
34006820:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34006822:	60bb      	str	r3, [r7, #8]

  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || \
34006824:	687b      	ldr	r3, [r7, #4]
34006826:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34006828:	2b00      	cmp	r3, #0
3400682a:	d039      	beq.n	340068a0 <I2C_ITError+0x140>
3400682c:	68bb      	ldr	r3, [r7, #8]
3400682e:	2b11      	cmp	r3, #17
34006830:	d002      	beq.n	34006838 <I2C_ITError+0xd8>
34006832:	68bb      	ldr	r3, [r7, #8]
34006834:	2b21      	cmp	r3, #33	@ 0x21
34006836:	d133      	bne.n	340068a0 <I2C_ITError+0x140>
                                 (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
34006838:	687b      	ldr	r3, [r7, #4]
3400683a:	681b      	ldr	r3, [r3, #0]
3400683c:	681b      	ldr	r3, [r3, #0]
3400683e:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
34006842:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
34006846:	d107      	bne.n	34006858 <I2C_ITError+0xf8>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
34006848:	687b      	ldr	r3, [r7, #4]
3400684a:	681b      	ldr	r3, [r3, #0]
3400684c:	681a      	ldr	r2, [r3, #0]
3400684e:	687b      	ldr	r3, [r7, #4]
34006850:	681b      	ldr	r3, [r3, #0]
34006852:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
34006856:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
34006858:	687b      	ldr	r3, [r7, #4]
3400685a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400685c:	4618      	mov	r0, r3
3400685e:	f7fd ffa8 	bl	340047b2 <HAL_DMA_GetState>
34006862:	4603      	mov	r3, r0
34006864:	2b01      	cmp	r3, #1
34006866:	d017      	beq.n	34006898 <I2C_ITError+0x138>
    {
      /* Set the I2C DMA Abort callback :
       will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
34006868:	687b      	ldr	r3, [r7, #4]
3400686a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400686c:	4a33      	ldr	r2, [pc, #204]	@ (3400693c <I2C_ITError+0x1dc>)
3400686e:	66da      	str	r2, [r3, #108]	@ 0x6c

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
34006870:	687b      	ldr	r3, [r7, #4]
34006872:	2200      	movs	r2, #0
34006874:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

      /* Abort DMA TX */
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
34006878:	687b      	ldr	r3, [r7, #4]
3400687a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400687c:	4618      	mov	r0, r3
3400687e:	f7fd ff6f 	bl	34004760 <HAL_DMA_Abort_IT>
34006882:	4603      	mov	r3, r0
34006884:	2b00      	cmp	r3, #0
34006886:	d04d      	beq.n	34006924 <I2C_ITError+0x1c4>
      {
        /* Call Directly XferAbortCallback function in case of error */
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
34006888:	687b      	ldr	r3, [r7, #4]
3400688a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400688c:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
3400688e:	687a      	ldr	r2, [r7, #4]
34006890:	6b92      	ldr	r2, [r2, #56]	@ 0x38
34006892:	4610      	mov	r0, r2
34006894:	4798      	blx	r3
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
34006896:	e045      	b.n	34006924 <I2C_ITError+0x1c4>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
34006898:	6878      	ldr	r0, [r7, #4]
3400689a:	f000 f851 	bl	34006940 <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
3400689e:	e041      	b.n	34006924 <I2C_ITError+0x1c4>
    }
  }
  /* Abort DMA RX transfer if any */
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || \
340068a0:	687b      	ldr	r3, [r7, #4]
340068a2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340068a4:	2b00      	cmp	r3, #0
340068a6:	d039      	beq.n	3400691c <I2C_ITError+0x1bc>
340068a8:	68bb      	ldr	r3, [r7, #8]
340068aa:	2b12      	cmp	r3, #18
340068ac:	d002      	beq.n	340068b4 <I2C_ITError+0x154>
340068ae:	68bb      	ldr	r3, [r7, #8]
340068b0:	2b22      	cmp	r3, #34	@ 0x22
340068b2:	d133      	bne.n	3400691c <I2C_ITError+0x1bc>
                                      (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
  {
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
340068b4:	687b      	ldr	r3, [r7, #4]
340068b6:	681b      	ldr	r3, [r3, #0]
340068b8:	681b      	ldr	r3, [r3, #0]
340068ba:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
340068be:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
340068c2:	d107      	bne.n	340068d4 <I2C_ITError+0x174>
    {
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
340068c4:	687b      	ldr	r3, [r7, #4]
340068c6:	681b      	ldr	r3, [r3, #0]
340068c8:	681a      	ldr	r2, [r3, #0]
340068ca:	687b      	ldr	r3, [r7, #4]
340068cc:	681b      	ldr	r3, [r3, #0]
340068ce:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
340068d2:	601a      	str	r2, [r3, #0]
    }

    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
340068d4:	687b      	ldr	r3, [r7, #4]
340068d6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340068d8:	4618      	mov	r0, r3
340068da:	f7fd ff6a 	bl	340047b2 <HAL_DMA_GetState>
340068de:	4603      	mov	r3, r0
340068e0:	2b01      	cmp	r3, #1
340068e2:	d017      	beq.n	34006914 <I2C_ITError+0x1b4>
    {
      /* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
340068e4:	687b      	ldr	r3, [r7, #4]
340068e6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340068e8:	4a14      	ldr	r2, [pc, #80]	@ (3400693c <I2C_ITError+0x1dc>)
340068ea:	66da      	str	r2, [r3, #108]	@ 0x6c

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
340068ec:	687b      	ldr	r3, [r7, #4]
340068ee:	2200      	movs	r2, #0
340068f0:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

      /* Abort DMA RX */
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
340068f4:	687b      	ldr	r3, [r7, #4]
340068f6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340068f8:	4618      	mov	r0, r3
340068fa:	f7fd ff31 	bl	34004760 <HAL_DMA_Abort_IT>
340068fe:	4603      	mov	r3, r0
34006900:	2b00      	cmp	r3, #0
34006902:	d011      	beq.n	34006928 <I2C_ITError+0x1c8>
      {
        /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
34006904:	687b      	ldr	r3, [r7, #4]
34006906:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34006908:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
3400690a:	687a      	ldr	r2, [r7, #4]
3400690c:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
3400690e:	4610      	mov	r0, r2
34006910:	4798      	blx	r3
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
34006912:	e009      	b.n	34006928 <I2C_ITError+0x1c8>
      }
    }
    else
    {
      I2C_TreatErrorCallback(hi2c);
34006914:	6878      	ldr	r0, [r7, #4]
34006916:	f000 f813 	bl	34006940 <I2C_TreatErrorCallback>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
3400691a:	e005      	b.n	34006928 <I2C_ITError+0x1c8>
    }
  }
  else
#endif /* HAL_DMA_MODULE_ENABLED */
  {
    I2C_TreatErrorCallback(hi2c);
3400691c:	6878      	ldr	r0, [r7, #4]
3400691e:	f000 f80f 	bl	34006940 <I2C_TreatErrorCallback>
  }
}
34006922:	e002      	b.n	3400692a <I2C_ITError+0x1ca>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
34006924:	bf00      	nop
34006926:	e000      	b.n	3400692a <I2C_ITError+0x1ca>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
34006928:	bf00      	nop
}
3400692a:	bf00      	nop
3400692c:	3710      	adds	r7, #16
3400692e:	46bd      	mov	sp, r7
34006930:	bd80      	pop	{r7, pc}
34006932:	bf00      	nop
34006934:	ffff0000 	.word	0xffff0000
34006938:	340057b7 	.word	0x340057b7
3400693c:	340069d7 	.word	0x340069d7

34006940 <I2C_TreatErrorCallback>:
  * @brief  I2C Error callback treatment.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_TreatErrorCallback(I2C_HandleTypeDef *hi2c)
{
34006940:	b580      	push	{r7, lr}
34006942:	b082      	sub	sp, #8
34006944:	af00      	add	r7, sp, #0
34006946:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_ABORT)
34006948:	687b      	ldr	r3, [r7, #4]
3400694a:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
3400694e:	b2db      	uxtb	r3, r3
34006950:	2b60      	cmp	r3, #96	@ 0x60
34006952:	d10e      	bne.n	34006972 <I2C_TreatErrorCallback+0x32>
  {
    hi2c->State = HAL_I2C_STATE_READY;
34006954:	687b      	ldr	r3, [r7, #4]
34006956:	2220      	movs	r2, #32
34006958:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
3400695c:	687b      	ldr	r3, [r7, #4]
3400695e:	2200      	movs	r2, #0
34006960:	631a      	str	r2, [r3, #48]	@ 0x30

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34006962:	687b      	ldr	r3, [r7, #4]
34006964:	2200      	movs	r2, #0
34006966:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AbortCpltCallback(hi2c);
#else
    HAL_I2C_AbortCpltCallback(hi2c);
3400696a:	6878      	ldr	r0, [r7, #4]
3400696c:	f008 fed5 	bl	3400f71a <HAL_I2C_AbortCpltCallback>
    hi2c->ErrorCallback(hi2c);
#else
    HAL_I2C_ErrorCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
34006970:	e009      	b.n	34006986 <I2C_TreatErrorCallback+0x46>
    hi2c->PreviousState = I2C_STATE_NONE;
34006972:	687b      	ldr	r3, [r7, #4]
34006974:	2200      	movs	r2, #0
34006976:	631a      	str	r2, [r3, #48]	@ 0x30
    __HAL_UNLOCK(hi2c);
34006978:	687b      	ldr	r3, [r7, #4]
3400697a:	2200      	movs	r2, #0
3400697c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    HAL_I2C_ErrorCallback(hi2c);
34006980:	6878      	ldr	r0, [r7, #4]
34006982:	f008 febd 	bl	3400f700 <HAL_I2C_ErrorCallback>
}
34006986:	bf00      	nop
34006988:	3708      	adds	r7, #8
3400698a:	46bd      	mov	sp, r7
3400698c:	bd80      	pop	{r7, pc}

3400698e <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
3400698e:	b480      	push	{r7}
34006990:	b083      	sub	sp, #12
34006992:	af00      	add	r7, sp, #0
34006994:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
34006996:	687b      	ldr	r3, [r7, #4]
34006998:	681b      	ldr	r3, [r3, #0]
3400699a:	699b      	ldr	r3, [r3, #24]
3400699c:	f003 0302 	and.w	r3, r3, #2
340069a0:	2b02      	cmp	r3, #2
340069a2:	d103      	bne.n	340069ac <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
340069a4:	687b      	ldr	r3, [r7, #4]
340069a6:	681b      	ldr	r3, [r3, #0]
340069a8:	2200      	movs	r2, #0
340069aa:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
340069ac:	687b      	ldr	r3, [r7, #4]
340069ae:	681b      	ldr	r3, [r3, #0]
340069b0:	699b      	ldr	r3, [r3, #24]
340069b2:	f003 0301 	and.w	r3, r3, #1
340069b6:	2b01      	cmp	r3, #1
340069b8:	d007      	beq.n	340069ca <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
340069ba:	687b      	ldr	r3, [r7, #4]
340069bc:	681b      	ldr	r3, [r3, #0]
340069be:	699a      	ldr	r2, [r3, #24]
340069c0:	687b      	ldr	r3, [r7, #4]
340069c2:	681b      	ldr	r3, [r3, #0]
340069c4:	f042 0201 	orr.w	r2, r2, #1
340069c8:	619a      	str	r2, [r3, #24]
  }
}
340069ca:	bf00      	nop
340069cc:	370c      	adds	r7, #12
340069ce:	46bd      	mov	sp, r7
340069d0:	f85d 7b04 	ldr.w	r7, [sp], #4
340069d4:	4770      	bx	lr

340069d6 <I2C_DMAAbort>:
  *        (To be called at end of DMA Abort procedure).
  * @param hdma DMA handle.
  * @retval None
  */
static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
{
340069d6:	b580      	push	{r7, lr}
340069d8:	b084      	sub	sp, #16
340069da:	af00      	add	r7, sp, #0
340069dc:	6078      	str	r0, [r7, #4]
  /* Derogation MISRAC2012-Rule-11.5 */
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent);
340069de:	687b      	ldr	r3, [r7, #4]
340069e0:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
340069e2:	60fb      	str	r3, [r7, #12]

  /* Reset AbortCpltCallback */
  if (hi2c->hdmatx != NULL)
340069e4:	68fb      	ldr	r3, [r7, #12]
340069e6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340069e8:	2b00      	cmp	r3, #0
340069ea:	d003      	beq.n	340069f4 <I2C_DMAAbort+0x1e>
  {
    hi2c->hdmatx->XferAbortCallback = NULL;
340069ec:	68fb      	ldr	r3, [r7, #12]
340069ee:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
340069f0:	2200      	movs	r2, #0
340069f2:	66da      	str	r2, [r3, #108]	@ 0x6c
  }
  if (hi2c->hdmarx != NULL)
340069f4:	68fb      	ldr	r3, [r7, #12]
340069f6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
340069f8:	2b00      	cmp	r3, #0
340069fa:	d003      	beq.n	34006a04 <I2C_DMAAbort+0x2e>
  {
    hi2c->hdmarx->XferAbortCallback = NULL;
340069fc:	68fb      	ldr	r3, [r7, #12]
340069fe:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34006a00:	2200      	movs	r2, #0
34006a02:	66da      	str	r2, [r3, #108]	@ 0x6c
  }

  I2C_TreatErrorCallback(hi2c);
34006a04:	68f8      	ldr	r0, [r7, #12]
34006a06:	f7ff ff9b 	bl	34006940 <I2C_TreatErrorCallback>
}
34006a0a:	bf00      	nop
34006a0c:	3710      	adds	r7, #16
34006a0e:	46bd      	mov	sp, r7
34006a10:	bd80      	pop	{r7, pc}
	...

34006a14 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
34006a14:	b480      	push	{r7}
34006a16:	b087      	sub	sp, #28
34006a18:	af00      	add	r7, sp, #0
34006a1a:	60f8      	str	r0, [r7, #12]
34006a1c:	607b      	str	r3, [r7, #4]
34006a1e:	460b      	mov	r3, r1
34006a20:	817b      	strh	r3, [r7, #10]
34006a22:	4613      	mov	r3, r2
34006a24:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
34006a26:	897b      	ldrh	r3, [r7, #10]
34006a28:	f3c3 0209 	ubfx	r2, r3, #0, #10
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
34006a2c:	7a7b      	ldrb	r3, [r7, #9]
34006a2e:	041b      	lsls	r3, r3, #16
34006a30:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
34006a34:	431a      	orrs	r2, r3
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
34006a36:	687b      	ldr	r3, [r7, #4]
34006a38:	431a      	orrs	r2, r3
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
34006a3a:	6a3b      	ldr	r3, [r7, #32]
34006a3c:	4313      	orrs	r3, r2
34006a3e:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
34006a42:	617b      	str	r3, [r7, #20]
                    (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
34006a44:	68fb      	ldr	r3, [r7, #12]
34006a46:	681b      	ldr	r3, [r3, #0]
34006a48:	685a      	ldr	r2, [r3, #4]
34006a4a:	6a3b      	ldr	r3, [r7, #32]
34006a4c:	0d5b      	lsrs	r3, r3, #21
34006a4e:	f403 6180 	and.w	r1, r3, #1024	@ 0x400
34006a52:	4b08      	ldr	r3, [pc, #32]	@ (34006a74 <I2C_TransferConfig+0x60>)
34006a54:	430b      	orrs	r3, r1
34006a56:	43db      	mvns	r3, r3
34006a58:	ea02 0103 	and.w	r1, r2, r3
34006a5c:	68fb      	ldr	r3, [r7, #12]
34006a5e:	681b      	ldr	r3, [r3, #0]
34006a60:	697a      	ldr	r2, [r7, #20]
34006a62:	430a      	orrs	r2, r1
34006a64:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
34006a66:	bf00      	nop
34006a68:	371c      	adds	r7, #28
34006a6a:	46bd      	mov	sp, r7
34006a6c:	f85d 7b04 	ldr.w	r7, [sp], #4
34006a70:	4770      	bx	lr
34006a72:	bf00      	nop
34006a74:	03ff63ff 	.word	0x03ff63ff

34006a78 <I2C_Enable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
34006a78:	b480      	push	{r7}
34006a7a:	b085      	sub	sp, #20
34006a7c:	af00      	add	r7, sp, #0
34006a7e:	6078      	str	r0, [r7, #4]
34006a80:	460b      	mov	r3, r1
34006a82:	807b      	strh	r3, [r7, #2]
  uint32_t tmpisr = 0U;
34006a84:	2300      	movs	r3, #0
34006a86:	60fb      	str	r3, [r7, #12]

#if defined(HAL_DMA_MODULE_ENABLED)
  if ((hi2c->XferISR != I2C_Master_ISR_DMA) && \
34006a88:	687b      	ldr	r3, [r7, #4]
34006a8a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34006a8c:	4a39      	ldr	r2, [pc, #228]	@ (34006b74 <I2C_Enable_IRQ+0xfc>)
34006a8e:	4293      	cmp	r3, r2
34006a90:	d032      	beq.n	34006af8 <I2C_Enable_IRQ+0x80>
      (hi2c->XferISR != I2C_Slave_ISR_DMA) && \
34006a92:	687b      	ldr	r3, [r7, #4]
34006a94:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
  if ((hi2c->XferISR != I2C_Master_ISR_DMA) && \
34006a96:	4a38      	ldr	r2, [pc, #224]	@ (34006b78 <I2C_Enable_IRQ+0x100>)
34006a98:	4293      	cmp	r3, r2
34006a9a:	d02d      	beq.n	34006af8 <I2C_Enable_IRQ+0x80>
      (hi2c->XferISR != I2C_Mem_ISR_DMA))
34006a9c:	687b      	ldr	r3, [r7, #4]
34006a9e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
      (hi2c->XferISR != I2C_Slave_ISR_DMA) && \
34006aa0:	4a36      	ldr	r2, [pc, #216]	@ (34006b7c <I2C_Enable_IRQ+0x104>)
34006aa2:	4293      	cmp	r3, r2
34006aa4:	d028      	beq.n	34006af8 <I2C_Enable_IRQ+0x80>
#endif /* HAL_DMA_MODULE_ENABLED */
  {
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
34006aa6:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
34006aaa:	2b00      	cmp	r3, #0
34006aac:	da03      	bge.n	34006ab6 <I2C_Enable_IRQ+0x3e>
    {
      /* Enable ERR, STOP, NACK and ADDR interrupts */
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
34006aae:	68fb      	ldr	r3, [r7, #12]
34006ab0:	f043 03b8 	orr.w	r3, r3, #184	@ 0xb8
34006ab4:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
34006ab6:	887b      	ldrh	r3, [r7, #2]
34006ab8:	f003 0301 	and.w	r3, r3, #1
34006abc:	2b00      	cmp	r3, #0
34006abe:	d003      	beq.n	34006ac8 <I2C_Enable_IRQ+0x50>
    {
      /* Enable ERR, TC, STOP, NACK and TXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI;
34006ac0:	68fb      	ldr	r3, [r7, #12]
34006ac2:	f043 03f2 	orr.w	r3, r3, #242	@ 0xf2
34006ac6:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
34006ac8:	887b      	ldrh	r3, [r7, #2]
34006aca:	f003 0302 	and.w	r3, r3, #2
34006ace:	2b00      	cmp	r3, #0
34006ad0:	d003      	beq.n	34006ada <I2C_Enable_IRQ+0x62>
    {
      /* Enable ERR, TC, STOP, NACK and RXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI;
34006ad2:	68fb      	ldr	r3, [r7, #12]
34006ad4:	f043 03f4 	orr.w	r3, r3, #244	@ 0xf4
34006ad8:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_ERROR_IT)
34006ada:	887b      	ldrh	r3, [r7, #2]
34006adc:	2b10      	cmp	r3, #16
34006ade:	d103      	bne.n	34006ae8 <I2C_Enable_IRQ+0x70>
    {
      /* Enable ERR and NACK interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
34006ae0:	68fb      	ldr	r3, [r7, #12]
34006ae2:	f043 0390 	orr.w	r3, r3, #144	@ 0x90
34006ae6:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_CPLT_IT)
34006ae8:	887b      	ldrh	r3, [r7, #2]
34006aea:	2b20      	cmp	r3, #32
34006aec:	d133      	bne.n	34006b56 <I2C_Enable_IRQ+0xde>
    {
      /* Enable STOP interrupts */
      tmpisr |= I2C_IT_STOPI;
34006aee:	68fb      	ldr	r3, [r7, #12]
34006af0:	f043 0320 	orr.w	r3, r3, #32
34006af4:	60fb      	str	r3, [r7, #12]
    if (InterruptRequest == I2C_XFER_CPLT_IT)
34006af6:	e02e      	b.n	34006b56 <I2C_Enable_IRQ+0xde>
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  else
  {
    if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
34006af8:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
34006afc:	2b00      	cmp	r3, #0
34006afe:	da03      	bge.n	34006b08 <I2C_Enable_IRQ+0x90>
    {
      /* Enable ERR, STOP, NACK and ADDR interrupts */
      tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
34006b00:	68fb      	ldr	r3, [r7, #12]
34006b02:	f043 03b8 	orr.w	r3, r3, #184	@ 0xb8
34006b06:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
34006b08:	887b      	ldrh	r3, [r7, #2]
34006b0a:	f003 0301 	and.w	r3, r3, #1
34006b0e:	2b00      	cmp	r3, #0
34006b10:	d003      	beq.n	34006b1a <I2C_Enable_IRQ+0xa2>
    {
      /* Enable ERR, TC, STOP, NACK and TXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_TXI;
34006b12:	68fb      	ldr	r3, [r7, #12]
34006b14:	f043 03f2 	orr.w	r3, r3, #242	@ 0xf2
34006b18:	60fb      	str	r3, [r7, #12]
    }

    if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
34006b1a:	887b      	ldrh	r3, [r7, #2]
34006b1c:	f003 0302 	and.w	r3, r3, #2
34006b20:	2b00      	cmp	r3, #0
34006b22:	d003      	beq.n	34006b2c <I2C_Enable_IRQ+0xb4>
    {
      /* Enable ERR, TC, STOP, NACK and RXI interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_TCI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_RXI;
34006b24:	68fb      	ldr	r3, [r7, #12]
34006b26:	f043 03f4 	orr.w	r3, r3, #244	@ 0xf4
34006b2a:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_ERROR_IT)
34006b2c:	887b      	ldrh	r3, [r7, #2]
34006b2e:	2b10      	cmp	r3, #16
34006b30:	d103      	bne.n	34006b3a <I2C_Enable_IRQ+0xc2>
    {
      /* Enable ERR and NACK interrupts */
      tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
34006b32:	68fb      	ldr	r3, [r7, #12]
34006b34:	f043 0390 	orr.w	r3, r3, #144	@ 0x90
34006b38:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_CPLT_IT)
34006b3a:	887b      	ldrh	r3, [r7, #2]
34006b3c:	2b20      	cmp	r3, #32
34006b3e:	d103      	bne.n	34006b48 <I2C_Enable_IRQ+0xd0>
    {
      /* Enable STOP interrupts */
      tmpisr |= (I2C_IT_STOPI | I2C_IT_TCI);
34006b40:	68fb      	ldr	r3, [r7, #12]
34006b42:	f043 0360 	orr.w	r3, r3, #96	@ 0x60
34006b46:	60fb      	str	r3, [r7, #12]
    }

    if (InterruptRequest == I2C_XFER_RELOAD_IT)
34006b48:	887b      	ldrh	r3, [r7, #2]
34006b4a:	2b40      	cmp	r3, #64	@ 0x40
34006b4c:	d103      	bne.n	34006b56 <I2C_Enable_IRQ+0xde>
    {
      /* Enable TC interrupts */
      tmpisr |= I2C_IT_TCI;
34006b4e:	68fb      	ldr	r3, [r7, #12]
34006b50:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
34006b54:	60fb      	str	r3, [r7, #12]
#endif /* HAL_DMA_MODULE_ENABLED */

  /* Enable interrupts only at the end */
  /* to avoid the risk of I2C interrupt handle execution before */
  /* all interrupts requested done */
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
34006b56:	687b      	ldr	r3, [r7, #4]
34006b58:	681b      	ldr	r3, [r3, #0]
34006b5a:	6819      	ldr	r1, [r3, #0]
34006b5c:	687b      	ldr	r3, [r7, #4]
34006b5e:	681b      	ldr	r3, [r3, #0]
34006b60:	68fa      	ldr	r2, [r7, #12]
34006b62:	430a      	orrs	r2, r1
34006b64:	601a      	str	r2, [r3, #0]
}
34006b66:	bf00      	nop
34006b68:	3714      	adds	r7, #20
34006b6a:	46bd      	mov	sp, r7
34006b6c:	f85d 7b04 	ldr.w	r7, [sp], #4
34006b70:	4770      	bx	lr
34006b72:	bf00      	nop
34006b74:	340059bf 	.word	0x340059bf
34006b78:	34005e05 	.word	0x34005e05
34006b7c:	34005ba5 	.word	0x34005ba5

34006b80 <I2C_Disable_IRQ>:
  *                the configuration information for the specified I2C.
  * @param  InterruptRequest Value of @ref I2C_Interrupt_configuration_definition.
  * @retval None
  */
static void I2C_Disable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
34006b80:	b480      	push	{r7}
34006b82:	b085      	sub	sp, #20
34006b84:	af00      	add	r7, sp, #0
34006b86:	6078      	str	r0, [r7, #4]
34006b88:	460b      	mov	r3, r1
34006b8a:	807b      	strh	r3, [r7, #2]
  uint32_t tmpisr = 0U;
34006b8c:	2300      	movs	r3, #0
34006b8e:	60fb      	str	r3, [r7, #12]

  if ((InterruptRequest & I2C_XFER_TX_IT) == I2C_XFER_TX_IT)
34006b90:	887b      	ldrh	r3, [r7, #2]
34006b92:	f003 0301 	and.w	r3, r3, #1
34006b96:	2b00      	cmp	r3, #0
34006b98:	d00f      	beq.n	34006bba <I2C_Disable_IRQ+0x3a>
  {
    /* Disable TC and TXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_TXI;
34006b9a:	68fb      	ldr	r3, [r7, #12]
34006b9c:	f043 0342 	orr.w	r3, r3, #66	@ 0x42
34006ba0:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
34006ba2:	687b      	ldr	r3, [r7, #4]
34006ba4:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34006ba8:	b2db      	uxtb	r3, r3
34006baa:	f003 0328 	and.w	r3, r3, #40	@ 0x28
34006bae:	2b28      	cmp	r3, #40	@ 0x28
34006bb0:	d003      	beq.n	34006bba <I2C_Disable_IRQ+0x3a>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
34006bb2:	68fb      	ldr	r3, [r7, #12]
34006bb4:	f043 03b0 	orr.w	r3, r3, #176	@ 0xb0
34006bb8:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_RX_IT) == I2C_XFER_RX_IT)
34006bba:	887b      	ldrh	r3, [r7, #2]
34006bbc:	f003 0302 	and.w	r3, r3, #2
34006bc0:	2b00      	cmp	r3, #0
34006bc2:	d00f      	beq.n	34006be4 <I2C_Disable_IRQ+0x64>
  {
    /* Disable TC and RXI interrupts */
    tmpisr |= I2C_IT_TCI | I2C_IT_RXI;
34006bc4:	68fb      	ldr	r3, [r7, #12]
34006bc6:	f043 0344 	orr.w	r3, r3, #68	@ 0x44
34006bca:	60fb      	str	r3, [r7, #12]

    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
34006bcc:	687b      	ldr	r3, [r7, #4]
34006bce:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34006bd2:	b2db      	uxtb	r3, r3
34006bd4:	f003 0328 	and.w	r3, r3, #40	@ 0x28
34006bd8:	2b28      	cmp	r3, #40	@ 0x28
34006bda:	d003      	beq.n	34006be4 <I2C_Disable_IRQ+0x64>
    {
      /* Disable NACK and STOP interrupts */
      tmpisr |= I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
34006bdc:	68fb      	ldr	r3, [r7, #12]
34006bde:	f043 03b0 	orr.w	r3, r3, #176	@ 0xb0
34006be2:	60fb      	str	r3, [r7, #12]
    }
  }

  if ((InterruptRequest & I2C_XFER_LISTEN_IT) == I2C_XFER_LISTEN_IT)
34006be4:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
34006be8:	2b00      	cmp	r3, #0
34006bea:	da03      	bge.n	34006bf4 <I2C_Disable_IRQ+0x74>
  {
    /* Disable ADDR, NACK and STOP interrupts */
    tmpisr |= I2C_IT_ADDRI | I2C_IT_STOPI | I2C_IT_NACKI | I2C_IT_ERRI;
34006bec:	68fb      	ldr	r3, [r7, #12]
34006bee:	f043 03b8 	orr.w	r3, r3, #184	@ 0xb8
34006bf2:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_ERROR_IT)
34006bf4:	887b      	ldrh	r3, [r7, #2]
34006bf6:	2b10      	cmp	r3, #16
34006bf8:	d103      	bne.n	34006c02 <I2C_Disable_IRQ+0x82>
  {
    /* Enable ERR and NACK interrupts */
    tmpisr |= I2C_IT_ERRI | I2C_IT_NACKI;
34006bfa:	68fb      	ldr	r3, [r7, #12]
34006bfc:	f043 0390 	orr.w	r3, r3, #144	@ 0x90
34006c00:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_CPLT_IT)
34006c02:	887b      	ldrh	r3, [r7, #2]
34006c04:	2b20      	cmp	r3, #32
34006c06:	d103      	bne.n	34006c10 <I2C_Disable_IRQ+0x90>
  {
    /* Enable STOP interrupts */
    tmpisr |= I2C_IT_STOPI;
34006c08:	68fb      	ldr	r3, [r7, #12]
34006c0a:	f043 0320 	orr.w	r3, r3, #32
34006c0e:	60fb      	str	r3, [r7, #12]
  }

  if (InterruptRequest == I2C_XFER_RELOAD_IT)
34006c10:	887b      	ldrh	r3, [r7, #2]
34006c12:	2b40      	cmp	r3, #64	@ 0x40
34006c14:	d103      	bne.n	34006c1e <I2C_Disable_IRQ+0x9e>
  {
    /* Enable TC interrupts */
    tmpisr |= I2C_IT_TCI;
34006c16:	68fb      	ldr	r3, [r7, #12]
34006c18:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
34006c1c:	60fb      	str	r3, [r7, #12]
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
34006c1e:	687b      	ldr	r3, [r7, #4]
34006c20:	681b      	ldr	r3, [r3, #0]
34006c22:	6819      	ldr	r1, [r3, #0]
34006c24:	68fb      	ldr	r3, [r7, #12]
34006c26:	43da      	mvns	r2, r3
34006c28:	687b      	ldr	r3, [r7, #4]
34006c2a:	681b      	ldr	r3, [r3, #0]
34006c2c:	400a      	ands	r2, r1
34006c2e:	601a      	str	r2, [r3, #0]
}
34006c30:	bf00      	nop
34006c32:	3714      	adds	r7, #20
34006c34:	46bd      	mov	sp, r7
34006c36:	f85d 7b04 	ldr.w	r7, [sp], #4
34006c3a:	4770      	bx	lr

34006c3c <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
34006c3c:	b480      	push	{r7}
34006c3e:	b083      	sub	sp, #12
34006c40:	af00      	add	r7, sp, #0
34006c42:	6078      	str	r0, [r7, #4]
34006c44:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
34006c46:	687b      	ldr	r3, [r7, #4]
34006c48:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34006c4c:	b2db      	uxtb	r3, r3
34006c4e:	2b20      	cmp	r3, #32
34006c50:	d138      	bne.n	34006cc4 <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
34006c52:	687b      	ldr	r3, [r7, #4]
34006c54:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
34006c58:	2b01      	cmp	r3, #1
34006c5a:	d101      	bne.n	34006c60 <HAL_I2CEx_ConfigAnalogFilter+0x24>
34006c5c:	2302      	movs	r3, #2
34006c5e:	e032      	b.n	34006cc6 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
34006c60:	687b      	ldr	r3, [r7, #4]
34006c62:	2201      	movs	r2, #1
34006c64:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
34006c68:	687b      	ldr	r3, [r7, #4]
34006c6a:	2224      	movs	r2, #36	@ 0x24
34006c6c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
34006c70:	687b      	ldr	r3, [r7, #4]
34006c72:	681b      	ldr	r3, [r3, #0]
34006c74:	681a      	ldr	r2, [r3, #0]
34006c76:	687b      	ldr	r3, [r7, #4]
34006c78:	681b      	ldr	r3, [r3, #0]
34006c7a:	f022 0201 	bic.w	r2, r2, #1
34006c7e:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
34006c80:	687b      	ldr	r3, [r7, #4]
34006c82:	681b      	ldr	r3, [r3, #0]
34006c84:	681a      	ldr	r2, [r3, #0]
34006c86:	687b      	ldr	r3, [r7, #4]
34006c88:	681b      	ldr	r3, [r3, #0]
34006c8a:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
34006c8e:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
34006c90:	687b      	ldr	r3, [r7, #4]
34006c92:	681b      	ldr	r3, [r3, #0]
34006c94:	6819      	ldr	r1, [r3, #0]
34006c96:	687b      	ldr	r3, [r7, #4]
34006c98:	681b      	ldr	r3, [r3, #0]
34006c9a:	683a      	ldr	r2, [r7, #0]
34006c9c:	430a      	orrs	r2, r1
34006c9e:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
34006ca0:	687b      	ldr	r3, [r7, #4]
34006ca2:	681b      	ldr	r3, [r3, #0]
34006ca4:	681a      	ldr	r2, [r3, #0]
34006ca6:	687b      	ldr	r3, [r7, #4]
34006ca8:	681b      	ldr	r3, [r3, #0]
34006caa:	f042 0201 	orr.w	r2, r2, #1
34006cae:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
34006cb0:	687b      	ldr	r3, [r7, #4]
34006cb2:	2220      	movs	r2, #32
34006cb4:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34006cb8:	687b      	ldr	r3, [r7, #4]
34006cba:	2200      	movs	r2, #0
34006cbc:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
34006cc0:	2300      	movs	r3, #0
34006cc2:	e000      	b.n	34006cc6 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
34006cc4:	2302      	movs	r3, #2
  }
}
34006cc6:	4618      	mov	r0, r3
34006cc8:	370c      	adds	r7, #12
34006cca:	46bd      	mov	sp, r7
34006ccc:	f85d 7b04 	ldr.w	r7, [sp], #4
34006cd0:	4770      	bx	lr

34006cd2 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
34006cd2:	b480      	push	{r7}
34006cd4:	b085      	sub	sp, #20
34006cd6:	af00      	add	r7, sp, #0
34006cd8:	6078      	str	r0, [r7, #4]
34006cda:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
34006cdc:	687b      	ldr	r3, [r7, #4]
34006cde:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
34006ce2:	b2db      	uxtb	r3, r3
34006ce4:	2b20      	cmp	r3, #32
34006ce6:	d139      	bne.n	34006d5c <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
34006ce8:	687b      	ldr	r3, [r7, #4]
34006cea:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
34006cee:	2b01      	cmp	r3, #1
34006cf0:	d101      	bne.n	34006cf6 <HAL_I2CEx_ConfigDigitalFilter+0x24>
34006cf2:	2302      	movs	r3, #2
34006cf4:	e033      	b.n	34006d5e <HAL_I2CEx_ConfigDigitalFilter+0x8c>
34006cf6:	687b      	ldr	r3, [r7, #4]
34006cf8:	2201      	movs	r2, #1
34006cfa:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
34006cfe:	687b      	ldr	r3, [r7, #4]
34006d00:	2224      	movs	r2, #36	@ 0x24
34006d02:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
34006d06:	687b      	ldr	r3, [r7, #4]
34006d08:	681b      	ldr	r3, [r3, #0]
34006d0a:	681a      	ldr	r2, [r3, #0]
34006d0c:	687b      	ldr	r3, [r7, #4]
34006d0e:	681b      	ldr	r3, [r3, #0]
34006d10:	f022 0201 	bic.w	r2, r2, #1
34006d14:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
34006d16:	687b      	ldr	r3, [r7, #4]
34006d18:	681b      	ldr	r3, [r3, #0]
34006d1a:	681b      	ldr	r3, [r3, #0]
34006d1c:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
34006d1e:	68fb      	ldr	r3, [r7, #12]
34006d20:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
34006d24:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
34006d26:	683b      	ldr	r3, [r7, #0]
34006d28:	021b      	lsls	r3, r3, #8
34006d2a:	68fa      	ldr	r2, [r7, #12]
34006d2c:	4313      	orrs	r3, r2
34006d2e:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
34006d30:	687b      	ldr	r3, [r7, #4]
34006d32:	681b      	ldr	r3, [r3, #0]
34006d34:	68fa      	ldr	r2, [r7, #12]
34006d36:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
34006d38:	687b      	ldr	r3, [r7, #4]
34006d3a:	681b      	ldr	r3, [r3, #0]
34006d3c:	681a      	ldr	r2, [r3, #0]
34006d3e:	687b      	ldr	r3, [r7, #4]
34006d40:	681b      	ldr	r3, [r3, #0]
34006d42:	f042 0201 	orr.w	r2, r2, #1
34006d46:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
34006d48:	687b      	ldr	r3, [r7, #4]
34006d4a:	2220      	movs	r2, #32
34006d4c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
34006d50:	687b      	ldr	r3, [r7, #4]
34006d52:	2200      	movs	r2, #0
34006d54:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
34006d58:	2300      	movs	r3, #0
34006d5a:	e000      	b.n	34006d5e <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
34006d5c:	2302      	movs	r3, #2
  }
}
34006d5e:	4618      	mov	r0, r3
34006d60:	3714      	adds	r7, #20
34006d62:	46bd      	mov	sp, r7
34006d64:	f85d 7b04 	ldr.w	r7, [sp], #4
34006d68:	4770      	bx	lr

34006d6a <HAL_LTDC_Init>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_Init(LTDC_HandleTypeDef *hltdc)
{
34006d6a:	b580      	push	{r7, lr}
34006d6c:	b084      	sub	sp, #16
34006d6e:	af00      	add	r7, sp, #0
34006d70:	6078      	str	r0, [r7, #4]
  uint32_t tmp;
  uint32_t tmp1;

  /* Check the LTDC peripheral state */
  if (hltdc == NULL)
34006d72:	687b      	ldr	r3, [r7, #4]
34006d74:	2b00      	cmp	r3, #0
34006d76:	d101      	bne.n	34006d7c <HAL_LTDC_Init+0x12>
  {
    return HAL_ERROR;
34006d78:	2301      	movs	r3, #1
34006d7a:	e09d      	b.n	34006eb8 <HAL_LTDC_Init+0x14e>
    }
    /* Init the low level hardware */
    hltdc->MspInitCallback(hltdc);
  }
#else
  if (hltdc->State == HAL_LTDC_STATE_RESET)
34006d7c:	687b      	ldr	r3, [r7, #4]
34006d7e:	f893 30a1 	ldrb.w	r3, [r3, #161]	@ 0xa1
34006d82:	b2db      	uxtb	r3, r3
34006d84:	2b00      	cmp	r3, #0
34006d86:	d106      	bne.n	34006d96 <HAL_LTDC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hltdc->Lock = HAL_UNLOCKED;
34006d88:	687b      	ldr	r3, [r7, #4]
34006d8a:	2200      	movs	r2, #0
34006d8c:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0
    /* Init the low level hardware */
    HAL_LTDC_MspInit(hltdc);
34006d90:	6878      	ldr	r0, [r7, #4]
34006d92:	f000 f895 	bl	34006ec0 <HAL_LTDC_MspInit>
  }
#endif /* USE_HAL_LTDC_REGISTER_CALLBACKS */

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
34006d96:	687b      	ldr	r3, [r7, #4]
34006d98:	2202      	movs	r2, #2
34006d9a:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Configure the HS, VS, DE and PC polarity */
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
34006d9e:	687b      	ldr	r3, [r7, #4]
34006da0:	681b      	ldr	r3, [r3, #0]
34006da2:	699a      	ldr	r2, [r3, #24]
34006da4:	687b      	ldr	r3, [r7, #4]
34006da6:	681b      	ldr	r3, [r3, #0]
34006da8:	f022 4270 	bic.w	r2, r2, #4026531840	@ 0xf0000000
34006dac:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34006dae:	687b      	ldr	r3, [r7, #4]
34006db0:	681b      	ldr	r3, [r3, #0]
34006db2:	6999      	ldr	r1, [r3, #24]
34006db4:	687b      	ldr	r3, [r7, #4]
34006db6:	685a      	ldr	r2, [r3, #4]
34006db8:	687b      	ldr	r3, [r7, #4]
34006dba:	689b      	ldr	r3, [r3, #8]
34006dbc:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
34006dbe:	687b      	ldr	r3, [r7, #4]
34006dc0:	68db      	ldr	r3, [r3, #12]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34006dc2:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
34006dc4:	687b      	ldr	r3, [r7, #4]
34006dc6:	691b      	ldr	r3, [r3, #16]
34006dc8:	431a      	orrs	r2, r3
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
34006dca:	687b      	ldr	r3, [r7, #4]
34006dcc:	681b      	ldr	r3, [r3, #0]
34006dce:	430a      	orrs	r2, r1
34006dd0:	619a      	str	r2, [r3, #24]

  /* Set Synchronization size */
  tmp = (hltdc->Init.HorizontalSync << 16U);
34006dd2:	687b      	ldr	r3, [r7, #4]
34006dd4:	695b      	ldr	r3, [r3, #20]
34006dd6:	041b      	lsls	r3, r3, #16
34006dd8:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->SSCR, (tmp | hltdc->Init.VerticalSync));
34006dda:	687b      	ldr	r3, [r7, #4]
34006ddc:	6999      	ldr	r1, [r3, #24]
34006dde:	687b      	ldr	r3, [r7, #4]
34006de0:	681b      	ldr	r3, [r3, #0]
34006de2:	68fa      	ldr	r2, [r7, #12]
34006de4:	430a      	orrs	r2, r1
34006de6:	609a      	str	r2, [r3, #8]

  /* Set Accumulated Back porch */
  tmp = (hltdc->Init.AccumulatedHBP << 16U);
34006de8:	687b      	ldr	r3, [r7, #4]
34006dea:	69db      	ldr	r3, [r3, #28]
34006dec:	041b      	lsls	r3, r3, #16
34006dee:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->BPCR, (tmp | hltdc->Init.AccumulatedVBP));
34006df0:	687b      	ldr	r3, [r7, #4]
34006df2:	6a19      	ldr	r1, [r3, #32]
34006df4:	687b      	ldr	r3, [r7, #4]
34006df6:	681b      	ldr	r3, [r3, #0]
34006df8:	68fa      	ldr	r2, [r7, #12]
34006dfa:	430a      	orrs	r2, r1
34006dfc:	60da      	str	r2, [r3, #12]

  /* Set Accumulated Active Width */
  tmp = (hltdc->Init.AccumulatedActiveW << 16U);
34006dfe:	687b      	ldr	r3, [r7, #4]
34006e00:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34006e02:	041b      	lsls	r3, r3, #16
34006e04:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->AWCR, (tmp | hltdc->Init.AccumulatedActiveH));
34006e06:	687b      	ldr	r3, [r7, #4]
34006e08:	6a99      	ldr	r1, [r3, #40]	@ 0x28
34006e0a:	687b      	ldr	r3, [r7, #4]
34006e0c:	681b      	ldr	r3, [r3, #0]
34006e0e:	68fa      	ldr	r2, [r7, #12]
34006e10:	430a      	orrs	r2, r1
34006e12:	611a      	str	r2, [r3, #16]

  /* Set Total Width */
  tmp = (hltdc->Init.TotalWidth << 16U);
34006e14:	687b      	ldr	r3, [r7, #4]
34006e16:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34006e18:	041b      	lsls	r3, r3, #16
34006e1a:	60fb      	str	r3, [r7, #12]
  WRITE_REG(hltdc->Instance->TWCR, (tmp | hltdc->Init.TotalHeigh));
34006e1c:	687b      	ldr	r3, [r7, #4]
34006e1e:	6b19      	ldr	r1, [r3, #48]	@ 0x30
34006e20:	687b      	ldr	r3, [r7, #4]
34006e22:	681b      	ldr	r3, [r3, #0]
34006e24:	68fa      	ldr	r2, [r7, #12]
34006e26:	430a      	orrs	r2, r1
34006e28:	615a      	str	r2, [r3, #20]

  /* Set the background color value */
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
34006e2a:	687b      	ldr	r3, [r7, #4]
34006e2c:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
34006e30:	021b      	lsls	r3, r3, #8
34006e32:	60fb      	str	r3, [r7, #12]
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
34006e34:	687b      	ldr	r3, [r7, #4]
34006e36:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
34006e3a:	041b      	lsls	r3, r3, #16
34006e3c:	60bb      	str	r3, [r7, #8]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
34006e3e:	687b      	ldr	r3, [r7, #4]
34006e40:	681b      	ldr	r3, [r3, #0]
34006e42:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
34006e44:	687b      	ldr	r3, [r7, #4]
34006e46:	681b      	ldr	r3, [r3, #0]
34006e48:	f002 427f 	and.w	r2, r2, #4278190080	@ 0xff000000
34006e4c:	62da      	str	r2, [r3, #44]	@ 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
34006e4e:	687b      	ldr	r3, [r7, #4]
34006e50:	681b      	ldr	r3, [r3, #0]
34006e52:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
34006e54:	68ba      	ldr	r2, [r7, #8]
34006e56:	68fb      	ldr	r3, [r7, #12]
34006e58:	4313      	orrs	r3, r2
34006e5a:	687a      	ldr	r2, [r7, #4]
34006e5c:	f892 2034 	ldrb.w	r2, [r2, #52]	@ 0x34
34006e60:	431a      	orrs	r2, r3
34006e62:	687b      	ldr	r3, [r7, #4]
34006e64:	681b      	ldr	r3, [r3, #0]
34006e66:	430a      	orrs	r2, r1
34006e68:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Activate Global Reload for Layer 1 and Layer 2 */
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_1)->RCR, LTDC_LxRCR_GRMSK);
34006e6a:	687b      	ldr	r3, [r7, #4]
34006e6c:	681b      	ldr	r3, [r3, #0]
34006e6e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34006e72:	461a      	mov	r2, r3
34006e74:	2304      	movs	r3, #4
34006e76:	6093      	str	r3, [r2, #8]
  WRITE_REG(LTDC_LAYER(hltdc, LTDC_LAYER_2)->RCR, LTDC_LxRCR_GRMSK);
34006e78:	687b      	ldr	r3, [r7, #4]
34006e7a:	681b      	ldr	r3, [r3, #0]
34006e7c:	f503 7300 	add.w	r3, r3, #512	@ 0x200
34006e80:	461a      	mov	r2, r3
34006e82:	2304      	movs	r3, #4
34006e84:	6093      	str	r3, [r2, #8]

  /* Enable the Transfer Error and FIFO underrun interrupts */
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
34006e86:	687b      	ldr	r3, [r7, #4]
34006e88:	681b      	ldr	r3, [r3, #0]
34006e8a:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
34006e8c:	687b      	ldr	r3, [r7, #4]
34006e8e:	681b      	ldr	r3, [r3, #0]
34006e90:	f042 0244 	orr.w	r2, r2, #68	@ 0x44
34006e94:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Enable LTDC by setting LTDCEN bit */
  __HAL_LTDC_ENABLE(hltdc);
34006e96:	687b      	ldr	r3, [r7, #4]
34006e98:	681b      	ldr	r3, [r3, #0]
34006e9a:	699a      	ldr	r2, [r3, #24]
34006e9c:	687b      	ldr	r3, [r7, #4]
34006e9e:	681b      	ldr	r3, [r3, #0]
34006ea0:	f042 0201 	orr.w	r2, r2, #1
34006ea4:	619a      	str	r2, [r3, #24]

  /* Initialize the error code */
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
34006ea6:	687b      	ldr	r3, [r7, #4]
34006ea8:	2200      	movs	r2, #0
34006eaa:	f8c3 20a4 	str.w	r2, [r3, #164]	@ 0xa4

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
34006eae:	687b      	ldr	r3, [r7, #4]
34006eb0:	2201      	movs	r2, #1
34006eb2:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  return HAL_OK;
34006eb6:	2300      	movs	r3, #0
}
34006eb8:	4618      	mov	r0, r3
34006eba:	3710      	adds	r7, #16
34006ebc:	46bd      	mov	sp, r7
34006ebe:	bd80      	pop	{r7, pc}

34006ec0 <HAL_LTDC_MspInit>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  */
__weak void HAL_LTDC_MspInit(LTDC_HandleTypeDef *hltdc)
{
34006ec0:	b480      	push	{r7}
34006ec2:	b083      	sub	sp, #12
34006ec4:	af00      	add	r7, sp, #0
34006ec6:	6078      	str	r0, [r7, #4]
  UNUSED(hltdc);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LTDC_MspInit could be implemented in the user file
   */
}
34006ec8:	bf00      	nop
34006eca:	370c      	adds	r7, #12
34006ecc:	46bd      	mov	sp, r7
34006ece:	f85d 7b04 	ldr.w	r7, [sp], #4
34006ed2:	4770      	bx	lr

34006ed4 <HAL_LTDC_ConfigLayer>:
  *                    This parameter can be one of the following values:
  *                    LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{
34006ed4:	b5b0      	push	{r4, r5, r7, lr}
34006ed6:	b086      	sub	sp, #24
34006ed8:	af02      	add	r7, sp, #8
34006eda:	60f8      	str	r0, [r7, #12]
34006edc:	60b9      	str	r1, [r7, #8]
34006ede:	607a      	str	r2, [r7, #4]
  assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
  assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
  assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));

  /* Process locked */
  __HAL_LOCK(hltdc);
34006ee0:	68fb      	ldr	r3, [r7, #12]
34006ee2:	f893 30a0 	ldrb.w	r3, [r3, #160]	@ 0xa0
34006ee6:	2b01      	cmp	r3, #1
34006ee8:	d101      	bne.n	34006eee <HAL_LTDC_ConfigLayer+0x1a>
34006eea:	2302      	movs	r3, #2
34006eec:	e052      	b.n	34006f94 <HAL_LTDC_ConfigLayer+0xc0>
34006eee:	68fb      	ldr	r3, [r7, #12]
34006ef0:	2201      	movs	r2, #1
34006ef2:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
34006ef6:	68fb      	ldr	r3, [r7, #12]
34006ef8:	2202      	movs	r2, #2
34006efa:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Copy new layer configuration into handle structure */
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
34006efe:	68fa      	ldr	r2, [r7, #12]
34006f00:	687b      	ldr	r3, [r7, #4]
34006f02:	2134      	movs	r1, #52	@ 0x34
34006f04:	fb01 f303 	mul.w	r3, r1, r3
34006f08:	4413      	add	r3, r2
34006f0a:	f103 0238 	add.w	r2, r3, #56	@ 0x38
34006f0e:	68bb      	ldr	r3, [r7, #8]
34006f10:	4614      	mov	r4, r2
34006f12:	461d      	mov	r5, r3
34006f14:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34006f16:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34006f18:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34006f1a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34006f1c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
34006f1e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
34006f20:	682b      	ldr	r3, [r5, #0]
34006f22:	6023      	str	r3, [r4, #0]

  /* Configure Predefined format */
  LTDC_SetPredefFormat(hltdc, LayerIdx);
34006f24:	6879      	ldr	r1, [r7, #4]
34006f26:	68f8      	ldr	r0, [r7, #12]
34006f28:	f000 ff6c 	bl	34007e04 <LTDC_SetPredefFormat>

  /* Configure composition and blending*/
  LTDC_SetCompositionConfig(hltdc, LayerIdx);
34006f2c:	6879      	ldr	r1, [r7, #4]
34006f2e:	68f8      	ldr	r0, [r7, #12]
34006f30:	f000 fec0 	bl	34007cb4 <LTDC_SetCompositionConfig>

  /* Disable YUV format */
  CLEAR_BIT(LTDC_LAYER(hltdc, LayerIdx)->PCR, LTDC_LxPCR_YCEN);
34006f34:	68fb      	ldr	r3, [r7, #12]
34006f36:	681b      	ldr	r3, [r3, #0]
34006f38:	461a      	mov	r2, r3
34006f3a:	687b      	ldr	r3, [r7, #4]
34006f3c:	021b      	lsls	r3, r3, #8
34006f3e:	4413      	add	r3, r2
34006f40:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34006f44:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
34006f46:	68fa      	ldr	r2, [r7, #12]
34006f48:	6812      	ldr	r2, [r2, #0]
34006f4a:	4611      	mov	r1, r2
34006f4c:	687a      	ldr	r2, [r7, #4]
34006f4e:	0212      	lsls	r2, r2, #8
34006f50:	440a      	add	r2, r1
34006f52:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34006f56:	f023 0308 	bic.w	r3, r3, #8
34006f5a:	6313      	str	r3, [r2, #48]	@ 0x30

  /* Configure the LTDC Layer */
  LTDC_SetConfig(hltdc, 0U, 0U, LTDC_MIRROR_NONE, LayerIdx);
34006f5c:	687b      	ldr	r3, [r7, #4]
34006f5e:	9300      	str	r3, [sp, #0]
34006f60:	2303      	movs	r3, #3
34006f62:	2200      	movs	r2, #0
34006f64:	2100      	movs	r1, #0
34006f66:	68f8      	ldr	r0, [r7, #12]
34006f68:	f000 f818 	bl	34006f9c <LTDC_SetConfig>

  /* Set the Immediate Reload type */
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->RCR, LTDC_LxRCR_IMR | LTDC_LxRCR_GRMSK);
34006f6c:	68fb      	ldr	r3, [r7, #12]
34006f6e:	681b      	ldr	r3, [r3, #0]
34006f70:	461a      	mov	r2, r3
34006f72:	687b      	ldr	r3, [r7, #4]
34006f74:	021b      	lsls	r3, r3, #8
34006f76:	4413      	add	r3, r2
34006f78:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34006f7c:	461a      	mov	r2, r3
34006f7e:	2305      	movs	r3, #5
34006f80:	6093      	str	r3, [r2, #8]

  /* Initialize the LTDC state*/
  hltdc->State  = HAL_LTDC_STATE_READY;
34006f82:	68fb      	ldr	r3, [r7, #12]
34006f84:	2201      	movs	r2, #1
34006f86:	f883 20a1 	strb.w	r2, [r3, #161]	@ 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
34006f8a:	68fb      	ldr	r3, [r7, #12]
34006f8c:	2200      	movs	r2, #0
34006f8e:	f883 20a0 	strb.w	r2, [r3, #160]	@ 0xa0

  return HAL_OK;
34006f92:	2300      	movs	r3, #0
}
34006f94:	4618      	mov	r0, r3
34006f96:	3710      	adds	r7, #16
34006f98:	46bd      	mov	sp, r7
34006f9a:	bdb0      	pop	{r4, r5, r7, pc}

34006f9c <LTDC_SetConfig>:
  *       This function does not return a value as it is a static function used internally within the
  *        driver.
  */
static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, uint32_t Aux0Addr, uint32_t Aux1Addr, uint32_t Mirror,
                           uint32_t LayerIdx)
{
34006f9c:	b4b0      	push	{r4, r5, r7}
34006f9e:	b087      	sub	sp, #28
34006fa0:	af00      	add	r7, sp, #0
34006fa2:	60f8      	str	r0, [r7, #12]
34006fa4:	60b9      	str	r1, [r7, #8]
34006fa6:	607a      	str	r2, [r7, #4]
34006fa8:	603b      	str	r3, [r7, #0]
  uint32_t stride;
  uint32_t tmp;

  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (hltdc->LayerCfg[LayerIdx].ImageHeight);
34006faa:	68fb      	ldr	r3, [r7, #12]
34006fac:	681b      	ldr	r3, [r3, #0]
34006fae:	461a      	mov	r2, r3
34006fb0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34006fb2:	021b      	lsls	r3, r3, #8
34006fb4:	4413      	add	r3, r2
34006fb6:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34006fba:	4618      	mov	r0, r3
34006fbc:	68fa      	ldr	r2, [r7, #12]
34006fbe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34006fc0:	2134      	movs	r1, #52	@ 0x34
34006fc2:	fb01 f303 	mul.w	r3, r1, r3
34006fc6:	4413      	add	r3, r2
34006fc8:	3364      	adds	r3, #100	@ 0x64
34006fca:	681b      	ldr	r3, [r3, #0]
34006fcc:	63c3      	str	r3, [r0, #60]	@ 0x3c

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34006fce:	68fa      	ldr	r2, [r7, #12]
34006fd0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34006fd2:	2134      	movs	r1, #52	@ 0x34
34006fd4:	fb01 f303 	mul.w	r3, r1, r3
34006fd8:	4413      	add	r3, r2
34006fda:	3348      	adds	r3, #72	@ 0x48
34006fdc:	681b      	ldr	r3, [r3, #0]
34006fde:	2b03      	cmp	r3, #3
34006fe0:	d821      	bhi.n	34007026 <LTDC_SetConfig+0x8a>
34006fe2:	e025      	b.n	34007030 <LTDC_SetConfig+0x94>
34006fe4:	3b04      	subs	r3, #4
34006fe6:	2201      	movs	r2, #1
34006fe8:	fa02 f303 	lsl.w	r3, r2, r3
34006fec:	f240 229b 	movw	r2, #667	@ 0x29b
34006ff0:	401a      	ands	r2, r3
34006ff2:	2a00      	cmp	r2, #0
34006ff4:	bf14      	ite	ne
34006ff6:	2201      	movne	r2, #1
34006ff8:	2200      	moveq	r2, #0
34006ffa:	b2d2      	uxtb	r2, r2
34006ffc:	2a00      	cmp	r2, #0
34006ffe:	d11d      	bne.n	3400703c <LTDC_SetConfig+0xa0>
34007000:	f403 7280 	and.w	r2, r3, #256	@ 0x100
34007004:	2a00      	cmp	r2, #0
34007006:	bf14      	ite	ne
34007008:	2201      	movne	r2, #1
3400700a:	2200      	moveq	r2, #0
3400700c:	b2d2      	uxtb	r2, r2
3400700e:	2a00      	cmp	r2, #0
34007010:	d117      	bne.n	34007042 <LTDC_SetConfig+0xa6>
34007012:	f003 0304 	and.w	r3, r3, #4
34007016:	2b00      	cmp	r3, #0
34007018:	bf14      	ite	ne
3400701a:	2301      	movne	r3, #1
3400701c:	2300      	moveq	r3, #0
3400701e:	b2db      	uxtb	r3, r3
34007020:	2b00      	cmp	r3, #0
34007022:	d108      	bne.n	34007036 <LTDC_SetConfig+0x9a>
34007024:	e01b      	b.n	3400705e <LTDC_SetConfig+0xc2>
34007026:	2b0d      	cmp	r3, #13
34007028:	d819      	bhi.n	3400705e <LTDC_SetConfig+0xc2>
3400702a:	2b04      	cmp	r3, #4
3400702c:	d2da      	bcs.n	34006fe4 <LTDC_SetConfig+0x48>
3400702e:	e016      	b.n	3400705e <LTDC_SetConfig+0xc2>
  {
    case LTDC_PIXEL_FORMAT_ARGB8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_ABGR8888:
    case LTDC_PIXEL_FORMAT_RGBA8888:
      stride = 4U;
34007030:	2304      	movs	r3, #4
34007032:	617b      	str	r3, [r7, #20]
      break;
34007034:	e016      	b.n	34007064 <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_RGB888:
      stride = 3U;
34007036:	2303      	movs	r3, #3
34007038:	617b      	str	r3, [r7, #20]
      break;
3400703a:	e013      	b.n	34007064 <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_BGR565:
    case LTDC_PIXEL_FORMAT_ARGB1555:
    case LTDC_PIXEL_FORMAT_ARGB4444:
    case LTDC_PIXEL_FORMAT_AL88:
    case LTDC_PIXEL_FORMAT_FLEX_YUV_COPLANAR:
      stride = 2U;
3400703c:	2302      	movs	r3, #2
3400703e:	617b      	str	r3, [r7, #20]
      break;
34007040:	e010      	b.n	34007064 <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_FLEX_ARGB:
      stride = (((LTDC_LAYER(hltdc, LayerIdx)->FPF1R) & LTDC_LxFPF1R_PSIZE_Msk) >> LTDC_LxFPF1R_PSIZE_Pos);
34007042:	68fb      	ldr	r3, [r7, #12]
34007044:	681b      	ldr	r3, [r3, #0]
34007046:	461a      	mov	r2, r3
34007048:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400704a:	021b      	lsls	r3, r3, #8
3400704c:	4413      	add	r3, r2
3400704e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007052:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
34007054:	0c9b      	lsrs	r3, r3, #18
34007056:	f003 0307 	and.w	r3, r3, #7
3400705a:	617b      	str	r3, [r7, #20]
      break;
3400705c:	e002      	b.n	34007064 <LTDC_SetConfig+0xc8>
    case LTDC_PIXEL_FORMAT_L8:
    case LTDC_PIXEL_FORMAT_AL44:
    case LTDC_PIXEL_FORMAT_FLEX_YUV_SEMIPLANAR:
    default:
      stride = 1U;
3400705e:	2301      	movs	r3, #1
34007060:	617b      	str	r3, [r7, #20]
      break;
34007062:	bf00      	nop
  }

  /* Configure the horizontal start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
34007064:	68fa      	ldr	r2, [r7, #12]
34007066:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007068:	2134      	movs	r1, #52	@ 0x34
3400706a:	fb01 f303 	mul.w	r3, r1, r3
3400706e:	4413      	add	r3, r2
34007070:	333c      	adds	r3, #60	@ 0x3c
34007072:	681a      	ldr	r2, [r3, #0]
34007074:	68fb      	ldr	r3, [r7, #12]
34007076:	681b      	ldr	r3, [r3, #0]
34007078:	68db      	ldr	r3, [r3, #12]
3400707a:	0c1b      	lsrs	r3, r3, #16
3400707c:	f3c3 030b 	ubfx	r3, r3, #0, #12
34007080:	4413      	add	r3, r2
34007082:	041b      	lsls	r3, r3, #16
34007084:	613b      	str	r3, [r7, #16]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
34007086:	68fa      	ldr	r2, [r7, #12]
34007088:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400708a:	2134      	movs	r1, #52	@ 0x34
3400708c:	fb01 f303 	mul.w	r3, r1, r3
34007090:	4413      	add	r3, r2
34007092:	3338      	adds	r3, #56	@ 0x38
34007094:	681a      	ldr	r2, [r3, #0]
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
34007096:	68fb      	ldr	r3, [r7, #12]
34007098:	681b      	ldr	r3, [r3, #0]
3400709a:	68db      	ldr	r3, [r3, #12]
3400709c:	0c1b      	lsrs	r3, r3, #16
3400709e:	f3c3 030b 	ubfx	r3, r3, #0, #12
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
340070a2:	4413      	add	r3, r2
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
340070a4:	1c5a      	adds	r2, r3, #1
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
340070a6:	68fb      	ldr	r3, [r7, #12]
340070a8:	681b      	ldr	r3, [r3, #0]
340070aa:	4619      	mov	r1, r3
340070ac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340070ae:	021b      	lsls	r3, r3, #8
340070b0:	440b      	add	r3, r1
340070b2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
340070b6:	4619      	mov	r1, r3
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
340070b8:	693b      	ldr	r3, [r7, #16]
340070ba:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((hltdc->LayerCfg[LayerIdx].WindowX0 +
340070bc:	610b      	str	r3, [r1, #16]

  /* Configure the vertical start and stop position */
  tmp = ((hltdc->LayerCfg[LayerIdx].WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
340070be:	68fa      	ldr	r2, [r7, #12]
340070c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340070c2:	2134      	movs	r1, #52	@ 0x34
340070c4:	fb01 f303 	mul.w	r3, r1, r3
340070c8:	4413      	add	r3, r2
340070ca:	3344      	adds	r3, #68	@ 0x44
340070cc:	681a      	ldr	r2, [r3, #0]
340070ce:	68fb      	ldr	r3, [r7, #12]
340070d0:	681b      	ldr	r3, [r3, #0]
340070d2:	68db      	ldr	r3, [r3, #12]
340070d4:	f3c3 030b 	ubfx	r3, r3, #0, #12
340070d8:	4413      	add	r3, r2
340070da:	041b      	lsls	r3, r3, #16
340070dc:	613b      	str	r3, [r7, #16]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
340070de:	68fa      	ldr	r2, [r7, #12]
340070e0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340070e2:	2134      	movs	r1, #52	@ 0x34
340070e4:	fb01 f303 	mul.w	r3, r1, r3
340070e8:	4413      	add	r3, r2
340070ea:	3340      	adds	r3, #64	@ 0x40
340070ec:	681a      	ldr	r2, [r3, #0]
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
340070ee:	68fb      	ldr	r3, [r7, #12]
340070f0:	681b      	ldr	r3, [r3, #0]
340070f2:	68db      	ldr	r3, [r3, #12]
340070f4:	f3c3 030b 	ubfx	r3, r3, #0, #12
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
340070f8:	4413      	add	r3, r2
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
340070fa:	1c5a      	adds	r2, r3, #1
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
340070fc:	68fb      	ldr	r3, [r7, #12]
340070fe:	681b      	ldr	r3, [r3, #0]
34007100:	4619      	mov	r1, r3
34007102:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007104:	021b      	lsls	r3, r3, #8
34007106:	440b      	add	r3, r1
34007108:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400710c:	4619      	mov	r1, r3
                                         (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
3400710e:	693b      	ldr	r3, [r7, #16]
34007110:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR = ((hltdc->LayerCfg[LayerIdx].WindowY0 +
34007112:	614b      	str	r3, [r1, #20]

  if (Mirror == LTDC_MIRROR_NONE)
34007114:	683b      	ldr	r3, [r7, #0]
34007116:	2b03      	cmp	r3, #3
34007118:	f040 80fb 	bne.w	34007312 <LTDC_SetConfig+0x376>
  {
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (hltdc->LayerCfg[LayerIdx].FBStartAdress);
3400711c:	68fb      	ldr	r3, [r7, #12]
3400711e:	681b      	ldr	r3, [r3, #0]
34007120:	461a      	mov	r2, r3
34007122:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007124:	021b      	lsls	r3, r3, #8
34007126:	4413      	add	r3, r2
34007128:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400712c:	4618      	mov	r0, r3
3400712e:	68fa      	ldr	r2, [r7, #12]
34007130:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007132:	2134      	movs	r1, #52	@ 0x34
34007134:	fb01 f303 	mul.w	r3, r1, r3
34007138:	4413      	add	r3, r2
3400713a:	335c      	adds	r3, #92	@ 0x5c
3400713c:	681b      	ldr	r3, [r3, #0]
3400713e:	6343      	str	r3, [r0, #52]	@ 0x34

    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34007140:	68fa      	ldr	r2, [r7, #12]
34007142:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007144:	2134      	movs	r1, #52	@ 0x34
34007146:	fb01 f303 	mul.w	r3, r1, r3
3400714a:	4413      	add	r3, r2
3400714c:	3348      	adds	r3, #72	@ 0x48
3400714e:	681b      	ldr	r3, [r3, #0]
34007150:	f240 120d 	movw	r2, #269	@ 0x10d
34007154:	4293      	cmp	r3, r2
34007156:	d004      	beq.n	34007162 <LTDC_SetConfig+0x1c6>
34007158:	f240 220d 	movw	r2, #525	@ 0x20d
3400715c:	4293      	cmp	r3, r2
3400715e:	d043      	beq.n	340071e8 <LTDC_SetConfig+0x24c>
        /* Configure the frame buffer line number */
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
        break;
      default:
        /* Nothing to do */
        break;
34007160:	e092      	b.n	34007288 <LTDC_SetConfig+0x2ec>
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
34007162:	68fb      	ldr	r3, [r7, #12]
34007164:	681b      	ldr	r3, [r3, #0]
34007166:	461a      	mov	r2, r3
34007168:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400716a:	021b      	lsls	r3, r3, #8
3400716c:	4413      	add	r3, r2
3400716e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007172:	461a      	mov	r2, r3
34007174:	68bb      	ldr	r3, [r7, #8]
34007176:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
34007178:	68fa      	ldr	r2, [r7, #12]
3400717a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400717c:	2134      	movs	r1, #52	@ 0x34
3400717e:	fb01 f303 	mul.w	r3, r1, r3
34007182:	4413      	add	r3, r2
34007184:	3360      	adds	r3, #96	@ 0x60
34007186:	681b      	ldr	r3, [r3, #0]
34007188:	041a      	lsls	r2, r3, #16
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400718a:	68f9      	ldr	r1, [r7, #12]
3400718c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400718e:	2034      	movs	r0, #52	@ 0x34
34007190:	fb00 f303 	mul.w	r3, r0, r3
34007194:	440b      	add	r3, r1
34007196:	333c      	adds	r3, #60	@ 0x3c
34007198:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0 + 7U);
3400719a:	68f8      	ldr	r0, [r7, #12]
3400719c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400719e:	2434      	movs	r4, #52	@ 0x34
340071a0:	fb04 f303 	mul.w	r3, r4, r3
340071a4:	4403      	add	r3, r0
340071a6:	3338      	adds	r3, #56	@ 0x38
340071a8:	681b      	ldr	r3, [r3, #0]
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 -
340071aa:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0 + 7U);
340071ac:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
340071ae:	68f9      	ldr	r1, [r7, #12]
340071b0:	6809      	ldr	r1, [r1, #0]
340071b2:	4608      	mov	r0, r1
340071b4:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
340071b6:	0209      	lsls	r1, r1, #8
340071b8:	4401      	add	r1, r0
340071ba:	f501 7180 	add.w	r1, r1, #256	@ 0x100
340071be:	4313      	orrs	r3, r2
340071c0:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
340071c2:	68fa      	ldr	r2, [r7, #12]
340071c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340071c6:	2134      	movs	r1, #52	@ 0x34
340071c8:	fb01 f303 	mul.w	r3, r1, r3
340071cc:	4413      	add	r3, r2
340071ce:	3364      	adds	r3, #100	@ 0x64
340071d0:	681b      	ldr	r3, [r3, #0]
340071d2:	68fa      	ldr	r2, [r7, #12]
340071d4:	6812      	ldr	r2, [r2, #0]
340071d6:	4611      	mov	r1, r2
340071d8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340071da:	0212      	lsls	r2, r2, #8
340071dc:	440a      	add	r2, r1
340071de:	f502 7280 	add.w	r2, r2, #256	@ 0x100
340071e2:	085b      	lsrs	r3, r3, #1
340071e4:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
340071e6:	e04f      	b.n	34007288 <LTDC_SetConfig+0x2ec>
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr;
340071e8:	68fb      	ldr	r3, [r7, #12]
340071ea:	681b      	ldr	r3, [r3, #0]
340071ec:	461a      	mov	r2, r3
340071ee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340071f0:	021b      	lsls	r3, r3, #8
340071f2:	4413      	add	r3, r2
340071f4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
340071f8:	461a      	mov	r2, r3
340071fa:	68bb      	ldr	r3, [r7, #8]
340071fc:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr;
340071fe:	68fb      	ldr	r3, [r7, #12]
34007200:	681b      	ldr	r3, [r3, #0]
34007202:	461a      	mov	r2, r3
34007204:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007206:	021b      	lsls	r3, r3, #8
34007208:	4413      	add	r3, r2
3400720a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400720e:	461a      	mov	r2, r3
34007210:	687b      	ldr	r3, [r7, #4]
34007212:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
34007214:	68fa      	ldr	r2, [r7, #12]
34007216:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007218:	2134      	movs	r1, #52	@ 0x34
3400721a:	fb01 f303 	mul.w	r3, r1, r3
3400721e:	4413      	add	r3, r2
34007220:	3360      	adds	r3, #96	@ 0x60
34007222:	681b      	ldr	r3, [r3, #0]
34007224:	085b      	lsrs	r3, r3, #1
34007226:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
34007228:	68f9      	ldr	r1, [r7, #12]
3400722a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400722c:	2034      	movs	r0, #52	@ 0x34
3400722e:	fb00 f303 	mul.w	r3, r0, r3
34007232:	440b      	add	r3, r1
34007234:	333c      	adds	r3, #60	@ 0x3c
34007236:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
34007238:	68f8      	ldr	r0, [r7, #12]
3400723a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400723c:	2434      	movs	r4, #52	@ 0x34
3400723e:	fb04 f303 	mul.w	r3, r4, r3
34007242:	4403      	add	r3, r0
34007244:	3338      	adds	r3, #56	@ 0x38
34007246:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
34007248:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
3400724a:	085b      	lsrs	r3, r3, #1
3400724c:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
3400724e:	68f9      	ldr	r1, [r7, #12]
34007250:	6809      	ldr	r1, [r1, #0]
34007252:	4608      	mov	r0, r1
34007254:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34007256:	0209      	lsls	r1, r1, #8
34007258:	4401      	add	r1, r0
3400725a:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400725e:	4313      	orrs	r3, r2
34007260:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = (hltdc->LayerCfg[LayerIdx].ImageHeight) >> 1U;
34007262:	68fa      	ldr	r2, [r7, #12]
34007264:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007266:	2134      	movs	r1, #52	@ 0x34
34007268:	fb01 f303 	mul.w	r3, r1, r3
3400726c:	4413      	add	r3, r2
3400726e:	3364      	adds	r3, #100	@ 0x64
34007270:	681b      	ldr	r3, [r3, #0]
34007272:	68fa      	ldr	r2, [r7, #12]
34007274:	6812      	ldr	r2, [r2, #0]
34007276:	4611      	mov	r1, r2
34007278:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400727a:	0212      	lsls	r2, r2, #8
3400727c:	440a      	add	r2, r1
3400727e:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34007282:	085b      	lsrs	r3, r3, #1
34007284:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
34007286:	bf00      	nop
    }

    /* Configure the color frame buffer pitch in byte */
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
34007288:	68fa      	ldr	r2, [r7, #12]
3400728a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400728c:	2134      	movs	r1, #52	@ 0x34
3400728e:	fb01 f303 	mul.w	r3, r1, r3
34007292:	4413      	add	r3, r2
34007294:	3360      	adds	r3, #96	@ 0x60
34007296:	681b      	ldr	r3, [r3, #0]
34007298:	697a      	ldr	r2, [r7, #20]
3400729a:	fb02 f303 	mul.w	r3, r2, r3
3400729e:	041a      	lsls	r2, r3, #16
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 - hltdc->LayerCfg[LayerIdx].WindowX0) *
340072a0:	68f9      	ldr	r1, [r7, #12]
340072a2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340072a4:	2034      	movs	r0, #52	@ 0x34
340072a6:	fb00 f303 	mul.w	r3, r0, r3
340072aa:	440b      	add	r3, r1
340072ac:	333c      	adds	r3, #60	@ 0x3c
340072ae:	6819      	ldr	r1, [r3, #0]
340072b0:	68f8      	ldr	r0, [r7, #12]
340072b2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340072b4:	2434      	movs	r4, #52	@ 0x34
340072b6:	fb04 f303 	mul.w	r3, r4, r3
340072ba:	4403      	add	r3, r0
340072bc:	3338      	adds	r3, #56	@ 0x38
340072be:	681b      	ldr	r3, [r3, #0]
340072c0:	1acb      	subs	r3, r1, r3
340072c2:	6979      	ldr	r1, [r7, #20]
340072c4:	fb01 f303 	mul.w	r3, r1, r3
                                            stride)  + 7U));
340072c8:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
340072ca:	68f9      	ldr	r1, [r7, #12]
340072cc:	6809      	ldr	r1, [r1, #0]
340072ce:	4608      	mov	r0, r1
340072d0:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
340072d2:	0209      	lsls	r1, r1, #8
340072d4:	4401      	add	r1, r0
340072d6:	f501 7180 	add.w	r1, r1, #256	@ 0x100
340072da:	4313      	orrs	r3, r2
340072dc:	638b      	str	r3, [r1, #56]	@ 0x38

    /* Enable LTDC_Layer by setting LEN bit */
    MODIFY_REG(LTDC_LAYER(hltdc, LayerIdx)->CR,LTDC_LxCR_HMEN, LTDC_LxCR_LEN);
340072de:	68fb      	ldr	r3, [r7, #12]
340072e0:	681b      	ldr	r3, [r3, #0]
340072e2:	461a      	mov	r2, r3
340072e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340072e6:	021b      	lsls	r3, r3, #8
340072e8:	4413      	add	r3, r2
340072ea:	f503 7380 	add.w	r3, r3, #256	@ 0x100
340072ee:	68db      	ldr	r3, [r3, #12]
340072f0:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
340072f4:	f023 0301 	bic.w	r3, r3, #1
340072f8:	68fa      	ldr	r2, [r7, #12]
340072fa:	6812      	ldr	r2, [r2, #0]
340072fc:	4611      	mov	r1, r2
340072fe:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007300:	0212      	lsls	r2, r2, #8
34007302:	440a      	add	r2, r1
34007304:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34007308:	f043 0301 	orr.w	r3, r3, #1
3400730c:	60d3      	str	r3, [r2, #12]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));

    /* Enable horizontal mirroring bit & LTDC_Layer by setting LEN bit */
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
  }
}
3400730e:	f000 bccc 	b.w	34007caa <LTDC_SetConfig+0xd0e>
  else if (Mirror == LTDC_MIRROR_HORIZONTAL)
34007312:	683b      	ldr	r3, [r7, #0]
34007314:	2b00      	cmp	r3, #0
34007316:	f040 814e 	bne.w	340075b6 <LTDC_SetConfig+0x61a>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400731a:	68fa      	ldr	r2, [r7, #12]
3400731c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400731e:	2134      	movs	r1, #52	@ 0x34
34007320:	fb01 f303 	mul.w	r3, r1, r3
34007324:	4413      	add	r3, r2
34007326:	335c      	adds	r3, #92	@ 0x5c
34007328:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400732a:	68f9      	ldr	r1, [r7, #12]
3400732c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400732e:	2034      	movs	r0, #52	@ 0x34
34007330:	fb00 f303 	mul.w	r3, r0, r3
34007334:	440b      	add	r3, r1
34007336:	333c      	adds	r3, #60	@ 0x3c
34007338:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3400733a:	68f8      	ldr	r0, [r7, #12]
3400733c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400733e:	2434      	movs	r4, #52	@ 0x34
34007340:	fb04 f303 	mul.w	r3, r4, r3
34007344:	4403      	add	r3, r0
34007346:	3338      	adds	r3, #56	@ 0x38
34007348:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400734a:	1acb      	subs	r3, r1, r3
3400734c:	6979      	ldr	r1, [r7, #20]
3400734e:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34007352:	4413      	add	r3, r2
34007354:	68fa      	ldr	r2, [r7, #12]
34007356:	6812      	ldr	r2, [r2, #0]
34007358:	4611      	mov	r1, r2
3400735a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400735c:	0212      	lsls	r2, r2, #8
3400735e:	440a      	add	r2, r1
34007360:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                    hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
34007364:	3b01      	subs	r3, #1
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34007366:	6353      	str	r3, [r2, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34007368:	68fa      	ldr	r2, [r7, #12]
3400736a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400736c:	2134      	movs	r1, #52	@ 0x34
3400736e:	fb01 f303 	mul.w	r3, r1, r3
34007372:	4413      	add	r3, r2
34007374:	3348      	adds	r3, #72	@ 0x48
34007376:	681b      	ldr	r3, [r3, #0]
34007378:	f240 120d 	movw	r2, #269	@ 0x10d
3400737c:	4293      	cmp	r3, r2
3400737e:	d004      	beq.n	3400738a <LTDC_SetConfig+0x3ee>
34007380:	f240 220d 	movw	r2, #525	@ 0x20d
34007384:	4293      	cmp	r3, r2
34007386:	d058      	beq.n	3400743a <LTDC_SetConfig+0x49e>
        break;
34007388:	e0d3      	b.n	34007532 <LTDC_SetConfig+0x596>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
3400738a:	68fa      	ldr	r2, [r7, #12]
3400738c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400738e:	2134      	movs	r1, #52	@ 0x34
34007390:	fb01 f303 	mul.w	r3, r1, r3
34007394:	4413      	add	r3, r2
34007396:	333c      	adds	r3, #60	@ 0x3c
34007398:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
3400739a:	68f9      	ldr	r1, [r7, #12]
3400739c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400739e:	2034      	movs	r0, #52	@ 0x34
340073a0:	fb00 f303 	mul.w	r3, r0, r3
340073a4:	440b      	add	r3, r1
340073a6:	3338      	adds	r3, #56	@ 0x38
340073a8:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
340073aa:	1ad3      	subs	r3, r2, r3
340073ac:	697a      	ldr	r2, [r7, #20]
340073ae:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
340073b2:	68bb      	ldr	r3, [r7, #8]
340073b4:	4413      	add	r3, r2
340073b6:	68fa      	ldr	r2, [r7, #12]
340073b8:	6812      	ldr	r2, [r2, #0]
340073ba:	4611      	mov	r1, r2
340073bc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340073be:	0212      	lsls	r2, r2, #8
340073c0:	440a      	add	r2, r1
340073c2:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                         hltdc->LayerCfg[LayerIdx].WindowX0)) - 1U;
340073c6:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
340073c8:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
340073ca:	68fa      	ldr	r2, [r7, #12]
340073cc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340073ce:	2134      	movs	r1, #52	@ 0x34
340073d0:	fb01 f303 	mul.w	r3, r1, r3
340073d4:	4413      	add	r3, r2
340073d6:	3360      	adds	r3, #96	@ 0x60
340073d8:	681b      	ldr	r3, [r3, #0]
340073da:	041a      	lsls	r2, r3, #16
                                             (hltdc->LayerCfg[LayerIdx].WindowX1 - hltdc->LayerCfg[LayerIdx].WindowX0 +
340073dc:	68f9      	ldr	r1, [r7, #12]
340073de:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340073e0:	2034      	movs	r0, #52	@ 0x34
340073e2:	fb00 f303 	mul.w	r3, r0, r3
340073e6:	440b      	add	r3, r1
340073e8:	333c      	adds	r3, #60	@ 0x3c
340073ea:	6819      	ldr	r1, [r3, #0]
340073ec:	68f8      	ldr	r0, [r7, #12]
340073ee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340073f0:	2434      	movs	r4, #52	@ 0x34
340073f2:	fb04 f303 	mul.w	r3, r4, r3
340073f6:	4403      	add	r3, r0
340073f8:	3338      	adds	r3, #56	@ 0x38
340073fa:	681b      	ldr	r3, [r3, #0]
340073fc:	1acb      	subs	r3, r1, r3
340073fe:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (hltdc->LayerCfg[LayerIdx].ImageWidth << 16U) |
34007400:	68f9      	ldr	r1, [r7, #12]
34007402:	6809      	ldr	r1, [r1, #0]
34007404:	4608      	mov	r0, r1
34007406:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34007408:	0209      	lsls	r1, r1, #8
3400740a:	4401      	add	r1, r0
3400740c:	f501 7180 	add.w	r1, r1, #256	@ 0x100
34007410:	4313      	orrs	r3, r2
34007412:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U ;
34007414:	68fa      	ldr	r2, [r7, #12]
34007416:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007418:	2134      	movs	r1, #52	@ 0x34
3400741a:	fb01 f303 	mul.w	r3, r1, r3
3400741e:	4413      	add	r3, r2
34007420:	3364      	adds	r3, #100	@ 0x64
34007422:	681b      	ldr	r3, [r3, #0]
34007424:	68fa      	ldr	r2, [r7, #12]
34007426:	6812      	ldr	r2, [r2, #0]
34007428:	4611      	mov	r1, r2
3400742a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400742c:	0212      	lsls	r2, r2, #8
3400742e:	440a      	add	r2, r1
34007430:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34007434:	085b      	lsrs	r3, r3, #1
34007436:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
34007438:	e07b      	b.n	34007532 <LTDC_SetConfig+0x596>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400743a:	68fa      	ldr	r2, [r7, #12]
3400743c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400743e:	2134      	movs	r1, #52	@ 0x34
34007440:	fb01 f303 	mul.w	r3, r1, r3
34007444:	4413      	add	r3, r2
34007446:	333c      	adds	r3, #60	@ 0x3c
34007448:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400744a:	68f9      	ldr	r1, [r7, #12]
3400744c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400744e:	2034      	movs	r0, #52	@ 0x34
34007450:	fb00 f303 	mul.w	r3, r0, r3
34007454:	440b      	add	r3, r1
34007456:	3338      	adds	r3, #56	@ 0x38
34007458:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400745a:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400745c:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400745e:	697a      	ldr	r2, [r7, #20]
34007460:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34007464:	68bb      	ldr	r3, [r7, #8]
34007466:	4413      	add	r3, r2
34007468:	68fa      	ldr	r2, [r7, #12]
3400746a:	6812      	ldr	r2, [r2, #0]
3400746c:	4611      	mov	r1, r2
3400746e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007470:	0212      	lsls	r2, r2, #8
34007472:	440a      	add	r2, r1
34007474:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
34007478:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
3400747a:	6413      	str	r3, [r2, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400747c:	68fa      	ldr	r2, [r7, #12]
3400747e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007480:	2134      	movs	r1, #52	@ 0x34
34007482:	fb01 f303 	mul.w	r3, r1, r3
34007486:	4413      	add	r3, r2
34007488:	333c      	adds	r3, #60	@ 0x3c
3400748a:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400748c:	68f9      	ldr	r1, [r7, #12]
3400748e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007490:	2034      	movs	r0, #52	@ 0x34
34007492:	fb00 f303 	mul.w	r3, r0, r3
34007496:	440b      	add	r3, r1
34007498:	3338      	adds	r3, #56	@ 0x38
3400749a:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400749c:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
3400749e:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
340074a0:	697a      	ldr	r2, [r7, #20]
340074a2:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
340074a6:	687b      	ldr	r3, [r7, #4]
340074a8:	4413      	add	r3, r2
340074aa:	68fa      	ldr	r2, [r7, #12]
340074ac:	6812      	ldr	r2, [r2, #0]
340074ae:	4611      	mov	r1, r2
340074b0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340074b2:	0212      	lsls	r2, r2, #8
340074b4:	440a      	add	r2, r1
340074b6:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U)) - 1U;
340074ba:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
340074bc:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
340074be:	68fa      	ldr	r2, [r7, #12]
340074c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340074c2:	2134      	movs	r1, #52	@ 0x34
340074c4:	fb01 f303 	mul.w	r3, r1, r3
340074c8:	4413      	add	r3, r2
340074ca:	3360      	adds	r3, #96	@ 0x60
340074cc:	681b      	ldr	r3, [r3, #0]
340074ce:	085b      	lsrs	r3, r3, #1
340074d0:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
340074d2:	68f9      	ldr	r1, [r7, #12]
340074d4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340074d6:	2034      	movs	r0, #52	@ 0x34
340074d8:	fb00 f303 	mul.w	r3, r0, r3
340074dc:	440b      	add	r3, r1
340074de:	333c      	adds	r3, #60	@ 0x3c
340074e0:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
340074e2:	68f8      	ldr	r0, [r7, #12]
340074e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340074e6:	2434      	movs	r4, #52	@ 0x34
340074e8:	fb04 f303 	mul.w	r3, r4, r3
340074ec:	4403      	add	r3, r0
340074ee:	3338      	adds	r3, #56	@ 0x38
340074f0:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
340074f2:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) + 7U);
340074f4:	085b      	lsrs	r3, r3, #1
340074f6:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U) << 16U) |
340074f8:	68f9      	ldr	r1, [r7, #12]
340074fa:	6809      	ldr	r1, [r1, #0]
340074fc:	4608      	mov	r0, r1
340074fe:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34007500:	0209      	lsls	r1, r1, #8
34007502:	4401      	add	r1, r0
34007504:	f501 7180 	add.w	r1, r1, #256	@ 0x100
34007508:	4313      	orrs	r3, r2
3400750a:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
3400750c:	68fa      	ldr	r2, [r7, #12]
3400750e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007510:	2134      	movs	r1, #52	@ 0x34
34007512:	fb01 f303 	mul.w	r3, r1, r3
34007516:	4413      	add	r3, r2
34007518:	3364      	adds	r3, #100	@ 0x64
3400751a:	681b      	ldr	r3, [r3, #0]
3400751c:	68fa      	ldr	r2, [r7, #12]
3400751e:	6812      	ldr	r2, [r2, #0]
34007520:	4611      	mov	r1, r2
34007522:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007524:	0212      	lsls	r2, r2, #8
34007526:	440a      	add	r2, r1
34007528:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400752c:	085b      	lsrs	r3, r3, #1
3400752e:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
34007530:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
34007532:	68fa      	ldr	r2, [r7, #12]
34007534:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007536:	2134      	movs	r1, #52	@ 0x34
34007538:	fb01 f303 	mul.w	r3, r1, r3
3400753c:	4413      	add	r3, r2
3400753e:	3360      	adds	r3, #96	@ 0x60
34007540:	681b      	ldr	r3, [r3, #0]
34007542:	697a      	ldr	r2, [r7, #20]
34007544:	fb02 f303 	mul.w	r3, r2, r3
34007548:	041a      	lsls	r2, r3, #16
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400754a:	68f9      	ldr	r1, [r7, #12]
3400754c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400754e:	2034      	movs	r0, #52	@ 0x34
34007550:	fb00 f303 	mul.w	r3, r0, r3
34007554:	440b      	add	r3, r1
34007556:	333c      	adds	r3, #60	@ 0x3c
34007558:	6819      	ldr	r1, [r3, #0]
                                             hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U));
3400755a:	68f8      	ldr	r0, [r7, #12]
3400755c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400755e:	2434      	movs	r4, #52	@ 0x34
34007560:	fb04 f303 	mul.w	r3, r4, r3
34007564:	4403      	add	r3, r0
34007566:	3338      	adds	r3, #56	@ 0x38
34007568:	681b      	ldr	r3, [r3, #0]
                                          (((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400756a:	1acb      	subs	r3, r1, r3
                                             hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U));
3400756c:	6979      	ldr	r1, [r7, #20]
3400756e:	fb01 f303 	mul.w	r3, r1, r3
34007572:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR = (((hltdc->LayerCfg[LayerIdx].ImageWidth * stride) << 16U) |
34007574:	68f9      	ldr	r1, [r7, #12]
34007576:	6809      	ldr	r1, [r1, #0]
34007578:	4608      	mov	r0, r1
3400757a:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400757c:	0209      	lsls	r1, r1, #8
3400757e:	4401      	add	r1, r0
34007580:	f501 7180 	add.w	r1, r1, #256	@ 0x100
34007584:	4313      	orrs	r3, r2
34007586:	638b      	str	r3, [r1, #56]	@ 0x38
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
34007588:	68fb      	ldr	r3, [r7, #12]
3400758a:	681b      	ldr	r3, [r3, #0]
3400758c:	461a      	mov	r2, r3
3400758e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007590:	021b      	lsls	r3, r3, #8
34007592:	4413      	add	r3, r2
34007594:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007598:	68db      	ldr	r3, [r3, #12]
3400759a:	68fa      	ldr	r2, [r7, #12]
3400759c:	6812      	ldr	r2, [r2, #0]
3400759e:	4611      	mov	r1, r2
340075a0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340075a2:	0212      	lsls	r2, r2, #8
340075a4:	440a      	add	r2, r1
340075a6:	f502 7280 	add.w	r2, r2, #256	@ 0x100
340075aa:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
340075ae:	f043 0301 	orr.w	r3, r3, #1
340075b2:	60d3      	str	r3, [r2, #12]
}
340075b4:	e379      	b.n	34007caa <LTDC_SetConfig+0xd0e>
  else if (Mirror == LTDC_MIRROR_VERTICAL)
340075b6:	683b      	ldr	r3, [r7, #0]
340075b8:	2b01      	cmp	r3, #1
340075ba:	f040 81b4 	bne.w	34007926 <LTDC_SetConfig+0x98a>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
340075be:	68fa      	ldr	r2, [r7, #12]
340075c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340075c2:	2134      	movs	r1, #52	@ 0x34
340075c4:	fb01 f303 	mul.w	r3, r1, r3
340075c8:	4413      	add	r3, r2
340075ca:	335c      	adds	r3, #92	@ 0x5c
340075cc:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
340075ce:	68f9      	ldr	r1, [r7, #12]
340075d0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340075d2:	2034      	movs	r0, #52	@ 0x34
340075d4:	fb00 f303 	mul.w	r3, r0, r3
340075d8:	440b      	add	r3, r1
340075da:	333c      	adds	r3, #60	@ 0x3c
340075dc:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
340075de:	68f8      	ldr	r0, [r7, #12]
340075e0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340075e2:	2434      	movs	r4, #52	@ 0x34
340075e4:	fb04 f303 	mul.w	r3, r4, r3
340075e8:	4403      	add	r3, r0
340075ea:	3338      	adds	r3, #56	@ 0x38
340075ec:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
340075ee:	1acb      	subs	r3, r1, r3
340075f0:	6979      	ldr	r1, [r7, #20]
340075f2:	fb01 f303 	mul.w	r3, r1, r3
                                          ((hltdc->LayerCfg[LayerIdx].WindowY1 -
340075f6:	68f8      	ldr	r0, [r7, #12]
340075f8:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
340075fa:	2434      	movs	r4, #52	@ 0x34
340075fc:	fb04 f101 	mul.w	r1, r4, r1
34007600:	4401      	add	r1, r0
34007602:	3144      	adds	r1, #68	@ 0x44
34007604:	6808      	ldr	r0, [r1, #0]
                                            hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
34007606:	68fc      	ldr	r4, [r7, #12]
34007608:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400760a:	2534      	movs	r5, #52	@ 0x34
3400760c:	fb05 f101 	mul.w	r1, r5, r1
34007610:	4421      	add	r1, r4
34007612:	3140      	adds	r1, #64	@ 0x40
34007614:	6809      	ldr	r1, [r1, #0]
                                          ((hltdc->LayerCfg[LayerIdx].WindowY1 -
34007616:	1a41      	subs	r1, r0, r1
                                            hltdc->LayerCfg[LayerIdx].WindowY0) - 1U));
34007618:	3901      	subs	r1, #1
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
3400761a:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
3400761e:	68f9      	ldr	r1, [r7, #12]
34007620:	6809      	ldr	r1, [r1, #0]
34007622:	4608      	mov	r0, r1
34007624:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34007626:	0209      	lsls	r1, r1, #8
34007628:	4401      	add	r1, r0
3400762a:	f501 7180 	add.w	r1, r1, #256	@ 0x100
3400762e:	4413      	add	r3, r2
34007630:	634b      	str	r3, [r1, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34007632:	68fa      	ldr	r2, [r7, #12]
34007634:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007636:	2134      	movs	r1, #52	@ 0x34
34007638:	fb01 f303 	mul.w	r3, r1, r3
3400763c:	4413      	add	r3, r2
3400763e:	3348      	adds	r3, #72	@ 0x48
34007640:	681b      	ldr	r3, [r3, #0]
34007642:	f240 120d 	movw	r2, #269	@ 0x10d
34007646:	4293      	cmp	r3, r2
34007648:	d004      	beq.n	34007654 <LTDC_SetConfig+0x6b8>
3400764a:	f240 220d 	movw	r2, #525	@ 0x20d
3400764e:	4293      	cmp	r3, r2
34007650:	d075      	beq.n	3400773e <LTDC_SetConfig+0x7a2>
        break;
34007652:	e122      	b.n	3400789a <LTDC_SetConfig+0x8fe>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
34007654:	68fa      	ldr	r2, [r7, #12]
34007656:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007658:	2134      	movs	r1, #52	@ 0x34
3400765a:	fb01 f303 	mul.w	r3, r1, r3
3400765e:	4413      	add	r3, r2
34007660:	333c      	adds	r3, #60	@ 0x3c
34007662:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
34007664:	68f9      	ldr	r1, [r7, #12]
34007666:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007668:	2034      	movs	r0, #52	@ 0x34
3400766a:	fb00 f303 	mul.w	r3, r0, r3
3400766e:	440b      	add	r3, r1
34007670:	3338      	adds	r3, #56	@ 0x38
34007672:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
34007674:	1ad3      	subs	r3, r2, r3
34007676:	697a      	ldr	r2, [r7, #20]
34007678:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400767c:	68f9      	ldr	r1, [r7, #12]
3400767e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007680:	2034      	movs	r0, #52	@ 0x34
34007682:	fb00 f202 	mul.w	r2, r0, r2
34007686:	440a      	add	r2, r1
34007688:	3244      	adds	r2, #68	@ 0x44
3400768a:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400768c:	68f8      	ldr	r0, [r7, #12]
3400768e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007690:	2434      	movs	r4, #52	@ 0x34
34007692:	fb04 f202 	mul.w	r2, r4, r2
34007696:	4402      	add	r2, r0
34007698:	3240      	adds	r2, #64	@ 0x40
3400769a:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
3400769c:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400769e:	0852      	lsrs	r2, r2, #1
340076a0:	3a01      	subs	r2, #1
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
340076a2:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
340076a6:	68fb      	ldr	r3, [r7, #12]
340076a8:	681b      	ldr	r3, [r3, #0]
340076aa:	4619      	mov	r1, r3
340076ac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340076ae:	021b      	lsls	r3, r3, #8
340076b0:	440b      	add	r3, r1
340076b2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
340076b6:	4619      	mov	r1, r3
340076b8:	68bb      	ldr	r3, [r7, #8]
340076ba:	4413      	add	r3, r2
340076bc:	640b      	str	r3, [r1, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
340076be:	68fa      	ldr	r2, [r7, #12]
340076c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340076c2:	2134      	movs	r1, #52	@ 0x34
340076c4:	fb01 f303 	mul.w	r3, r1, r3
340076c8:	4413      	add	r3, r2
340076ca:	3360      	adds	r3, #96	@ 0x60
340076cc:	681b      	ldr	r3, [r3, #0]
340076ce:	697a      	ldr	r2, [r7, #20]
340076d0:	fb02 f303 	mul.w	r3, r2, r3
340076d4:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
340076d8:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
340076da:	68f9      	ldr	r1, [r7, #12]
340076dc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340076de:	2034      	movs	r0, #52	@ 0x34
340076e0:	fb00 f303 	mul.w	r3, r0, r3
340076e4:	440b      	add	r3, r1
340076e6:	333c      	adds	r3, #60	@ 0x3c
340076e8:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U);
340076ea:	68f8      	ldr	r0, [r7, #12]
340076ec:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340076ee:	2434      	movs	r4, #52	@ 0x34
340076f0:	fb04 f303 	mul.w	r3, r4, r3
340076f4:	4403      	add	r3, r0
340076f6:	3338      	adds	r3, #56	@ 0x38
340076f8:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
340076fa:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride)  + 7U);
340076fc:	6979      	ldr	r1, [r7, #20]
340076fe:	fb01 f303 	mul.w	r3, r1, r3
34007702:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
34007704:	68f9      	ldr	r1, [r7, #12]
34007706:	6809      	ldr	r1, [r1, #0]
34007708:	4608      	mov	r0, r1
3400770a:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400770c:	0209      	lsls	r1, r1, #8
3400770e:	4401      	add	r1, r0
34007710:	f501 7180 	add.w	r1, r1, #256	@ 0x100
34007714:	4313      	orrs	r3, r2
34007716:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34007718:	68fa      	ldr	r2, [r7, #12]
3400771a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400771c:	2134      	movs	r1, #52	@ 0x34
3400771e:	fb01 f303 	mul.w	r3, r1, r3
34007722:	4413      	add	r3, r2
34007724:	3364      	adds	r3, #100	@ 0x64
34007726:	681b      	ldr	r3, [r3, #0]
34007728:	68fa      	ldr	r2, [r7, #12]
3400772a:	6812      	ldr	r2, [r2, #0]
3400772c:	4611      	mov	r1, r2
3400772e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007730:	0212      	lsls	r2, r2, #8
34007732:	440a      	add	r2, r1
34007734:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34007738:	085b      	lsrs	r3, r3, #1
3400773a:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
3400773c:	e0ad      	b.n	3400789a <LTDC_SetConfig+0x8fe>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400773e:	68fa      	ldr	r2, [r7, #12]
34007740:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007742:	2134      	movs	r1, #52	@ 0x34
34007744:	fb01 f303 	mul.w	r3, r1, r3
34007748:	4413      	add	r3, r2
3400774a:	333c      	adds	r3, #60	@ 0x3c
3400774c:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400774e:	68f9      	ldr	r1, [r7, #12]
34007750:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007752:	2034      	movs	r0, #52	@ 0x34
34007754:	fb00 f303 	mul.w	r3, r0, r3
34007758:	440b      	add	r3, r1
3400775a:	3338      	adds	r3, #56	@ 0x38
3400775c:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
3400775e:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34007760:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34007762:	697a      	ldr	r2, [r7, #20]
34007764:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
34007768:	68f9      	ldr	r1, [r7, #12]
3400776a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400776c:	2034      	movs	r0, #52	@ 0x34
3400776e:	fb00 f202 	mul.w	r2, r0, r2
34007772:	440a      	add	r2, r1
34007774:	3244      	adds	r2, #68	@ 0x44
34007776:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
34007778:	68f8      	ldr	r0, [r7, #12]
3400777a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400777c:	2434      	movs	r4, #52	@ 0x34
3400777e:	fb04 f202 	mul.w	r2, r4, r2
34007782:	4402      	add	r2, r0
34007784:	3240      	adds	r2, #64	@ 0x40
34007786:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
34007788:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
3400778a:	0852      	lsrs	r2, r2, #1
3400778c:	3a01      	subs	r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
3400778e:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34007792:	68fb      	ldr	r3, [r7, #12]
34007794:	681b      	ldr	r3, [r3, #0]
34007796:	4619      	mov	r1, r3
34007798:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400779a:	021b      	lsls	r3, r3, #8
3400779c:	440b      	add	r3, r1
3400779e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
340077a2:	4619      	mov	r1, r3
340077a4:	68bb      	ldr	r3, [r7, #8]
340077a6:	4413      	add	r3, r2
340077a8:	640b      	str	r3, [r1, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
340077aa:	68fa      	ldr	r2, [r7, #12]
340077ac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340077ae:	2134      	movs	r1, #52	@ 0x34
340077b0:	fb01 f303 	mul.w	r3, r1, r3
340077b4:	4413      	add	r3, r2
340077b6:	333c      	adds	r3, #60	@ 0x3c
340077b8:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
340077ba:	68f9      	ldr	r1, [r7, #12]
340077bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340077be:	2034      	movs	r0, #52	@ 0x34
340077c0:	fb00 f303 	mul.w	r3, r0, r3
340077c4:	440b      	add	r3, r1
340077c6:	3338      	adds	r3, #56	@ 0x38
340077c8:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
340077ca:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
340077cc:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
340077ce:	697a      	ldr	r2, [r7, #20]
340077d0:	fb02 f303 	mul.w	r3, r2, r3
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
340077d4:	68f9      	ldr	r1, [r7, #12]
340077d6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340077d8:	2034      	movs	r0, #52	@ 0x34
340077da:	fb00 f202 	mul.w	r2, r0, r2
340077de:	440a      	add	r2, r1
340077e0:	3244      	adds	r2, #68	@ 0x44
340077e2:	6811      	ldr	r1, [r2, #0]
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
340077e4:	68f8      	ldr	r0, [r7, #12]
340077e6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340077e8:	2434      	movs	r4, #52	@ 0x34
340077ea:	fb04 f202 	mul.w	r2, r4, r2
340077ee:	4402      	add	r2, r0
340077f0:	3240      	adds	r2, #64	@ 0x40
340077f2:	6812      	ldr	r2, [r2, #0]
                                               (((hltdc->LayerCfg[LayerIdx].WindowY1 -
340077f4:	1a8a      	subs	r2, r1, r2
                                                  hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U) - 1U));
340077f6:	0852      	lsrs	r2, r2, #1
340077f8:	3a01      	subs	r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
340077fa:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
340077fe:	68fb      	ldr	r3, [r7, #12]
34007800:	681b      	ldr	r3, [r3, #0]
34007802:	4619      	mov	r1, r3
34007804:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007806:	021b      	lsls	r3, r3, #8
34007808:	440b      	add	r3, r1
3400780a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
3400780e:	4619      	mov	r1, r3
34007810:	687b      	ldr	r3, [r7, #4]
34007812:	4413      	add	r3, r2
34007814:	644b      	str	r3, [r1, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
34007816:	68fa      	ldr	r2, [r7, #12]
34007818:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400781a:	2134      	movs	r1, #52	@ 0x34
3400781c:	fb01 f303 	mul.w	r3, r1, r3
34007820:	4413      	add	r3, r2
34007822:	3360      	adds	r3, #96	@ 0x60
34007824:	681b      	ldr	r3, [r3, #0]
34007826:	085b      	lsrs	r3, r3, #1
34007828:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
3400782c:	697a      	ldr	r2, [r7, #20]
3400782e:	fb02 f303 	mul.w	r3, r2, r3
                                               stride) << 16U) |
34007832:	041a      	lsls	r2, r3, #16
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
34007834:	68f9      	ldr	r1, [r7, #12]
34007836:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007838:	2034      	movs	r0, #52	@ 0x34
3400783a:	fb00 f303 	mul.w	r3, r0, r3
3400783e:	440b      	add	r3, r1
34007840:	333c      	adds	r3, #60	@ 0x3c
34007842:	6819      	ldr	r1, [r3, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
34007844:	68f8      	ldr	r0, [r7, #12]
34007846:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007848:	2434      	movs	r4, #52	@ 0x34
3400784a:	fb04 f303 	mul.w	r3, r4, r3
3400784e:	4403      	add	r3, r0
34007850:	3338      	adds	r3, #56	@ 0x38
34007852:	681b      	ldr	r3, [r3, #0]
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
34007854:	1acb      	subs	r3, r1, r3
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
34007856:	085b      	lsrs	r3, r3, #1
34007858:	6979      	ldr	r1, [r7, #20]
3400785a:	fb01 f303 	mul.w	r3, r1, r3
3400785e:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
34007860:	68f9      	ldr	r1, [r7, #12]
34007862:	6809      	ldr	r1, [r1, #0]
34007864:	4608      	mov	r0, r1
34007866:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34007868:	0209      	lsls	r1, r1, #8
3400786a:	4401      	add	r1, r0
3400786c:	f501 7180 	add.w	r1, r1, #256	@ 0x100
                                               stride) << 16U) |
34007870:	4313      	orrs	r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) *
34007872:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34007874:	68fa      	ldr	r2, [r7, #12]
34007876:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007878:	2134      	movs	r1, #52	@ 0x34
3400787a:	fb01 f303 	mul.w	r3, r1, r3
3400787e:	4413      	add	r3, r2
34007880:	3364      	adds	r3, #100	@ 0x64
34007882:	681b      	ldr	r3, [r3, #0]
34007884:	68fa      	ldr	r2, [r7, #12]
34007886:	6812      	ldr	r2, [r2, #0]
34007888:	4611      	mov	r1, r2
3400788a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400788c:	0212      	lsls	r2, r2, #8
3400788e:	440a      	add	r2, r1
34007890:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34007894:	085b      	lsrs	r3, r3, #1
34007896:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
34007898:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
3400789a:	68fa      	ldr	r2, [r7, #12]
3400789c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400789e:	2134      	movs	r1, #52	@ 0x34
340078a0:	fb01 f303 	mul.w	r3, r1, r3
340078a4:	4413      	add	r3, r2
340078a6:	3360      	adds	r3, #96	@ 0x60
340078a8:	681b      	ldr	r3, [r3, #0]
340078aa:	697a      	ldr	r2, [r7, #20]
340078ac:	fb02 f303 	mul.w	r3, r2, r3
340078b0:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
340078b4:	041a      	lsls	r2, r3, #16
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
340078b6:	68f9      	ldr	r1, [r7, #12]
340078b8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340078ba:	2034      	movs	r0, #52	@ 0x34
340078bc:	fb00 f303 	mul.w	r3, r0, r3
340078c0:	440b      	add	r3, r1
340078c2:	333c      	adds	r3, #60	@ 0x3c
340078c4:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
340078c6:	68f8      	ldr	r0, [r7, #12]
340078c8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340078ca:	2434      	movs	r4, #52	@ 0x34
340078cc:	fb04 f303 	mul.w	r3, r4, r3
340078d0:	4403      	add	r3, r0
340078d2:	3338      	adds	r3, #56	@ 0x38
340078d4:	681b      	ldr	r3, [r3, #0]
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
340078d6:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
340078d8:	6979      	ldr	r1, [r7, #20]
340078da:	fb01 f303 	mul.w	r3, r1, r3
340078de:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
340078e0:	68f9      	ldr	r1, [r7, #12]
340078e2:	6809      	ldr	r1, [r1, #0]
340078e4:	4608      	mov	r0, r1
340078e6:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
340078e8:	0209      	lsls	r1, r1, #8
340078ea:	4401      	add	r1, r0
340078ec:	f501 7180 	add.w	r1, r1, #256	@ 0x100
340078f0:	4313      	orrs	r3, r2
340078f2:	638b      	str	r3, [r1, #56]	@ 0x38
    MODIFY_REG(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN, LTDC_LxCR_LEN);
340078f4:	68fb      	ldr	r3, [r7, #12]
340078f6:	681b      	ldr	r3, [r3, #0]
340078f8:	461a      	mov	r2, r3
340078fa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340078fc:	021b      	lsls	r3, r3, #8
340078fe:	4413      	add	r3, r2
34007900:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007904:	68db      	ldr	r3, [r3, #12]
34007906:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
3400790a:	f023 0301 	bic.w	r3, r3, #1
3400790e:	68fa      	ldr	r2, [r7, #12]
34007910:	6812      	ldr	r2, [r2, #0]
34007912:	4611      	mov	r1, r2
34007914:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007916:	0212      	lsls	r2, r2, #8
34007918:	440a      	add	r2, r1
3400791a:	f502 7280 	add.w	r2, r2, #256	@ 0x100
3400791e:	f043 0301 	orr.w	r3, r3, #1
34007922:	60d3      	str	r3, [r2, #12]
}
34007924:	e1c1      	b.n	34007caa <LTDC_SetConfig+0xd0e>
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34007926:	68fa      	ldr	r2, [r7, #12]
34007928:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400792a:	2134      	movs	r1, #52	@ 0x34
3400792c:	fb01 f303 	mul.w	r3, r1, r3
34007930:	4413      	add	r3, r2
34007932:	335c      	adds	r3, #92	@ 0x5c
34007934:	681a      	ldr	r2, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
34007936:	68f9      	ldr	r1, [r7, #12]
34007938:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400793a:	2034      	movs	r0, #52	@ 0x34
3400793c:	fb00 f303 	mul.w	r3, r0, r3
34007940:	440b      	add	r3, r1
34007942:	333c      	adds	r3, #60	@ 0x3c
34007944:	6819      	ldr	r1, [r3, #0]
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
34007946:	68f8      	ldr	r0, [r7, #12]
34007948:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400794a:	2434      	movs	r4, #52	@ 0x34
3400794c:	fb04 f303 	mul.w	r3, r4, r3
34007950:	4403      	add	r3, r0
34007952:	3338      	adds	r3, #56	@ 0x38
34007954:	681b      	ldr	r3, [r3, #0]
                                         (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
34007956:	1acb      	subs	r3, r1, r3
34007958:	6979      	ldr	r1, [r7, #20]
3400795a:	fb01 f303 	mul.w	r3, r1, r3
                                          (hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400795e:	68f8      	ldr	r0, [r7, #12]
34007960:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34007962:	2434      	movs	r4, #52	@ 0x34
34007964:	fb04 f101 	mul.w	r1, r4, r1
34007968:	4401      	add	r1, r0
3400796a:	3144      	adds	r1, #68	@ 0x44
3400796c:	6808      	ldr	r0, [r1, #0]
                                           hltdc->LayerCfg[LayerIdx].WindowY0)) - 1U;
3400796e:	68fc      	ldr	r4, [r7, #12]
34007970:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34007972:	2534      	movs	r5, #52	@ 0x34
34007974:	fb05 f101 	mul.w	r1, r5, r1
34007978:	4421      	add	r1, r4
3400797a:	3140      	adds	r1, #64	@ 0x40
3400797c:	6809      	ldr	r1, [r1, #0]
                                          (hltdc->LayerCfg[LayerIdx].WindowY1 - \
3400797e:	1a41      	subs	r1, r0, r1
                                                    hltdc->LayerCfg[LayerIdx].WindowX0) *
34007980:	fb01 f303 	mul.w	r3, r1, r3
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34007984:	4413      	add	r3, r2
34007986:	68fa      	ldr	r2, [r7, #12]
34007988:	6812      	ldr	r2, [r2, #0]
3400798a:	4611      	mov	r1, r2
3400798c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400798e:	0212      	lsls	r2, r2, #8
34007990:	440a      	add	r2, r1
34007992:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                           hltdc->LayerCfg[LayerIdx].WindowY0)) - 1U;
34007996:	3b01      	subs	r3, #1
    LTDC_LAYER(hltdc, LayerIdx)->CFBAR = hltdc->LayerCfg[LayerIdx].FBStartAdress +
34007998:	6353      	str	r3, [r2, #52]	@ 0x34
    switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
3400799a:	68fa      	ldr	r2, [r7, #12]
3400799c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400799e:	2134      	movs	r1, #52	@ 0x34
340079a0:	fb01 f303 	mul.w	r3, r1, r3
340079a4:	4413      	add	r3, r2
340079a6:	3348      	adds	r3, #72	@ 0x48
340079a8:	681b      	ldr	r3, [r3, #0]
340079aa:	f240 120d 	movw	r2, #269	@ 0x10d
340079ae:	4293      	cmp	r3, r2
340079b0:	d004      	beq.n	340079bc <LTDC_SetConfig+0xa20>
340079b2:	f240 220d 	movw	r2, #525	@ 0x20d
340079b6:	4293      	cmp	r3, r2
340079b8:	d074      	beq.n	34007aa4 <LTDC_SetConfig+0xb08>
        break;
340079ba:	e133      	b.n	34007c24 <LTDC_SetConfig+0xc88>
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
340079bc:	68fa      	ldr	r2, [r7, #12]
340079be:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340079c0:	2134      	movs	r1, #52	@ 0x34
340079c2:	fb01 f303 	mul.w	r3, r1, r3
340079c6:	4413      	add	r3, r2
340079c8:	333c      	adds	r3, #60	@ 0x3c
340079ca:	681a      	ldr	r2, [r3, #0]
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
340079cc:	68f9      	ldr	r1, [r7, #12]
340079ce:	6abb      	ldr	r3, [r7, #40]	@ 0x28
340079d0:	2034      	movs	r0, #52	@ 0x34
340079d2:	fb00 f303 	mul.w	r3, r0, r3
340079d6:	440b      	add	r3, r1
340079d8:	3338      	adds	r3, #56	@ 0x38
340079da:	681b      	ldr	r3, [r3, #0]
                                              (stride * (hltdc->LayerCfg[LayerIdx].WindowX1 -
340079dc:	1ad3      	subs	r3, r2, r3
340079de:	697a      	ldr	r2, [r7, #20]
340079e0:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
340079e4:	68f9      	ldr	r1, [r7, #12]
340079e6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340079e8:	2034      	movs	r0, #52	@ 0x34
340079ea:	fb00 f202 	mul.w	r2, r0, r2
340079ee:	440a      	add	r2, r1
340079f0:	3244      	adds	r2, #68	@ 0x44
340079f2:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
340079f4:	68f8      	ldr	r0, [r7, #12]
340079f6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
340079f8:	2434      	movs	r4, #52	@ 0x34
340079fa:	fb04 f202 	mul.w	r2, r4, r2
340079fe:	4402      	add	r2, r0
34007a00:	3240      	adds	r2, #64	@ 0x40
34007a02:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
34007a04:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34007a06:	0852      	lsrs	r2, r2, #1
                                                         hltdc->LayerCfg[LayerIdx].WindowX0) *
34007a08:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34007a0c:	68bb      	ldr	r3, [r7, #8]
34007a0e:	4413      	add	r3, r2
34007a10:	68fa      	ldr	r2, [r7, #12]
34007a12:	6812      	ldr	r2, [r2, #0]
34007a14:	4611      	mov	r1, r2
34007a16:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007a18:	0212      	lsls	r2, r2, #8
34007a1a:	440a      	add	r2, r1
34007a1c:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34007a20:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34007a22:	6413      	str	r3, [r2, #64]	@ 0x40
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
34007a24:	68fa      	ldr	r2, [r7, #12]
34007a26:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007a28:	2134      	movs	r1, #52	@ 0x34
34007a2a:	fb01 f303 	mul.w	r3, r1, r3
34007a2e:	4413      	add	r3, r2
34007a30:	3360      	adds	r3, #96	@ 0x60
34007a32:	681b      	ldr	r3, [r3, #0]
34007a34:	697a      	ldr	r2, [r7, #20]
34007a36:	fb02 f303 	mul.w	r3, r2, r3
34007a3a:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
34007a3e:	041a      	lsls	r2, r3, #16
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
34007a40:	68f9      	ldr	r1, [r7, #12]
34007a42:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007a44:	2034      	movs	r0, #52	@ 0x34
34007a46:	fb00 f303 	mul.w	r3, r0, r3
34007a4a:	440b      	add	r3, r1
34007a4c:	333c      	adds	r3, #60	@ 0x3c
34007a4e:	6819      	ldr	r1, [r3, #0]
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U);
34007a50:	68f8      	ldr	r0, [r7, #12]
34007a52:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007a54:	2434      	movs	r4, #52	@ 0x34
34007a56:	fb04 f303 	mul.w	r3, r4, r3
34007a5a:	4403      	add	r3, r0
34007a5c:	3338      	adds	r3, #56	@ 0x38
34007a5e:	681b      	ldr	r3, [r3, #0]
                                             (((hltdc->LayerCfg[LayerIdx].WindowX1 -
34007a60:	1acb      	subs	r3, r1, r3
                                                hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U);
34007a62:	6979      	ldr	r1, [r7, #20]
34007a64:	fb01 f303 	mul.w	r3, r1, r3
34007a68:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = ((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride)) << 16U) |
34007a6a:	68f9      	ldr	r1, [r7, #12]
34007a6c:	6809      	ldr	r1, [r1, #0]
34007a6e:	4608      	mov	r0, r1
34007a70:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34007a72:	0209      	lsls	r1, r1, #8
34007a74:	4401      	add	r1, r0
34007a76:	f501 7180 	add.w	r1, r1, #256	@ 0x100
34007a7a:	4313      	orrs	r3, r2
34007a7c:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34007a7e:	68fa      	ldr	r2, [r7, #12]
34007a80:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007a82:	2134      	movs	r1, #52	@ 0x34
34007a84:	fb01 f303 	mul.w	r3, r1, r3
34007a88:	4413      	add	r3, r2
34007a8a:	3364      	adds	r3, #100	@ 0x64
34007a8c:	681b      	ldr	r3, [r3, #0]
34007a8e:	68fa      	ldr	r2, [r7, #12]
34007a90:	6812      	ldr	r2, [r2, #0]
34007a92:	4611      	mov	r1, r2
34007a94:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007a96:	0212      	lsls	r2, r2, #8
34007a98:	440a      	add	r2, r1
34007a9a:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34007a9e:	085b      	lsrs	r3, r3, #1
34007aa0:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
34007aa2:	e0bf      	b.n	34007c24 <LTDC_SetConfig+0xc88>
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34007aa4:	68fa      	ldr	r2, [r7, #12]
34007aa6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007aa8:	2134      	movs	r1, #52	@ 0x34
34007aaa:	fb01 f303 	mul.w	r3, r1, r3
34007aae:	4413      	add	r3, r2
34007ab0:	333c      	adds	r3, #60	@ 0x3c
34007ab2:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34007ab4:	68f9      	ldr	r1, [r7, #12]
34007ab6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007ab8:	2034      	movs	r0, #52	@ 0x34
34007aba:	fb00 f303 	mul.w	r3, r0, r3
34007abe:	440b      	add	r3, r1
34007ac0:	3338      	adds	r3, #56	@ 0x38
34007ac2:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34007ac4:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34007ac6:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34007ac8:	697a      	ldr	r2, [r7, #20]
34007aca:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
34007ace:	68f9      	ldr	r1, [r7, #12]
34007ad0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007ad2:	2034      	movs	r0, #52	@ 0x34
34007ad4:	fb00 f202 	mul.w	r2, r0, r2
34007ad8:	440a      	add	r2, r1
34007ada:	3244      	adds	r2, #68	@ 0x44
34007adc:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34007ade:	68f8      	ldr	r0, [r7, #12]
34007ae0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007ae2:	2434      	movs	r4, #52	@ 0x34
34007ae4:	fb04 f202 	mul.w	r2, r4, r2
34007ae8:	4402      	add	r2, r0
34007aea:	3240      	adds	r2, #64	@ 0x40
34007aec:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
34007aee:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34007af0:	0852      	lsrs	r2, r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34007af2:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34007af6:	68bb      	ldr	r3, [r7, #8]
34007af8:	4413      	add	r3, r2
34007afa:	68fa      	ldr	r2, [r7, #12]
34007afc:	6812      	ldr	r2, [r2, #0]
34007afe:	4611      	mov	r1, r2
34007b00:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007b02:	0212      	lsls	r2, r2, #8
34007b04:	440a      	add	r2, r1
34007b06:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34007b0a:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA0R = Aux0Addr +
34007b0c:	6413      	str	r3, [r2, #64]	@ 0x40
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34007b0e:	68fa      	ldr	r2, [r7, #12]
34007b10:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007b12:	2134      	movs	r1, #52	@ 0x34
34007b14:	fb01 f303 	mul.w	r3, r1, r3
34007b18:	4413      	add	r3, r2
34007b1a:	333c      	adds	r3, #60	@ 0x3c
34007b1c:	681a      	ldr	r2, [r3, #0]
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34007b1e:	68f9      	ldr	r1, [r7, #12]
34007b20:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007b22:	2034      	movs	r0, #52	@ 0x34
34007b24:	fb00 f303 	mul.w	r3, r0, r3
34007b28:	440b      	add	r3, r1
34007b2a:	3338      	adds	r3, #56	@ 0x38
34007b2c:	681b      	ldr	r3, [r3, #0]
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34007b2e:	1ad3      	subs	r3, r2, r3
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34007b30:	085b      	lsrs	r3, r3, #1
                                              (stride * ((hltdc->LayerCfg[LayerIdx].WindowX1 -
34007b32:	697a      	ldr	r2, [r7, #20]
34007b34:	fb02 f303 	mul.w	r3, r2, r3
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
34007b38:	68f9      	ldr	r1, [r7, #12]
34007b3a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007b3c:	2034      	movs	r0, #52	@ 0x34
34007b3e:	fb00 f202 	mul.w	r2, r0, r2
34007b42:	440a      	add	r2, r1
34007b44:	3244      	adds	r2, #68	@ 0x44
34007b46:	6811      	ldr	r1, [r2, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34007b48:	68f8      	ldr	r0, [r7, #12]
34007b4a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007b4c:	2434      	movs	r4, #52	@ 0x34
34007b4e:	fb04 f202 	mul.w	r2, r4, r2
34007b52:	4402      	add	r2, r0
34007b54:	3240      	adds	r2, #64	@ 0x40
34007b56:	6812      	ldr	r2, [r2, #0]
                                               ((hltdc->LayerCfg[LayerIdx].WindowY1 -
34007b58:	1a8a      	subs	r2, r1, r2
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34007b5a:	0852      	lsrs	r2, r2, #1
                                                          hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) *
34007b5c:	fb03 f202 	mul.w	r2, r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34007b60:	687b      	ldr	r3, [r7, #4]
34007b62:	4413      	add	r3, r2
34007b64:	68fa      	ldr	r2, [r7, #12]
34007b66:	6812      	ldr	r2, [r2, #0]
34007b68:	4611      	mov	r1, r2
34007b6a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007b6c:	0212      	lsls	r2, r2, #8
34007b6e:	440a      	add	r2, r1
34007b70:	f502 7280 	add.w	r2, r2, #256	@ 0x100
                                                 hltdc->LayerCfg[LayerIdx].WindowY0) >> 1U)) - 1U;
34007b74:	3b01      	subs	r3, #1
        LTDC_LAYER(hltdc, LayerIdx)->AFBA1R = Aux1Addr +
34007b76:	6453      	str	r3, [r2, #68]	@ 0x44
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34007b78:	68fa      	ldr	r2, [r7, #12]
34007b7a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007b7c:	2134      	movs	r1, #52	@ 0x34
34007b7e:	fb01 f303 	mul.w	r3, r1, r3
34007b82:	4413      	add	r3, r2
34007b84:	3360      	adds	r3, #96	@ 0x60
34007b86:	681b      	ldr	r3, [r3, #0]
34007b88:	085b      	lsrs	r3, r3, #1
34007b8a:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
34007b8e:	697a      	ldr	r2, [r7, #20]
34007b90:	fb02 f303 	mul.w	r3, r2, r3
                                              << 16U) |
34007b94:	041a      	lsls	r2, r3, #16
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
34007b96:	68f9      	ldr	r1, [r7, #12]
34007b98:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007b9a:	2034      	movs	r0, #52	@ 0x34
34007b9c:	fb00 f303 	mul.w	r3, r0, r3
34007ba0:	440b      	add	r3, r1
34007ba2:	333c      	adds	r3, #60	@ 0x3c
34007ba4:	6819      	ldr	r1, [r3, #0]
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
34007ba6:	68f8      	ldr	r0, [r7, #12]
34007ba8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007baa:	2434      	movs	r4, #52	@ 0x34
34007bac:	fb04 f303 	mul.w	r3, r4, r3
34007bb0:	4403      	add	r3, r0
34007bb2:	3338      	adds	r3, #56	@ 0x38
34007bb4:	681b      	ldr	r3, [r3, #0]
                                             ((((hltdc->LayerCfg[LayerIdx].WindowX1 -
34007bb6:	1acb      	subs	r3, r1, r3
                                                 hltdc->LayerCfg[LayerIdx].WindowX0) >> 1U) * stride) + 7U);
34007bb8:	085b      	lsrs	r3, r3, #1
34007bba:	6979      	ldr	r1, [r7, #20]
34007bbc:	fb01 f303 	mul.w	r3, r1, r3
34007bc0:	3307      	adds	r3, #7
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34007bc2:	68f9      	ldr	r1, [r7, #12]
34007bc4:	6809      	ldr	r1, [r1, #0]
34007bc6:	4608      	mov	r0, r1
34007bc8:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34007bca:	0209      	lsls	r1, r1, #8
34007bcc:	4401      	add	r1, r0
34007bce:	f501 7180 	add.w	r1, r1, #256	@ 0x100
                                              << 16U) |
34007bd2:	4313      	orrs	r3, r2
        LTDC_LAYER(hltdc, LayerIdx)->AFBLR = (((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth >> 1U)) * stride)
34007bd4:	648b      	str	r3, [r1, #72]	@ 0x48
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR &= ~(LTDC_L1AFBLNR_AFBLNBR);
34007bd6:	68fb      	ldr	r3, [r7, #12]
34007bd8:	681b      	ldr	r3, [r3, #0]
34007bda:	461a      	mov	r2, r3
34007bdc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007bde:	021b      	lsls	r3, r3, #8
34007be0:	4413      	add	r3, r2
34007be2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007be6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34007be8:	68fa      	ldr	r2, [r7, #12]
34007bea:	6812      	ldr	r2, [r2, #0]
34007bec:	4611      	mov	r1, r2
34007bee:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007bf0:	0212      	lsls	r2, r2, #8
34007bf2:	440a      	add	r2, r1
34007bf4:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34007bf8:	0c1b      	lsrs	r3, r3, #16
34007bfa:	041b      	lsls	r3, r3, #16
34007bfc:	64d3      	str	r3, [r2, #76]	@ 0x4c
        LTDC_LAYER(hltdc, LayerIdx)->AFBLNR = hltdc->LayerCfg[LayerIdx].ImageHeight >> 1U;
34007bfe:	68fa      	ldr	r2, [r7, #12]
34007c00:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007c02:	2134      	movs	r1, #52	@ 0x34
34007c04:	fb01 f303 	mul.w	r3, r1, r3
34007c08:	4413      	add	r3, r2
34007c0a:	3364      	adds	r3, #100	@ 0x64
34007c0c:	681b      	ldr	r3, [r3, #0]
34007c0e:	68fa      	ldr	r2, [r7, #12]
34007c10:	6812      	ldr	r2, [r2, #0]
34007c12:	4611      	mov	r1, r2
34007c14:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007c16:	0212      	lsls	r2, r2, #8
34007c18:	440a      	add	r2, r1
34007c1a:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34007c1e:	085b      	lsrs	r3, r3, #1
34007c20:	64d3      	str	r3, [r2, #76]	@ 0x4c
        break;
34007c22:	bf00      	nop
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
34007c24:	68fa      	ldr	r2, [r7, #12]
34007c26:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007c28:	2134      	movs	r1, #52	@ 0x34
34007c2a:	fb01 f303 	mul.w	r3, r1, r3
34007c2e:	4413      	add	r3, r2
34007c30:	3360      	adds	r3, #96	@ 0x60
34007c32:	681b      	ldr	r3, [r3, #0]
34007c34:	697a      	ldr	r2, [r7, #20]
34007c36:	fb02 f303 	mul.w	r3, r2, r3
34007c3a:	f5c3 4300 	rsb	r3, r3, #32768	@ 0x8000
34007c3e:	041a      	lsls	r2, r3, #16
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
34007c40:	68f9      	ldr	r1, [r7, #12]
34007c42:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007c44:	2034      	movs	r0, #52	@ 0x34
34007c46:	fb00 f303 	mul.w	r3, r0, r3
34007c4a:	440b      	add	r3, r1
34007c4c:	333c      	adds	r3, #60	@ 0x3c
34007c4e:	6819      	ldr	r1, [r3, #0]
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
34007c50:	68f8      	ldr	r0, [r7, #12]
34007c52:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007c54:	2434      	movs	r4, #52	@ 0x34
34007c56:	fb04 f303 	mul.w	r3, r4, r3
34007c5a:	4403      	add	r3, r0
34007c5c:	3338      	adds	r3, #56	@ 0x38
34007c5e:	681b      	ldr	r3, [r3, #0]
                                           (((hltdc->LayerCfg[LayerIdx].WindowX1 -
34007c60:	1acb      	subs	r3, r1, r3
                                              hltdc->LayerCfg[LayerIdx].WindowX0) * stride) + 7U));
34007c62:	6979      	ldr	r1, [r7, #20]
34007c64:	fb01 f303 	mul.w	r3, r1, r3
34007c68:	3307      	adds	r3, #7
    LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = ((((0x8000U - (hltdc->LayerCfg[LayerIdx].ImageWidth * stride))) << 16U) |
34007c6a:	68f9      	ldr	r1, [r7, #12]
34007c6c:	6809      	ldr	r1, [r1, #0]
34007c6e:	4608      	mov	r0, r1
34007c70:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
34007c72:	0209      	lsls	r1, r1, #8
34007c74:	4401      	add	r1, r0
34007c76:	f501 7180 	add.w	r1, r1, #256	@ 0x100
34007c7a:	4313      	orrs	r3, r2
34007c7c:	638b      	str	r3, [r1, #56]	@ 0x38
    SET_BIT(LTDC_LAYER(hltdc, LayerIdx)->CR, LTDC_LxCR_HMEN | LTDC_LxCR_LEN);
34007c7e:	68fb      	ldr	r3, [r7, #12]
34007c80:	681b      	ldr	r3, [r3, #0]
34007c82:	461a      	mov	r2, r3
34007c84:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007c86:	021b      	lsls	r3, r3, #8
34007c88:	4413      	add	r3, r2
34007c8a:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007c8e:	68db      	ldr	r3, [r3, #12]
34007c90:	68fa      	ldr	r2, [r7, #12]
34007c92:	6812      	ldr	r2, [r2, #0]
34007c94:	4611      	mov	r1, r2
34007c96:	6aba      	ldr	r2, [r7, #40]	@ 0x28
34007c98:	0212      	lsls	r2, r2, #8
34007c9a:	440a      	add	r2, r1
34007c9c:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34007ca0:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
34007ca4:	f043 0301 	orr.w	r3, r3, #1
34007ca8:	60d3      	str	r3, [r2, #12]
}
34007caa:	bf00      	nop
34007cac:	371c      	adds	r7, #28
34007cae:	46bd      	mov	sp, r7
34007cb0:	bcb0      	pop	{r4, r5, r7}
34007cb2:	4770      	bx	lr

34007cb4 <LTDC_SetCompositionConfig>:
  *                 - Other layer indices as defined by the hardware and used within the driver.
  *
  * @note This function is intended for internal use within the LTDC driver and does not return a value.
 */
static void LTDC_SetCompositionConfig(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{
34007cb4:	b480      	push	{r7}
34007cb6:	b087      	sub	sp, #28
34007cb8:	af00      	add	r7, sp, #0
34007cba:	6078      	str	r0, [r7, #4]
34007cbc:	6039      	str	r1, [r7, #0]
  uint32_t tmp;
  uint32_t tmp1;
  uint32_t tmp2;

  /* Configure the default color values */
  tmp = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Green) << 8U);
34007cbe:	687a      	ldr	r2, [r7, #4]
34007cc0:	683b      	ldr	r3, [r7, #0]
34007cc2:	2134      	movs	r1, #52	@ 0x34
34007cc4:	fb01 f303 	mul.w	r3, r1, r3
34007cc8:	4413      	add	r3, r2
34007cca:	3369      	adds	r3, #105	@ 0x69
34007ccc:	781b      	ldrb	r3, [r3, #0]
34007cce:	021b      	lsls	r3, r3, #8
34007cd0:	617b      	str	r3, [r7, #20]
  tmp1 = ((uint32_t)(hltdc->LayerCfg[LayerIdx].Backcolor.Red) << 16U);
34007cd2:	687a      	ldr	r2, [r7, #4]
34007cd4:	683b      	ldr	r3, [r7, #0]
34007cd6:	2134      	movs	r1, #52	@ 0x34
34007cd8:	fb01 f303 	mul.w	r3, r1, r3
34007cdc:	4413      	add	r3, r2
34007cde:	336a      	adds	r3, #106	@ 0x6a
34007ce0:	781b      	ldrb	r3, [r3, #0]
34007ce2:	041b      	lsls	r3, r3, #16
34007ce4:	613b      	str	r3, [r7, #16]
  tmp2 = (hltdc->LayerCfg[LayerIdx].Alpha0 << 24U);
34007ce6:	687a      	ldr	r2, [r7, #4]
34007ce8:	683b      	ldr	r3, [r7, #0]
34007cea:	2134      	movs	r1, #52	@ 0x34
34007cec:	fb01 f303 	mul.w	r3, r1, r3
34007cf0:	4413      	add	r3, r2
34007cf2:	3350      	adds	r3, #80	@ 0x50
34007cf4:	681b      	ldr	r3, [r3, #0]
34007cf6:	061b      	lsls	r3, r3, #24
34007cf8:	60fb      	str	r3, [r7, #12]
  WRITE_REG(LTDC_LAYER(hltdc, LayerIdx)->DCCR, (hltdc->LayerCfg[LayerIdx].Backcolor.Blue | tmp | tmp1 | tmp2));
34007cfa:	687a      	ldr	r2, [r7, #4]
34007cfc:	683b      	ldr	r3, [r7, #0]
34007cfe:	2134      	movs	r1, #52	@ 0x34
34007d00:	fb01 f303 	mul.w	r3, r1, r3
34007d04:	4413      	add	r3, r2
34007d06:	3368      	adds	r3, #104	@ 0x68
34007d08:	781b      	ldrb	r3, [r3, #0]
34007d0a:	461a      	mov	r2, r3
34007d0c:	697b      	ldr	r3, [r7, #20]
34007d0e:	431a      	orrs	r2, r3
34007d10:	693b      	ldr	r3, [r7, #16]
34007d12:	431a      	orrs	r2, r3
34007d14:	687b      	ldr	r3, [r7, #4]
34007d16:	681b      	ldr	r3, [r3, #0]
34007d18:	4619      	mov	r1, r3
34007d1a:	683b      	ldr	r3, [r7, #0]
34007d1c:	021b      	lsls	r3, r3, #8
34007d1e:	440b      	add	r3, r1
34007d20:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007d24:	4619      	mov	r1, r3
34007d26:	68fb      	ldr	r3, [r7, #12]
34007d28:	4313      	orrs	r3, r2
34007d2a:	624b      	str	r3, [r1, #36]	@ 0x24

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
34007d2c:	687b      	ldr	r3, [r7, #4]
34007d2e:	681b      	ldr	r3, [r3, #0]
34007d30:	461a      	mov	r2, r3
34007d32:	683b      	ldr	r3, [r7, #0]
34007d34:	021b      	lsls	r3, r3, #8
34007d36:	4413      	add	r3, r2
34007d38:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007d3c:	6a1b      	ldr	r3, [r3, #32]
34007d3e:	687a      	ldr	r2, [r7, #4]
34007d40:	6812      	ldr	r2, [r2, #0]
34007d42:	4611      	mov	r1, r2
34007d44:	683a      	ldr	r2, [r7, #0]
34007d46:	0212      	lsls	r2, r2, #8
34007d48:	440a      	add	r2, r1
34007d4a:	f502 7280 	add.w	r2, r2, #256	@ 0x100
34007d4e:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
34007d52:	6213      	str	r3, [r2, #32]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (hltdc->LayerCfg[LayerIdx].Alpha);
34007d54:	687b      	ldr	r3, [r7, #4]
34007d56:	681b      	ldr	r3, [r3, #0]
34007d58:	461a      	mov	r2, r3
34007d5a:	683b      	ldr	r3, [r7, #0]
34007d5c:	021b      	lsls	r3, r3, #8
34007d5e:	4413      	add	r3, r2
34007d60:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007d64:	4618      	mov	r0, r3
34007d66:	687a      	ldr	r2, [r7, #4]
34007d68:	683b      	ldr	r3, [r7, #0]
34007d6a:	2134      	movs	r1, #52	@ 0x34
34007d6c:	fb01 f303 	mul.w	r3, r1, r3
34007d70:	4413      	add	r3, r2
34007d72:	334c      	adds	r3, #76	@ 0x4c
34007d74:	681b      	ldr	r3, [r3, #0]
34007d76:	6203      	str	r3, [r0, #32]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BOR | LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
34007d78:	687b      	ldr	r3, [r7, #4]
34007d7a:	681b      	ldr	r3, [r3, #0]
34007d7c:	461a      	mov	r2, r3
34007d7e:	683b      	ldr	r3, [r7, #0]
34007d80:	021b      	lsls	r3, r3, #8
34007d82:	4413      	add	r3, r2
34007d84:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007d88:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34007d8a:	687b      	ldr	r3, [r7, #4]
34007d8c:	681b      	ldr	r3, [r3, #0]
34007d8e:	4619      	mov	r1, r3
34007d90:	683b      	ldr	r3, [r7, #0]
34007d92:	021b      	lsls	r3, r3, #8
34007d94:	440b      	add	r3, r1
34007d96:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007d9a:	4619      	mov	r1, r3
34007d9c:	4b18      	ldr	r3, [pc, #96]	@ (34007e00 <LTDC_SetCompositionConfig+0x14c>)
34007d9e:	4013      	ands	r3, r2
34007da0:	628b      	str	r3, [r1, #40]	@ 0x28
  tmp = ((uint32_t)(LTDC_LAYER(hltdc, LayerIdx)->BFCR & LTDC_LxBFCR_BOR_Msk) >> LTDC_LxBFCR_BOR_Pos) << 16U;
34007da2:	687b      	ldr	r3, [r7, #4]
34007da4:	681b      	ldr	r3, [r3, #0]
34007da6:	461a      	mov	r2, r3
34007da8:	683b      	ldr	r3, [r7, #0]
34007daa:	021b      	lsls	r3, r3, #8
34007dac:	4413      	add	r3, r2
34007dae:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007db2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
34007db4:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
34007db8:	617b      	str	r3, [r7, #20]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
34007dba:	687a      	ldr	r2, [r7, #4]
34007dbc:	683b      	ldr	r3, [r7, #0]
34007dbe:	2134      	movs	r1, #52	@ 0x34
34007dc0:	fb01 f303 	mul.w	r3, r1, r3
34007dc4:	4413      	add	r3, r2
34007dc6:	3354      	adds	r3, #84	@ 0x54
34007dc8:	681a      	ldr	r2, [r3, #0]
                                       hltdc->LayerCfg[LayerIdx].BlendingFactor2 | tmp);
34007dca:	6879      	ldr	r1, [r7, #4]
34007dcc:	683b      	ldr	r3, [r7, #0]
34007dce:	2034      	movs	r0, #52	@ 0x34
34007dd0:	fb00 f303 	mul.w	r3, r0, r3
34007dd4:	440b      	add	r3, r1
34007dd6:	3358      	adds	r3, #88	@ 0x58
34007dd8:	681b      	ldr	r3, [r3, #0]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
34007dda:	431a      	orrs	r2, r3
34007ddc:	687b      	ldr	r3, [r7, #4]
34007dde:	681b      	ldr	r3, [r3, #0]
34007de0:	4619      	mov	r1, r3
34007de2:	683b      	ldr	r3, [r7, #0]
34007de4:	021b      	lsls	r3, r3, #8
34007de6:	440b      	add	r3, r1
34007de8:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007dec:	4619      	mov	r1, r3
                                       hltdc->LayerCfg[LayerIdx].BlendingFactor2 | tmp);
34007dee:	697b      	ldr	r3, [r7, #20]
34007df0:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (hltdc->LayerCfg[LayerIdx].BlendingFactor1 |
34007df2:	628b      	str	r3, [r1, #40]	@ 0x28
}
34007df4:	bf00      	nop
34007df6:	371c      	adds	r7, #28
34007df8:	46bd      	mov	sp, r7
34007dfa:	f85d 7b04 	ldr.w	r7, [sp], #4
34007dfe:	4770      	bx	lr
34007e00:	fffef8f8 	.word	0xfffef8f8

34007e04 <LTDC_SetPredefFormat>:
  *
  *  @note This function does not return a value as it is a static function used internally within the
  *        driver.
  */
static void LTDC_SetPredefFormat(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{
34007e04:	b480      	push	{r7}
34007e06:	b08d      	sub	sp, #52	@ 0x34
34007e08:	af00      	add	r7, sp, #0
34007e0a:	6078      	str	r0, [r7, #4]
34007e0c:	6039      	str	r1, [r7, #0]
  uint32_t PSIZE = 0U;
34007e0e:	2300      	movs	r3, #0
34007e10:	62fb      	str	r3, [r7, #44]	@ 0x2c
  uint32_t ALEN = 0U;
34007e12:	2300      	movs	r3, #0
34007e14:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t APOS = 0U;
34007e16:	2300      	movs	r3, #0
34007e18:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t RLEN = 0U;
34007e1a:	2300      	movs	r3, #0
34007e1c:	623b      	str	r3, [r7, #32]
  uint32_t RPOS = 0U;
34007e1e:	2300      	movs	r3, #0
34007e20:	61fb      	str	r3, [r7, #28]
  uint32_t BLEN = 0U;
34007e22:	2300      	movs	r3, #0
34007e24:	61bb      	str	r3, [r7, #24]
  uint32_t BPOS = 0U;
34007e26:	2300      	movs	r3, #0
34007e28:	617b      	str	r3, [r7, #20]
  uint32_t GLEN = 0U;
34007e2a:	2300      	movs	r3, #0
34007e2c:	613b      	str	r3, [r7, #16]
  uint32_t GPOS = 0U;
34007e2e:	2300      	movs	r3, #0
34007e30:	60fb      	str	r3, [r7, #12]

  /* Specify Flex ARGB parameters according to pixel format */
  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34007e32:	687a      	ldr	r2, [r7, #4]
34007e34:	683b      	ldr	r3, [r7, #0]
34007e36:	2134      	movs	r1, #52	@ 0x34
34007e38:	fb01 f303 	mul.w	r3, r1, r3
34007e3c:	4413      	add	r3, r2
34007e3e:	3348      	adds	r3, #72	@ 0x48
34007e40:	681b      	ldr	r3, [r3, #0]
34007e42:	3b07      	subs	r3, #7
34007e44:	2b04      	cmp	r3, #4
34007e46:	d86c      	bhi.n	34007f22 <LTDC_SetPredefFormat+0x11e>
34007e48:	a201      	add	r2, pc, #4	@ (adr r2, 34007e50 <LTDC_SetPredefFormat+0x4c>)
34007e4a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
34007e4e:	bf00      	nop
34007e50:	34007e65 	.word	0x34007e65
34007e54:	34007e8b 	.word	0x34007e8b
34007e58:	34007eb1 	.word	0x34007eb1
34007e5c:	34007ed7 	.word	0x34007ed7
34007e60:	34007efd 	.word	0x34007efd
  {
    case LTDC_PIXEL_FORMAT_ARGB1555:
      PSIZE = 2U;
34007e64:	2302      	movs	r3, #2
34007e66:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 1U;
34007e68:	2301      	movs	r3, #1
34007e6a:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 15U;
34007e6c:	230f      	movs	r3, #15
34007e6e:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 5U;
34007e70:	2305      	movs	r3, #5
34007e72:	623b      	str	r3, [r7, #32]
      RPOS = 10U;
34007e74:	230a      	movs	r3, #10
34007e76:	61fb      	str	r3, [r7, #28]
      GLEN = 5U;
34007e78:	2305      	movs	r3, #5
34007e7a:	613b      	str	r3, [r7, #16]
      GPOS = 5U;
34007e7c:	2305      	movs	r3, #5
34007e7e:	60fb      	str	r3, [r7, #12]
      BLEN = 5U;
34007e80:	2305      	movs	r3, #5
34007e82:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
34007e84:	2300      	movs	r3, #0
34007e86:	617b      	str	r3, [r7, #20]
      break;
34007e88:	e04c      	b.n	34007f24 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_ARGB4444:
      PSIZE = 2U;
34007e8a:	2302      	movs	r3, #2
34007e8c:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 4U;
34007e8e:	2304      	movs	r3, #4
34007e90:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 12U;
34007e92:	230c      	movs	r3, #12
34007e94:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 4U;
34007e96:	2304      	movs	r3, #4
34007e98:	623b      	str	r3, [r7, #32]
      RPOS = 8U;
34007e9a:	2308      	movs	r3, #8
34007e9c:	61fb      	str	r3, [r7, #28]
      GLEN = 4U;
34007e9e:	2304      	movs	r3, #4
34007ea0:	613b      	str	r3, [r7, #16]
      GPOS = 4U;
34007ea2:	2304      	movs	r3, #4
34007ea4:	60fb      	str	r3, [r7, #12]
      BLEN = 4U;
34007ea6:	2304      	movs	r3, #4
34007ea8:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
34007eaa:	2300      	movs	r3, #0
34007eac:	617b      	str	r3, [r7, #20]
      break;
34007eae:	e039      	b.n	34007f24 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_L8:
      PSIZE = 1U;
34007eb0:	2301      	movs	r3, #1
34007eb2:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 0U;
34007eb4:	2300      	movs	r3, #0
34007eb6:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 0U;
34007eb8:	2300      	movs	r3, #0
34007eba:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 8U;
34007ebc:	2308      	movs	r3, #8
34007ebe:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
34007ec0:	2300      	movs	r3, #0
34007ec2:	61fb      	str	r3, [r7, #28]
      GLEN = 8U;
34007ec4:	2308      	movs	r3, #8
34007ec6:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
34007ec8:	2300      	movs	r3, #0
34007eca:	60fb      	str	r3, [r7, #12]
      BLEN = 8U;
34007ecc:	2308      	movs	r3, #8
34007ece:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
34007ed0:	2300      	movs	r3, #0
34007ed2:	617b      	str	r3, [r7, #20]
      break;
34007ed4:	e026      	b.n	34007f24 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_AL44:
      PSIZE = 1U;
34007ed6:	2301      	movs	r3, #1
34007ed8:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 4U;
34007eda:	2304      	movs	r3, #4
34007edc:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 4U;
34007ede:	2304      	movs	r3, #4
34007ee0:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 4U;
34007ee2:	2304      	movs	r3, #4
34007ee4:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
34007ee6:	2300      	movs	r3, #0
34007ee8:	61fb      	str	r3, [r7, #28]
      GLEN = 4U;
34007eea:	2304      	movs	r3, #4
34007eec:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
34007eee:	2300      	movs	r3, #0
34007ef0:	60fb      	str	r3, [r7, #12]
      BLEN = 4U;
34007ef2:	2304      	movs	r3, #4
34007ef4:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
34007ef6:	2300      	movs	r3, #0
34007ef8:	617b      	str	r3, [r7, #20]
      break;
34007efa:	e013      	b.n	34007f24 <LTDC_SetPredefFormat+0x120>
    case LTDC_PIXEL_FORMAT_AL88:
      PSIZE = 2U;
34007efc:	2302      	movs	r3, #2
34007efe:	62fb      	str	r3, [r7, #44]	@ 0x2c
      ALEN = 8U;
34007f00:	2308      	movs	r3, #8
34007f02:	62bb      	str	r3, [r7, #40]	@ 0x28
      APOS = 8U;
34007f04:	2308      	movs	r3, #8
34007f06:	627b      	str	r3, [r7, #36]	@ 0x24
      RLEN = 8U;
34007f08:	2308      	movs	r3, #8
34007f0a:	623b      	str	r3, [r7, #32]
      RPOS = 0U;
34007f0c:	2300      	movs	r3, #0
34007f0e:	61fb      	str	r3, [r7, #28]
      GLEN = 8U;
34007f10:	2308      	movs	r3, #8
34007f12:	613b      	str	r3, [r7, #16]
      GPOS = 0U;
34007f14:	2300      	movs	r3, #0
34007f16:	60fb      	str	r3, [r7, #12]
      BLEN = 8U;
34007f18:	2308      	movs	r3, #8
34007f1a:	61bb      	str	r3, [r7, #24]
      BPOS = 0U;
34007f1c:	2300      	movs	r3, #0
34007f1e:	617b      	str	r3, [r7, #20]
      break;
34007f20:	e000      	b.n	34007f24 <LTDC_SetPredefFormat+0x120>
    default:
      break;
34007f22:	bf00      	nop
  }

  switch (hltdc->LayerCfg[LayerIdx].PixelFormat)
34007f24:	687a      	ldr	r2, [r7, #4]
34007f26:	683b      	ldr	r3, [r7, #0]
34007f28:	2134      	movs	r1, #52	@ 0x34
34007f2a:	fb01 f303 	mul.w	r3, r1, r3
34007f2e:	4413      	add	r3, r2
34007f30:	3348      	adds	r3, #72	@ 0x48
34007f32:	681b      	ldr	r3, [r3, #0]
34007f34:	2b06      	cmp	r3, #6
34007f36:	d903      	bls.n	34007f40 <LTDC_SetPredefFormat+0x13c>
34007f38:	3b07      	subs	r3, #7
34007f3a:	2b04      	cmp	r3, #4
34007f3c:	d860      	bhi.n	34008000 <LTDC_SetPredefFormat+0x1fc>
34007f3e:	e028      	b.n	34007f92 <LTDC_SetPredefFormat+0x18e>
    case LTDC_PIXEL_FORMAT_RGBA8888:
    case LTDC_PIXEL_FORMAT_BGRA8888:
    case LTDC_PIXEL_FORMAT_RGB565:
    case LTDC_PIXEL_FORMAT_BGR565:
    case LTDC_PIXEL_FORMAT_RGB888:
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = (hltdc->LayerCfg[LayerIdx].PixelFormat);
34007f40:	687b      	ldr	r3, [r7, #4]
34007f42:	681b      	ldr	r3, [r3, #0]
34007f44:	461a      	mov	r2, r3
34007f46:	683b      	ldr	r3, [r7, #0]
34007f48:	021b      	lsls	r3, r3, #8
34007f4a:	4413      	add	r3, r2
34007f4c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007f50:	4618      	mov	r0, r3
34007f52:	687a      	ldr	r2, [r7, #4]
34007f54:	683b      	ldr	r3, [r7, #0]
34007f56:	2134      	movs	r1, #52	@ 0x34
34007f58:	fb01 f303 	mul.w	r3, r1, r3
34007f5c:	4413      	add	r3, r2
34007f5e:	3348      	adds	r3, #72	@ 0x48
34007f60:	681b      	ldr	r3, [r3, #0]
34007f62:	61c3      	str	r3, [r0, #28]
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = 0U;
34007f64:	687b      	ldr	r3, [r7, #4]
34007f66:	681b      	ldr	r3, [r3, #0]
34007f68:	461a      	mov	r2, r3
34007f6a:	683b      	ldr	r3, [r7, #0]
34007f6c:	021b      	lsls	r3, r3, #8
34007f6e:	4413      	add	r3, r2
34007f70:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007f74:	461a      	mov	r2, r3
34007f76:	2300      	movs	r3, #0
34007f78:	6753      	str	r3, [r2, #116]	@ 0x74
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = 0U;
34007f7a:	687b      	ldr	r3, [r7, #4]
34007f7c:	681b      	ldr	r3, [r3, #0]
34007f7e:	461a      	mov	r2, r3
34007f80:	683b      	ldr	r3, [r7, #0]
34007f82:	021b      	lsls	r3, r3, #8
34007f84:	4413      	add	r3, r2
34007f86:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007f8a:	461a      	mov	r2, r3
34007f8c:	2300      	movs	r3, #0
34007f8e:	6793      	str	r3, [r2, #120]	@ 0x78
      break;
34007f90:	e037      	b.n	34008002 <LTDC_SetPredefFormat+0x1fe>
    case LTDC_PIXEL_FORMAT_ARGB1555:
    case LTDC_PIXEL_FORMAT_ARGB4444:
    case LTDC_PIXEL_FORMAT_L8:
    case LTDC_PIXEL_FORMAT_AL44:
    case LTDC_PIXEL_FORMAT_AL88:
      LTDC_LAYER(hltdc, LayerIdx)->PFCR = LTDC_LxPFCR_PF;
34007f92:	687b      	ldr	r3, [r7, #4]
34007f94:	681b      	ldr	r3, [r3, #0]
34007f96:	461a      	mov	r2, r3
34007f98:	683b      	ldr	r3, [r7, #0]
34007f9a:	021b      	lsls	r3, r3, #8
34007f9c:	4413      	add	r3, r2
34007f9e:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007fa2:	461a      	mov	r2, r3
34007fa4:	2307      	movs	r3, #7
34007fa6:	61d3      	str	r3, [r2, #28]
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
34007fa8:	6a3b      	ldr	r3, [r7, #32]
34007faa:	039a      	lsls	r2, r3, #14
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
34007fac:	69fb      	ldr	r3, [r7, #28]
34007fae:	025b      	lsls	r3, r3, #9
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
34007fb0:	441a      	add	r2, r3
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
34007fb2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
34007fb4:	015b      	lsls	r3, r3, #5
                                           (RPOS << LTDC_LxFPF0R_RPOS_Pos) +
34007fb6:	441a      	add	r2, r3
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
34007fb8:	687b      	ldr	r3, [r7, #4]
34007fba:	681b      	ldr	r3, [r3, #0]
34007fbc:	4619      	mov	r1, r3
34007fbe:	683b      	ldr	r3, [r7, #0]
34007fc0:	021b      	lsls	r3, r3, #8
34007fc2:	440b      	add	r3, r1
34007fc4:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007fc8:	4619      	mov	r1, r3
                                           (ALEN << LTDC_LxFPF0R_ALEN_Pos) +
34007fca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
34007fcc:	4413      	add	r3, r2
      LTDC_LAYER(hltdc, LayerIdx)->FPF0R = (RLEN << LTDC_LxFPF0R_RLEN_Pos) +
34007fce:	674b      	str	r3, [r1, #116]	@ 0x74
                                           APOS;
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
34007fd0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
34007fd2:	049a      	lsls	r2, r3, #18
                                           (BLEN << LTDC_LxFPF1R_BLEN_Pos)  +
34007fd4:	69bb      	ldr	r3, [r7, #24]
34007fd6:	039b      	lsls	r3, r3, #14
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
34007fd8:	441a      	add	r2, r3
                                           (BPOS << LTDC_LxFPF1R_BPOS_Pos) +
34007fda:	697b      	ldr	r3, [r7, #20]
34007fdc:	025b      	lsls	r3, r3, #9
                                           (BLEN << LTDC_LxFPF1R_BLEN_Pos)  +
34007fde:	441a      	add	r2, r3
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
34007fe0:	693b      	ldr	r3, [r7, #16]
34007fe2:	015b      	lsls	r3, r3, #5
                                           (BPOS << LTDC_LxFPF1R_BPOS_Pos) +
34007fe4:	441a      	add	r2, r3
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
34007fe6:	687b      	ldr	r3, [r7, #4]
34007fe8:	681b      	ldr	r3, [r3, #0]
34007fea:	4619      	mov	r1, r3
34007fec:	683b      	ldr	r3, [r7, #0]
34007fee:	021b      	lsls	r3, r3, #8
34007ff0:	440b      	add	r3, r1
34007ff2:	f503 7380 	add.w	r3, r3, #256	@ 0x100
34007ff6:	4619      	mov	r1, r3
                                           (GLEN << LTDC_LxFPF1R_GLEN_Pos) +
34007ff8:	68fb      	ldr	r3, [r7, #12]
34007ffa:	4413      	add	r3, r2
      LTDC_LAYER(hltdc, LayerIdx)->FPF1R = (PSIZE << LTDC_LxFPF1R_PSIZE_Pos) +
34007ffc:	678b      	str	r3, [r1, #120]	@ 0x78
                                           GPOS;
      break;
34007ffe:	e000      	b.n	34008002 <LTDC_SetPredefFormat+0x1fe>
    default:
      break;
34008000:	bf00      	nop
  }
}
34008002:	bf00      	nop
34008004:	3734      	adds	r7, #52	@ 0x34
34008006:	46bd      	mov	sp, r7
34008008:	f85d 7b04 	ldr.w	r7, [sp], #4
3400800c:	4770      	bx	lr
3400800e:	bf00      	nop

34008010 <HAL_PWREx_EnableVddIO2>:
  * @brief  Enable VDDIO2 supply valid.
  * @note   Setting this bit is mandatory to use PO[5:0] and PP[15:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO2(void)
{
34008010:	b480      	push	{r7}
34008012:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO2SV);
34008014:	4b05      	ldr	r3, [pc, #20]	@ (3400802c <HAL_PWREx_EnableVddIO2+0x1c>)
34008016:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34008018:	4a04      	ldr	r2, [pc, #16]	@ (3400802c <HAL_PWREx_EnableVddIO2+0x1c>)
3400801a:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3400801e:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
34008020:	bf00      	nop
34008022:	46bd      	mov	sp, r7
34008024:	f85d 7b04 	ldr.w	r7, [sp], #4
34008028:	4770      	bx	lr
3400802a:	bf00      	nop
3400802c:	56024800 	.word	0x56024800

34008030 <HAL_PWREx_EnableVddIO3>:
  * @brief  Enable VDDIO3 supply valid.
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO3(void)
{
34008030:	b480      	push	{r7}
34008032:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR3, PWR_SVMCR3_VDDIO3SV);
34008034:	4b05      	ldr	r3, [pc, #20]	@ (3400804c <HAL_PWREx_EnableVddIO3+0x1c>)
34008036:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34008038:	4a04      	ldr	r2, [pc, #16]	@ (3400804c <HAL_PWREx_EnableVddIO3+0x1c>)
3400803a:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
3400803e:	63d3      	str	r3, [r2, #60]	@ 0x3c
}
34008040:	bf00      	nop
34008042:	46bd      	mov	sp, r7
34008044:	f85d 7b04 	ldr.w	r7, [sp], #4
34008048:	4770      	bx	lr
3400804a:	bf00      	nop
3400804c:	56024800 	.word	0x56024800

34008050 <HAL_PWREx_EnableVddIO4>:
  * @brief  Enable VDDIO4 supply valid.
  * @note   Setting this bit is mandatory to use PB[9,8], PC[12:6], and PD[2] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO4(void)
{
34008050:	b480      	push	{r7}
34008052:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR1, PWR_SVMCR1_VDDIO4SV);
34008054:	4b05      	ldr	r3, [pc, #20]	@ (3400806c <HAL_PWREx_EnableVddIO4+0x1c>)
34008056:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
34008058:	4a04      	ldr	r2, [pc, #16]	@ (3400806c <HAL_PWREx_EnableVddIO4+0x1c>)
3400805a:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3400805e:	6353      	str	r3, [r2, #52]	@ 0x34
}
34008060:	bf00      	nop
34008062:	46bd      	mov	sp, r7
34008064:	f85d 7b04 	ldr.w	r7, [sp], #4
34008068:	4770      	bx	lr
3400806a:	bf00      	nop
3400806c:	56024800 	.word	0x56024800

34008070 <HAL_PWREx_EnableVddIO5>:
  * @brief  Enable VDDIO5 supply valid.
  * @note   Setting this bit is mandatory to use PN[12:0] I/Os.
  * @retval None.
  */
void HAL_PWREx_EnableVddIO5(void)
{
34008070:	b480      	push	{r7}
34008072:	af00      	add	r7, sp, #0
  SET_BIT(PWR->SVMCR2, PWR_SVMCR2_VDDIO5SV);
34008074:	4b05      	ldr	r3, [pc, #20]	@ (3400808c <HAL_PWREx_EnableVddIO5+0x1c>)
34008076:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
34008078:	4a04      	ldr	r2, [pc, #16]	@ (3400808c <HAL_PWREx_EnableVddIO5+0x1c>)
3400807a:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
3400807e:	6393      	str	r3, [r2, #56]	@ 0x38
}
34008080:	bf00      	nop
34008082:	46bd      	mov	sp, r7
34008084:	f85d 7b04 	ldr.w	r7, [sp], #4
34008088:	4770      	bx	lr
3400808a:	bf00      	nop
3400808c:	56024800 	.word	0x56024800

34008090 <LL_RCC_HSE_SelectHSEAsDiv2Clock>:
  * @brief  Select the HSE as hse_div2_osc_ck output clock
  * @rmtoll HSECFGR      HSEDIV2SEL    LL_RCC_HSE_SelectHSEAsDiv2Clock
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSE_SelectHSEAsDiv2Clock(void)
{
34008090:	b480      	push	{r7}
34008092:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
34008094:	4b05      	ldr	r3, [pc, #20]	@ (340080ac <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
34008096:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34008098:	4a04      	ldr	r2, [pc, #16]	@ (340080ac <LL_RCC_HSE_SelectHSEAsDiv2Clock+0x1c>)
3400809a:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
3400809e:	6553      	str	r3, [r2, #84]	@ 0x54
}
340080a0:	bf00      	nop
340080a2:	46bd      	mov	sp, r7
340080a4:	f85d 7b04 	ldr.w	r7, [sp], #4
340080a8:	4770      	bx	lr
340080aa:	bf00      	nop
340080ac:	56028000 	.word	0x56028000

340080b0 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>:
  * @brief  Select the HSE divided by 2 as hse_div2_osc_ck output clock
  * @rmtoll HSECFGR      HSEDIV2SEL    LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock(void)
{
340080b0:	b480      	push	{r7}
340080b2:	af00      	add	r7, sp, #0
  SET_BIT(RCC->HSECFGR, RCC_HSECFGR_HSEDIV2SEL);
340080b4:	4b05      	ldr	r3, [pc, #20]	@ (340080cc <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
340080b6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340080b8:	4a04      	ldr	r2, [pc, #16]	@ (340080cc <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock+0x1c>)
340080ba:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
340080be:	6553      	str	r3, [r2, #84]	@ 0x54
}
340080c0:	bf00      	nop
340080c2:	46bd      	mov	sp, r7
340080c4:	f85d 7b04 	ldr.w	r7, [sp], #4
340080c8:	4770      	bx	lr
340080ca:	bf00      	nop
340080cc:	56028000 	.word	0x56028000

340080d0 <LL_RCC_LSE_IsReady>:
  * @brief  Check if LSE oscillator Ready
  * @rmtoll SR           LSERDY        LL_RCC_LSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSE_IsReady(void)
{
340080d0:	b480      	push	{r7}
340080d2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->SR, RCC_SR_LSERDY) != 0UL) ? 1UL : 0UL);
340080d4:	4b06      	ldr	r3, [pc, #24]	@ (340080f0 <LL_RCC_LSE_IsReady+0x20>)
340080d6:	685b      	ldr	r3, [r3, #4]
340080d8:	f003 0302 	and.w	r3, r3, #2
340080dc:	2b00      	cmp	r3, #0
340080de:	d001      	beq.n	340080e4 <LL_RCC_LSE_IsReady+0x14>
340080e0:	2301      	movs	r3, #1
340080e2:	e000      	b.n	340080e6 <LL_RCC_LSE_IsReady+0x16>
340080e4:	2300      	movs	r3, #0
}
340080e6:	4618      	mov	r0, r3
340080e8:	46bd      	mov	sp, r7
340080ea:	f85d 7b04 	ldr.w	r7, [sp], #4
340080ee:	4770      	bx	lr
340080f0:	56028000 	.word	0x56028000

340080f4 <LL_RCC_SetClockSource>:
  *         @arg @ref LL_RCC_XSPI3_CLKSOURCE_IC3
  *         @arg @ref LL_RCC_XSPI3_CLKSOURCE_IC4
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetClockSource(uint32_t ClkSource)
{
340080f4:	b480      	push	{r7}
340080f6:	b085      	sub	sp, #20
340080f8:	af00      	add	r7, sp, #0
340080fa:	6078      	str	r0, [r7, #4]
  volatile uint32_t *pReg = (uint32_t *)((uint32_t)&RCC->CCIPR1 + LL_CLKSOURCE_REG(ClkSource));
340080fc:	687b      	ldr	r3, [r7, #4]
340080fe:	b2da      	uxtb	r2, r3
34008100:	4b10      	ldr	r3, [pc, #64]	@ (34008144 <LL_RCC_SetClockSource+0x50>)
34008102:	4413      	add	r3, r2
34008104:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(*pReg, LL_CLKSOURCE_MASK(ClkSource), LL_CLKSOURCE_CONFIG(ClkSource));
34008106:	68fb      	ldr	r3, [r7, #12]
34008108:	681a      	ldr	r2, [r3, #0]
3400810a:	687b      	ldr	r3, [r7, #4]
3400810c:	0e19      	lsrs	r1, r3, #24
3400810e:	687b      	ldr	r3, [r7, #4]
34008110:	0a1b      	lsrs	r3, r3, #8
34008112:	f003 031f 	and.w	r3, r3, #31
34008116:	fa01 f303 	lsl.w	r3, r1, r3
3400811a:	43db      	mvns	r3, r3
3400811c:	401a      	ands	r2, r3
3400811e:	687b      	ldr	r3, [r7, #4]
34008120:	0c1b      	lsrs	r3, r3, #16
34008122:	b2d9      	uxtb	r1, r3
34008124:	687b      	ldr	r3, [r7, #4]
34008126:	0a1b      	lsrs	r3, r3, #8
34008128:	f003 031f 	and.w	r3, r3, #31
3400812c:	fa01 f303 	lsl.w	r3, r1, r3
34008130:	431a      	orrs	r2, r3
34008132:	68fb      	ldr	r3, [r7, #12]
34008134:	601a      	str	r2, [r3, #0]
}
34008136:	bf00      	nop
34008138:	3714      	adds	r7, #20
3400813a:	46bd      	mov	sp, r7
3400813c:	f85d 7b04 	ldr.w	r7, [sp], #4
34008140:	4770      	bx	lr
34008142:	bf00      	nop
34008144:	56028144 	.word	0x56028144

34008148 <LL_RCC_SetADFClockSource>:
  *         @arg @ref LL_RCC_ADF1_CLKSOURCE_I2S_CKIN
  *         @arg @ref LL_RCC_ADF1_CLKSOURCE_TIMG
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetADFClockSource(uint32_t ClkSource)
{
34008148:	b480      	push	{r7}
3400814a:	b083      	sub	sp, #12
3400814c:	af00      	add	r7, sp, #0
3400814e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_ADF1SEL, ClkSource);
34008150:	4b07      	ldr	r3, [pc, #28]	@ (34008170 <LL_RCC_SetADFClockSource+0x28>)
34008152:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34008156:	f023 0207 	bic.w	r2, r3, #7
3400815a:	4905      	ldr	r1, [pc, #20]	@ (34008170 <LL_RCC_SetADFClockSource+0x28>)
3400815c:	687b      	ldr	r3, [r7, #4]
3400815e:	4313      	orrs	r3, r2
34008160:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
34008164:	bf00      	nop
34008166:	370c      	adds	r7, #12
34008168:	46bd      	mov	sp, r7
3400816a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400816e:	4770      	bx	lr
34008170:	56028000 	.word	0x56028000

34008174 <LL_RCC_SetCLKPClockSource>:
  *         @arg @ref LL_RCC_CLKP_CLKSOURCE_IC15
  *         @arg @ref LL_RCC_CLKP_CLKSOURCE_IC20
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetCLKPClockSource(uint32_t ClkSource)
{
34008174:	b480      	push	{r7}
34008176:	b083      	sub	sp, #12
34008178:	af00      	add	r7, sp, #0
3400817a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PERSEL, ClkSource);
3400817c:	4b07      	ldr	r3, [pc, #28]	@ (3400819c <LL_RCC_SetCLKPClockSource+0x28>)
3400817e:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
34008182:	f023 0207 	bic.w	r2, r3, #7
34008186:	4905      	ldr	r1, [pc, #20]	@ (3400819c <LL_RCC_SetCLKPClockSource+0x28>)
34008188:	687b      	ldr	r3, [r7, #4]
3400818a:	4313      	orrs	r3, r2
3400818c:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
34008190:	bf00      	nop
34008192:	370c      	adds	r7, #12
34008194:	46bd      	mov	sp, r7
34008196:	f85d 7b04 	ldr.w	r7, [sp], #4
3400819a:	4770      	bx	lr
3400819c:	56028000 	.word	0x56028000

340081a0 <LL_RCC_SetDCMIPPClockSource>:
  *         @arg @ref LL_RCC_DCMIPP_CLKSOURCE_IC17
  *         @arg @ref LL_RCC_DCMIPP_CLKSOURCE_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetDCMIPPClockSource(uint32_t ClkSource)
{
340081a0:	b480      	push	{r7}
340081a2:	b083      	sub	sp, #12
340081a4:	af00      	add	r7, sp, #0
340081a6:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR1, RCC_CCIPR1_DCMIPPSEL, ClkSource);
340081a8:	4b07      	ldr	r3, [pc, #28]	@ (340081c8 <LL_RCC_SetDCMIPPClockSource+0x28>)
340081aa:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
340081ae:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
340081b2:	4905      	ldr	r1, [pc, #20]	@ (340081c8 <LL_RCC_SetDCMIPPClockSource+0x28>)
340081b4:	687b      	ldr	r3, [r7, #4]
340081b6:	4313      	orrs	r3, r2
340081b8:	f8c1 3144 	str.w	r3, [r1, #324]	@ 0x144
}
340081bc:	bf00      	nop
340081be:	370c      	adds	r7, #12
340081c0:	46bd      	mov	sp, r7
340081c2:	f85d 7b04 	ldr.w	r7, [sp], #4
340081c6:	4770      	bx	lr
340081c8:	56028000 	.word	0x56028000

340081cc <LL_RCC_SetETHClockSource>:
  *         @arg @ref LL_RCC_ETH1_CLKSOURCE_IC12
  *         @arg @ref LL_RCC_ETH1_CLKSOURCE_HSE
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetETHClockSource(uint32_t ClkSource)
{
340081cc:	b480      	push	{r7}
340081ce:	b083      	sub	sp, #12
340081d0:	af00      	add	r7, sp, #0
340081d2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1CLKSEL, ClkSource);
340081d4:	4b07      	ldr	r3, [pc, #28]	@ (340081f4 <LL_RCC_SetETHClockSource+0x28>)
340081d6:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
340081da:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
340081de:	4905      	ldr	r1, [pc, #20]	@ (340081f4 <LL_RCC_SetETHClockSource+0x28>)
340081e0:	687b      	ldr	r3, [r7, #4]
340081e2:	4313      	orrs	r3, r2
340081e4:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
340081e8:	bf00      	nop
340081ea:	370c      	adds	r7, #12
340081ec:	46bd      	mov	sp, r7
340081ee:	f85d 7b04 	ldr.w	r7, [sp], #4
340081f2:	4770      	bx	lr
340081f4:	56028000 	.word	0x56028000

340081f8 <LL_RCC_SetETHPHYInterface>:
  *         @arg @ref LL_RCC_ETH1PHY_IF_RGMII
  *         @arg @ref LL_RCC_ETH1PHY_IF_RMII
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetETHPHYInterface(uint32_t Interface)
{
340081f8:	b480      	push	{r7}
340081fa:	b083      	sub	sp, #12
340081fc:	af00      	add	r7, sp, #0
340081fe:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1SEL, Interface);
34008200:	4b07      	ldr	r3, [pc, #28]	@ (34008220 <LL_RCC_SetETHPHYInterface+0x28>)
34008202:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34008206:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
3400820a:	4905      	ldr	r1, [pc, #20]	@ (34008220 <LL_RCC_SetETHPHYInterface+0x28>)
3400820c:	687b      	ldr	r3, [r7, #4]
3400820e:	4313      	orrs	r3, r2
34008210:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34008214:	bf00      	nop
34008216:	370c      	adds	r7, #12
34008218:	46bd      	mov	sp, r7
3400821a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400821e:	4770      	bx	lr
34008220:	56028000 	.word	0x56028000

34008224 <LL_RCC_SetETHREFRXClockSource>:
  *         @arg @ref LL_RCC_ETH1REFRX_CLKSOURCE_EXT
  *         @arg @ref LL_RCC_ETH1REFRX_CLKSOURCE_INT
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetETHREFRXClockSource(uint32_t ClkSource)
{
34008224:	b480      	push	{r7}
34008226:	b083      	sub	sp, #12
34008228:	af00      	add	r7, sp, #0
3400822a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1REFCLKSEL, ClkSource);
3400822c:	4b07      	ldr	r3, [pc, #28]	@ (3400824c <LL_RCC_SetETHREFRXClockSource+0x28>)
3400822e:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
34008232:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
34008236:	4905      	ldr	r1, [pc, #20]	@ (3400824c <LL_RCC_SetETHREFRXClockSource+0x28>)
34008238:	687b      	ldr	r3, [r7, #4]
3400823a:	4313      	orrs	r3, r2
3400823c:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
34008240:	bf00      	nop
34008242:	370c      	adds	r7, #12
34008244:	46bd      	mov	sp, r7
34008246:	f85d 7b04 	ldr.w	r7, [sp], #4
3400824a:	4770      	bx	lr
3400824c:	56028000 	.word	0x56028000

34008250 <LL_RCC_SetETHREFTXClockSource>:
  *         @arg @ref LL_RCC_ETH1REFTX_CLKSOURCE_EXT
  *         @arg @ref LL_RCC_ETH1REFTX_CLKSOURCE_INT
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetETHREFTXClockSource(uint32_t ClkSource)
{
34008250:	b480      	push	{r7}
34008252:	b083      	sub	sp, #12
34008254:	af00      	add	r7, sp, #0
34008256:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR2, RCC_CCIPR2_ETH1GTXCLKSEL, ClkSource);
34008258:	4b07      	ldr	r3, [pc, #28]	@ (34008278 <LL_RCC_SetETHREFTXClockSource+0x28>)
3400825a:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400825e:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
34008262:	4905      	ldr	r1, [pc, #20]	@ (34008278 <LL_RCC_SetETHREFTXClockSource+0x28>)
34008264:	687b      	ldr	r3, [r7, #4]
34008266:	4313      	orrs	r3, r2
34008268:	f8c1 3148 	str.w	r3, [r1, #328]	@ 0x148
}
3400826c:	bf00      	nop
3400826e:	370c      	adds	r7, #12
34008270:	46bd      	mov	sp, r7
34008272:	f85d 7b04 	ldr.w	r7, [sp], #4
34008276:	4770      	bx	lr
34008278:	56028000 	.word	0x56028000

3400827c <LL_RCC_SetFDCANClockSource>:
  *         @arg @ref LL_RCC_FDCAN_CLKSOURCE_IC19
  *         @arg @ref LL_RCC_FDCAN_CLKSOURCE_HSE
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetFDCANClockSource(uint32_t ClkSource)
{
3400827c:	b480      	push	{r7}
3400827e:	b083      	sub	sp, #12
34008280:	af00      	add	r7, sp, #0
34008282:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FDCANSEL, ClkSource);
34008284:	4b07      	ldr	r3, [pc, #28]	@ (340082a4 <LL_RCC_SetFDCANClockSource+0x28>)
34008286:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
3400828a:	f023 0203 	bic.w	r2, r3, #3
3400828e:	4905      	ldr	r1, [pc, #20]	@ (340082a4 <LL_RCC_SetFDCANClockSource+0x28>)
34008290:	687b      	ldr	r3, [r7, #4]
34008292:	4313      	orrs	r3, r2
34008294:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
34008298:	bf00      	nop
3400829a:	370c      	adds	r7, #12
3400829c:	46bd      	mov	sp, r7
3400829e:	f85d 7b04 	ldr.w	r7, [sp], #4
340082a2:	4770      	bx	lr
340082a4:	56028000 	.word	0x56028000

340082a8 <LL_RCC_SetFMCClockSource>:
  *         @arg @ref LL_RCC_FMC_CLKSOURCE_IC3
  *         @arg @ref LL_RCC_FMC_CLKSOURCE_IC4
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetFMCClockSource(uint32_t ClkSource)
{
340082a8:	b480      	push	{r7}
340082aa:	b083      	sub	sp, #12
340082ac:	af00      	add	r7, sp, #0
340082ae:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR3, RCC_CCIPR3_FMCSEL, ClkSource);
340082b0:	4b07      	ldr	r3, [pc, #28]	@ (340082d0 <LL_RCC_SetFMCClockSource+0x28>)
340082b2:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
340082b6:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
340082ba:	4905      	ldr	r1, [pc, #20]	@ (340082d0 <LL_RCC_SetFMCClockSource+0x28>)
340082bc:	687b      	ldr	r3, [r7, #4]
340082be:	4313      	orrs	r3, r2
340082c0:	f8c1 314c 	str.w	r3, [r1, #332]	@ 0x14c
}
340082c4:	bf00      	nop
340082c6:	370c      	adds	r7, #12
340082c8:	46bd      	mov	sp, r7
340082ca:	f85d 7b04 	ldr.w	r7, [sp], #4
340082ce:	4770      	bx	lr
340082d0:	56028000 	.word	0x56028000

340082d4 <LL_RCC_SetI2CClockSource>:
  *         @arg @ref LL_RCC_I2C4_CLKSOURCE_MSI
  *         @arg @ref LL_RCC_I2C4_CLKSOURCE_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetI2CClockSource(uint32_t ClkSource)
{
340082d4:	b580      	push	{r7, lr}
340082d6:	b082      	sub	sp, #8
340082d8:	af00      	add	r7, sp, #0
340082da:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
340082dc:	6878      	ldr	r0, [r7, #4]
340082de:	f7ff ff09 	bl	340080f4 <LL_RCC_SetClockSource>
}
340082e2:	bf00      	nop
340082e4:	3708      	adds	r7, #8
340082e6:	46bd      	mov	sp, r7
340082e8:	bd80      	pop	{r7, pc}

340082ea <LL_RCC_SetI3CClockSource>:
  *         @arg @ref LL_RCC_I3C2_CLKSOURCE_MSI
  *         @arg @ref LL_RCC_I3C2_CLKSOURCE_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetI3CClockSource(uint32_t ClkSource)
{
340082ea:	b580      	push	{r7, lr}
340082ec:	b082      	sub	sp, #8
340082ee:	af00      	add	r7, sp, #0
340082f0:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
340082f2:	6878      	ldr	r0, [r7, #4]
340082f4:	f7ff fefe 	bl	340080f4 <LL_RCC_SetClockSource>
}
340082f8:	bf00      	nop
340082fa:	3708      	adds	r7, #8
340082fc:	46bd      	mov	sp, r7
340082fe:	bd80      	pop	{r7, pc}

34008300 <LL_RCC_SetLPTIMClockSource>:
  *         @arg @ref LL_RCC_LPTIM5_CLKSOURCE_LSI
  *         @arg @ref LL_RCC_LPTIM5_CLKSOURCE_TIMG
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetLPTIMClockSource(uint32_t ClkSource)
{
34008300:	b580      	push	{r7, lr}
34008302:	b082      	sub	sp, #8
34008304:	af00      	add	r7, sp, #0
34008306:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34008308:	6878      	ldr	r0, [r7, #4]
3400830a:	f7ff fef3 	bl	340080f4 <LL_RCC_SetClockSource>
}
3400830e:	bf00      	nop
34008310:	3708      	adds	r7, #8
34008312:	46bd      	mov	sp, r7
34008314:	bd80      	pop	{r7, pc}
	...

34008318 <LL_RCC_SetLPUARTClockSource>:
  *         @arg @ref LL_RCC_LPUART1_CLKSOURCE_MSI
  *         @arg @ref LL_RCC_LPUART1_CLKSOURCE_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetLPUARTClockSource(uint32_t ClkSource)
{
34008318:	b480      	push	{r7}
3400831a:	b083      	sub	sp, #12
3400831c:	af00      	add	r7, sp, #0
3400831e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR14, RCC_CCIPR14_LPUART1SEL, ClkSource);
34008320:	4b07      	ldr	r3, [pc, #28]	@ (34008340 <LL_RCC_SetLPUARTClockSource+0x28>)
34008322:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
34008326:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
3400832a:	4905      	ldr	r1, [pc, #20]	@ (34008340 <LL_RCC_SetLPUARTClockSource+0x28>)
3400832c:	687b      	ldr	r3, [r7, #4]
3400832e:	4313      	orrs	r3, r2
34008330:	f8c1 3178 	str.w	r3, [r1, #376]	@ 0x178
}
34008334:	bf00      	nop
34008336:	370c      	adds	r7, #12
34008338:	46bd      	mov	sp, r7
3400833a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400833e:	4770      	bx	lr
34008340:	56028000 	.word	0x56028000

34008344 <LL_RCC_SetLTDCClockSource>:
  *         @arg @ref LL_RCC_LTDC_CLKSOURCE_IC16
  *         @arg @ref LL_RCC_LTDC_CLKSOURCE_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetLTDCClockSource(uint32_t ClkSource)
{
34008344:	b480      	push	{r7}
34008346:	b083      	sub	sp, #12
34008348:	af00      	add	r7, sp, #0
3400834a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR4, RCC_CCIPR4_LTDCSEL, ClkSource);
3400834c:	4b07      	ldr	r3, [pc, #28]	@ (3400836c <LL_RCC_SetLTDCClockSource+0x28>)
3400834e:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
34008352:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
34008356:	4905      	ldr	r1, [pc, #20]	@ (3400836c <LL_RCC_SetLTDCClockSource+0x28>)
34008358:	687b      	ldr	r3, [r7, #4]
3400835a:	4313      	orrs	r3, r2
3400835c:	f8c1 3150 	str.w	r3, [r1, #336]	@ 0x150
}
34008360:	bf00      	nop
34008362:	370c      	adds	r7, #12
34008364:	46bd      	mov	sp, r7
34008366:	f85d 7b04 	ldr.w	r7, [sp], #4
3400836a:	4770      	bx	lr
3400836c:	56028000 	.word	0x56028000

34008370 <LL_RCC_SetMDFClockSource>:
  *         @arg @ref LL_RCC_MDF1_CLKSOURCE_I2S_CKIN
  *         @arg @ref LL_RCC_MDF1_CLKSOURCE_TIMG
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetMDFClockSource(uint32_t ClkSource)
{
34008370:	b480      	push	{r7}
34008372:	b083      	sub	sp, #12
34008374:	af00      	add	r7, sp, #0
34008376:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR5, RCC_CCIPR5_MDF1SEL, ClkSource);
34008378:	4b07      	ldr	r3, [pc, #28]	@ (34008398 <LL_RCC_SetMDFClockSource+0x28>)
3400837a:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
3400837e:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
34008382:	4905      	ldr	r1, [pc, #20]	@ (34008398 <LL_RCC_SetMDFClockSource+0x28>)
34008384:	687b      	ldr	r3, [r7, #4]
34008386:	4313      	orrs	r3, r2
34008388:	f8c1 3154 	str.w	r3, [r1, #340]	@ 0x154
}
3400838c:	bf00      	nop
3400838e:	370c      	adds	r7, #12
34008390:	46bd      	mov	sp, r7
34008392:	f85d 7b04 	ldr.w	r7, [sp], #4
34008396:	4770      	bx	lr
34008398:	56028000 	.word	0x56028000

3400839c <LL_RCC_SetOTGPHYClockSource>:
  *         @arg @ref LL_RCC_OTGPHY2_CLKSOURCE_IC15
  *         @arg @ref LL_RCC_OTGPHY2_CLKSOURCE_HSE_DIV_2_OSC
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetOTGPHYClockSource(uint32_t ClkSource)
{
3400839c:	b580      	push	{r7, lr}
3400839e:	b082      	sub	sp, #8
340083a0:	af00      	add	r7, sp, #0
340083a2:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
340083a4:	6878      	ldr	r0, [r7, #4]
340083a6:	f7ff fea5 	bl	340080f4 <LL_RCC_SetClockSource>
}
340083aa:	bf00      	nop
340083ac:	3708      	adds	r7, #8
340083ae:	46bd      	mov	sp, r7
340083b0:	bd80      	pop	{r7, pc}

340083b2 <LL_RCC_SetOTGPHYCKREFClockSource>:
  *         @arg @ref LL_RCC_OTGPHY2CKREF_CLKSOURCE_OTGPHY2
  *         @arg @ref LL_RCC_OTGPHY2CKREF_CLKSOURCE_HSE_DIV_2_OSC
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetOTGPHYCKREFClockSource(uint32_t ClkSource)
{
340083b2:	b580      	push	{r7, lr}
340083b4:	b082      	sub	sp, #8
340083b6:	af00      	add	r7, sp, #0
340083b8:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
340083ba:	6878      	ldr	r0, [r7, #4]
340083bc:	f7ff fe9a 	bl	340080f4 <LL_RCC_SetClockSource>
}
340083c0:	bf00      	nop
340083c2:	3708      	adds	r7, #8
340083c4:	46bd      	mov	sp, r7
340083c6:	bd80      	pop	{r7, pc}

340083c8 <LL_RCC_SetPSSIClockSource>:
  *         @arg @ref LL_RCC_PSSI_CLKSOURCE_IC20
  *         @arg @ref LL_RCC_PSSI_CLKSOURCE_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetPSSIClockSource(uint32_t ClkSource)
{
340083c8:	b480      	push	{r7}
340083ca:	b083      	sub	sp, #12
340083cc:	af00      	add	r7, sp, #0
340083ce:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_PSSISEL, ClkSource);
340083d0:	4b07      	ldr	r3, [pc, #28]	@ (340083f0 <LL_RCC_SetPSSIClockSource+0x28>)
340083d2:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
340083d6:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
340083da:	4905      	ldr	r1, [pc, #20]	@ (340083f0 <LL_RCC_SetPSSIClockSource+0x28>)
340083dc:	687b      	ldr	r3, [r7, #4]
340083de:	4313      	orrs	r3, r2
340083e0:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
340083e4:	bf00      	nop
340083e6:	370c      	adds	r7, #12
340083e8:	46bd      	mov	sp, r7
340083ea:	f85d 7b04 	ldr.w	r7, [sp], #4
340083ee:	4770      	bx	lr
340083f0:	56028000 	.word	0x56028000

340083f4 <LL_RCC_SetSAIClockSource>:
  *         @arg @ref LL_RCC_SAI2_CLKSOURCE_I2S_CKIN
  *         @arg @ref LL_RCC_SAI2_CLKSOURCE_SPDIFRX1
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSAIClockSource(uint32_t ClkSource)
{
340083f4:	b580      	push	{r7, lr}
340083f6:	b082      	sub	sp, #8
340083f8:	af00      	add	r7, sp, #0
340083fa:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
340083fc:	6878      	ldr	r0, [r7, #4]
340083fe:	f7ff fe79 	bl	340080f4 <LL_RCC_SetClockSource>
}
34008402:	bf00      	nop
34008404:	3708      	adds	r7, #8
34008406:	46bd      	mov	sp, r7
34008408:	bd80      	pop	{r7, pc}

3400840a <LL_RCC_SetSDMMCClockSource>:
  *         @arg @ref LL_RCC_SDMMC2_CLKSOURCE_IC4
  *         @arg @ref LL_RCC_SDMMC2_CLKSOURCE_IC5
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSDMMCClockSource(uint32_t ClkSource)
{
3400840a:	b580      	push	{r7, lr}
3400840c:	b082      	sub	sp, #8
3400840e:	af00      	add	r7, sp, #0
34008410:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34008412:	6878      	ldr	r0, [r7, #4]
34008414:	f7ff fe6e 	bl	340080f4 <LL_RCC_SetClockSource>
}
34008418:	bf00      	nop
3400841a:	3708      	adds	r7, #8
3400841c:	46bd      	mov	sp, r7
3400841e:	bd80      	pop	{r7, pc}

34008420 <LL_RCC_SetSPDIFRXClockSource>:
  *         @arg @ref LL_RCC_SPDIFRX1_CLKSOURCE_HSI
  *         @arg @ref LL_RCC_SPDIFRX1_CLKSOURCE_I2S_CKIN
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSPDIFRXClockSource(uint32_t ClkSource)
{
34008420:	b480      	push	{r7}
34008422:	b083      	sub	sp, #12
34008424:	af00      	add	r7, sp, #0
34008426:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR9, RCC_CCIPR9_SPDIFRX1SEL, ClkSource);
34008428:	4b07      	ldr	r3, [pc, #28]	@ (34008448 <LL_RCC_SetSPDIFRXClockSource+0x28>)
3400842a:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
3400842e:	f023 0207 	bic.w	r2, r3, #7
34008432:	4905      	ldr	r1, [pc, #20]	@ (34008448 <LL_RCC_SetSPDIFRXClockSource+0x28>)
34008434:	687b      	ldr	r3, [r7, #4]
34008436:	4313      	orrs	r3, r2
34008438:	f8c1 3164 	str.w	r3, [r1, #356]	@ 0x164
}
3400843c:	bf00      	nop
3400843e:	370c      	adds	r7, #12
34008440:	46bd      	mov	sp, r7
34008442:	f85d 7b04 	ldr.w	r7, [sp], #4
34008446:	4770      	bx	lr
34008448:	56028000 	.word	0x56028000

3400844c <LL_RCC_SetSPIClockSource>:
  *         @arg @ref LL_RCC_SPI6_CLKSOURCE_HSI
  *         @arg @ref LL_RCC_SPI6_CLKSOURCE_I2S_CKIN
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSPIClockSource(uint32_t ClkSource)
{
3400844c:	b580      	push	{r7, lr}
3400844e:	b082      	sub	sp, #8
34008450:	af00      	add	r7, sp, #0
34008452:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34008454:	6878      	ldr	r0, [r7, #4]
34008456:	f7ff fe4d 	bl	340080f4 <LL_RCC_SetClockSource>
}
3400845a:	bf00      	nop
3400845c:	3708      	adds	r7, #8
3400845e:	46bd      	mov	sp, r7
34008460:	bd80      	pop	{r7, pc}

34008462 <LL_RCC_SetUSARTClockSource>:
  *         @arg @ref LL_RCC_USART10_CLKSOURCE_MSI
  *         @arg @ref LL_RCC_USART10_CLKSOURCE_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetUSARTClockSource(uint32_t ClkSource)
{
34008462:	b580      	push	{r7, lr}
34008464:	b082      	sub	sp, #8
34008466:	af00      	add	r7, sp, #0
34008468:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
3400846a:	6878      	ldr	r0, [r7, #4]
3400846c:	f7ff fe42 	bl	340080f4 <LL_RCC_SetClockSource>
}
34008470:	bf00      	nop
34008472:	3708      	adds	r7, #8
34008474:	46bd      	mov	sp, r7
34008476:	bd80      	pop	{r7, pc}

34008478 <LL_RCC_SetXSPIClockSource>:
  *         @arg @ref LL_RCC_XSPI3_CLKSOURCE_IC3
  *         @arg @ref LL_RCC_XSPI3_CLKSOURCE_IC4
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetXSPIClockSource(uint32_t ClkSource)
{
34008478:	b580      	push	{r7, lr}
3400847a:	b082      	sub	sp, #8
3400847c:	af00      	add	r7, sp, #0
3400847e:	6078      	str	r0, [r7, #4]
  LL_RCC_SetClockSource(ClkSource);
34008480:	6878      	ldr	r0, [r7, #4]
34008482:	f7ff fe37 	bl	340080f4 <LL_RCC_SetClockSource>
}
34008486:	bf00      	nop
34008488:	3708      	adds	r7, #8
3400848a:	46bd      	mov	sp, r7
3400848c:	bd80      	pop	{r7, pc}
	...

34008490 <LL_RCC_SetRTCClockSource>:
  *         @arg @ref LL_RCC_RTC_CLKSOURCE_LSI
  *         @arg @ref LL_RCC_RTC_CLKSOURCE_HSE
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetRTCClockSource(uint32_t Source)
{
34008490:	b480      	push	{r7}
34008492:	b083      	sub	sp, #12
34008494:	af00      	add	r7, sp, #0
34008496:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCSEL, Source);
34008498:	4b07      	ldr	r3, [pc, #28]	@ (340084b8 <LL_RCC_SetRTCClockSource+0x28>)
3400849a:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400849e:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
340084a2:	4905      	ldr	r1, [pc, #20]	@ (340084b8 <LL_RCC_SetRTCClockSource+0x28>)
340084a4:	687b      	ldr	r3, [r7, #4]
340084a6:	4313      	orrs	r3, r2
340084a8:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
340084ac:	bf00      	nop
340084ae:	370c      	adds	r7, #12
340084b0:	46bd      	mov	sp, r7
340084b2:	f85d 7b04 	ldr.w	r7, [sp], #4
340084b6:	4770      	bx	lr
340084b8:	56028000 	.word	0x56028000

340084bc <LL_RCC_GetRTCClockSource>:
  *         @arg @ref LL_RCC_RTC_CLKSOURCE_LSE
  *         @arg @ref LL_RCC_RTC_CLKSOURCE_LSI
  *         @arg @ref LL_RCC_RTC_CLKSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_GetRTCClockSource(void)
{
340084bc:	b480      	push	{r7}
340084be:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CCIPR7, RCC_CCIPR7_RTCSEL));
340084c0:	4b04      	ldr	r3, [pc, #16]	@ (340084d4 <LL_RCC_GetRTCClockSource+0x18>)
340084c2:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
340084c6:	f403 7340 	and.w	r3, r3, #768	@ 0x300
}
340084ca:	4618      	mov	r0, r3
340084cc:	46bd      	mov	sp, r7
340084ce:	f85d 7b04 	ldr.w	r7, [sp], #4
340084d2:	4770      	bx	lr
340084d4:	56028000 	.word	0x56028000

340084d8 <LL_RCC_SetRTC_HSEPrescaler>:
  *         @arg @ref LL_RCC_RTC_HSE_DIV_62
  *         @arg @ref LL_RCC_RTC_HSE_DIV_63
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetRTC_HSEPrescaler(uint32_t Prescaler)
{
340084d8:	b480      	push	{r7}
340084da:	b083      	sub	sp, #12
340084dc:	af00      	add	r7, sp, #0
340084de:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CCIPR7, RCC_CCIPR7_RTCPRE, Prescaler);
340084e0:	4b07      	ldr	r3, [pc, #28]	@ (34008500 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
340084e2:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
340084e6:	f423 327c 	bic.w	r2, r3, #258048	@ 0x3f000
340084ea:	4905      	ldr	r1, [pc, #20]	@ (34008500 <LL_RCC_SetRTC_HSEPrescaler+0x28>)
340084ec:	687b      	ldr	r3, [r7, #4]
340084ee:	4313      	orrs	r3, r2
340084f0:	f8c1 315c 	str.w	r3, [r1, #348]	@ 0x15c
}
340084f4:	bf00      	nop
340084f6:	370c      	adds	r7, #12
340084f8:	46bd      	mov	sp, r7
340084fa:	f85d 7b04 	ldr.w	r7, [sp], #4
340084fe:	4770      	bx	lr
34008500:	56028000 	.word	0x56028000

34008504 <LL_RCC_SetTIMPrescaler>:
  *         @arg @ref LL_RCC_TIM_PRESCALER_4
  *         @arg @ref LL_RCC_TIM_PRESCALER_8
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetTIMPrescaler(uint32_t Prescaler)
{
34008504:	b480      	push	{r7}
34008506:	b083      	sub	sp, #12
34008508:	af00      	add	r7, sp, #0
3400850a:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR2, RCC_CFGR2_TIMPRE, Prescaler << RCC_CFGR2_TIMPRE_Pos);
3400850c:	4b07      	ldr	r3, [pc, #28]	@ (3400852c <LL_RCC_SetTIMPrescaler+0x28>)
3400850e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34008510:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
34008514:	687b      	ldr	r3, [r7, #4]
34008516:	061b      	lsls	r3, r3, #24
34008518:	4904      	ldr	r1, [pc, #16]	@ (3400852c <LL_RCC_SetTIMPrescaler+0x28>)
3400851a:	4313      	orrs	r3, r2
3400851c:	624b      	str	r3, [r1, #36]	@ 0x24
}
3400851e:	bf00      	nop
34008520:	370c      	adds	r7, #12
34008522:	46bd      	mov	sp, r7
34008524:	f85d 7b04 	ldr.w	r7, [sp], #4
34008528:	4770      	bx	lr
3400852a:	bf00      	nop
3400852c:	56028000 	.word	0x56028000

34008530 <LL_RCC_IC3_Enable>:
  * @brief  Enable IC3
  * @rmtoll DIVENSR       IC3ENS        LL_RCC_IC3_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC3_Enable(void)
{
34008530:	b480      	push	{r7}
34008532:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC3ENS);
34008534:	4b04      	ldr	r3, [pc, #16]	@ (34008548 <LL_RCC_IC3_Enable+0x18>)
34008536:	2204      	movs	r2, #4
34008538:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400853c:	bf00      	nop
3400853e:	46bd      	mov	sp, r7
34008540:	f85d 7b04 	ldr.w	r7, [sp], #4
34008544:	4770      	bx	lr
34008546:	bf00      	nop
34008548:	56028000 	.word	0x56028000

3400854c <LL_RCC_IC4_Enable>:
  * @brief  Enable IC4
  * @rmtoll DIVENSR       IC4ENS        LL_RCC_IC4_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC4_Enable(void)
{
3400854c:	b480      	push	{r7}
3400854e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC4ENS);
34008550:	4b04      	ldr	r3, [pc, #16]	@ (34008564 <LL_RCC_IC4_Enable+0x18>)
34008552:	2208      	movs	r2, #8
34008554:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34008558:	bf00      	nop
3400855a:	46bd      	mov	sp, r7
3400855c:	f85d 7b04 	ldr.w	r7, [sp], #4
34008560:	4770      	bx	lr
34008562:	bf00      	nop
34008564:	56028000 	.word	0x56028000

34008568 <LL_RCC_IC5_Enable>:
  * @brief  Enable IC5
  * @rmtoll DIVENSR       IC5ENS        LL_RCC_IC5_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC5_Enable(void)
{
34008568:	b480      	push	{r7}
3400856a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC5ENS);
3400856c:	4b04      	ldr	r3, [pc, #16]	@ (34008580 <LL_RCC_IC5_Enable+0x18>)
3400856e:	2210      	movs	r2, #16
34008570:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34008574:	bf00      	nop
34008576:	46bd      	mov	sp, r7
34008578:	f85d 7b04 	ldr.w	r7, [sp], #4
3400857c:	4770      	bx	lr
3400857e:	bf00      	nop
34008580:	56028000 	.word	0x56028000

34008584 <LL_RCC_IC7_Enable>:
  * @brief  Enable IC7
  * @rmtoll DIVENSR       IC7ENS        LL_RCC_IC7_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC7_Enable(void)
{
34008584:	b480      	push	{r7}
34008586:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC7ENS);
34008588:	4b04      	ldr	r3, [pc, #16]	@ (3400859c <LL_RCC_IC7_Enable+0x18>)
3400858a:	2240      	movs	r2, #64	@ 0x40
3400858c:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34008590:	bf00      	nop
34008592:	46bd      	mov	sp, r7
34008594:	f85d 7b04 	ldr.w	r7, [sp], #4
34008598:	4770      	bx	lr
3400859a:	bf00      	nop
3400859c:	56028000 	.word	0x56028000

340085a0 <LL_RCC_IC8_Enable>:
  * @brief  Enable IC8
  * @rmtoll DIVENSR       IC8ENS        LL_RCC_IC8_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC8_Enable(void)
{
340085a0:	b480      	push	{r7}
340085a2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC8ENS);
340085a4:	4b04      	ldr	r3, [pc, #16]	@ (340085b8 <LL_RCC_IC8_Enable+0x18>)
340085a6:	2280      	movs	r2, #128	@ 0x80
340085a8:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340085ac:	bf00      	nop
340085ae:	46bd      	mov	sp, r7
340085b0:	f85d 7b04 	ldr.w	r7, [sp], #4
340085b4:	4770      	bx	lr
340085b6:	bf00      	nop
340085b8:	56028000 	.word	0x56028000

340085bc <LL_RCC_IC9_Enable>:
  * @brief  Enable IC9
  * @rmtoll DIVENSR       IC9ENS        LL_RCC_IC9_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC9_Enable(void)
{
340085bc:	b480      	push	{r7}
340085be:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC9ENS);
340085c0:	4b04      	ldr	r3, [pc, #16]	@ (340085d4 <LL_RCC_IC9_Enable+0x18>)
340085c2:	f44f 7280 	mov.w	r2, #256	@ 0x100
340085c6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340085ca:	bf00      	nop
340085cc:	46bd      	mov	sp, r7
340085ce:	f85d 7b04 	ldr.w	r7, [sp], #4
340085d2:	4770      	bx	lr
340085d4:	56028000 	.word	0x56028000

340085d8 <LL_RCC_IC10_Enable>:
  * @brief  Enable IC10
  * @rmtoll DIVENSR       IC10ENS        LL_RCC_IC10_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC10_Enable(void)
{
340085d8:	b480      	push	{r7}
340085da:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC10ENS);
340085dc:	4b04      	ldr	r3, [pc, #16]	@ (340085f0 <LL_RCC_IC10_Enable+0x18>)
340085de:	f44f 7200 	mov.w	r2, #512	@ 0x200
340085e2:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340085e6:	bf00      	nop
340085e8:	46bd      	mov	sp, r7
340085ea:	f85d 7b04 	ldr.w	r7, [sp], #4
340085ee:	4770      	bx	lr
340085f0:	56028000 	.word	0x56028000

340085f4 <LL_RCC_IC12_Enable>:
  * @brief  Enable IC12
  * @rmtoll DIVENSR       IC12ENS        LL_RCC_IC12_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC12_Enable(void)
{
340085f4:	b480      	push	{r7}
340085f6:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC12ENS);
340085f8:	4b04      	ldr	r3, [pc, #16]	@ (3400860c <LL_RCC_IC12_Enable+0x18>)
340085fa:	f44f 6200 	mov.w	r2, #2048	@ 0x800
340085fe:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34008602:	bf00      	nop
34008604:	46bd      	mov	sp, r7
34008606:	f85d 7b04 	ldr.w	r7, [sp], #4
3400860a:	4770      	bx	lr
3400860c:	56028000 	.word	0x56028000

34008610 <LL_RCC_IC13_Enable>:
  * @brief  Enable IC13
  * @rmtoll DIVENSR       IC13ENS        LL_RCC_IC13_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC13_Enable(void)
{
34008610:	b480      	push	{r7}
34008612:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC13ENS);
34008614:	4b04      	ldr	r3, [pc, #16]	@ (34008628 <LL_RCC_IC13_Enable+0x18>)
34008616:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
3400861a:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400861e:	bf00      	nop
34008620:	46bd      	mov	sp, r7
34008622:	f85d 7b04 	ldr.w	r7, [sp], #4
34008626:	4770      	bx	lr
34008628:	56028000 	.word	0x56028000

3400862c <LL_RCC_IC14_Enable>:
  * @brief  Enable IC14
  * @rmtoll DIVENSR       IC14ENS        LL_RCC_IC14_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC14_Enable(void)
{
3400862c:	b480      	push	{r7}
3400862e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC14ENS);
34008630:	4b04      	ldr	r3, [pc, #16]	@ (34008644 <LL_RCC_IC14_Enable+0x18>)
34008632:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
34008636:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400863a:	bf00      	nop
3400863c:	46bd      	mov	sp, r7
3400863e:	f85d 7b04 	ldr.w	r7, [sp], #4
34008642:	4770      	bx	lr
34008644:	56028000 	.word	0x56028000

34008648 <LL_RCC_IC15_Enable>:
  * @brief  Enable IC15
  * @rmtoll DIVENSR       IC15ENS        LL_RCC_IC15_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC15_Enable(void)
{
34008648:	b480      	push	{r7}
3400864a:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC15ENS);
3400864c:	4b04      	ldr	r3, [pc, #16]	@ (34008660 <LL_RCC_IC15_Enable+0x18>)
3400864e:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
34008652:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34008656:	bf00      	nop
34008658:	46bd      	mov	sp, r7
3400865a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400865e:	4770      	bx	lr
34008660:	56028000 	.word	0x56028000

34008664 <LL_RCC_IC16_Enable>:
  * @brief  Enable IC16
  * @rmtoll DIVENSR       IC16ENS        LL_RCC_IC16_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC16_Enable(void)
{
34008664:	b480      	push	{r7}
34008666:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC16ENS);
34008668:	4b04      	ldr	r3, [pc, #16]	@ (3400867c <LL_RCC_IC16_Enable+0x18>)
3400866a:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
3400866e:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
34008672:	bf00      	nop
34008674:	46bd      	mov	sp, r7
34008676:	f85d 7b04 	ldr.w	r7, [sp], #4
3400867a:	4770      	bx	lr
3400867c:	56028000 	.word	0x56028000

34008680 <LL_RCC_IC17_Enable>:
  * @brief  Enable IC17
  * @rmtoll DIVENSR       IC17ENS        LL_RCC_IC17_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC17_Enable(void)
{
34008680:	b480      	push	{r7}
34008682:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC17ENS);
34008684:	4b04      	ldr	r3, [pc, #16]	@ (34008698 <LL_RCC_IC17_Enable+0x18>)
34008686:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
3400868a:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
3400868e:	bf00      	nop
34008690:	46bd      	mov	sp, r7
34008692:	f85d 7b04 	ldr.w	r7, [sp], #4
34008696:	4770      	bx	lr
34008698:	56028000 	.word	0x56028000

3400869c <LL_RCC_IC18_Enable>:
  * @brief  Enable IC18
  * @rmtoll DIVENSR       IC18ENS        LL_RCC_IC18_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC18_Enable(void)
{
3400869c:	b480      	push	{r7}
3400869e:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC18ENS);
340086a0:	4b04      	ldr	r3, [pc, #16]	@ (340086b4 <LL_RCC_IC18_Enable+0x18>)
340086a2:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
340086a6:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340086aa:	bf00      	nop
340086ac:	46bd      	mov	sp, r7
340086ae:	f85d 7b04 	ldr.w	r7, [sp], #4
340086b2:	4770      	bx	lr
340086b4:	56028000 	.word	0x56028000

340086b8 <LL_RCC_IC19_Enable>:
  * @brief  Enable IC19
  * @rmtoll DIVENSR       IC19ENS        LL_RCC_IC19_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC19_Enable(void)
{
340086b8:	b480      	push	{r7}
340086ba:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC19ENS);
340086bc:	4b04      	ldr	r3, [pc, #16]	@ (340086d0 <LL_RCC_IC19_Enable+0x18>)
340086be:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
340086c2:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340086c6:	bf00      	nop
340086c8:	46bd      	mov	sp, r7
340086ca:	f85d 7b04 	ldr.w	r7, [sp], #4
340086ce:	4770      	bx	lr
340086d0:	56028000 	.word	0x56028000

340086d4 <LL_RCC_IC20_Enable>:
  * @brief  Enable IC20
  * @rmtoll DIVENSR       IC20ENS        LL_RCC_IC20_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_IC20_Enable(void)
{
340086d4:	b480      	push	{r7}
340086d6:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->DIVENSR, RCC_DIVENSR_IC20ENS);
340086d8:	4b04      	ldr	r3, [pc, #16]	@ (340086ec <LL_RCC_IC20_Enable+0x18>)
340086da:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
340086de:	f8c3 2a40 	str.w	r2, [r3, #2624]	@ 0xa40
}
340086e2:	bf00      	nop
340086e4:	46bd      	mov	sp, r7
340086e6:	f85d 7b04 	ldr.w	r7, [sp], #4
340086ea:	4770      	bx	lr
340086ec:	56028000 	.word	0x56028000

340086f0 <LL_RCC_CLKP_Enable>:
  * @brief  Enable CLKP
  * @rmtoll MISCENSR      PERENS        LL_RCC_CLKP_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_CLKP_Enable(void)
{
340086f0:	b480      	push	{r7}
340086f2:	af00      	add	r7, sp, #0
  WRITE_REG(RCC->MISCENSR, RCC_MISCENSR_PERENS);
340086f4:	4b04      	ldr	r3, [pc, #16]	@ (34008708 <LL_RCC_CLKP_Enable+0x18>)
340086f6:	2240      	movs	r2, #64	@ 0x40
340086f8:	f8c3 2a48 	str.w	r2, [r3, #2632]	@ 0xa48
}
340086fc:	bf00      	nop
340086fe:	46bd      	mov	sp, r7
34008700:	f85d 7b04 	ldr.w	r7, [sp], #4
34008704:	4770      	bx	lr
34008706:	bf00      	nop
34008708:	56028000 	.word	0x56028000

3400870c <HAL_RCCEx_PeriphCLKConfig>:
  *         modification indeed impacts all peripherals using this ICx as clock source.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
3400870c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
34008710:	b0f2      	sub	sp, #456	@ 0x1c8
34008712:	af00      	add	r7, sp, #0
34008714:	f8c7 01b4 	str.w	r0, [r7, #436]	@ 0x1b4
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
34008718:	2300      	movs	r3, #0
3400871a:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
3400871e:	2300      	movs	r3, #0
34008720:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- RTC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
34008724:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008728:	e9d3 2300 	ldrd	r2, r3, [r3]
3400872c:	f002 6400 	and.w	r4, r2, #134217728	@ 0x8000000
34008730:	2500      	movs	r5, #0
34008732:	ea54 0305 	orrs.w	r3, r4, r5
34008736:	d06c      	beq.n	34008812 <HAL_RCCEx_PeriphCLKConfig+0x106>
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* As the RTC clock source selection can be changed only if the Backup Domain is reset */
    /* reset the Backup domain only if the RTC Clock source selection is modified from default reset value */
    tmpreg = LL_RCC_GetRTCClockSource();
34008738:	f7ff fec0 	bl	340084bc <LL_RCC_GetRTCClockSource>
3400873c:	f8c7 01c0 	str.w	r0, [r7, #448]	@ 0x1c0

    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_CCIPR7_RTCSEL)))
34008740:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
34008744:	2b00      	cmp	r3, #0
34008746:	d018      	beq.n	3400877a <HAL_RCCEx_PeriphCLKConfig+0x6e>
34008748:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400874c:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
34008750:	f403 7240 	and.w	r2, r3, #768	@ 0x300
34008754:	f8d7 31c0 	ldr.w	r3, [r7, #448]	@ 0x1c0
34008758:	4293      	cmp	r3, r2
3400875a:	d00e      	beq.n	3400877a <HAL_RCCEx_PeriphCLKConfig+0x6e>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->DBPCR, PWR_DBPCR_DBP);
3400875c:	4bc3      	ldr	r3, [pc, #780]	@ (34008a6c <HAL_RCCEx_PeriphCLKConfig+0x360>)
3400875e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34008760:	4ac2      	ldr	r2, [pc, #776]	@ (34008a6c <HAL_RCCEx_PeriphCLKConfig+0x360>)
34008762:	f043 0301 	orr.w	r3, r3, #1
34008766:	62d3      	str	r3, [r2, #44]	@ 0x2c

      /* Read back to check Backup domain enabled */
      if (READ_BIT(PWR->DBPCR, PWR_DBPCR_DBP) == 0U)
34008768:	4bc0      	ldr	r3, [pc, #768]	@ (34008a6c <HAL_RCCEx_PeriphCLKConfig+0x360>)
3400876a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400876c:	f003 0301 	and.w	r3, r3, #1
34008770:	2b00      	cmp	r3, #0
34008772:	d102      	bne.n	3400877a <HAL_RCCEx_PeriphCLKConfig+0x6e>
      {
        ret = HAL_ERROR;
34008774:	2301      	movs	r3, #1
34008776:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
        WRITE_REG(RCC->BDCR, tmpreg);
#endif /* #if 0  TO DO */
      }
    }

    if (ret == HAL_OK)
3400877a:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
3400877e:	2b00      	cmp	r3, #0
34008780:	d143      	bne.n	3400880a <HAL_RCCEx_PeriphCLKConfig+0xfe>
    {
      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
34008782:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008786:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
3400878a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
3400878e:	d117      	bne.n	340087c0 <HAL_RCCEx_PeriphCLKConfig+0xb4>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
34008790:	f7f9 feba 	bl	34002508 <HAL_GetTick>
34008794:	f8c7 01bc 	str.w	r0, [r7, #444]	@ 0x1bc

        /* Wait till LSE is ready */
        while (LL_RCC_LSE_IsReady() == 0U)
34008798:	e00d      	b.n	340087b6 <HAL_RCCEx_PeriphCLKConfig+0xaa>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
3400879a:	f7f9 feb5 	bl	34002508 <HAL_GetTick>
3400879e:	4602      	mov	r2, r0
340087a0:	f8d7 31bc 	ldr.w	r3, [r7, #444]	@ 0x1bc
340087a4:	1ad2      	subs	r2, r2, r3
340087a6:	f241 3388 	movw	r3, #5000	@ 0x1388
340087aa:	429a      	cmp	r2, r3
340087ac:	d903      	bls.n	340087b6 <HAL_RCCEx_PeriphCLKConfig+0xaa>
          {
            ret = HAL_TIMEOUT;
340087ae:	2303      	movs	r3, #3
340087b0:	f887 31c7 	strb.w	r3, [r7, #455]	@ 0x1c7
            break;
340087b4:	e004      	b.n	340087c0 <HAL_RCCEx_PeriphCLKConfig+0xb4>
        while (LL_RCC_LSE_IsReady() == 0U)
340087b6:	f7ff fc8b 	bl	340080d0 <LL_RCC_LSE_IsReady>
340087ba:	4603      	mov	r3, r0
340087bc:	2b00      	cmp	r3, #0
340087be:	d0ec      	beq.n	3400879a <HAL_RCCEx_PeriphCLKConfig+0x8e>
          }
        }
      }

      if (ret == HAL_OK)
340087c0:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
340087c4:	2b00      	cmp	r3, #0
340087c6:	d11b      	bne.n	34008800 <HAL_RCCEx_PeriphCLKConfig+0xf4>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
340087c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340087cc:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
340087d0:	f403 7340 	and.w	r3, r3, #768	@ 0x300
340087d4:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
340087d8:	d108      	bne.n	340087ec <HAL_RCCEx_PeriphCLKConfig+0xe0>
340087da:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340087de:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
340087e2:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
340087e6:	4618      	mov	r0, r3
340087e8:	f7ff fe76 	bl	340084d8 <LL_RCC_SetRTC_HSEPrescaler>
340087ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340087f0:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
340087f4:	f403 7340 	and.w	r3, r3, #768	@ 0x300
340087f8:	4618      	mov	r0, r3
340087fa:	f7ff fe49 	bl	34008490 <LL_RCC_SetRTCClockSource>
340087fe:	e008      	b.n	34008812 <HAL_RCCEx_PeriphCLKConfig+0x106>
      }
      else
      {
        /* set overall return value */
        status = ret;
34008800:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
34008804:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6
34008808:	e003      	b.n	34008812 <HAL_RCCEx_PeriphCLKConfig+0x106>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
3400880a:	f897 31c7 	ldrb.w	r3, [r7, #455]	@ 0x1c7
3400880e:	f887 31c6 	strb.w	r3, [r7, #454]	@ 0x1c6
    }
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
34008812:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008816:	e9d3 2300 	ldrd	r2, r3, [r3]
3400881a:	f002 0804 	and.w	r8, r2, #4
3400881e:	f04f 0900 	mov.w	r9, #0
34008822:	ea58 0309 	orrs.w	r3, r8, r9
34008826:	f000 809b 	beq.w	34008960 <HAL_RCCEx_PeriphCLKConfig+0x254>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CKPERCLKSOURCE(PeriphClkInit->CkperClockSelection));

    if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC5)
3400882a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400882e:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
34008832:	2b04      	cmp	r3, #4
34008834:	d116      	bne.n	34008864 <HAL_RCCEx_PeriphCLKConfig+0x158>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
34008836:	4b8e      	ldr	r3, [pc, #568]	@ (34008a70 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34008838:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3400883c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008840:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008844:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008848:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
3400884a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400884e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34008850:	3b01      	subs	r3, #1
34008852:	041b      	lsls	r3, r3, #16
34008854:	4313      	orrs	r3, r2
34008856:	4a86      	ldr	r2, [pc, #536]	@ (34008a70 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34008858:	430b      	orrs	r3, r1
3400885a:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
3400885e:	f7ff fe83 	bl	34008568 <LL_RCC_IC5_Enable>
34008862:	e076      	b.n	34008952 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC10)
34008864:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008868:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400886c:	2b05      	cmp	r3, #5
3400886e:	d116      	bne.n	3400889e <HAL_RCCEx_PeriphCLKConfig+0x192>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34008870:	4b7f      	ldr	r3, [pc, #508]	@ (34008a70 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34008872:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34008876:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400887a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400887e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008882:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34008884:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008888:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400888a:	3b01      	subs	r3, #1
3400888c:	041b      	lsls	r3, r3, #16
3400888e:	4313      	orrs	r3, r2
34008890:	4a77      	ldr	r2, [pc, #476]	@ (34008a70 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34008892:	430b      	orrs	r3, r1
34008894:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34008898:	f7ff fe9e 	bl	340085d8 <LL_RCC_IC10_Enable>
3400889c:	e059      	b.n	34008952 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC15)
3400889e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340088a2:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
340088a6:	2b06      	cmp	r3, #6
340088a8:	d116      	bne.n	340088d8 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340088aa:	4b71      	ldr	r3, [pc, #452]	@ (34008a70 <HAL_RCCEx_PeriphCLKConfig+0x364>)
340088ac:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340088b0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340088b4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340088b8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340088bc:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340088be:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340088c2:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340088c4:	3b01      	subs	r3, #1
340088c6:	041b      	lsls	r3, r3, #16
340088c8:	4313      	orrs	r3, r2
340088ca:	4a69      	ldr	r2, [pc, #420]	@ (34008a70 <HAL_RCCEx_PeriphCLKConfig+0x364>)
340088cc:	430b      	orrs	r3, r1
340088ce:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340088d2:	f7ff feb9 	bl	34008648 <LL_RCC_IC15_Enable>
340088d6:	e03c      	b.n	34008952 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC19)
340088d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340088dc:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
340088e0:	2b03      	cmp	r3, #3
340088e2:	d118      	bne.n	34008916 <HAL_RCCEx_PeriphCLKConfig+0x20a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
340088e4:	4b62      	ldr	r3, [pc, #392]	@ (34008a70 <HAL_RCCEx_PeriphCLKConfig+0x364>)
340088e6:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
340088ea:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340088ee:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340088f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340088f6:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
340088fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340088fe:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
34008902:	3b01      	subs	r3, #1
34008904:	041b      	lsls	r3, r3, #16
34008906:	4313      	orrs	r3, r2
34008908:	4a59      	ldr	r2, [pc, #356]	@ (34008a70 <HAL_RCCEx_PeriphCLKConfig+0x364>)
3400890a:	430b      	orrs	r3, r1
3400890c:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
34008910:	f7ff fed2 	bl	340086b8 <LL_RCC_IC19_Enable>
34008914:	e01d      	b.n	34008952 <HAL_RCCEx_PeriphCLKConfig+0x246>
    }
    else if (PeriphClkInit->CkperClockSelection == RCC_CLKPCLKSOURCE_IC20)
34008916:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400891a:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400891e:	2b07      	cmp	r3, #7
34008920:	d117      	bne.n	34008952 <HAL_RCCEx_PeriphCLKConfig+0x246>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
34008922:	4b53      	ldr	r3, [pc, #332]	@ (34008a70 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34008924:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34008928:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400892c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008930:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008934:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
34008938:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400893c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34008940:	3b01      	subs	r3, #1
34008942:	041b      	lsls	r3, r3, #16
34008944:	4313      	orrs	r3, r2
34008946:	4a4a      	ldr	r2, [pc, #296]	@ (34008a70 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34008948:	430b      	orrs	r3, r1
3400894a:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
3400894e:	f7ff fec1 	bl	340086d4 <LL_RCC_IC20_Enable>
    {
      /* No ICx selected as source */
    }

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
34008952:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008956:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
3400895a:	4618      	mov	r0, r3
3400895c:	f7ff fc0a 	bl	34008174 <LL_RCC_SetCLKPClockSource>
  }

  /*-------------------------- XSPI1 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI1) == RCC_PERIPHCLK_XSPI1)
34008960:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008964:	e9d3 2300 	ldrd	r2, r3, [r3]
34008968:	f04f 0a00 	mov.w	sl, #0
3400896c:	f403 0b80 	and.w	fp, r3, #4194304	@ 0x400000
34008970:	ea5a 030b 	orrs.w	r3, sl, fp
34008974:	d04b      	beq.n	34008a0e <HAL_RCCEx_PeriphCLKConfig+0x302>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI1CLKSOURCE(PeriphClkInit->Xspi1ClockSelection));

    if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC3)
34008976:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400897a:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
3400897e:	4b3d      	ldr	r3, [pc, #244]	@ (34008a74 <HAL_RCCEx_PeriphCLKConfig+0x368>)
34008980:	429a      	cmp	r2, r3
34008982:	d116      	bne.n	340089b2 <HAL_RCCEx_PeriphCLKConfig+0x2a6>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
34008984:	4b3a      	ldr	r3, [pc, #232]	@ (34008a70 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34008986:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
3400898a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400898e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008992:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008996:	699a      	ldr	r2, [r3, #24]
34008998:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400899c:	69db      	ldr	r3, [r3, #28]
3400899e:	3b01      	subs	r3, #1
340089a0:	041b      	lsls	r3, r3, #16
340089a2:	4313      	orrs	r3, r2
340089a4:	4a32      	ldr	r2, [pc, #200]	@ (34008a70 <HAL_RCCEx_PeriphCLKConfig+0x364>)
340089a6:	430b      	orrs	r3, r1
340089a8:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
340089ac:	f7ff fdc0 	bl	34008530 <LL_RCC_IC3_Enable>
340089b0:	e026      	b.n	34008a00 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_IC4)
340089b2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340089b6:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
340089ba:	4b2f      	ldr	r3, [pc, #188]	@ (34008a78 <HAL_RCCEx_PeriphCLKConfig+0x36c>)
340089bc:	429a      	cmp	r2, r3
340089be:	d116      	bne.n	340089ee <HAL_RCCEx_PeriphCLKConfig+0x2e2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
340089c0:	4b2b      	ldr	r3, [pc, #172]	@ (34008a70 <HAL_RCCEx_PeriphCLKConfig+0x364>)
340089c2:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
340089c6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340089ca:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340089ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340089d2:	6a1a      	ldr	r2, [r3, #32]
340089d4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340089d8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
340089da:	3b01      	subs	r3, #1
340089dc:	041b      	lsls	r3, r3, #16
340089de:	4313      	orrs	r3, r2
340089e0:	4a23      	ldr	r2, [pc, #140]	@ (34008a70 <HAL_RCCEx_PeriphCLKConfig+0x364>)
340089e2:	430b      	orrs	r3, r1
340089e4:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
340089e8:	f7ff fdb0 	bl	3400854c <LL_RCC_IC4_Enable>
340089ec:	e008      	b.n	34008a00 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    }
    else if (PeriphClkInit->Xspi1ClockSelection == RCC_XSPI1CLKSOURCE_CLKP)
340089ee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340089f2:	f8d3 20ac 	ldr.w	r2, [r3, #172]	@ 0xac
340089f6:	4b21      	ldr	r3, [pc, #132]	@ (34008a7c <HAL_RCCEx_PeriphCLKConfig+0x370>)
340089f8:	429a      	cmp	r2, r3
340089fa:	d101      	bne.n	34008a00 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    {
      LL_RCC_CLKP_Enable();
340089fc:	f7ff fe78 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI1 clock source */
    __HAL_RCC_XSPI1_CONFIG(PeriphClkInit->Xspi1ClockSelection);
34008a00:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008a04:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
34008a08:	4618      	mov	r0, r3
34008a0a:	f7ff fd35 	bl	34008478 <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI2 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI2) == RCC_PERIPHCLK_XSPI2)
34008a0e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008a12:	e9d3 2300 	ldrd	r2, r3, [r3]
34008a16:	2100      	movs	r1, #0
34008a18:	f8c7 11a8 	str.w	r1, [r7, #424]	@ 0x1a8
34008a1c:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
34008a20:	f8c7 31ac 	str.w	r3, [r7, #428]	@ 0x1ac
34008a24:	e9d7 016a 	ldrd	r0, r1, [r7, #424]	@ 0x1a8
34008a28:	4603      	mov	r3, r0
34008a2a:	460a      	mov	r2, r1
34008a2c:	4313      	orrs	r3, r2
34008a2e:	d057      	beq.n	34008ae0 <HAL_RCCEx_PeriphCLKConfig+0x3d4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI2CLKSOURCE(PeriphClkInit->Xspi2ClockSelection));

    if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC3)
34008a30:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008a34:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
34008a38:	4b11      	ldr	r3, [pc, #68]	@ (34008a80 <HAL_RCCEx_PeriphCLKConfig+0x374>)
34008a3a:	429a      	cmp	r2, r3
34008a3c:	d122      	bne.n	34008a84 <HAL_RCCEx_PeriphCLKConfig+0x378>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
34008a3e:	4b0c      	ldr	r3, [pc, #48]	@ (34008a70 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34008a40:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34008a44:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008a48:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008a4c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008a50:	699a      	ldr	r2, [r3, #24]
34008a52:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008a56:	69db      	ldr	r3, [r3, #28]
34008a58:	3b01      	subs	r3, #1
34008a5a:	041b      	lsls	r3, r3, #16
34008a5c:	4313      	orrs	r3, r2
34008a5e:	4a04      	ldr	r2, [pc, #16]	@ (34008a70 <HAL_RCCEx_PeriphCLKConfig+0x364>)
34008a60:	430b      	orrs	r3, r1
34008a62:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
34008a66:	f7ff fd63 	bl	34008530 <LL_RCC_IC3_Enable>
34008a6a:	e032      	b.n	34008ad2 <HAL_RCCEx_PeriphCLKConfig+0x3c6>
34008a6c:	56024800 	.word	0x56024800
34008a70:	56028000 	.word	0x56028000
34008a74:	03020014 	.word	0x03020014
34008a78:	03030014 	.word	0x03030014
34008a7c:	03010014 	.word	0x03010014
34008a80:	03020414 	.word	0x03020414
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_IC4)
34008a84:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008a88:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
34008a8c:	4bc5      	ldr	r3, [pc, #788]	@ (34008da4 <HAL_RCCEx_PeriphCLKConfig+0x698>)
34008a8e:	429a      	cmp	r2, r3
34008a90:	d116      	bne.n	34008ac0 <HAL_RCCEx_PeriphCLKConfig+0x3b4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34008a92:	4bc5      	ldr	r3, [pc, #788]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008a94:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34008a98:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008a9c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008aa0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008aa4:	6a1a      	ldr	r2, [r3, #32]
34008aa6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008aaa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34008aac:	3b01      	subs	r3, #1
34008aae:	041b      	lsls	r3, r3, #16
34008ab0:	4313      	orrs	r3, r2
34008ab2:	4abd      	ldr	r2, [pc, #756]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008ab4:	430b      	orrs	r3, r1
34008ab6:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34008aba:	f7ff fd47 	bl	3400854c <LL_RCC_IC4_Enable>
34008abe:	e008      	b.n	34008ad2 <HAL_RCCEx_PeriphCLKConfig+0x3c6>
    }
    else if (PeriphClkInit->Xspi2ClockSelection == RCC_XSPI2CLKSOURCE_CLKP)
34008ac0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008ac4:	f8d3 20b0 	ldr.w	r2, [r3, #176]	@ 0xb0
34008ac8:	4bb8      	ldr	r3, [pc, #736]	@ (34008dac <HAL_RCCEx_PeriphCLKConfig+0x6a0>)
34008aca:	429a      	cmp	r2, r3
34008acc:	d101      	bne.n	34008ad2 <HAL_RCCEx_PeriphCLKConfig+0x3c6>
    {
      LL_RCC_CLKP_Enable();
34008ace:	f7ff fe0f 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI2 clock source */
    __HAL_RCC_XSPI2_CONFIG(PeriphClkInit->Xspi2ClockSelection);
34008ad2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008ad6:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
34008ada:	4618      	mov	r0, r3
34008adc:	f7ff fccc 	bl	34008478 <LL_RCC_SetXSPIClockSource>
  }

  /*-------------------------- XSPI3 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI3) == RCC_PERIPHCLK_XSPI3)
34008ae0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008ae4:	e9d3 2300 	ldrd	r2, r3, [r3]
34008ae8:	2100      	movs	r1, #0
34008aea:	f8c7 11a0 	str.w	r1, [r7, #416]	@ 0x1a0
34008aee:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
34008af2:	f8c7 31a4 	str.w	r3, [r7, #420]	@ 0x1a4
34008af6:	e9d7 0168 	ldrd	r0, r1, [r7, #416]	@ 0x1a0
34008afa:	4603      	mov	r3, r0
34008afc:	460a      	mov	r2, r1
34008afe:	4313      	orrs	r3, r2
34008b00:	d04b      	beq.n	34008b9a <HAL_RCCEx_PeriphCLKConfig+0x48e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI3CLKSOURCE(PeriphClkInit->Xspi3ClockSelection));

    if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC3)
34008b02:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008b06:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
34008b0a:	4ba9      	ldr	r3, [pc, #676]	@ (34008db0 <HAL_RCCEx_PeriphCLKConfig+0x6a4>)
34008b0c:	429a      	cmp	r2, r3
34008b0e:	d116      	bne.n	34008b3e <HAL_RCCEx_PeriphCLKConfig+0x432>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
34008b10:	4ba5      	ldr	r3, [pc, #660]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008b12:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34008b16:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008b1a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008b1e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008b22:	699a      	ldr	r2, [r3, #24]
34008b24:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008b28:	69db      	ldr	r3, [r3, #28]
34008b2a:	3b01      	subs	r3, #1
34008b2c:	041b      	lsls	r3, r3, #16
34008b2e:	4313      	orrs	r3, r2
34008b30:	4a9d      	ldr	r2, [pc, #628]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008b32:	430b      	orrs	r3, r1
34008b34:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
34008b38:	f7ff fcfa 	bl	34008530 <LL_RCC_IC3_Enable>
34008b3c:	e026      	b.n	34008b8c <HAL_RCCEx_PeriphCLKConfig+0x480>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_IC4)
34008b3e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008b42:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
34008b46:	4b9b      	ldr	r3, [pc, #620]	@ (34008db4 <HAL_RCCEx_PeriphCLKConfig+0x6a8>)
34008b48:	429a      	cmp	r2, r3
34008b4a:	d116      	bne.n	34008b7a <HAL_RCCEx_PeriphCLKConfig+0x46e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34008b4c:	4b96      	ldr	r3, [pc, #600]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008b4e:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34008b52:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008b56:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008b5a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008b5e:	6a1a      	ldr	r2, [r3, #32]
34008b60:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008b64:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34008b66:	3b01      	subs	r3, #1
34008b68:	041b      	lsls	r3, r3, #16
34008b6a:	4313      	orrs	r3, r2
34008b6c:	4a8e      	ldr	r2, [pc, #568]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008b6e:	430b      	orrs	r3, r1
34008b70:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34008b74:	f7ff fcea 	bl	3400854c <LL_RCC_IC4_Enable>
34008b78:	e008      	b.n	34008b8c <HAL_RCCEx_PeriphCLKConfig+0x480>
    }
    else if (PeriphClkInit->Xspi3ClockSelection == RCC_XSPI3CLKSOURCE_CLKP)
34008b7a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008b7e:	f8d3 20b4 	ldr.w	r2, [r3, #180]	@ 0xb4
34008b82:	4b8d      	ldr	r3, [pc, #564]	@ (34008db8 <HAL_RCCEx_PeriphCLKConfig+0x6ac>)
34008b84:	429a      	cmp	r2, r3
34008b86:	d101      	bne.n	34008b8c <HAL_RCCEx_PeriphCLKConfig+0x480>
    {
      LL_RCC_CLKP_Enable();
34008b88:	f7ff fdb2 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the XSPI3 clock source */
    __HAL_RCC_XSPI3_CONFIG(PeriphClkInit->Xspi3ClockSelection);
34008b8c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008b90:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
34008b94:	4618      	mov	r0, r3
34008b96:	f7ff fc6f 	bl	34008478 <LL_RCC_SetXSPIClockSource>
  }

  /*---------------------------- FMC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
34008b9a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008b9e:	e9d3 2300 	ldrd	r2, r3, [r3]
34008ba2:	f402 6300 	and.w	r3, r2, #2048	@ 0x800
34008ba6:	f8c7 3198 	str.w	r3, [r7, #408]	@ 0x198
34008baa:	2300      	movs	r3, #0
34008bac:	f8c7 319c 	str.w	r3, [r7, #412]	@ 0x19c
34008bb0:	e9d7 0166 	ldrd	r0, r1, [r7, #408]	@ 0x198
34008bb4:	4603      	mov	r3, r0
34008bb6:	460a      	mov	r2, r1
34008bb8:	4313      	orrs	r3, r2
34008bba:	d048      	beq.n	34008c4e <HAL_RCCEx_PeriphCLKConfig+0x542>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FMCCLKSOURCE(PeriphClkInit->FmcClockSelection));

    if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC3)
34008bbc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008bc0:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34008bc4:	2b20      	cmp	r3, #32
34008bc6:	d116      	bne.n	34008bf6 <HAL_RCCEx_PeriphCLKConfig+0x4ea>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC3].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC3].ClockDivider));

      /* Set IC3 configuration */
      MODIFY_REG(RCC->IC3CFGR, RCC_IC3CFGR_IC3SEL | RCC_IC3CFGR_IC3INT,
34008bc8:	4b77      	ldr	r3, [pc, #476]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008bca:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34008bce:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008bd2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008bd6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008bda:	699a      	ldr	r2, [r3, #24]
34008bdc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008be0:	69db      	ldr	r3, [r3, #28]
34008be2:	3b01      	subs	r3, #1
34008be4:	041b      	lsls	r3, r3, #16
34008be6:	4313      	orrs	r3, r2
34008be8:	4a6f      	ldr	r2, [pc, #444]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008bea:	430b      	orrs	r3, r1
34008bec:	f8c2 30cc 	str.w	r3, [r2, #204]	@ 0xcc
                 PeriphClkInit->ICSelection[RCC_IC3].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC3].ClockDivider - 1U) << RCC_IC3CFGR_IC3INT_Pos));

      LL_RCC_IC3_Enable();
34008bf0:	f7ff fc9e 	bl	34008530 <LL_RCC_IC3_Enable>
34008bf4:	e024      	b.n	34008c40 <HAL_RCCEx_PeriphCLKConfig+0x534>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_IC4)
34008bf6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008bfa:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34008bfe:	2b30      	cmp	r3, #48	@ 0x30
34008c00:	d116      	bne.n	34008c30 <HAL_RCCEx_PeriphCLKConfig+0x524>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34008c02:	4b69      	ldr	r3, [pc, #420]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008c04:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34008c08:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008c0c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008c10:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008c14:	6a1a      	ldr	r2, [r3, #32]
34008c16:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008c1a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34008c1c:	3b01      	subs	r3, #1
34008c1e:	041b      	lsls	r3, r3, #16
34008c20:	4313      	orrs	r3, r2
34008c22:	4a61      	ldr	r2, [pc, #388]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008c24:	430b      	orrs	r3, r1
34008c26:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34008c2a:	f7ff fc8f 	bl	3400854c <LL_RCC_IC4_Enable>
34008c2e:	e007      	b.n	34008c40 <HAL_RCCEx_PeriphCLKConfig+0x534>
    }
    else if (PeriphClkInit->FmcClockSelection == RCC_FMCCLKSOURCE_CLKP)
34008c30:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008c34:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34008c38:	2b10      	cmp	r3, #16
34008c3a:	d101      	bne.n	34008c40 <HAL_RCCEx_PeriphCLKConfig+0x534>
    {
      LL_RCC_CLKP_Enable();
34008c3c:	f7ff fd58 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FMC kernel clock*/
    __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
34008c40:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008c44:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
34008c48:	4618      	mov	r0, r3
34008c4a:	f7ff fb2d 	bl	340082a8 <LL_RCC_SetFMCClockSource>
  }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
34008c4e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008c52:	e9d3 2300 	ldrd	r2, r3, [r3]
34008c56:	f002 4380 	and.w	r3, r2, #1073741824	@ 0x40000000
34008c5a:	f8c7 3190 	str.w	r3, [r7, #400]	@ 0x190
34008c5e:	2300      	movs	r3, #0
34008c60:	f8c7 3194 	str.w	r3, [r7, #404]	@ 0x194
34008c64:	e9d7 0164 	ldrd	r0, r1, [r7, #400]	@ 0x190
34008c68:	4603      	mov	r3, r0
34008c6a:	460a      	mov	r2, r1
34008c6c:	4313      	orrs	r3, r2
34008c6e:	d04b      	beq.n	34008d08 <HAL_RCCEx_PeriphCLKConfig+0x5fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC4)
34008c70:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008c74:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
34008c78:	4b50      	ldr	r3, [pc, #320]	@ (34008dbc <HAL_RCCEx_PeriphCLKConfig+0x6b0>)
34008c7a:	429a      	cmp	r2, r3
34008c7c:	d116      	bne.n	34008cac <HAL_RCCEx_PeriphCLKConfig+0x5a0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34008c7e:	4b4a      	ldr	r3, [pc, #296]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008c80:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34008c84:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008c88:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008c8c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008c90:	6a1a      	ldr	r2, [r3, #32]
34008c92:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008c96:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34008c98:	3b01      	subs	r3, #1
34008c9a:	041b      	lsls	r3, r3, #16
34008c9c:	4313      	orrs	r3, r2
34008c9e:	4a42      	ldr	r2, [pc, #264]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008ca0:	430b      	orrs	r3, r1
34008ca2:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34008ca6:	f7ff fc51 	bl	3400854c <LL_RCC_IC4_Enable>
34008caa:	e026      	b.n	34008cfa <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_IC5)
34008cac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008cb0:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
34008cb4:	4b42      	ldr	r3, [pc, #264]	@ (34008dc0 <HAL_RCCEx_PeriphCLKConfig+0x6b4>)
34008cb6:	429a      	cmp	r2, r3
34008cb8:	d116      	bne.n	34008ce8 <HAL_RCCEx_PeriphCLKConfig+0x5dc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
34008cba:	4b3b      	ldr	r3, [pc, #236]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008cbc:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34008cc0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008cc4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008cc8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008ccc:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34008cce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008cd2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34008cd4:	3b01      	subs	r3, #1
34008cd6:	041b      	lsls	r3, r3, #16
34008cd8:	4313      	orrs	r3, r2
34008cda:	4a33      	ldr	r2, [pc, #204]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008cdc:	430b      	orrs	r3, r1
34008cde:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
34008ce2:	f7ff fc41 	bl	34008568 <LL_RCC_IC5_Enable>
34008ce6:	e008      	b.n	34008cfa <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    }
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_CLKP)
34008ce8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008cec:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
34008cf0:	4b34      	ldr	r3, [pc, #208]	@ (34008dc4 <HAL_RCCEx_PeriphCLKConfig+0x6b8>)
34008cf2:	429a      	cmp	r2, r3
34008cf4:	d101      	bne.n	34008cfa <HAL_RCCEx_PeriphCLKConfig+0x5ee>
    {
      LL_RCC_CLKP_Enable();
34008cf6:	f7ff fcfb 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC1 clock*/
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
34008cfa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008cfe:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
34008d02:	4618      	mov	r0, r3
34008d04:	f7ff fb81 	bl	3400840a <LL_RCC_SetSDMMCClockSource>
  }

  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
34008d08:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008d0c:	e9d3 2300 	ldrd	r2, r3, [r3]
34008d10:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
34008d14:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
34008d18:	2300      	movs	r3, #0
34008d1a:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
34008d1e:	e9d7 0162 	ldrd	r0, r1, [r7, #392]	@ 0x188
34008d22:	4603      	mov	r3, r0
34008d24:	460a      	mov	r2, r1
34008d26:	4313      	orrs	r3, r2
34008d28:	d062      	beq.n	34008df0 <HAL_RCCEx_PeriphCLKConfig+0x6e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));

    if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC4)
34008d2a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008d2e:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
34008d32:	4b25      	ldr	r3, [pc, #148]	@ (34008dc8 <HAL_RCCEx_PeriphCLKConfig+0x6bc>)
34008d34:	429a      	cmp	r2, r3
34008d36:	d116      	bne.n	34008d66 <HAL_RCCEx_PeriphCLKConfig+0x65a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC4].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC4].ClockDivider));

      /* Set IC4 configuration */
      MODIFY_REG(RCC->IC4CFGR, RCC_IC4CFGR_IC4SEL | RCC_IC4CFGR_IC4INT,
34008d38:	4b1b      	ldr	r3, [pc, #108]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008d3a:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
34008d3e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008d42:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008d46:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008d4a:	6a1a      	ldr	r2, [r3, #32]
34008d4c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008d50:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
34008d52:	3b01      	subs	r3, #1
34008d54:	041b      	lsls	r3, r3, #16
34008d56:	4313      	orrs	r3, r2
34008d58:	4a13      	ldr	r2, [pc, #76]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008d5a:	430b      	orrs	r3, r1
34008d5c:	f8c2 30d0 	str.w	r3, [r2, #208]	@ 0xd0
                 PeriphClkInit->ICSelection[RCC_IC4].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC4].ClockDivider - 1U) << RCC_IC4CFGR_IC4INT_Pos));

      LL_RCC_IC4_Enable();
34008d60:	f7ff fbf4 	bl	3400854c <LL_RCC_IC4_Enable>
34008d64:	e03d      	b.n	34008de2 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_IC5)
34008d66:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008d6a:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
34008d6e:	4b17      	ldr	r3, [pc, #92]	@ (34008dcc <HAL_RCCEx_PeriphCLKConfig+0x6c0>)
34008d70:	429a      	cmp	r2, r3
34008d72:	d12d      	bne.n	34008dd0 <HAL_RCCEx_PeriphCLKConfig+0x6c4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC5].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC5].ClockDivider));

      /* Set IC5 configuration */
      MODIFY_REG(RCC->IC5CFGR, RCC_IC5CFGR_IC5SEL | RCC_IC5CFGR_IC5INT,
34008d74:	4b0c      	ldr	r3, [pc, #48]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008d76:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
34008d7a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008d7e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008d82:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008d86:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
34008d88:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008d8c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
34008d8e:	3b01      	subs	r3, #1
34008d90:	041b      	lsls	r3, r3, #16
34008d92:	4313      	orrs	r3, r2
34008d94:	4a04      	ldr	r2, [pc, #16]	@ (34008da8 <HAL_RCCEx_PeriphCLKConfig+0x69c>)
34008d96:	430b      	orrs	r3, r1
34008d98:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
                 PeriphClkInit->ICSelection[RCC_IC5].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC5].ClockDivider - 1U) << RCC_IC5CFGR_IC5INT_Pos));

      LL_RCC_IC5_Enable();
34008d9c:	f7ff fbe4 	bl	34008568 <LL_RCC_IC5_Enable>
34008da0:	e01f      	b.n	34008de2 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
34008da2:	bf00      	nop
34008da4:	03030414 	.word	0x03030414
34008da8:	56028000 	.word	0x56028000
34008dac:	03010414 	.word	0x03010414
34008db0:	03020814 	.word	0x03020814
34008db4:	03030814 	.word	0x03030814
34008db8:	03010814 	.word	0x03010814
34008dbc:	0302001c 	.word	0x0302001c
34008dc0:	0303001c 	.word	0x0303001c
34008dc4:	0301001c 	.word	0x0301001c
34008dc8:	0302041c 	.word	0x0302041c
34008dcc:	0303041c 	.word	0x0303041c
    }
    else if (PeriphClkInit->Sdmmc2ClockSelection == RCC_SDMMC2CLKSOURCE_CLKP)
34008dd0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008dd4:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
34008dd8:	4bb3      	ldr	r3, [pc, #716]	@ (340090a8 <HAL_RCCEx_PeriphCLKConfig+0x99c>)
34008dda:	429a      	cmp	r2, r3
34008ddc:	d101      	bne.n	34008de2 <HAL_RCCEx_PeriphCLKConfig+0x6d6>
    {
      LL_RCC_CLKP_Enable();
34008dde:	f7ff fc87 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SDMMC2 clock*/
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
34008de2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008de6:	f8d3 3130 	ldr.w	r3, [r3, #304]	@ 0x130
34008dea:	4618      	mov	r0, r3
34008dec:	f7ff fb0d 	bl	3400840a <LL_RCC_SetSDMMCClockSource>
  }

  /*---------------------------- ADC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
34008df0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008df4:	e9d3 2300 	ldrd	r2, r3, [r3]
34008df8:	f002 0301 	and.w	r3, r2, #1
34008dfc:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
34008e00:	2300      	movs	r3, #0
34008e02:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
34008e06:	e9d7 0160 	ldrd	r0, r1, [r7, #384]	@ 0x180
34008e0a:	4603      	mov	r3, r0
34008e0c:	460a      	mov	r2, r1
34008e0e:	4313      	orrs	r3, r2
34008e10:	d057      	beq.n	34008ec2 <HAL_RCCEx_PeriphCLKConfig+0x7b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));
    assert_param(IS_RCC_ADCDIVIDER(PeriphClkInit->AdcDivider));

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC7)
34008e12:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008e16:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34008e1a:	2b20      	cmp	r3, #32
34008e1c:	d116      	bne.n	34008e4c <HAL_RCCEx_PeriphCLKConfig+0x740>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34008e1e:	4ba3      	ldr	r3, [pc, #652]	@ (340090ac <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34008e20:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34008e24:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008e28:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008e2c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008e30:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34008e32:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008e36:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34008e38:	3b01      	subs	r3, #1
34008e3a:	041b      	lsls	r3, r3, #16
34008e3c:	4313      	orrs	r3, r2
34008e3e:	4a9b      	ldr	r2, [pc, #620]	@ (340090ac <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34008e40:	430b      	orrs	r3, r1
34008e42:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34008e46:	f7ff fb9d 	bl	34008584 <LL_RCC_IC7_Enable>
34008e4a:	e024      	b.n	34008e96 <HAL_RCCEx_PeriphCLKConfig+0x78a>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_IC8)
34008e4c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008e50:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34008e54:	2b30      	cmp	r3, #48	@ 0x30
34008e56:	d116      	bne.n	34008e86 <HAL_RCCEx_PeriphCLKConfig+0x77a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34008e58:	4b94      	ldr	r3, [pc, #592]	@ (340090ac <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34008e5a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34008e5e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008e62:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008e66:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008e6a:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34008e6c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008e70:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34008e72:	3b01      	subs	r3, #1
34008e74:	041b      	lsls	r3, r3, #16
34008e76:	4313      	orrs	r3, r2
34008e78:	4a8c      	ldr	r2, [pc, #560]	@ (340090ac <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34008e7a:	430b      	orrs	r3, r1
34008e7c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34008e80:	f7ff fb8e 	bl	340085a0 <LL_RCC_IC8_Enable>
34008e84:	e007      	b.n	34008e96 <HAL_RCCEx_PeriphCLKConfig+0x78a>
    }
    else if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_CLKP)
34008e86:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008e8a:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34008e8e:	2b10      	cmp	r3, #16
34008e90:	d101      	bne.n	34008e96 <HAL_RCCEx_PeriphCLKConfig+0x78a>
    {
      LL_RCC_CLKP_Enable();
34008e92:	f7ff fc2d 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ADC clock source and divider */
    MODIFY_REG(RCC->CCIPR1, (RCC_CCIPR1_ADCPRE | RCC_CCIPR1_ADC12SEL), \
34008e96:	4b85      	ldr	r3, [pc, #532]	@ (340090ac <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34008e98:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
34008e9c:	f423 417f 	bic.w	r1, r3, #65280	@ 0xff00
34008ea0:	f021 0170 	bic.w	r1, r1, #112	@ 0x70
34008ea4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008ea8:	f8d3 30c0 	ldr.w	r3, [r3, #192]	@ 0xc0
34008eac:	3b01      	subs	r3, #1
34008eae:	021a      	lsls	r2, r3, #8
34008eb0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008eb4:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
34008eb8:	4313      	orrs	r3, r2
34008eba:	4a7c      	ldr	r2, [pc, #496]	@ (340090ac <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34008ebc:	430b      	orrs	r3, r1
34008ebe:	f8c2 3144 	str.w	r3, [r2, #324]	@ 0x144
               (((PeriphClkInit->AdcDivider - 1U) << RCC_CCIPR1_ADCPRE_Pos) | (PeriphClkInit->AdcClockSelection)));
  }

  /*---------------------------- ADF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
34008ec2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008ec6:	e9d3 2300 	ldrd	r2, r3, [r3]
34008eca:	f002 0302 	and.w	r3, r2, #2
34008ece:	f8c7 3178 	str.w	r3, [r7, #376]	@ 0x178
34008ed2:	2300      	movs	r3, #0
34008ed4:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
34008ed8:	e9d7 015e 	ldrd	r0, r1, [r7, #376]	@ 0x178
34008edc:	4603      	mov	r3, r0
34008ede:	460a      	mov	r2, r1
34008ee0:	4313      	orrs	r3, r2
34008ee2:	d048      	beq.n	34008f76 <HAL_RCCEx_PeriphCLKConfig+0x86a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADF1CLKSOURCE(PeriphClkInit->Adf1ClockSelection));

    if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC7)
34008ee4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008ee8:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34008eec:	2b02      	cmp	r3, #2
34008eee:	d116      	bne.n	34008f1e <HAL_RCCEx_PeriphCLKConfig+0x812>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34008ef0:	4b6e      	ldr	r3, [pc, #440]	@ (340090ac <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34008ef2:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34008ef6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008efa:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008efe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008f02:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34008f04:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008f08:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34008f0a:	3b01      	subs	r3, #1
34008f0c:	041b      	lsls	r3, r3, #16
34008f0e:	4313      	orrs	r3, r2
34008f10:	4a66      	ldr	r2, [pc, #408]	@ (340090ac <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34008f12:	430b      	orrs	r3, r1
34008f14:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34008f18:	f7ff fb34 	bl	34008584 <LL_RCC_IC7_Enable>
34008f1c:	e024      	b.n	34008f68 <HAL_RCCEx_PeriphCLKConfig+0x85c>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_IC8)
34008f1e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008f22:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34008f26:	2b03      	cmp	r3, #3
34008f28:	d116      	bne.n	34008f58 <HAL_RCCEx_PeriphCLKConfig+0x84c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34008f2a:	4b60      	ldr	r3, [pc, #384]	@ (340090ac <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34008f2c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34008f30:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008f34:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008f38:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008f3c:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34008f3e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008f42:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34008f44:	3b01      	subs	r3, #1
34008f46:	041b      	lsls	r3, r3, #16
34008f48:	4313      	orrs	r3, r2
34008f4a:	4a58      	ldr	r2, [pc, #352]	@ (340090ac <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34008f4c:	430b      	orrs	r3, r1
34008f4e:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34008f52:	f7ff fb25 	bl	340085a0 <LL_RCC_IC8_Enable>
34008f56:	e007      	b.n	34008f68 <HAL_RCCEx_PeriphCLKConfig+0x85c>
    }
    else if (PeriphClkInit->Adf1ClockSelection == RCC_ADF1CLKSOURCE_CLKP)
34008f58:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008f5c:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34008f60:	2b01      	cmp	r3, #1
34008f62:	d101      	bne.n	34008f68 <HAL_RCCEx_PeriphCLKConfig+0x85c>
    {
      LL_RCC_CLKP_Enable();
34008f64:	f7ff fbc4 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of ADF1 clock*/
    __HAL_RCC_ADF1_CONFIG(PeriphClkInit->Adf1ClockSelection);
34008f68:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008f6c:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
34008f70:	4618      	mov	r0, r3
34008f72:	f7ff f8e9 	bl	34008148 <LL_RCC_SetADFClockSource>
  }

  /*------------------------------------ CSI configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CSI) == RCC_PERIPHCLK_CSI)
34008f76:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008f7a:	e9d3 2300 	ldrd	r2, r3, [r3]
34008f7e:	f002 0308 	and.w	r3, r2, #8
34008f82:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
34008f86:	2300      	movs	r3, #0
34008f88:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
34008f8c:	e9d7 015c 	ldrd	r0, r1, [r7, #368]	@ 0x170
34008f90:	4603      	mov	r3, r0
34008f92:	460a      	mov	r2, r1
34008f94:	4313      	orrs	r3, r2
34008f96:	d017      	beq.n	34008fc8 <HAL_RCCEx_PeriphCLKConfig+0x8bc>
    /* Check the parameters */
    assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC18].ClockSelection));
    assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC18].ClockDivider));

    /* Set IC18 configuration */
    MODIFY_REG(RCC->IC18CFGR, RCC_IC18CFGR_IC18SEL | RCC_IC18CFGR_IC18INT,
34008f98:	4b44      	ldr	r3, [pc, #272]	@ (340090ac <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34008f9a:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
34008f9e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34008fa2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34008fa6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008faa:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
34008fae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008fb2:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
34008fb6:	3b01      	subs	r3, #1
34008fb8:	041b      	lsls	r3, r3, #16
34008fba:	4313      	orrs	r3, r2
34008fbc:	4a3b      	ldr	r2, [pc, #236]	@ (340090ac <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34008fbe:	430b      	orrs	r3, r1
34008fc0:	f8c2 3108 	str.w	r3, [r2, #264]	@ 0x108
               PeriphClkInit->ICSelection[RCC_IC18].ClockSelection | \
               ((PeriphClkInit->ICSelection[RCC_IC18].ClockDivider - 1U) << RCC_IC18CFGR_IC18INT_Pos));

    LL_RCC_IC18_Enable();
34008fc4:	f7ff fb6a 	bl	3400869c <LL_RCC_IC18_Enable>
  }

  /*---------------------- DCMIPP configuration ------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_DCMIPP) == RCC_PERIPHCLK_DCMIPP)
34008fc8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008fcc:	e9d3 2300 	ldrd	r2, r3, [r3]
34008fd0:	f002 0310 	and.w	r3, r2, #16
34008fd4:	f8c7 3168 	str.w	r3, [r7, #360]	@ 0x168
34008fd8:	2300      	movs	r3, #0
34008fda:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c
34008fde:	e9d7 015a 	ldrd	r0, r1, [r7, #360]	@ 0x168
34008fe2:	4603      	mov	r3, r0
34008fe4:	460a      	mov	r2, r1
34008fe6:	4313      	orrs	r3, r2
34008fe8:	d02f      	beq.n	3400904a <HAL_RCCEx_PeriphCLKConfig+0x93e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DCMIPPCLKSOURCE(PeriphClkInit->DcmippClockSelection));

    if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_IC17)
34008fea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34008fee:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34008ff2:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
34008ff6:	d118      	bne.n	3400902a <HAL_RCCEx_PeriphCLKConfig+0x91e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC17].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC17].ClockDivider));

      /* Set IC17 configuration */
      MODIFY_REG(RCC->IC17CFGR, RCC_IC17CFGR_IC17SEL | RCC_IC17CFGR_IC17INT,
34008ff8:	4b2c      	ldr	r3, [pc, #176]	@ (340090ac <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
34008ffa:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34008ffe:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009002:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009006:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400900a:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
3400900e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009012:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
34009016:	3b01      	subs	r3, #1
34009018:	041b      	lsls	r3, r3, #16
3400901a:	4313      	orrs	r3, r2
3400901c:	4a23      	ldr	r2, [pc, #140]	@ (340090ac <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3400901e:	430b      	orrs	r3, r1
34009020:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
                 PeriphClkInit->ICSelection[RCC_IC17].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC17].ClockDivider - 1U) << RCC_IC17CFGR_IC17INT_Pos));

      LL_RCC_IC17_Enable();
34009024:	f7ff fb2c 	bl	34008680 <LL_RCC_IC17_Enable>
34009028:	e008      	b.n	3400903c <HAL_RCCEx_PeriphCLKConfig+0x930>
    }
    else if (PeriphClkInit->DcmippClockSelection == RCC_DCMIPPCLKSOURCE_CLKP)
3400902a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400902e:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34009032:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
34009036:	d101      	bne.n	3400903c <HAL_RCCEx_PeriphCLKConfig+0x930>
    {
      LL_RCC_CLKP_Enable();
34009038:	f7ff fb5a 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the CEC clock source */
    __HAL_RCC_DCMIPP_CONFIG(PeriphClkInit->DcmippClockSelection);
3400903c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009040:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
34009044:	4618      	mov	r0, r3
34009046:	f7ff f8ab 	bl	340081a0 <LL_RCC_SetDCMIPPClockSource>
  }

  /*---------------------- ETH1 configuration --------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1) == RCC_PERIPHCLK_ETH1)
3400904a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400904e:	e9d3 2300 	ldrd	r2, r3, [r3]
34009052:	f002 0320 	and.w	r3, r2, #32
34009056:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
3400905a:	2300      	movs	r3, #0
3400905c:	f8c7 3164 	str.w	r3, [r7, #356]	@ 0x164
34009060:	e9d7 0158 	ldrd	r0, r1, [r7, #352]	@ 0x160
34009064:	4603      	mov	r3, r0
34009066:	460a      	mov	r2, r1
34009068:	4313      	orrs	r3, r2
3400906a:	d031      	beq.n	340090d0 <HAL_RCCEx_PeriphCLKConfig+0x9c4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1CLKSOURCE(PeriphClkInit->Eth1ClockSelection));

    if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_IC12)
3400906c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009070:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
34009074:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
34009078:	d11a      	bne.n	340090b0 <HAL_RCCEx_PeriphCLKConfig+0x9a4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC12].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC12].ClockDivider));

      /* Set IC12 configuration */
      MODIFY_REG(RCC->IC12CFGR, RCC_IC12CFGR_IC12SEL | RCC_IC12CFGR_IC12INT,
3400907a:	4b0c      	ldr	r3, [pc, #48]	@ (340090ac <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3400907c:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
34009080:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009084:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009088:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400908c:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
3400908e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009092:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
34009094:	3b01      	subs	r3, #1
34009096:	041b      	lsls	r3, r3, #16
34009098:	4313      	orrs	r3, r2
3400909a:	4a04      	ldr	r2, [pc, #16]	@ (340090ac <HAL_RCCEx_PeriphCLKConfig+0x9a0>)
3400909c:	430b      	orrs	r3, r1
3400909e:	f8c2 30f0 	str.w	r3, [r2, #240]	@ 0xf0
                 PeriphClkInit->ICSelection[RCC_IC12].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC12].ClockDivider - 1U) << RCC_IC12CFGR_IC12INT_Pos));

      LL_RCC_IC12_Enable();
340090a2:	f7ff faa7 	bl	340085f4 <LL_RCC_IC12_Enable>
340090a6:	e00c      	b.n	340090c2 <HAL_RCCEx_PeriphCLKConfig+0x9b6>
340090a8:	0301041c 	.word	0x0301041c
340090ac:	56028000 	.word	0x56028000
    }
    else if (PeriphClkInit->Eth1ClockSelection == RCC_ETH1CLKSOURCE_CLKP)
340090b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340090b4:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
340090b8:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
340090bc:	d101      	bne.n	340090c2 <HAL_RCCEx_PeriphCLKConfig+0x9b6>
    {
      LL_RCC_CLKP_Enable();
340090be:	f7ff fb17 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 clock source */
    __HAL_RCC_ETH1_CONFIG(PeriphClkInit->Eth1ClockSelection);
340090c2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340090c6:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
340090ca:	4618      	mov	r0, r3
340090cc:	f7ff f87e 	bl	340081cc <LL_RCC_SetETHClockSource>
  }

  /*---------------------- ETH1PHY configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PHY) == RCC_PERIPHCLK_ETH1PHY)
340090d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340090d4:	e9d3 2300 	ldrd	r2, r3, [r3]
340090d8:	f002 0340 	and.w	r3, r2, #64	@ 0x40
340090dc:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
340090e0:	2300      	movs	r3, #0
340090e2:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
340090e6:	e9d7 0156 	ldrd	r0, r1, [r7, #344]	@ 0x158
340090ea:	4603      	mov	r3, r0
340090ec:	460a      	mov	r2, r1
340090ee:	4313      	orrs	r3, r2
340090f0:	d006      	beq.n	34009100 <HAL_RCCEx_PeriphCLKConfig+0x9f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PHYIF(PeriphClkInit->Eth1PhyInterfaceSelection));

    /* Configure the source of ETH1 PHY interface */
    __HAL_RCC_ETH1PHY_CONFIG(PeriphClkInit->Eth1PhyInterfaceSelection);
340090f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340090f6:	f8d3 30d0 	ldr.w	r3, [r3, #208]	@ 0xd0
340090fa:	4618      	mov	r0, r3
340090fc:	f7ff f87c 	bl	340081f8 <LL_RCC_SetETHPHYInterface>
  }

  /*---------------------- ETH1 RX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1RX) == RCC_PERIPHCLK_ETH1RX)
34009100:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009104:	e9d3 2300 	ldrd	r2, r3, [r3]
34009108:	f002 0380 	and.w	r3, r2, #128	@ 0x80
3400910c:	f8c7 3150 	str.w	r3, [r7, #336]	@ 0x150
34009110:	2300      	movs	r3, #0
34009112:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
34009116:	e9d7 0154 	ldrd	r0, r1, [r7, #336]	@ 0x150
3400911a:	4603      	mov	r3, r0
3400911c:	460a      	mov	r2, r1
3400911e:	4313      	orrs	r3, r2
34009120:	d006      	beq.n	34009130 <HAL_RCCEx_PeriphCLKConfig+0xa24>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1RXCLKSOURCE(PeriphClkInit->Eth1RxClockSelection));

    /* Configure the ETH1 RX clock source */
    __HAL_RCC_ETH1RX_CONFIG(PeriphClkInit->Eth1RxClockSelection);
34009122:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009126:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
3400912a:	4618      	mov	r0, r3
3400912c:	f7ff f87a 	bl	34008224 <LL_RCC_SetETHREFRXClockSource>
  }

  /*---------------------- ETH1 TX configuration -----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1TX) == RCC_PERIPHCLK_ETH1TX)
34009130:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009134:	e9d3 2300 	ldrd	r2, r3, [r3]
34009138:	f402 7380 	and.w	r3, r2, #256	@ 0x100
3400913c:	f8c7 3148 	str.w	r3, [r7, #328]	@ 0x148
34009140:	2300      	movs	r3, #0
34009142:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
34009146:	e9d7 0152 	ldrd	r0, r1, [r7, #328]	@ 0x148
3400914a:	4603      	mov	r3, r0
3400914c:	460a      	mov	r2, r1
3400914e:	4313      	orrs	r3, r2
34009150:	d006      	beq.n	34009160 <HAL_RCCEx_PeriphCLKConfig+0xa54>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1TXCLKSOURCE(PeriphClkInit->Eth1TxClockSelection));

    /* Configure the ETH1 TX clock source */
    __HAL_RCC_ETH1TX_CONFIG(PeriphClkInit->Eth1TxClockSelection);
34009152:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009156:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
3400915a:	4618      	mov	r0, r3
3400915c:	f7ff f878 	bl	34008250 <LL_RCC_SetETHREFTXClockSource>
  }

  /*---------------------- ETH1 PTP configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PTP) == RCC_PERIPHCLK_ETH1PTP)
34009160:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009164:	e9d3 2300 	ldrd	r2, r3, [r3]
34009168:	f402 7300 	and.w	r3, r2, #512	@ 0x200
3400916c:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
34009170:	2300      	movs	r3, #0
34009172:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
34009176:	e9d7 0150 	ldrd	r0, r1, [r7, #320]	@ 0x140
3400917a:	4603      	mov	r3, r0
3400917c:	460a      	mov	r2, r1
3400917e:	4313      	orrs	r3, r2
34009180:	d038      	beq.n	340091f4 <HAL_RCCEx_PeriphCLKConfig+0xae8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PTPCLKSOURCE(PeriphClkInit->Eth1PtpClockSelection));
    assert_param(IS_RCC_ETH1PTPDIVIDER(PeriphClkInit->Eth1PtpDivider));

    if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_IC13)
34009182:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009186:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
3400918a:	2b02      	cmp	r3, #2
3400918c:	d116      	bne.n	340091bc <HAL_RCCEx_PeriphCLKConfig+0xab0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC13].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC13].ClockDivider));

      /* Set IC13 configuration */
      MODIFY_REG(RCC->IC13CFGR, RCC_IC13CFGR_IC13SEL | RCC_IC13CFGR_IC13INT,
3400918e:	4bbc      	ldr	r3, [pc, #752]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34009190:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
34009194:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009198:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400919c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340091a0:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
340091a2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340091a6:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
340091a8:	3b01      	subs	r3, #1
340091aa:	041b      	lsls	r3, r3, #16
340091ac:	4313      	orrs	r3, r2
340091ae:	4ab4      	ldr	r2, [pc, #720]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340091b0:	430b      	orrs	r3, r1
340091b2:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
                 PeriphClkInit->ICSelection[RCC_IC13].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC13].ClockDivider - 1U) << RCC_IC13CFGR_IC13INT_Pos));

      LL_RCC_IC13_Enable();
340091b6:	f7ff fa2b 	bl	34008610 <LL_RCC_IC13_Enable>
340091ba:	e007      	b.n	340091cc <HAL_RCCEx_PeriphCLKConfig+0xac0>
    }
    else if (PeriphClkInit->Eth1PtpClockSelection == RCC_ETH1PTPCLKSOURCE_CLKP)
340091bc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340091c0:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
340091c4:	2b01      	cmp	r3, #1
340091c6:	d101      	bne.n	340091cc <HAL_RCCEx_PeriphCLKConfig+0xac0>
    {
      LL_RCC_CLKP_Enable();
340091c8:	f7ff fa92 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Configure the ETH1 PTP clock source and divider */
    MODIFY_REG(RCC->CCIPR2, (RCC_CCIPR2_ETH1PTPDIV | RCC_CCIPR2_ETH1PTPSEL), \
340091cc:	4bac      	ldr	r3, [pc, #688]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340091ce:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
340091d2:	f023 01f3 	bic.w	r1, r3, #243	@ 0xf3
340091d6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340091da:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
340091de:	3b01      	subs	r3, #1
340091e0:	011a      	lsls	r2, r3, #4
340091e2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340091e6:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
340091ea:	4313      	orrs	r3, r2
340091ec:	4aa4      	ldr	r2, [pc, #656]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340091ee:	430b      	orrs	r3, r1
340091f0:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
               (((PeriphClkInit->Eth1PtpDivider - 1U) << RCC_CCIPR2_ETH1PTPDIV_Pos) | PeriphClkInit->Eth1PtpClockSelection));
  }

  /*---------------------- FDCAN configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
340091f4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340091f8:	e9d3 2300 	ldrd	r2, r3, [r3]
340091fc:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
34009200:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
34009204:	2300      	movs	r3, #0
34009206:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
3400920a:	e9d7 014e 	ldrd	r0, r1, [r7, #312]	@ 0x138
3400920e:	4603      	mov	r3, r0
34009210:	460a      	mov	r2, r1
34009212:	4313      	orrs	r3, r2
34009214:	d02d      	beq.n	34009272 <HAL_RCCEx_PeriphCLKConfig+0xb66>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_IC19)
34009216:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400921a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400921e:	2b02      	cmp	r3, #2
34009220:	d118      	bne.n	34009254 <HAL_RCCEx_PeriphCLKConfig+0xb48>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC19].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC19].ClockDivider));

      /* Set IC19 configuration */
      MODIFY_REG(RCC->IC19CFGR, RCC_IC19CFGR_IC19SEL | RCC_IC19CFGR_IC19INT,
34009222:	4b97      	ldr	r3, [pc, #604]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34009224:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
34009228:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400922c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009230:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009234:	f8d3 2098 	ldr.w	r2, [r3, #152]	@ 0x98
34009238:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400923c:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
34009240:	3b01      	subs	r3, #1
34009242:	041b      	lsls	r3, r3, #16
34009244:	4313      	orrs	r3, r2
34009246:	4a8e      	ldr	r2, [pc, #568]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34009248:	430b      	orrs	r3, r1
3400924a:	f8c2 310c 	str.w	r3, [r2, #268]	@ 0x10c
                 PeriphClkInit->ICSelection[RCC_IC19].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC19].ClockDivider - 1U) << RCC_IC19CFGR_IC19INT_Pos));

      LL_RCC_IC19_Enable();
3400924e:	f7ff fa33 	bl	340086b8 <LL_RCC_IC19_Enable>
34009252:	e007      	b.n	34009264 <HAL_RCCEx_PeriphCLKConfig+0xb58>
    }
    else if (PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_CLKP)
34009254:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009258:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400925c:	2b01      	cmp	r3, #1
3400925e:	d101      	bne.n	34009264 <HAL_RCCEx_PeriphCLKConfig+0xb58>
    {
      LL_RCC_CLKP_Enable();
34009260:	f7ff fa46 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of FDCAN clock*/
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
34009264:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009268:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400926c:	4618      	mov	r0, r3
3400926e:	f7ff f805 	bl	3400827c <LL_RCC_SetFDCANClockSource>
  }

  /*------------------------------ I2C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
34009272:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009276:	e9d3 2300 	ldrd	r2, r3, [r3]
3400927a:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
3400927e:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
34009282:	2300      	movs	r3, #0
34009284:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
34009288:	e9d7 014c 	ldrd	r0, r1, [r7, #304]	@ 0x130
3400928c:	4603      	mov	r3, r0
3400928e:	460a      	mov	r2, r1
34009290:	4313      	orrs	r3, r2
34009292:	d04b      	beq.n	3400932c <HAL_RCCEx_PeriphCLKConfig+0xc20>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC10)
34009294:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009298:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
3400929c:	4b79      	ldr	r3, [pc, #484]	@ (34009484 <HAL_RCCEx_PeriphCLKConfig+0xd78>)
3400929e:	429a      	cmp	r2, r3
340092a0:	d116      	bne.n	340092d0 <HAL_RCCEx_PeriphCLKConfig+0xbc4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
340092a2:	4b77      	ldr	r3, [pc, #476]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340092a4:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
340092a8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340092ac:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340092b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340092b4:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
340092b6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340092ba:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340092bc:	3b01      	subs	r3, #1
340092be:	041b      	lsls	r3, r3, #16
340092c0:	4313      	orrs	r3, r2
340092c2:	4a6f      	ldr	r2, [pc, #444]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340092c4:	430b      	orrs	r3, r1
340092c6:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
340092ca:	f7ff f985 	bl	340085d8 <LL_RCC_IC10_Enable>
340092ce:	e026      	b.n	3400931e <HAL_RCCEx_PeriphCLKConfig+0xc12>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_IC15)
340092d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340092d4:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
340092d8:	4b6b      	ldr	r3, [pc, #428]	@ (34009488 <HAL_RCCEx_PeriphCLKConfig+0xd7c>)
340092da:	429a      	cmp	r2, r3
340092dc:	d116      	bne.n	3400930c <HAL_RCCEx_PeriphCLKConfig+0xc00>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340092de:	4b68      	ldr	r3, [pc, #416]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340092e0:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340092e4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340092e8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340092ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340092f0:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340092f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340092f6:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340092f8:	3b01      	subs	r3, #1
340092fa:	041b      	lsls	r3, r3, #16
340092fc:	4313      	orrs	r3, r2
340092fe:	4a60      	ldr	r2, [pc, #384]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34009300:	430b      	orrs	r3, r1
34009302:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34009306:	f7ff f99f 	bl	34008648 <LL_RCC_IC15_Enable>
3400930a:	e008      	b.n	3400931e <HAL_RCCEx_PeriphCLKConfig+0xc12>
    }
    else if (PeriphClkInit->I2c1ClockSelection == RCC_I2C1CLKSOURCE_CLKP)
3400930c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009310:	f8d3 20e8 	ldr.w	r2, [r3, #232]	@ 0xe8
34009314:	4b5d      	ldr	r3, [pc, #372]	@ (3400948c <HAL_RCCEx_PeriphCLKConfig+0xd80>)
34009316:	429a      	cmp	r2, r3
34009318:	d101      	bne.n	3400931e <HAL_RCCEx_PeriphCLKConfig+0xc12>
    {
      LL_RCC_CLKP_Enable();
3400931a:	f7ff f9e9 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C1 clock*/
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
3400931e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009322:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34009326:	4618      	mov	r0, r3
34009328:	f7fe ffd4 	bl	340082d4 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
3400932c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009330:	e9d3 2300 	ldrd	r2, r3, [r3]
34009334:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
34009338:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
3400933c:	2300      	movs	r3, #0
3400933e:	f8c7 312c 	str.w	r3, [r7, #300]	@ 0x12c
34009342:	e9d7 014a 	ldrd	r0, r1, [r7, #296]	@ 0x128
34009346:	4603      	mov	r3, r0
34009348:	460a      	mov	r2, r1
3400934a:	4313      	orrs	r3, r2
3400934c:	d04b      	beq.n	340093e6 <HAL_RCCEx_PeriphCLKConfig+0xcda>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC10)
3400934e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009352:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34009356:	4b4e      	ldr	r3, [pc, #312]	@ (34009490 <HAL_RCCEx_PeriphCLKConfig+0xd84>)
34009358:	429a      	cmp	r2, r3
3400935a:	d116      	bne.n	3400938a <HAL_RCCEx_PeriphCLKConfig+0xc7e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
3400935c:	4b48      	ldr	r3, [pc, #288]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3400935e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
34009362:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009366:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400936a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400936e:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34009370:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009374:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34009376:	3b01      	subs	r3, #1
34009378:	041b      	lsls	r3, r3, #16
3400937a:	4313      	orrs	r3, r2
3400937c:	4a40      	ldr	r2, [pc, #256]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3400937e:	430b      	orrs	r3, r1
34009380:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34009384:	f7ff f928 	bl	340085d8 <LL_RCC_IC10_Enable>
34009388:	e026      	b.n	340093d8 <HAL_RCCEx_PeriphCLKConfig+0xccc>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_IC15)
3400938a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400938e:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
34009392:	4b40      	ldr	r3, [pc, #256]	@ (34009494 <HAL_RCCEx_PeriphCLKConfig+0xd88>)
34009394:	429a      	cmp	r2, r3
34009396:	d116      	bne.n	340093c6 <HAL_RCCEx_PeriphCLKConfig+0xcba>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34009398:	4b39      	ldr	r3, [pc, #228]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
3400939a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400939e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340093a2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340093a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340093aa:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340093ac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340093b0:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340093b2:	3b01      	subs	r3, #1
340093b4:	041b      	lsls	r3, r3, #16
340093b6:	4313      	orrs	r3, r2
340093b8:	4a31      	ldr	r2, [pc, #196]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
340093ba:	430b      	orrs	r3, r1
340093bc:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340093c0:	f7ff f942 	bl	34008648 <LL_RCC_IC15_Enable>
340093c4:	e008      	b.n	340093d8 <HAL_RCCEx_PeriphCLKConfig+0xccc>
    }
    else if (PeriphClkInit->I2c2ClockSelection == RCC_I2C2CLKSOURCE_CLKP)
340093c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340093ca:	f8d3 20ec 	ldr.w	r2, [r3, #236]	@ 0xec
340093ce:	4b32      	ldr	r3, [pc, #200]	@ (34009498 <HAL_RCCEx_PeriphCLKConfig+0xd8c>)
340093d0:	429a      	cmp	r2, r3
340093d2:	d101      	bne.n	340093d8 <HAL_RCCEx_PeriphCLKConfig+0xccc>
    {
      LL_RCC_CLKP_Enable();
340093d4:	f7ff f98c 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C2 clock*/
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
340093d8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340093dc:	f8d3 30ec 	ldr.w	r3, [r3, #236]	@ 0xec
340093e0:	4618      	mov	r0, r3
340093e2:	f7fe ff77 	bl	340082d4 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C3 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
340093e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340093ea:	e9d3 2300 	ldrd	r2, r3, [r3]
340093ee:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
340093f2:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
340093f6:	2300      	movs	r3, #0
340093f8:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
340093fc:	e9d7 0148 	ldrd	r0, r1, [r7, #288]	@ 0x120
34009400:	4603      	mov	r3, r0
34009402:	460a      	mov	r2, r1
34009404:	4313      	orrs	r3, r2
34009406:	d05d      	beq.n	340094c4 <HAL_RCCEx_PeriphCLKConfig+0xdb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC10)
34009408:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400940c:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
34009410:	4b22      	ldr	r3, [pc, #136]	@ (3400949c <HAL_RCCEx_PeriphCLKConfig+0xd90>)
34009412:	429a      	cmp	r2, r3
34009414:	d116      	bne.n	34009444 <HAL_RCCEx_PeriphCLKConfig+0xd38>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34009416:	4b1a      	ldr	r3, [pc, #104]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34009418:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400941c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009420:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009424:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009428:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3400942a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400942e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34009430:	3b01      	subs	r3, #1
34009432:	041b      	lsls	r3, r3, #16
34009434:	4313      	orrs	r3, r2
34009436:	4a12      	ldr	r2, [pc, #72]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34009438:	430b      	orrs	r3, r1
3400943a:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3400943e:	f7ff f8cb 	bl	340085d8 <LL_RCC_IC10_Enable>
34009442:	e038      	b.n	340094b6 <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_IC15)
34009444:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009448:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
3400944c:	4b14      	ldr	r3, [pc, #80]	@ (340094a0 <HAL_RCCEx_PeriphCLKConfig+0xd94>)
3400944e:	429a      	cmp	r2, r3
34009450:	d128      	bne.n	340094a4 <HAL_RCCEx_PeriphCLKConfig+0xd98>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34009452:	4b0b      	ldr	r3, [pc, #44]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34009454:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34009458:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400945c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009460:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009464:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34009466:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400946a:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400946c:	3b01      	subs	r3, #1
3400946e:	041b      	lsls	r3, r3, #16
34009470:	4313      	orrs	r3, r2
34009472:	4a03      	ldr	r2, [pc, #12]	@ (34009480 <HAL_RCCEx_PeriphCLKConfig+0xd74>)
34009474:	430b      	orrs	r3, r1
34009476:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400947a:	f7ff f8e5 	bl	34008648 <LL_RCC_IC15_Enable>
3400947e:	e01a      	b.n	340094b6 <HAL_RCCEx_PeriphCLKConfig+0xdaa>
34009480:	56028000 	.word	0x56028000
34009484:	0702000c 	.word	0x0702000c
34009488:	0703000c 	.word	0x0703000c
3400948c:	0701000c 	.word	0x0701000c
34009490:	0702040c 	.word	0x0702040c
34009494:	0703040c 	.word	0x0703040c
34009498:	0701040c 	.word	0x0701040c
3400949c:	0702080c 	.word	0x0702080c
340094a0:	0703080c 	.word	0x0703080c
    }
    else if (PeriphClkInit->I2c3ClockSelection == RCC_I2C3CLKSOURCE_CLKP)
340094a4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340094a8:	f8d3 20f0 	ldr.w	r2, [r3, #240]	@ 0xf0
340094ac:	4bc8      	ldr	r3, [pc, #800]	@ (340097d0 <HAL_RCCEx_PeriphCLKConfig+0x10c4>)
340094ae:	429a      	cmp	r2, r3
340094b0:	d101      	bne.n	340094b6 <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    {
      LL_RCC_CLKP_Enable();
340094b2:	f7ff f91d 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C3 clock*/
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
340094b6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340094ba:	f8d3 30f0 	ldr.w	r3, [r3, #240]	@ 0xf0
340094be:	4618      	mov	r0, r3
340094c0:	f7fe ff08 	bl	340082d4 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I2C4 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
340094c4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340094c8:	e9d3 2300 	ldrd	r2, r3, [r3]
340094cc:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
340094d0:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
340094d4:	2300      	movs	r3, #0
340094d6:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
340094da:	e9d7 0146 	ldrd	r0, r1, [r7, #280]	@ 0x118
340094de:	4603      	mov	r3, r0
340094e0:	460a      	mov	r2, r1
340094e2:	4313      	orrs	r3, r2
340094e4:	d04b      	beq.n	3400957e <HAL_RCCEx_PeriphCLKConfig+0xe72>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC10)
340094e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340094ea:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
340094ee:	4bb9      	ldr	r3, [pc, #740]	@ (340097d4 <HAL_RCCEx_PeriphCLKConfig+0x10c8>)
340094f0:	429a      	cmp	r2, r3
340094f2:	d116      	bne.n	34009522 <HAL_RCCEx_PeriphCLKConfig+0xe16>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
340094f4:	4bb8      	ldr	r3, [pc, #736]	@ (340097d8 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
340094f6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
340094fa:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340094fe:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009502:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009506:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
34009508:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400950c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
3400950e:	3b01      	subs	r3, #1
34009510:	041b      	lsls	r3, r3, #16
34009512:	4313      	orrs	r3, r2
34009514:	4ab0      	ldr	r2, [pc, #704]	@ (340097d8 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34009516:	430b      	orrs	r3, r1
34009518:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
3400951c:	f7ff f85c 	bl	340085d8 <LL_RCC_IC10_Enable>
34009520:	e026      	b.n	34009570 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_IC15)
34009522:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009526:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
3400952a:	4bac      	ldr	r3, [pc, #688]	@ (340097dc <HAL_RCCEx_PeriphCLKConfig+0x10d0>)
3400952c:	429a      	cmp	r2, r3
3400952e:	d116      	bne.n	3400955e <HAL_RCCEx_PeriphCLKConfig+0xe52>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34009530:	4ba9      	ldr	r3, [pc, #676]	@ (340097d8 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34009532:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34009536:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400953a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400953e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009542:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34009544:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009548:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400954a:	3b01      	subs	r3, #1
3400954c:	041b      	lsls	r3, r3, #16
3400954e:	4313      	orrs	r3, r2
34009550:	4aa1      	ldr	r2, [pc, #644]	@ (340097d8 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34009552:	430b      	orrs	r3, r1
34009554:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34009558:	f7ff f876 	bl	34008648 <LL_RCC_IC15_Enable>
3400955c:	e008      	b.n	34009570 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    }
    else if (PeriphClkInit->I2c4ClockSelection == RCC_I2C4CLKSOURCE_CLKP)
3400955e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009562:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
34009566:	4b9e      	ldr	r3, [pc, #632]	@ (340097e0 <HAL_RCCEx_PeriphCLKConfig+0x10d4>)
34009568:	429a      	cmp	r2, r3
3400956a:	d101      	bne.n	34009570 <HAL_RCCEx_PeriphCLKConfig+0xe64>
    {
      LL_RCC_CLKP_Enable();
3400956c:	f7ff f8c0 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I2C4 clock*/
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
34009570:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009574:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
34009578:	4618      	mov	r0, r3
3400957a:	f7fe feab 	bl	340082d4 <LL_RCC_SetI2CClockSource>
  }

  /*------------------------------ I3C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C1) == RCC_PERIPHCLK_I3C1)
3400957e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009582:	e9d3 2300 	ldrd	r2, r3, [r3]
34009586:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
3400958a:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
3400958e:	2300      	movs	r3, #0
34009590:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
34009594:	e9d7 0144 	ldrd	r0, r1, [r7, #272]	@ 0x110
34009598:	4603      	mov	r3, r0
3400959a:	460a      	mov	r2, r1
3400959c:	4313      	orrs	r3, r2
3400959e:	d04b      	beq.n	34009638 <HAL_RCCEx_PeriphCLKConfig+0xf2c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C1CLKSOURCE(PeriphClkInit->I3c1ClockSelection));

    if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC10)
340095a0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340095a4:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
340095a8:	4b8e      	ldr	r3, [pc, #568]	@ (340097e4 <HAL_RCCEx_PeriphCLKConfig+0x10d8>)
340095aa:	429a      	cmp	r2, r3
340095ac:	d116      	bne.n	340095dc <HAL_RCCEx_PeriphCLKConfig+0xed0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
340095ae:	4b8a      	ldr	r3, [pc, #552]	@ (340097d8 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
340095b0:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
340095b4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340095b8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340095bc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340095c0:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
340095c2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340095c6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
340095c8:	3b01      	subs	r3, #1
340095ca:	041b      	lsls	r3, r3, #16
340095cc:	4313      	orrs	r3, r2
340095ce:	4a82      	ldr	r2, [pc, #520]	@ (340097d8 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
340095d0:	430b      	orrs	r3, r1
340095d2:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
340095d6:	f7fe ffff 	bl	340085d8 <LL_RCC_IC10_Enable>
340095da:	e026      	b.n	3400962a <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_IC15)
340095dc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340095e0:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
340095e4:	4b80      	ldr	r3, [pc, #512]	@ (340097e8 <HAL_RCCEx_PeriphCLKConfig+0x10dc>)
340095e6:	429a      	cmp	r2, r3
340095e8:	d116      	bne.n	34009618 <HAL_RCCEx_PeriphCLKConfig+0xf0c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340095ea:	4b7b      	ldr	r3, [pc, #492]	@ (340097d8 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
340095ec:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340095f0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340095f4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340095f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340095fc:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340095fe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009602:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34009604:	3b01      	subs	r3, #1
34009606:	041b      	lsls	r3, r3, #16
34009608:	4313      	orrs	r3, r2
3400960a:	4a73      	ldr	r2, [pc, #460]	@ (340097d8 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3400960c:	430b      	orrs	r3, r1
3400960e:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34009612:	f7ff f819 	bl	34008648 <LL_RCC_IC15_Enable>
34009616:	e008      	b.n	3400962a <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    }
    else if (PeriphClkInit->I3c1ClockSelection == RCC_I3C1CLKSOURCE_CLKP)
34009618:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400961c:	f8d3 20f8 	ldr.w	r2, [r3, #248]	@ 0xf8
34009620:	4b72      	ldr	r3, [pc, #456]	@ (340097ec <HAL_RCCEx_PeriphCLKConfig+0x10e0>)
34009622:	429a      	cmp	r2, r3
34009624:	d101      	bne.n	3400962a <HAL_RCCEx_PeriphCLKConfig+0xf1e>
    {
      LL_RCC_CLKP_Enable();
34009626:	f7ff f863 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C1 clock*/
    __HAL_RCC_I3C1_CONFIG(PeriphClkInit->I3c1ClockSelection);
3400962a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400962e:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34009632:	4618      	mov	r0, r3
34009634:	f7fe fe59 	bl	340082ea <LL_RCC_SetI3CClockSource>
  }

  /*------------------------------ I3C2 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I3C2) == RCC_PERIPHCLK_I3C2)
34009638:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400963c:	e9d3 2300 	ldrd	r2, r3, [r3]
34009640:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
34009644:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
34009648:	2300      	movs	r3, #0
3400964a:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
3400964e:	e9d7 0142 	ldrd	r0, r1, [r7, #264]	@ 0x108
34009652:	4603      	mov	r3, r0
34009654:	460a      	mov	r2, r1
34009656:	4313      	orrs	r3, r2
34009658:	d04b      	beq.n	340096f2 <HAL_RCCEx_PeriphCLKConfig+0xfe6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I3C2CLKSOURCE(PeriphClkInit->I3c2ClockSelection));

    if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC10)
3400965a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400965e:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
34009662:	4b63      	ldr	r3, [pc, #396]	@ (340097f0 <HAL_RCCEx_PeriphCLKConfig+0x10e4>)
34009664:	429a      	cmp	r2, r3
34009666:	d116      	bne.n	34009696 <HAL_RCCEx_PeriphCLKConfig+0xf8a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC10].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC10].ClockDivider));

      /* Set IC10 configuration */
      MODIFY_REG(RCC->IC10CFGR, RCC_IC10CFGR_IC10SEL | RCC_IC10CFGR_IC10INT,
34009668:	4b5b      	ldr	r3, [pc, #364]	@ (340097d8 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3400966a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
3400966e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009672:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009676:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400967a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
3400967c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009680:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
34009682:	3b01      	subs	r3, #1
34009684:	041b      	lsls	r3, r3, #16
34009686:	4313      	orrs	r3, r2
34009688:	4a53      	ldr	r2, [pc, #332]	@ (340097d8 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
3400968a:	430b      	orrs	r3, r1
3400968c:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
                 PeriphClkInit->ICSelection[RCC_IC10].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC10].ClockDivider - 1U) << RCC_IC10CFGR_IC10INT_Pos));

      LL_RCC_IC10_Enable();
34009690:	f7fe ffa2 	bl	340085d8 <LL_RCC_IC10_Enable>
34009694:	e026      	b.n	340096e4 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_IC15)
34009696:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400969a:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
3400969e:	4b55      	ldr	r3, [pc, #340]	@ (340097f4 <HAL_RCCEx_PeriphCLKConfig+0x10e8>)
340096a0:	429a      	cmp	r2, r3
340096a2:	d116      	bne.n	340096d2 <HAL_RCCEx_PeriphCLKConfig+0xfc6>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340096a4:	4b4c      	ldr	r3, [pc, #304]	@ (340097d8 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
340096a6:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340096aa:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340096ae:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340096b2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340096b6:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340096b8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340096bc:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340096be:	3b01      	subs	r3, #1
340096c0:	041b      	lsls	r3, r3, #16
340096c2:	4313      	orrs	r3, r2
340096c4:	4a44      	ldr	r2, [pc, #272]	@ (340097d8 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
340096c6:	430b      	orrs	r3, r1
340096c8:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340096cc:	f7fe ffbc 	bl	34008648 <LL_RCC_IC15_Enable>
340096d0:	e008      	b.n	340096e4 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    }
    else if (PeriphClkInit->I3c2ClockSelection == RCC_I3C2CLKSOURCE_CLKP)
340096d2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340096d6:	f8d3 20fc 	ldr.w	r2, [r3, #252]	@ 0xfc
340096da:	4b47      	ldr	r3, [pc, #284]	@ (340097f8 <HAL_RCCEx_PeriphCLKConfig+0x10ec>)
340096dc:	429a      	cmp	r2, r3
340096de:	d101      	bne.n	340096e4 <HAL_RCCEx_PeriphCLKConfig+0xfd8>
    {
      LL_RCC_CLKP_Enable();
340096e0:	f7ff f806 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of I3C2 clock*/
    __HAL_RCC_I3C2_CONFIG(PeriphClkInit->I3c2ClockSelection);
340096e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340096e8:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340096ec:	4618      	mov	r0, r3
340096ee:	f7fe fdfc 	bl	340082ea <LL_RCC_SetI3CClockSource>
  }

  /*---------------------------- LPTIM1 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
340096f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340096f6:	e9d3 2300 	ldrd	r2, r3, [r3]
340096fa:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
340096fe:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
34009702:	2300      	movs	r3, #0
34009704:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
34009708:	e9d7 0140 	ldrd	r0, r1, [r7, #256]	@ 0x100
3400970c:	4603      	mov	r3, r0
3400970e:	460a      	mov	r2, r1
34009710:	4313      	orrs	r3, r2
34009712:	d02d      	beq.n	34009770 <HAL_RCCEx_PeriphCLKConfig+0x1064>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_IC15)
34009714:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009718:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
3400971c:	4b37      	ldr	r3, [pc, #220]	@ (340097fc <HAL_RCCEx_PeriphCLKConfig+0x10f0>)
3400971e:	429a      	cmp	r2, r3
34009720:	d116      	bne.n	34009750 <HAL_RCCEx_PeriphCLKConfig+0x1044>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34009722:	4b2d      	ldr	r3, [pc, #180]	@ (340097d8 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34009724:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
34009728:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400972c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009730:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009734:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34009736:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400973a:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400973c:	3b01      	subs	r3, #1
3400973e:	041b      	lsls	r3, r3, #16
34009740:	4313      	orrs	r3, r2
34009742:	4a25      	ldr	r2, [pc, #148]	@ (340097d8 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
34009744:	430b      	orrs	r3, r1
34009746:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400974a:	f7fe ff7d 	bl	34008648 <LL_RCC_IC15_Enable>
3400974e:	e008      	b.n	34009762 <HAL_RCCEx_PeriphCLKConfig+0x1056>
    }
    else if (PeriphClkInit->Lptim1ClockSelection == RCC_LPTIM1CLKSOURCE_CLKP)
34009750:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009754:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
34009758:	4b29      	ldr	r3, [pc, #164]	@ (34009800 <HAL_RCCEx_PeriphCLKConfig+0x10f4>)
3400975a:	429a      	cmp	r2, r3
3400975c:	d101      	bne.n	34009762 <HAL_RCCEx_PeriphCLKConfig+0x1056>
    {
      LL_RCC_CLKP_Enable();
3400975e:	f7fe ffc7 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM1 clock*/
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
34009762:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009766:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
3400976a:	4618      	mov	r0, r3
3400976c:	f7fe fdc8 	bl	34008300 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM2 configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
34009770:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009774:	e9d3 2300 	ldrd	r2, r3, [r3]
34009778:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
3400977c:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
34009780:	2300      	movs	r3, #0
34009782:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
34009786:	e9d7 013e 	ldrd	r0, r1, [r7, #248]	@ 0xf8
3400978a:	4603      	mov	r3, r0
3400978c:	460a      	mov	r2, r1
3400978e:	4313      	orrs	r3, r2
34009790:	d04a      	beq.n	34009828 <HAL_RCCEx_PeriphCLKConfig+0x111c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_IC15)
34009792:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009796:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
3400979a:	4b1a      	ldr	r3, [pc, #104]	@ (34009804 <HAL_RCCEx_PeriphCLKConfig+0x10f8>)
3400979c:	429a      	cmp	r2, r3
3400979e:	d133      	bne.n	34009808 <HAL_RCCEx_PeriphCLKConfig+0x10fc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340097a0:	4b0d      	ldr	r3, [pc, #52]	@ (340097d8 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
340097a2:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340097a6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340097aa:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340097ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340097b2:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340097b4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340097b8:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340097ba:	3b01      	subs	r3, #1
340097bc:	041b      	lsls	r3, r3, #16
340097be:	4313      	orrs	r3, r2
340097c0:	4a05      	ldr	r2, [pc, #20]	@ (340097d8 <HAL_RCCEx_PeriphCLKConfig+0x10cc>)
340097c2:	430b      	orrs	r3, r1
340097c4:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340097c8:	f7fe ff3e 	bl	34008648 <LL_RCC_IC15_Enable>
340097cc:	e025      	b.n	3400981a <HAL_RCCEx_PeriphCLKConfig+0x110e>
340097ce:	bf00      	nop
340097d0:	0701080c 	.word	0x0701080c
340097d4:	07020c0c 	.word	0x07020c0c
340097d8:	56028000 	.word	0x56028000
340097dc:	07030c0c 	.word	0x07030c0c
340097e0:	07010c0c 	.word	0x07010c0c
340097e4:	0702100c 	.word	0x0702100c
340097e8:	0703100c 	.word	0x0703100c
340097ec:	0701100c 	.word	0x0701100c
340097f0:	0702140c 	.word	0x0702140c
340097f4:	0703140c 	.word	0x0703140c
340097f8:	0701140c 	.word	0x0701140c
340097fc:	0702082c 	.word	0x0702082c
34009800:	0701082c 	.word	0x0701082c
34009804:	07020c2c 	.word	0x07020c2c
    }
    else if (PeriphClkInit->Lptim2ClockSelection == RCC_LPTIM2CLKSOURCE_CLKP)
34009808:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400980c:	f8d3 2104 	ldr.w	r2, [r3, #260]	@ 0x104
34009810:	4bca      	ldr	r3, [pc, #808]	@ (34009b3c <HAL_RCCEx_PeriphCLKConfig+0x1430>)
34009812:	429a      	cmp	r2, r3
34009814:	d101      	bne.n	3400981a <HAL_RCCEx_PeriphCLKConfig+0x110e>
    {
      LL_RCC_CLKP_Enable();
34009816:	f7fe ff6b 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM2 clock*/
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
3400981a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400981e:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
34009822:	4618      	mov	r0, r3
34009824:	f7fe fd6c 	bl	34008300 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM3 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM3) == RCC_PERIPHCLK_LPTIM3)
34009828:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400982c:	e9d3 2300 	ldrd	r2, r3, [r3]
34009830:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
34009834:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
34009838:	2300      	movs	r3, #0
3400983a:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
3400983e:	e9d7 013c 	ldrd	r0, r1, [r7, #240]	@ 0xf0
34009842:	4603      	mov	r3, r0
34009844:	460a      	mov	r2, r1
34009846:	4313      	orrs	r3, r2
34009848:	d02d      	beq.n	340098a6 <HAL_RCCEx_PeriphCLKConfig+0x119a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_IC15)
3400984a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400984e:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
34009852:	4bbb      	ldr	r3, [pc, #748]	@ (34009b40 <HAL_RCCEx_PeriphCLKConfig+0x1434>)
34009854:	429a      	cmp	r2, r3
34009856:	d116      	bne.n	34009886 <HAL_RCCEx_PeriphCLKConfig+0x117a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34009858:	4bba      	ldr	r3, [pc, #744]	@ (34009b44 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3400985a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400985e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009862:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009866:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400986a:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
3400986c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009870:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
34009872:	3b01      	subs	r3, #1
34009874:	041b      	lsls	r3, r3, #16
34009876:	4313      	orrs	r3, r2
34009878:	4ab2      	ldr	r2, [pc, #712]	@ (34009b44 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
3400987a:	430b      	orrs	r3, r1
3400987c:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
34009880:	f7fe fee2 	bl	34008648 <LL_RCC_IC15_Enable>
34009884:	e008      	b.n	34009898 <HAL_RCCEx_PeriphCLKConfig+0x118c>
    }
    else if (PeriphClkInit->Lptim3ClockSelection == RCC_LPTIM3CLKSOURCE_CLKP)
34009886:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400988a:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3400988e:	4bae      	ldr	r3, [pc, #696]	@ (34009b48 <HAL_RCCEx_PeriphCLKConfig+0x143c>)
34009890:	429a      	cmp	r2, r3
34009892:	d101      	bne.n	34009898 <HAL_RCCEx_PeriphCLKConfig+0x118c>
    {
      LL_RCC_CLKP_Enable();
34009894:	f7fe ff2c 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM3 clock */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
34009898:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400989c:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
340098a0:	4618      	mov	r0, r3
340098a2:	f7fe fd2d 	bl	34008300 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM4 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM4) == RCC_PERIPHCLK_LPTIM4)
340098a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340098aa:	e9d3 2300 	ldrd	r2, r3, [r3]
340098ae:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
340098b2:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
340098b6:	2300      	movs	r3, #0
340098b8:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
340098bc:	e9d7 013a 	ldrd	r0, r1, [r7, #232]	@ 0xe8
340098c0:	4603      	mov	r3, r0
340098c2:	460a      	mov	r2, r1
340098c4:	4313      	orrs	r3, r2
340098c6:	d02d      	beq.n	34009924 <HAL_RCCEx_PeriphCLKConfig+0x1218>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM4CLKSOURCE(PeriphClkInit->Lptim4ClockSelection));

    if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_IC15)
340098c8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340098cc:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
340098d0:	4b9e      	ldr	r3, [pc, #632]	@ (34009b4c <HAL_RCCEx_PeriphCLKConfig+0x1440>)
340098d2:	429a      	cmp	r2, r3
340098d4:	d116      	bne.n	34009904 <HAL_RCCEx_PeriphCLKConfig+0x11f8>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
340098d6:	4b9b      	ldr	r3, [pc, #620]	@ (34009b44 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
340098d8:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
340098dc:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340098e0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340098e4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340098e8:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
340098ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340098ee:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
340098f0:	3b01      	subs	r3, #1
340098f2:	041b      	lsls	r3, r3, #16
340098f4:	4313      	orrs	r3, r2
340098f6:	4a93      	ldr	r2, [pc, #588]	@ (34009b44 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
340098f8:	430b      	orrs	r3, r1
340098fa:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
340098fe:	f7fe fea3 	bl	34008648 <LL_RCC_IC15_Enable>
34009902:	e008      	b.n	34009916 <HAL_RCCEx_PeriphCLKConfig+0x120a>
    }
    else if (PeriphClkInit->Lptim4ClockSelection == RCC_LPTIM4CLKSOURCE_CLKP)
34009904:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009908:	f8d3 210c 	ldr.w	r2, [r3, #268]	@ 0x10c
3400990c:	4b90      	ldr	r3, [pc, #576]	@ (34009b50 <HAL_RCCEx_PeriphCLKConfig+0x1444>)
3400990e:	429a      	cmp	r2, r3
34009910:	d101      	bne.n	34009916 <HAL_RCCEx_PeriphCLKConfig+0x120a>
    {
      LL_RCC_CLKP_Enable();
34009912:	f7fe feed 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM4 clock */
    __HAL_RCC_LPTIM4_CONFIG(PeriphClkInit->Lptim4ClockSelection);
34009916:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400991a:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3400991e:	4618      	mov	r0, r3
34009920:	f7fe fcee 	bl	34008300 <LL_RCC_SetLPTIMClockSource>
  }

  /*---------------------------- LPTIM5 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM5) == RCC_PERIPHCLK_LPTIM5)
34009924:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009928:	e9d3 2300 	ldrd	r2, r3, [r3]
3400992c:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
34009930:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
34009934:	2300      	movs	r3, #0
34009936:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
3400993a:	e9d7 0138 	ldrd	r0, r1, [r7, #224]	@ 0xe0
3400993e:	4603      	mov	r3, r0
34009940:	460a      	mov	r2, r1
34009942:	4313      	orrs	r3, r2
34009944:	d02d      	beq.n	340099a2 <HAL_RCCEx_PeriphCLKConfig+0x1296>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM5CLKSOURCE(PeriphClkInit->Lptim5ClockSelection));

    if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_IC15)
34009946:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400994a:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3400994e:	4b81      	ldr	r3, [pc, #516]	@ (34009b54 <HAL_RCCEx_PeriphCLKConfig+0x1448>)
34009950:	429a      	cmp	r2, r3
34009952:	d116      	bne.n	34009982 <HAL_RCCEx_PeriphCLKConfig+0x1276>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
34009954:	4b7b      	ldr	r3, [pc, #492]	@ (34009b44 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34009956:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400995a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400995e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009962:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009966:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
34009968:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400996c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
3400996e:	3b01      	subs	r3, #1
34009970:	041b      	lsls	r3, r3, #16
34009972:	4313      	orrs	r3, r2
34009974:	4a73      	ldr	r2, [pc, #460]	@ (34009b44 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34009976:	430b      	orrs	r3, r1
34009978:	f8c2 30fc 	str.w	r3, [r2, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400997c:	f7fe fe64 	bl	34008648 <LL_RCC_IC15_Enable>
34009980:	e008      	b.n	34009994 <HAL_RCCEx_PeriphCLKConfig+0x1288>
    }
    else if (PeriphClkInit->Lptim5ClockSelection == RCC_LPTIM5CLKSOURCE_CLKP)
34009982:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009986:	f8d3 2110 	ldr.w	r2, [r3, #272]	@ 0x110
3400998a:	4b73      	ldr	r3, [pc, #460]	@ (34009b58 <HAL_RCCEx_PeriphCLKConfig+0x144c>)
3400998c:	429a      	cmp	r2, r3
3400998e:	d101      	bne.n	34009994 <HAL_RCCEx_PeriphCLKConfig+0x1288>
    {
      LL_RCC_CLKP_Enable();
34009990:	f7fe feae 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPTIM5 clock */
    __HAL_RCC_LPTIM5_CONFIG(PeriphClkInit->Lptim5ClockSelection);
34009994:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009998:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
3400999c:	4618      	mov	r0, r3
3400999e:	f7fe fcaf 	bl	34008300 <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
340099a2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340099a6:	e9d3 2300 	ldrd	r2, r3, [r3]
340099aa:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
340099ae:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
340099b2:	2300      	movs	r3, #0
340099b4:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
340099b8:	e9d7 0136 	ldrd	r0, r1, [r7, #216]	@ 0xd8
340099bc:	4603      	mov	r3, r0
340099be:	460a      	mov	r2, r1
340099c0:	4313      	orrs	r3, r2
340099c2:	d04b      	beq.n	34009a5c <HAL_RCCEx_PeriphCLKConfig+0x1350>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC9)
340099c4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340099c8:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
340099cc:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
340099d0:	d116      	bne.n	34009a00 <HAL_RCCEx_PeriphCLKConfig+0x12f4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
340099d2:	4b5c      	ldr	r3, [pc, #368]	@ (34009b44 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
340099d4:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
340099d8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
340099dc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
340099e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340099e4:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
340099e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
340099ea:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
340099ec:	3b01      	subs	r3, #1
340099ee:	041b      	lsls	r3, r3, #16
340099f0:	4313      	orrs	r3, r2
340099f2:	4a54      	ldr	r2, [pc, #336]	@ (34009b44 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
340099f4:	430b      	orrs	r3, r1
340099f6:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
340099fa:	f7fe fddf 	bl	340085bc <LL_RCC_IC9_Enable>
340099fe:	e026      	b.n	34009a4e <HAL_RCCEx_PeriphCLKConfig+0x1342>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_IC14)
34009a00:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009a04:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34009a08:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
34009a0c:	d116      	bne.n	34009a3c <HAL_RCCEx_PeriphCLKConfig+0x1330>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
34009a0e:	4b4d      	ldr	r3, [pc, #308]	@ (34009b44 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34009a10:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
34009a14:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009a18:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009a1c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009a20:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
34009a22:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009a26:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
34009a28:	3b01      	subs	r3, #1
34009a2a:	041b      	lsls	r3, r3, #16
34009a2c:	4313      	orrs	r3, r2
34009a2e:	4a45      	ldr	r2, [pc, #276]	@ (34009b44 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34009a30:	430b      	orrs	r3, r1
34009a32:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
34009a36:	f7fe fdf9 	bl	3400862c <LL_RCC_IC14_Enable>
34009a3a:	e008      	b.n	34009a4e <HAL_RCCEx_PeriphCLKConfig+0x1342>
    }
    else if (PeriphClkInit->Lpuart1ClockSelection == RCC_LPUART1CLKSOURCE_CLKP)
34009a3c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009a40:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34009a44:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
34009a48:	d101      	bne.n	34009a4e <HAL_RCCEx_PeriphCLKConfig+0x1342>
    {
      LL_RCC_CLKP_Enable();
34009a4a:	f7fe fe51 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LPUART1 clock */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
34009a4e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009a52:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
34009a56:	4618      	mov	r0, r3
34009a58:	f7fe fc5e 	bl	34008318 <LL_RCC_SetLPUARTClockSource>
  }

  /*-------------------------- LTDC Configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
34009a5c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009a60:	e9d3 2300 	ldrd	r2, r3, [r3]
34009a64:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
34009a68:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
34009a6c:	2300      	movs	r3, #0
34009a6e:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
34009a72:	e9d7 0134 	ldrd	r0, r1, [r7, #208]	@ 0xd0
34009a76:	4603      	mov	r3, r0
34009a78:	460a      	mov	r2, r1
34009a7a:	4313      	orrs	r3, r2
34009a7c:	d02f      	beq.n	34009ade <HAL_RCCEx_PeriphCLKConfig+0x13d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LTDCCLKSOURCE(PeriphClkInit->LtdcClockSelection));

    if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_IC16)
34009a7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009a82:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
34009a86:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
34009a8a:	d118      	bne.n	34009abe <HAL_RCCEx_PeriphCLKConfig+0x13b2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC16].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC16].ClockDivider));

      /* Set IC16 configuration */
      MODIFY_REG(RCC->IC16CFGR, RCC_IC16CFGR_IC16SEL | RCC_IC16CFGR_IC16INT,
34009a8c:	4b2d      	ldr	r3, [pc, #180]	@ (34009b44 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34009a8e:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
34009a92:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009a96:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009a9a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009a9e:	f8d3 2080 	ldr.w	r2, [r3, #128]	@ 0x80
34009aa2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009aa6:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
34009aaa:	3b01      	subs	r3, #1
34009aac:	041b      	lsls	r3, r3, #16
34009aae:	4313      	orrs	r3, r2
34009ab0:	4a24      	ldr	r2, [pc, #144]	@ (34009b44 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34009ab2:	430b      	orrs	r3, r1
34009ab4:	f8c2 3100 	str.w	r3, [r2, #256]	@ 0x100
                 PeriphClkInit->ICSelection[RCC_IC16].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC16].ClockDivider - 1U) << RCC_IC16CFGR_IC16INT_Pos));

      LL_RCC_IC16_Enable();
34009ab8:	f7fe fdd4 	bl	34008664 <LL_RCC_IC16_Enable>
34009abc:	e008      	b.n	34009ad0 <HAL_RCCEx_PeriphCLKConfig+0x13c4>
    }
    else if (PeriphClkInit->LtdcClockSelection == RCC_LTDCCLKSOURCE_CLKP)
34009abe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009ac2:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
34009ac6:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
34009aca:	d101      	bne.n	34009ad0 <HAL_RCCEx_PeriphCLKConfig+0x13c4>
    {
      LL_RCC_CLKP_Enable();
34009acc:	f7fe fe10 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of LTDC clock */
    __HAL_RCC_LTDC_CONFIG(PeriphClkInit->LtdcClockSelection);
34009ad0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009ad4:	f8d3 3118 	ldr.w	r3, [r3, #280]	@ 0x118
34009ad8:	4618      	mov	r0, r3
34009ada:	f7fe fc33 	bl	34008344 <LL_RCC_SetLTDCClockSource>
  }

  /*---------------------------- MDF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_MDF1) == RCC_PERIPHCLK_MDF1)
34009ade:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009ae2:	e9d3 2300 	ldrd	r2, r3, [r3]
34009ae6:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
34009aea:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
34009aee:	2300      	movs	r3, #0
34009af0:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
34009af4:	e9d7 0132 	ldrd	r0, r1, [r7, #200]	@ 0xc8
34009af8:	4603      	mov	r3, r0
34009afa:	460a      	mov	r2, r1
34009afc:	4313      	orrs	r3, r2
34009afe:	d05b      	beq.n	34009bb8 <HAL_RCCEx_PeriphCLKConfig+0x14ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_MDF1CLKSOURCE(PeriphClkInit->Mdf1ClockSelection));

    if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC7)
34009b00:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009b04:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34009b08:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
34009b0c:	d126      	bne.n	34009b5c <HAL_RCCEx_PeriphCLKConfig+0x1450>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34009b0e:	4b0d      	ldr	r3, [pc, #52]	@ (34009b44 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34009b10:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34009b14:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009b18:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009b1c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009b20:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34009b22:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009b26:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34009b28:	3b01      	subs	r3, #1
34009b2a:	041b      	lsls	r3, r3, #16
34009b2c:	4313      	orrs	r3, r2
34009b2e:	4a05      	ldr	r2, [pc, #20]	@ (34009b44 <HAL_RCCEx_PeriphCLKConfig+0x1438>)
34009b30:	430b      	orrs	r3, r1
34009b32:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34009b36:	f7fe fd25 	bl	34008584 <LL_RCC_IC7_Enable>
34009b3a:	e036      	b.n	34009baa <HAL_RCCEx_PeriphCLKConfig+0x149e>
34009b3c:	07010c2c 	.word	0x07010c2c
34009b40:	0702102c 	.word	0x0702102c
34009b44:	56028000 	.word	0x56028000
34009b48:	0701102c 	.word	0x0701102c
34009b4c:	0702142c 	.word	0x0702142c
34009b50:	0701142c 	.word	0x0701142c
34009b54:	0702182c 	.word	0x0702182c
34009b58:	0701182c 	.word	0x0701182c
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_IC8)
34009b5c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009b60:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34009b64:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
34009b68:	d116      	bne.n	34009b98 <HAL_RCCEx_PeriphCLKConfig+0x148c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34009b6a:	4bb5      	ldr	r3, [pc, #724]	@ (34009e40 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34009b6c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34009b70:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009b74:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009b78:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009b7c:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34009b7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009b82:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34009b84:	3b01      	subs	r3, #1
34009b86:	041b      	lsls	r3, r3, #16
34009b88:	4313      	orrs	r3, r2
34009b8a:	4aad      	ldr	r2, [pc, #692]	@ (34009e40 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34009b8c:	430b      	orrs	r3, r1
34009b8e:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34009b92:	f7fe fd05 	bl	340085a0 <LL_RCC_IC8_Enable>
34009b96:	e008      	b.n	34009baa <HAL_RCCEx_PeriphCLKConfig+0x149e>
    }
    else if (PeriphClkInit->Mdf1ClockSelection == RCC_MDF1CLKSOURCE_CLKP)
34009b98:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009b9c:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34009ba0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
34009ba4:	d101      	bne.n	34009baa <HAL_RCCEx_PeriphCLKConfig+0x149e>
    {
      LL_RCC_CLKP_Enable();
34009ba6:	f7fe fda3 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of MDF1 clock*/
    __HAL_RCC_MDF1_CONFIG(PeriphClkInit->Mdf1ClockSelection);
34009baa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009bae:	f8d3 311c 	ldr.w	r3, [r3, #284]	@ 0x11c
34009bb2:	4618      	mov	r0, r3
34009bb4:	f7fe fbdc 	bl	34008370 <LL_RCC_SetMDFClockSource>
  }

  /*---------------------------- PSSI configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PSSI) == RCC_PERIPHCLK_PSSI)
34009bb8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009bbc:	e9d3 2300 	ldrd	r2, r3, [r3]
34009bc0:	f002 6380 	and.w	r3, r2, #67108864	@ 0x4000000
34009bc4:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
34009bc8:	2300      	movs	r3, #0
34009bca:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
34009bce:	e9d7 0130 	ldrd	r0, r1, [r7, #192]	@ 0xc0
34009bd2:	4603      	mov	r3, r0
34009bd4:	460a      	mov	r2, r1
34009bd6:	4313      	orrs	r3, r2
34009bd8:	d02d      	beq.n	34009c36 <HAL_RCCEx_PeriphCLKConfig+0x152a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_PSSICLKSOURCE(PeriphClkInit->PssiClockSelection));

    if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_IC20)
34009bda:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009bde:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
34009be2:	2b20      	cmp	r3, #32
34009be4:	d118      	bne.n	34009c18 <HAL_RCCEx_PeriphCLKConfig+0x150c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC20].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC20].ClockDivider));

      /* Set IC20 configuration */
      MODIFY_REG(RCC->IC20CFGR, RCC_IC20CFGR_IC20SEL | RCC_IC20CFGR_IC20INT,
34009be6:	4b96      	ldr	r3, [pc, #600]	@ (34009e40 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34009be8:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
34009bec:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009bf0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009bf4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009bf8:	f8d3 20a0 	ldr.w	r2, [r3, #160]	@ 0xa0
34009bfc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009c00:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
34009c04:	3b01      	subs	r3, #1
34009c06:	041b      	lsls	r3, r3, #16
34009c08:	4313      	orrs	r3, r2
34009c0a:	4a8d      	ldr	r2, [pc, #564]	@ (34009e40 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34009c0c:	430b      	orrs	r3, r1
34009c0e:	f8c2 3110 	str.w	r3, [r2, #272]	@ 0x110
                 PeriphClkInit->ICSelection[RCC_IC20].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC20].ClockDivider - 1U) << RCC_IC20CFGR_IC20INT_Pos));

      LL_RCC_IC20_Enable();
34009c12:	f7fe fd5f 	bl	340086d4 <LL_RCC_IC20_Enable>
34009c16:	e007      	b.n	34009c28 <HAL_RCCEx_PeriphCLKConfig+0x151c>
    }
    else if (PeriphClkInit->PssiClockSelection == RCC_PSSICLKSOURCE_CLKP)
34009c18:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009c1c:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
34009c20:	2b10      	cmp	r3, #16
34009c22:	d101      	bne.n	34009c28 <HAL_RCCEx_PeriphCLKConfig+0x151c>
    {
      LL_RCC_CLKP_Enable();
34009c24:	f7fe fd64 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of PSSI clock*/
    __HAL_RCC_PSSI_CONFIG(PeriphClkInit->PssiClockSelection);
34009c28:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009c2c:	f8d3 3120 	ldr.w	r3, [r3, #288]	@ 0x120
34009c30:	4618      	mov	r0, r3
34009c32:	f7fe fbc9 	bl	340083c8 <LL_RCC_SetPSSIClockSource>
  }

  /*---------------------------- SAI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
34009c36:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009c3a:	e9d3 2300 	ldrd	r2, r3, [r3]
34009c3e:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
34009c42:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
34009c46:	2300      	movs	r3, #0
34009c48:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
34009c4c:	e9d7 012e 	ldrd	r0, r1, [r7, #184]	@ 0xb8
34009c50:	4603      	mov	r3, r0
34009c52:	460a      	mov	r2, r1
34009c54:	4313      	orrs	r3, r2
34009c56:	d04b      	beq.n	34009cf0 <HAL_RCCEx_PeriphCLKConfig+0x15e4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC7)
34009c58:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009c5c:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34009c60:	4b78      	ldr	r3, [pc, #480]	@ (34009e44 <HAL_RCCEx_PeriphCLKConfig+0x1738>)
34009c62:	429a      	cmp	r2, r3
34009c64:	d116      	bne.n	34009c94 <HAL_RCCEx_PeriphCLKConfig+0x1588>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34009c66:	4b76      	ldr	r3, [pc, #472]	@ (34009e40 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34009c68:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34009c6c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009c70:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009c74:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009c78:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34009c7a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009c7e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34009c80:	3b01      	subs	r3, #1
34009c82:	041b      	lsls	r3, r3, #16
34009c84:	4313      	orrs	r3, r2
34009c86:	4a6e      	ldr	r2, [pc, #440]	@ (34009e40 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34009c88:	430b      	orrs	r3, r1
34009c8a:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34009c8e:	f7fe fc79 	bl	34008584 <LL_RCC_IC7_Enable>
34009c92:	e026      	b.n	34009ce2 <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_IC8)
34009c94:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009c98:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34009c9c:	4b6a      	ldr	r3, [pc, #424]	@ (34009e48 <HAL_RCCEx_PeriphCLKConfig+0x173c>)
34009c9e:	429a      	cmp	r2, r3
34009ca0:	d116      	bne.n	34009cd0 <HAL_RCCEx_PeriphCLKConfig+0x15c4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34009ca2:	4b67      	ldr	r3, [pc, #412]	@ (34009e40 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34009ca4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34009ca8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009cac:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009cb0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009cb4:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34009cb6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009cba:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34009cbc:	3b01      	subs	r3, #1
34009cbe:	041b      	lsls	r3, r3, #16
34009cc0:	4313      	orrs	r3, r2
34009cc2:	4a5f      	ldr	r2, [pc, #380]	@ (34009e40 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34009cc4:	430b      	orrs	r3, r1
34009cc6:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34009cca:	f7fe fc69 	bl	340085a0 <LL_RCC_IC8_Enable>
34009cce:	e008      	b.n	34009ce2 <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    }
    else if (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_CLKP)
34009cd0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009cd4:	f8d3 2124 	ldr.w	r2, [r3, #292]	@ 0x124
34009cd8:	4b5c      	ldr	r3, [pc, #368]	@ (34009e4c <HAL_RCCEx_PeriphCLKConfig+0x1740>)
34009cda:	429a      	cmp	r2, r3
34009cdc:	d101      	bne.n	34009ce2 <HAL_RCCEx_PeriphCLKConfig+0x15d6>
    {
      LL_RCC_CLKP_Enable();
34009cde:	f7fe fd07 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI1 clock*/
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
34009ce2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009ce6:	f8d3 3124 	ldr.w	r3, [r3, #292]	@ 0x124
34009cea:	4618      	mov	r0, r3
34009cec:	f7fe fb82 	bl	340083f4 <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SAI2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
34009cf0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009cf4:	e9d3 2300 	ldrd	r2, r3, [r3]
34009cf8:	f002 5300 	and.w	r3, r2, #536870912	@ 0x20000000
34009cfc:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
34009d00:	2300      	movs	r3, #0
34009d02:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
34009d06:	e9d7 012c 	ldrd	r0, r1, [r7, #176]	@ 0xb0
34009d0a:	4603      	mov	r3, r0
34009d0c:	460a      	mov	r2, r1
34009d0e:	4313      	orrs	r3, r2
34009d10:	d04b      	beq.n	34009daa <HAL_RCCEx_PeriphCLKConfig+0x169e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC7)
34009d12:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009d16:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34009d1a:	4b4d      	ldr	r3, [pc, #308]	@ (34009e50 <HAL_RCCEx_PeriphCLKConfig+0x1744>)
34009d1c:	429a      	cmp	r2, r3
34009d1e:	d116      	bne.n	34009d4e <HAL_RCCEx_PeriphCLKConfig+0x1642>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34009d20:	4b47      	ldr	r3, [pc, #284]	@ (34009e40 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34009d22:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34009d26:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009d2a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009d2e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009d32:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34009d34:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009d38:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34009d3a:	3b01      	subs	r3, #1
34009d3c:	041b      	lsls	r3, r3, #16
34009d3e:	4313      	orrs	r3, r2
34009d40:	4a3f      	ldr	r2, [pc, #252]	@ (34009e40 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34009d42:	430b      	orrs	r3, r1
34009d44:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34009d48:	f7fe fc1c 	bl	34008584 <LL_RCC_IC7_Enable>
34009d4c:	e026      	b.n	34009d9c <HAL_RCCEx_PeriphCLKConfig+0x1690>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_IC8)
34009d4e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009d52:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34009d56:	4b3f      	ldr	r3, [pc, #252]	@ (34009e54 <HAL_RCCEx_PeriphCLKConfig+0x1748>)
34009d58:	429a      	cmp	r2, r3
34009d5a:	d116      	bne.n	34009d8a <HAL_RCCEx_PeriphCLKConfig+0x167e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34009d5c:	4b38      	ldr	r3, [pc, #224]	@ (34009e40 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34009d5e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34009d62:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009d66:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009d6a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009d6e:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34009d70:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009d74:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34009d76:	3b01      	subs	r3, #1
34009d78:	041b      	lsls	r3, r3, #16
34009d7a:	4313      	orrs	r3, r2
34009d7c:	4a30      	ldr	r2, [pc, #192]	@ (34009e40 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34009d7e:	430b      	orrs	r3, r1
34009d80:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34009d84:	f7fe fc0c 	bl	340085a0 <LL_RCC_IC8_Enable>
34009d88:	e008      	b.n	34009d9c <HAL_RCCEx_PeriphCLKConfig+0x1690>
    }
    else if (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_CLKP)
34009d8a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009d8e:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
34009d92:	4b31      	ldr	r3, [pc, #196]	@ (34009e58 <HAL_RCCEx_PeriphCLKConfig+0x174c>)
34009d94:	429a      	cmp	r2, r3
34009d96:	d101      	bne.n	34009d9c <HAL_RCCEx_PeriphCLKConfig+0x1690>
    {
      LL_RCC_CLKP_Enable();
34009d98:	f7fe fcaa 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SAI2 clock*/
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
34009d9c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009da0:	f8d3 3128 	ldr.w	r3, [r3, #296]	@ 0x128
34009da4:	4618      	mov	r0, r3
34009da6:	f7fe fb25 	bl	340083f4 <LL_RCC_SetSAIClockSource>
  }

  /*---------------------------- SPDIFRX1 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPDIFRX1) == RCC_PERIPHCLK_SPDIFRX1)
34009daa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009dae:	e9d3 2300 	ldrd	r2, r3, [r3]
34009db2:	2100      	movs	r1, #0
34009db4:	f8c7 10a8 	str.w	r1, [r7, #168]	@ 0xa8
34009db8:	f003 0301 	and.w	r3, r3, #1
34009dbc:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
34009dc0:	e9d7 012a 	ldrd	r0, r1, [r7, #168]	@ 0xa8
34009dc4:	4603      	mov	r3, r0
34009dc6:	460a      	mov	r2, r1
34009dc8:	4313      	orrs	r3, r2
34009dca:	d056      	beq.n	34009e7a <HAL_RCCEx_PeriphCLKConfig+0x176e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPDIFRX1CLKSOURCE(PeriphClkInit->Spdifrx1ClockSelection));

    if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC7)
34009dcc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009dd0:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34009dd4:	2b02      	cmp	r3, #2
34009dd6:	d116      	bne.n	34009e06 <HAL_RCCEx_PeriphCLKConfig+0x16fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC7].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC7].ClockDivider));

      /* Set IC7 configuration */
      MODIFY_REG(RCC->IC7CFGR, RCC_IC7CFGR_IC7SEL | RCC_IC7CFGR_IC7INT,
34009dd8:	4b19      	ldr	r3, [pc, #100]	@ (34009e40 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34009dda:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
34009dde:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009de2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009de6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009dea:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
34009dec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009df0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
34009df2:	3b01      	subs	r3, #1
34009df4:	041b      	lsls	r3, r3, #16
34009df6:	4313      	orrs	r3, r2
34009df8:	4a11      	ldr	r2, [pc, #68]	@ (34009e40 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34009dfa:	430b      	orrs	r3, r1
34009dfc:	f8c2 30dc 	str.w	r3, [r2, #220]	@ 0xdc
                 PeriphClkInit->ICSelection[RCC_IC7].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC7].ClockDivider - 1U) << RCC_IC7CFGR_IC7INT_Pos));

      LL_RCC_IC7_Enable();
34009e00:	f7fe fbc0 	bl	34008584 <LL_RCC_IC7_Enable>
34009e04:	e032      	b.n	34009e6c <HAL_RCCEx_PeriphCLKConfig+0x1760>
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_IC8)
34009e06:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009e0a:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34009e0e:	2b03      	cmp	r3, #3
34009e10:	d124      	bne.n	34009e5c <HAL_RCCEx_PeriphCLKConfig+0x1750>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34009e12:	4b0b      	ldr	r3, [pc, #44]	@ (34009e40 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34009e14:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34009e18:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009e1c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009e20:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009e24:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34009e26:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009e2a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34009e2c:	3b01      	subs	r3, #1
34009e2e:	041b      	lsls	r3, r3, #16
34009e30:	4313      	orrs	r3, r2
34009e32:	4a03      	ldr	r2, [pc, #12]	@ (34009e40 <HAL_RCCEx_PeriphCLKConfig+0x1734>)
34009e34:	430b      	orrs	r3, r1
34009e36:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34009e3a:	f7fe fbb1 	bl	340085a0 <LL_RCC_IC8_Enable>
34009e3e:	e015      	b.n	34009e6c <HAL_RCCEx_PeriphCLKConfig+0x1760>
34009e40:	56028000 	.word	0x56028000
34009e44:	07021418 	.word	0x07021418
34009e48:	07031418 	.word	0x07031418
34009e4c:	07011418 	.word	0x07011418
34009e50:	07021818 	.word	0x07021818
34009e54:	07031818 	.word	0x07031818
34009e58:	07011818 	.word	0x07011818
    }
    else if (PeriphClkInit->Spdifrx1ClockSelection == RCC_SPDIFRX1CLKSOURCE_CLKP)
34009e5c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009e60:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34009e64:	2b01      	cmp	r3, #1
34009e66:	d101      	bne.n	34009e6c <HAL_RCCEx_PeriphCLKConfig+0x1760>
    {
      LL_RCC_CLKP_Enable();
34009e68:	f7fe fc42 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPDIFRX1 clock */
    __HAL_RCC_SPDIFRX1_CONFIG(PeriphClkInit->Spdifrx1ClockSelection);
34009e6c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009e70:	f8d3 314c 	ldr.w	r3, [r3, #332]	@ 0x14c
34009e74:	4618      	mov	r0, r3
34009e76:	f7fe fad3 	bl	34008420 <LL_RCC_SetSPDIFRXClockSource>
  }

  /*---------------------------- SPI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
34009e7a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009e7e:	e9d3 2300 	ldrd	r2, r3, [r3]
34009e82:	2100      	movs	r1, #0
34009e84:	f8c7 10a0 	str.w	r1, [r7, #160]	@ 0xa0
34009e88:	f003 0302 	and.w	r3, r3, #2
34009e8c:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
34009e90:	e9d7 0128 	ldrd	r0, r1, [r7, #160]	@ 0xa0
34009e94:	4603      	mov	r3, r0
34009e96:	460a      	mov	r2, r1
34009e98:	4313      	orrs	r3, r2
34009e9a:	d04b      	beq.n	34009f34 <HAL_RCCEx_PeriphCLKConfig+0x1828>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI1CLKSOURCE(PeriphClkInit->Spi1ClockSelection));

    if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC8)
34009e9c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009ea0:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34009ea4:	4bc6      	ldr	r3, [pc, #792]	@ (3400a1c0 <HAL_RCCEx_PeriphCLKConfig+0x1ab4>)
34009ea6:	429a      	cmp	r2, r3
34009ea8:	d116      	bne.n	34009ed8 <HAL_RCCEx_PeriphCLKConfig+0x17cc>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34009eaa:	4bc6      	ldr	r3, [pc, #792]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34009eac:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34009eb0:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009eb4:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009eb8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009ebc:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34009ebe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009ec2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34009ec4:	3b01      	subs	r3, #1
34009ec6:	041b      	lsls	r3, r3, #16
34009ec8:	4313      	orrs	r3, r2
34009eca:	4abe      	ldr	r2, [pc, #760]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34009ecc:	430b      	orrs	r3, r1
34009ece:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34009ed2:	f7fe fb65 	bl	340085a0 <LL_RCC_IC8_Enable>
34009ed6:	e026      	b.n	34009f26 <HAL_RCCEx_PeriphCLKConfig+0x181a>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_IC9)
34009ed8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009edc:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34009ee0:	4bb9      	ldr	r3, [pc, #740]	@ (3400a1c8 <HAL_RCCEx_PeriphCLKConfig+0x1abc>)
34009ee2:	429a      	cmp	r2, r3
34009ee4:	d116      	bne.n	34009f14 <HAL_RCCEx_PeriphCLKConfig+0x1808>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34009ee6:	4bb7      	ldr	r3, [pc, #732]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34009ee8:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34009eec:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009ef0:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009ef4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009ef8:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34009efa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009efe:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34009f00:	3b01      	subs	r3, #1
34009f02:	041b      	lsls	r3, r3, #16
34009f04:	4313      	orrs	r3, r2
34009f06:	4aaf      	ldr	r2, [pc, #700]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34009f08:	430b      	orrs	r3, r1
34009f0a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34009f0e:	f7fe fb55 	bl	340085bc <LL_RCC_IC9_Enable>
34009f12:	e008      	b.n	34009f26 <HAL_RCCEx_PeriphCLKConfig+0x181a>
    }
    else if (PeriphClkInit->Spi1ClockSelection == RCC_SPI1CLKSOURCE_CLKP)
34009f14:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009f18:	f8d3 2134 	ldr.w	r2, [r3, #308]	@ 0x134
34009f1c:	4bab      	ldr	r3, [pc, #684]	@ (3400a1cc <HAL_RCCEx_PeriphCLKConfig+0x1ac0>)
34009f1e:	429a      	cmp	r2, r3
34009f20:	d101      	bne.n	34009f26 <HAL_RCCEx_PeriphCLKConfig+0x181a>
    {
      LL_RCC_CLKP_Enable();
34009f22:	f7fe fbe5 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI1 clock*/
    __HAL_RCC_SPI1_CONFIG(PeriphClkInit->Spi1ClockSelection);
34009f26:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009f2a:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
34009f2e:	4618      	mov	r0, r3
34009f30:	f7fe fa8c 	bl	3400844c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI2 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI2) == RCC_PERIPHCLK_SPI2)
34009f34:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009f38:	e9d3 2300 	ldrd	r2, r3, [r3]
34009f3c:	2100      	movs	r1, #0
34009f3e:	f8c7 1098 	str.w	r1, [r7, #152]	@ 0x98
34009f42:	f003 0304 	and.w	r3, r3, #4
34009f46:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
34009f4a:	e9d7 0126 	ldrd	r0, r1, [r7, #152]	@ 0x98
34009f4e:	4603      	mov	r3, r0
34009f50:	460a      	mov	r2, r1
34009f52:	4313      	orrs	r3, r2
34009f54:	d04b      	beq.n	34009fee <HAL_RCCEx_PeriphCLKConfig+0x18e2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI2CLKSOURCE(PeriphClkInit->Spi2ClockSelection));

    if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC8)
34009f56:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009f5a:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34009f5e:	4b9c      	ldr	r3, [pc, #624]	@ (3400a1d0 <HAL_RCCEx_PeriphCLKConfig+0x1ac4>)
34009f60:	429a      	cmp	r2, r3
34009f62:	d116      	bne.n	34009f92 <HAL_RCCEx_PeriphCLKConfig+0x1886>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
34009f64:	4b97      	ldr	r3, [pc, #604]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34009f66:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
34009f6a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009f6e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009f72:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009f76:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
34009f78:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009f7c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
34009f7e:	3b01      	subs	r3, #1
34009f80:	041b      	lsls	r3, r3, #16
34009f82:	4313      	orrs	r3, r2
34009f84:	4a8f      	ldr	r2, [pc, #572]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34009f86:	430b      	orrs	r3, r1
34009f88:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
34009f8c:	f7fe fb08 	bl	340085a0 <LL_RCC_IC8_Enable>
34009f90:	e026      	b.n	34009fe0 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_IC9)
34009f92:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009f96:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34009f9a:	4b8e      	ldr	r3, [pc, #568]	@ (3400a1d4 <HAL_RCCEx_PeriphCLKConfig+0x1ac8>)
34009f9c:	429a      	cmp	r2, r3
34009f9e:	d116      	bne.n	34009fce <HAL_RCCEx_PeriphCLKConfig+0x18c2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
34009fa0:	4b88      	ldr	r3, [pc, #544]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34009fa2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
34009fa6:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
34009faa:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
34009fae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009fb2:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
34009fb4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009fb8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
34009fba:	3b01      	subs	r3, #1
34009fbc:	041b      	lsls	r3, r3, #16
34009fbe:	4313      	orrs	r3, r2
34009fc0:	4a80      	ldr	r2, [pc, #512]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
34009fc2:	430b      	orrs	r3, r1
34009fc4:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
34009fc8:	f7fe faf8 	bl	340085bc <LL_RCC_IC9_Enable>
34009fcc:	e008      	b.n	34009fe0 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    }
    else if (PeriphClkInit->Spi2ClockSelection == RCC_SPI2CLKSOURCE_CLKP)
34009fce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009fd2:	f8d3 2138 	ldr.w	r2, [r3, #312]	@ 0x138
34009fd6:	4b80      	ldr	r3, [pc, #512]	@ (3400a1d8 <HAL_RCCEx_PeriphCLKConfig+0x1acc>)
34009fd8:	429a      	cmp	r2, r3
34009fda:	d101      	bne.n	34009fe0 <HAL_RCCEx_PeriphCLKConfig+0x18d4>
    {
      LL_RCC_CLKP_Enable();
34009fdc:	f7fe fb88 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI2 clock*/
    __HAL_RCC_SPI2_CONFIG(PeriphClkInit->Spi2ClockSelection);
34009fe0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009fe4:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
34009fe8:	4618      	mov	r0, r3
34009fea:	f7fe fa2f 	bl	3400844c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI3 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI3) == RCC_PERIPHCLK_SPI3)
34009fee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
34009ff2:	e9d3 2300 	ldrd	r2, r3, [r3]
34009ff6:	2100      	movs	r1, #0
34009ff8:	f8c7 1090 	str.w	r1, [r7, #144]	@ 0x90
34009ffc:	f003 0308 	and.w	r3, r3, #8
3400a000:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
3400a004:	e9d7 0124 	ldrd	r0, r1, [r7, #144]	@ 0x90
3400a008:	4603      	mov	r3, r0
3400a00a:	460a      	mov	r2, r1
3400a00c:	4313      	orrs	r3, r2
3400a00e:	d04b      	beq.n	3400a0a8 <HAL_RCCEx_PeriphCLKConfig+0x199c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI3CLKSOURCE(PeriphClkInit->Spi3ClockSelection));

    if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC8)
3400a010:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a014:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3400a018:	4b70      	ldr	r3, [pc, #448]	@ (3400a1dc <HAL_RCCEx_PeriphCLKConfig+0x1ad0>)
3400a01a:	429a      	cmp	r2, r3
3400a01c:	d116      	bne.n	3400a04c <HAL_RCCEx_PeriphCLKConfig+0x1940>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400a01e:	4b69      	ldr	r3, [pc, #420]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3400a020:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400a024:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a028:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a02c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a030:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400a032:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a036:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400a038:	3b01      	subs	r3, #1
3400a03a:	041b      	lsls	r3, r3, #16
3400a03c:	4313      	orrs	r3, r2
3400a03e:	4a61      	ldr	r2, [pc, #388]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3400a040:	430b      	orrs	r3, r1
3400a042:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3400a046:	f7fe faab 	bl	340085a0 <LL_RCC_IC8_Enable>
3400a04a:	e026      	b.n	3400a09a <HAL_RCCEx_PeriphCLKConfig+0x198e>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_IC9)
3400a04c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a050:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3400a054:	4b62      	ldr	r3, [pc, #392]	@ (3400a1e0 <HAL_RCCEx_PeriphCLKConfig+0x1ad4>)
3400a056:	429a      	cmp	r2, r3
3400a058:	d116      	bne.n	3400a088 <HAL_RCCEx_PeriphCLKConfig+0x197c>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400a05a:	4b5a      	ldr	r3, [pc, #360]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3400a05c:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400a060:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a064:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a068:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a06c:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400a06e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a072:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400a074:	3b01      	subs	r3, #1
3400a076:	041b      	lsls	r3, r3, #16
3400a078:	4313      	orrs	r3, r2
3400a07a:	4a52      	ldr	r2, [pc, #328]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3400a07c:	430b      	orrs	r3, r1
3400a07e:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400a082:	f7fe fa9b 	bl	340085bc <LL_RCC_IC9_Enable>
3400a086:	e008      	b.n	3400a09a <HAL_RCCEx_PeriphCLKConfig+0x198e>
    }
    else if (PeriphClkInit->Spi3ClockSelection == RCC_SPI3CLKSOURCE_CLKP)
3400a088:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a08c:	f8d3 213c 	ldr.w	r2, [r3, #316]	@ 0x13c
3400a090:	4b54      	ldr	r3, [pc, #336]	@ (3400a1e4 <HAL_RCCEx_PeriphCLKConfig+0x1ad8>)
3400a092:	429a      	cmp	r2, r3
3400a094:	d101      	bne.n	3400a09a <HAL_RCCEx_PeriphCLKConfig+0x198e>
    {
      LL_RCC_CLKP_Enable();
3400a096:	f7fe fb2b 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI3 clock*/
    __HAL_RCC_SPI3_CONFIG(PeriphClkInit->Spi3ClockSelection);
3400a09a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a09e:	f8d3 313c 	ldr.w	r3, [r3, #316]	@ 0x13c
3400a0a2:	4618      	mov	r0, r3
3400a0a4:	f7fe f9d2 	bl	3400844c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI4 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI4) == RCC_PERIPHCLK_SPI4)
3400a0a8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a0ac:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a0b0:	2100      	movs	r1, #0
3400a0b2:	f8c7 1088 	str.w	r1, [r7, #136]	@ 0x88
3400a0b6:	f003 0310 	and.w	r3, r3, #16
3400a0ba:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
3400a0be:	e9d7 0122 	ldrd	r0, r1, [r7, #136]	@ 0x88
3400a0c2:	4603      	mov	r3, r0
3400a0c4:	460a      	mov	r2, r1
3400a0c6:	4313      	orrs	r3, r2
3400a0c8:	d04b      	beq.n	3400a162 <HAL_RCCEx_PeriphCLKConfig+0x1a56>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI4CLKSOURCE(PeriphClkInit->Spi4ClockSelection));

    if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC9)
3400a0ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a0ce:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
3400a0d2:	4b45      	ldr	r3, [pc, #276]	@ (3400a1e8 <HAL_RCCEx_PeriphCLKConfig+0x1adc>)
3400a0d4:	429a      	cmp	r2, r3
3400a0d6:	d116      	bne.n	3400a106 <HAL_RCCEx_PeriphCLKConfig+0x19fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400a0d8:	4b3a      	ldr	r3, [pc, #232]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3400a0da:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400a0de:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a0e2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a0e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a0ea:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400a0ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a0f0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400a0f2:	3b01      	subs	r3, #1
3400a0f4:	041b      	lsls	r3, r3, #16
3400a0f6:	4313      	orrs	r3, r2
3400a0f8:	4a32      	ldr	r2, [pc, #200]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3400a0fa:	430b      	orrs	r3, r1
3400a0fc:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400a100:	f7fe fa5c 	bl	340085bc <LL_RCC_IC9_Enable>
3400a104:	e026      	b.n	3400a154 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_IC14)
3400a106:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a10a:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
3400a10e:	4b37      	ldr	r3, [pc, #220]	@ (3400a1ec <HAL_RCCEx_PeriphCLKConfig+0x1ae0>)
3400a110:	429a      	cmp	r2, r3
3400a112:	d116      	bne.n	3400a142 <HAL_RCCEx_PeriphCLKConfig+0x1a36>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400a114:	4b2b      	ldr	r3, [pc, #172]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3400a116:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400a11a:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a11e:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a122:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a126:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400a128:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a12c:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400a12e:	3b01      	subs	r3, #1
3400a130:	041b      	lsls	r3, r3, #16
3400a132:	4313      	orrs	r3, r2
3400a134:	4a23      	ldr	r2, [pc, #140]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3400a136:	430b      	orrs	r3, r1
3400a138:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400a13c:	f7fe fa76 	bl	3400862c <LL_RCC_IC14_Enable>
3400a140:	e008      	b.n	3400a154 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    }
    else if (PeriphClkInit->Spi4ClockSelection == RCC_SPI4CLKSOURCE_CLKP)
3400a142:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a146:	f8d3 2140 	ldr.w	r2, [r3, #320]	@ 0x140
3400a14a:	4b29      	ldr	r3, [pc, #164]	@ (3400a1f0 <HAL_RCCEx_PeriphCLKConfig+0x1ae4>)
3400a14c:	429a      	cmp	r2, r3
3400a14e:	d101      	bne.n	3400a154 <HAL_RCCEx_PeriphCLKConfig+0x1a48>
    {
      LL_RCC_CLKP_Enable();
3400a150:	f7fe face 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI4 clock */
    __HAL_RCC_SPI4_CONFIG(PeriphClkInit->Spi4ClockSelection);
3400a154:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a158:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
3400a15c:	4618      	mov	r0, r3
3400a15e:	f7fe f975 	bl	3400844c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI5 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI5) == RCC_PERIPHCLK_SPI5)
3400a162:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a166:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a16a:	2100      	movs	r1, #0
3400a16c:	f8c7 1080 	str.w	r1, [r7, #128]	@ 0x80
3400a170:	f003 0320 	and.w	r3, r3, #32
3400a174:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
3400a178:	e9d7 0120 	ldrd	r0, r1, [r7, #128]	@ 0x80
3400a17c:	4603      	mov	r3, r0
3400a17e:	460a      	mov	r2, r1
3400a180:	4313      	orrs	r3, r2
3400a182:	d067      	beq.n	3400a254 <HAL_RCCEx_PeriphCLKConfig+0x1b48>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI5CLKSOURCE(PeriphClkInit->Spi5ClockSelection));

    if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC9)
3400a184:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a188:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
3400a18c:	4b19      	ldr	r3, [pc, #100]	@ (3400a1f4 <HAL_RCCEx_PeriphCLKConfig+0x1ae8>)
3400a18e:	429a      	cmp	r2, r3
3400a190:	d132      	bne.n	3400a1f8 <HAL_RCCEx_PeriphCLKConfig+0x1aec>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400a192:	4b0c      	ldr	r3, [pc, #48]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3400a194:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400a198:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a19c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a1a0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a1a4:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400a1a6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a1aa:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400a1ac:	3b01      	subs	r3, #1
3400a1ae:	041b      	lsls	r3, r3, #16
3400a1b0:	4313      	orrs	r3, r2
3400a1b2:	4a04      	ldr	r2, [pc, #16]	@ (3400a1c4 <HAL_RCCEx_PeriphCLKConfig+0x1ab8>)
3400a1b4:	430b      	orrs	r3, r1
3400a1b6:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400a1ba:	f7fe f9ff 	bl	340085bc <LL_RCC_IC9_Enable>
3400a1be:	e042      	b.n	3400a246 <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
3400a1c0:	07020420 	.word	0x07020420
3400a1c4:	56028000 	.word	0x56028000
3400a1c8:	07030420 	.word	0x07030420
3400a1cc:	07010420 	.word	0x07010420
3400a1d0:	07020820 	.word	0x07020820
3400a1d4:	07030820 	.word	0x07030820
3400a1d8:	07010820 	.word	0x07010820
3400a1dc:	07020c20 	.word	0x07020c20
3400a1e0:	07030c20 	.word	0x07030c20
3400a1e4:	07010c20 	.word	0x07010c20
3400a1e8:	07021020 	.word	0x07021020
3400a1ec:	07031020 	.word	0x07031020
3400a1f0:	07011020 	.word	0x07011020
3400a1f4:	07021420 	.word	0x07021420
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_IC14)
3400a1f8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a1fc:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
3400a200:	4bc2      	ldr	r3, [pc, #776]	@ (3400a50c <HAL_RCCEx_PeriphCLKConfig+0x1e00>)
3400a202:	429a      	cmp	r2, r3
3400a204:	d116      	bne.n	3400a234 <HAL_RCCEx_PeriphCLKConfig+0x1b28>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400a206:	4bc2      	ldr	r3, [pc, #776]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a208:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400a20c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a210:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a214:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a218:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400a21a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a21e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400a220:	3b01      	subs	r3, #1
3400a222:	041b      	lsls	r3, r3, #16
3400a224:	4313      	orrs	r3, r2
3400a226:	4aba      	ldr	r2, [pc, #744]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a228:	430b      	orrs	r3, r1
3400a22a:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400a22e:	f7fe f9fd 	bl	3400862c <LL_RCC_IC14_Enable>
3400a232:	e008      	b.n	3400a246 <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
    }
    else if (PeriphClkInit->Spi5ClockSelection == RCC_SPI5CLKSOURCE_CLKP)
3400a234:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a238:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
3400a23c:	4bb5      	ldr	r3, [pc, #724]	@ (3400a514 <HAL_RCCEx_PeriphCLKConfig+0x1e08>)
3400a23e:	429a      	cmp	r2, r3
3400a240:	d101      	bne.n	3400a246 <HAL_RCCEx_PeriphCLKConfig+0x1b3a>
    {
      LL_RCC_CLKP_Enable();
3400a242:	f7fe fa55 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI5 clock */
    __HAL_RCC_SPI5_CONFIG(PeriphClkInit->Spi5ClockSelection);
3400a246:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a24a:	f8d3 3144 	ldr.w	r3, [r3, #324]	@ 0x144
3400a24e:	4618      	mov	r0, r3
3400a250:	f7fe f8fc 	bl	3400844c <LL_RCC_SetSPIClockSource>
  }

  /*---------------------------- SPI6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
3400a254:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a258:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a25c:	2100      	movs	r1, #0
3400a25e:	67b9      	str	r1, [r7, #120]	@ 0x78
3400a260:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400a264:	67fb      	str	r3, [r7, #124]	@ 0x7c
3400a266:	e9d7 011e 	ldrd	r0, r1, [r7, #120]	@ 0x78
3400a26a:	4603      	mov	r3, r0
3400a26c:	460a      	mov	r2, r1
3400a26e:	4313      	orrs	r3, r2
3400a270:	d04b      	beq.n	3400a30a <HAL_RCCEx_PeriphCLKConfig+0x1bfe>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI6CLKSOURCE(PeriphClkInit->Spi6ClockSelection));

    if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC8)
3400a272:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a276:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3400a27a:	4ba7      	ldr	r3, [pc, #668]	@ (3400a518 <HAL_RCCEx_PeriphCLKConfig+0x1e0c>)
3400a27c:	429a      	cmp	r2, r3
3400a27e:	d116      	bne.n	3400a2ae <HAL_RCCEx_PeriphCLKConfig+0x1ba2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC8].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC8].ClockDivider));

      /* Set IC8 configuration */
      MODIFY_REG(RCC->IC8CFGR, RCC_IC8CFGR_IC8SEL | RCC_IC8CFGR_IC8INT,
3400a280:	4ba3      	ldr	r3, [pc, #652]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a282:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
3400a286:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a28a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a28e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a292:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
3400a294:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a298:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400a29a:	3b01      	subs	r3, #1
3400a29c:	041b      	lsls	r3, r3, #16
3400a29e:	4313      	orrs	r3, r2
3400a2a0:	4a9b      	ldr	r2, [pc, #620]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a2a2:	430b      	orrs	r3, r1
3400a2a4:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
                 PeriphClkInit->ICSelection[RCC_IC8].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC8].ClockDivider - 1U) << RCC_IC8CFGR_IC8INT_Pos));

      LL_RCC_IC8_Enable();
3400a2a8:	f7fe f97a 	bl	340085a0 <LL_RCC_IC8_Enable>
3400a2ac:	e026      	b.n	3400a2fc <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_IC9)
3400a2ae:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a2b2:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3400a2b6:	4b99      	ldr	r3, [pc, #612]	@ (3400a51c <HAL_RCCEx_PeriphCLKConfig+0x1e10>)
3400a2b8:	429a      	cmp	r2, r3
3400a2ba:	d116      	bne.n	3400a2ea <HAL_RCCEx_PeriphCLKConfig+0x1bde>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400a2bc:	4b94      	ldr	r3, [pc, #592]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a2be:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400a2c2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a2c6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a2ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a2ce:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400a2d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a2d4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400a2d6:	3b01      	subs	r3, #1
3400a2d8:	041b      	lsls	r3, r3, #16
3400a2da:	4313      	orrs	r3, r2
3400a2dc:	4a8c      	ldr	r2, [pc, #560]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a2de:	430b      	orrs	r3, r1
3400a2e0:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400a2e4:	f7fe f96a 	bl	340085bc <LL_RCC_IC9_Enable>
3400a2e8:	e008      	b.n	3400a2fc <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    }
    else if (PeriphClkInit->Spi6ClockSelection == RCC_SPI6CLKSOURCE_CLKP)
3400a2ea:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a2ee:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
3400a2f2:	4b8b      	ldr	r3, [pc, #556]	@ (3400a520 <HAL_RCCEx_PeriphCLKConfig+0x1e14>)
3400a2f4:	429a      	cmp	r2, r3
3400a2f6:	d101      	bne.n	3400a2fc <HAL_RCCEx_PeriphCLKConfig+0x1bf0>
    {
      LL_RCC_CLKP_Enable();
3400a2f8:	f7fe f9fa 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of SPI6 clock*/
    __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
3400a2fc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a300:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
3400a304:	4618      	mov	r0, r3
3400a306:	f7fe f8a1 	bl	3400844c <LL_RCC_SetSPIClockSource>
  }

  /*-------------------------- USART1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
3400a30a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a30e:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a312:	2100      	movs	r1, #0
3400a314:	6739      	str	r1, [r7, #112]	@ 0x70
3400a316:	f403 7380 	and.w	r3, r3, #256	@ 0x100
3400a31a:	677b      	str	r3, [r7, #116]	@ 0x74
3400a31c:	e9d7 011c 	ldrd	r0, r1, [r7, #112]	@ 0x70
3400a320:	4603      	mov	r3, r0
3400a322:	460a      	mov	r2, r1
3400a324:	4313      	orrs	r3, r2
3400a326:	d04b      	beq.n	3400a3c0 <HAL_RCCEx_PeriphCLKConfig+0x1cb4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC9)
3400a328:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a32c:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3400a330:	4b7c      	ldr	r3, [pc, #496]	@ (3400a524 <HAL_RCCEx_PeriphCLKConfig+0x1e18>)
3400a332:	429a      	cmp	r2, r3
3400a334:	d116      	bne.n	3400a364 <HAL_RCCEx_PeriphCLKConfig+0x1c58>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400a336:	4b76      	ldr	r3, [pc, #472]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a338:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400a33c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a340:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a344:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a348:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400a34a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a34e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400a350:	3b01      	subs	r3, #1
3400a352:	041b      	lsls	r3, r3, #16
3400a354:	4313      	orrs	r3, r2
3400a356:	4a6e      	ldr	r2, [pc, #440]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a358:	430b      	orrs	r3, r1
3400a35a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400a35e:	f7fe f92d 	bl	340085bc <LL_RCC_IC9_Enable>
3400a362:	e026      	b.n	3400a3b2 <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_IC14)
3400a364:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a368:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3400a36c:	4b6e      	ldr	r3, [pc, #440]	@ (3400a528 <HAL_RCCEx_PeriphCLKConfig+0x1e1c>)
3400a36e:	429a      	cmp	r2, r3
3400a370:	d116      	bne.n	3400a3a0 <HAL_RCCEx_PeriphCLKConfig+0x1c94>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400a372:	4b67      	ldr	r3, [pc, #412]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a374:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400a378:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a37c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a380:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a384:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400a386:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a38a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400a38c:	3b01      	subs	r3, #1
3400a38e:	041b      	lsls	r3, r3, #16
3400a390:	4313      	orrs	r3, r2
3400a392:	4a5f      	ldr	r2, [pc, #380]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a394:	430b      	orrs	r3, r1
3400a396:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400a39a:	f7fe f947 	bl	3400862c <LL_RCC_IC14_Enable>
3400a39e:	e008      	b.n	3400a3b2 <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    }
    else if (PeriphClkInit->Usart1ClockSelection == RCC_USART1CLKSOURCE_CLKP)
3400a3a0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a3a4:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
3400a3a8:	4b60      	ldr	r3, [pc, #384]	@ (3400a52c <HAL_RCCEx_PeriphCLKConfig+0x1e20>)
3400a3aa:	429a      	cmp	r2, r3
3400a3ac:	d101      	bne.n	3400a3b2 <HAL_RCCEx_PeriphCLKConfig+0x1ca6>
    {
      LL_RCC_CLKP_Enable();
3400a3ae:	f7fe f99f 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART1 clock */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
3400a3b2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a3b6:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
3400a3ba:	4618      	mov	r0, r3
3400a3bc:	f7fe f851 	bl	34008462 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
3400a3c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a3c4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a3c8:	2100      	movs	r1, #0
3400a3ca:	66b9      	str	r1, [r7, #104]	@ 0x68
3400a3cc:	f403 7300 	and.w	r3, r3, #512	@ 0x200
3400a3d0:	66fb      	str	r3, [r7, #108]	@ 0x6c
3400a3d2:	e9d7 011a 	ldrd	r0, r1, [r7, #104]	@ 0x68
3400a3d6:	4603      	mov	r3, r0
3400a3d8:	460a      	mov	r2, r1
3400a3da:	4313      	orrs	r3, r2
3400a3dc:	d04b      	beq.n	3400a476 <HAL_RCCEx_PeriphCLKConfig+0x1d6a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC9)
3400a3de:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a3e2:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
3400a3e6:	4b52      	ldr	r3, [pc, #328]	@ (3400a530 <HAL_RCCEx_PeriphCLKConfig+0x1e24>)
3400a3e8:	429a      	cmp	r2, r3
3400a3ea:	d116      	bne.n	3400a41a <HAL_RCCEx_PeriphCLKConfig+0x1d0e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400a3ec:	4b48      	ldr	r3, [pc, #288]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a3ee:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400a3f2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a3f6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a3fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a3fe:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400a400:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a404:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400a406:	3b01      	subs	r3, #1
3400a408:	041b      	lsls	r3, r3, #16
3400a40a:	4313      	orrs	r3, r2
3400a40c:	4a40      	ldr	r2, [pc, #256]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a40e:	430b      	orrs	r3, r1
3400a410:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400a414:	f7fe f8d2 	bl	340085bc <LL_RCC_IC9_Enable>
3400a418:	e026      	b.n	3400a468 <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_IC14)
3400a41a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a41e:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
3400a422:	4b44      	ldr	r3, [pc, #272]	@ (3400a534 <HAL_RCCEx_PeriphCLKConfig+0x1e28>)
3400a424:	429a      	cmp	r2, r3
3400a426:	d116      	bne.n	3400a456 <HAL_RCCEx_PeriphCLKConfig+0x1d4a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400a428:	4b39      	ldr	r3, [pc, #228]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a42a:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400a42e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a432:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a436:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a43a:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400a43c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a440:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400a442:	3b01      	subs	r3, #1
3400a444:	041b      	lsls	r3, r3, #16
3400a446:	4313      	orrs	r3, r2
3400a448:	4a31      	ldr	r2, [pc, #196]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a44a:	430b      	orrs	r3, r1
3400a44c:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400a450:	f7fe f8ec 	bl	3400862c <LL_RCC_IC14_Enable>
3400a454:	e008      	b.n	3400a468 <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    }
    else if (PeriphClkInit->Usart2ClockSelection == RCC_USART2CLKSOURCE_CLKP)
3400a456:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a45a:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
3400a45e:	4b36      	ldr	r3, [pc, #216]	@ (3400a538 <HAL_RCCEx_PeriphCLKConfig+0x1e2c>)
3400a460:	429a      	cmp	r2, r3
3400a462:	d101      	bne.n	3400a468 <HAL_RCCEx_PeriphCLKConfig+0x1d5c>
    {
      LL_RCC_CLKP_Enable();
3400a464:	f7fe f944 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART2 clock */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
3400a468:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a46c:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
3400a470:	4618      	mov	r0, r3
3400a472:	f7fd fff6 	bl	34008462 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART3 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
3400a476:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a47a:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a47e:	2100      	movs	r1, #0
3400a480:	6639      	str	r1, [r7, #96]	@ 0x60
3400a482:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
3400a486:	667b      	str	r3, [r7, #100]	@ 0x64
3400a488:	e9d7 0118 	ldrd	r0, r1, [r7, #96]	@ 0x60
3400a48c:	4603      	mov	r3, r0
3400a48e:	460a      	mov	r2, r1
3400a490:	4313      	orrs	r3, r2
3400a492:	d067      	beq.n	3400a564 <HAL_RCCEx_PeriphCLKConfig+0x1e58>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC9)
3400a494:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a498:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
3400a49c:	4b27      	ldr	r3, [pc, #156]	@ (3400a53c <HAL_RCCEx_PeriphCLKConfig+0x1e30>)
3400a49e:	429a      	cmp	r2, r3
3400a4a0:	d116      	bne.n	3400a4d0 <HAL_RCCEx_PeriphCLKConfig+0x1dc4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400a4a2:	4b1b      	ldr	r3, [pc, #108]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a4a4:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400a4a8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a4ac:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a4b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a4b4:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400a4b6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a4ba:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400a4bc:	3b01      	subs	r3, #1
3400a4be:	041b      	lsls	r3, r3, #16
3400a4c0:	4313      	orrs	r3, r2
3400a4c2:	4a13      	ldr	r2, [pc, #76]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a4c4:	430b      	orrs	r3, r1
3400a4c6:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400a4ca:	f7fe f877 	bl	340085bc <LL_RCC_IC9_Enable>
3400a4ce:	e042      	b.n	3400a556 <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_IC14)
3400a4d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a4d4:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
3400a4d8:	4b19      	ldr	r3, [pc, #100]	@ (3400a540 <HAL_RCCEx_PeriphCLKConfig+0x1e34>)
3400a4da:	429a      	cmp	r2, r3
3400a4dc:	d132      	bne.n	3400a544 <HAL_RCCEx_PeriphCLKConfig+0x1e38>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400a4de:	4b0c      	ldr	r3, [pc, #48]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a4e0:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400a4e4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a4e8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a4ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a4f0:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400a4f2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a4f6:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400a4f8:	3b01      	subs	r3, #1
3400a4fa:	041b      	lsls	r3, r3, #16
3400a4fc:	4313      	orrs	r3, r2
3400a4fe:	4a04      	ldr	r2, [pc, #16]	@ (3400a510 <HAL_RCCEx_PeriphCLKConfig+0x1e04>)
3400a500:	430b      	orrs	r3, r1
3400a502:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400a506:	f7fe f891 	bl	3400862c <LL_RCC_IC14_Enable>
3400a50a:	e024      	b.n	3400a556 <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
3400a50c:	07031420 	.word	0x07031420
3400a510:	56028000 	.word	0x56028000
3400a514:	07011420 	.word	0x07011420
3400a518:	07021820 	.word	0x07021820
3400a51c:	07031820 	.word	0x07031820
3400a520:	07011820 	.word	0x07011820
3400a524:	07020030 	.word	0x07020030
3400a528:	07030030 	.word	0x07030030
3400a52c:	07010030 	.word	0x07010030
3400a530:	07020430 	.word	0x07020430
3400a534:	07030430 	.word	0x07030430
3400a538:	07010430 	.word	0x07010430
3400a53c:	07020830 	.word	0x07020830
3400a540:	07030830 	.word	0x07030830
    }
    else if (PeriphClkInit->Usart3ClockSelection == RCC_USART3CLKSOURCE_CLKP)
3400a544:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a548:	f8d3 2158 	ldr.w	r2, [r3, #344]	@ 0x158
3400a54c:	4bb3      	ldr	r3, [pc, #716]	@ (3400a81c <HAL_RCCEx_PeriphCLKConfig+0x2110>)
3400a54e:	429a      	cmp	r2, r3
3400a550:	d101      	bne.n	3400a556 <HAL_RCCEx_PeriphCLKConfig+0x1e4a>
    {
      LL_RCC_CLKP_Enable();
3400a552:	f7fe f8cd 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART3 clock */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
3400a556:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a55a:	f8d3 3158 	ldr.w	r3, [r3, #344]	@ 0x158
3400a55e:	4618      	mov	r0, r3
3400a560:	f7fd ff7f 	bl	34008462 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART4 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
3400a564:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a568:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a56c:	2100      	movs	r1, #0
3400a56e:	65b9      	str	r1, [r7, #88]	@ 0x58
3400a570:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
3400a574:	65fb      	str	r3, [r7, #92]	@ 0x5c
3400a576:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	@ 0x58
3400a57a:	4603      	mov	r3, r0
3400a57c:	460a      	mov	r2, r1
3400a57e:	4313      	orrs	r3, r2
3400a580:	d04b      	beq.n	3400a61a <HAL_RCCEx_PeriphCLKConfig+0x1f0e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC9)
3400a582:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a586:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400a58a:	4ba5      	ldr	r3, [pc, #660]	@ (3400a820 <HAL_RCCEx_PeriphCLKConfig+0x2114>)
3400a58c:	429a      	cmp	r2, r3
3400a58e:	d116      	bne.n	3400a5be <HAL_RCCEx_PeriphCLKConfig+0x1eb2>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400a590:	4ba4      	ldr	r3, [pc, #656]	@ (3400a824 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3400a592:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400a596:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a59a:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a59e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a5a2:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400a5a4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a5a8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400a5aa:	3b01      	subs	r3, #1
3400a5ac:	041b      	lsls	r3, r3, #16
3400a5ae:	4313      	orrs	r3, r2
3400a5b0:	4a9c      	ldr	r2, [pc, #624]	@ (3400a824 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3400a5b2:	430b      	orrs	r3, r1
3400a5b4:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400a5b8:	f7fe f800 	bl	340085bc <LL_RCC_IC9_Enable>
3400a5bc:	e026      	b.n	3400a60c <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_IC14)
3400a5be:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a5c2:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400a5c6:	4b98      	ldr	r3, [pc, #608]	@ (3400a828 <HAL_RCCEx_PeriphCLKConfig+0x211c>)
3400a5c8:	429a      	cmp	r2, r3
3400a5ca:	d116      	bne.n	3400a5fa <HAL_RCCEx_PeriphCLKConfig+0x1eee>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400a5cc:	4b95      	ldr	r3, [pc, #596]	@ (3400a824 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3400a5ce:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400a5d2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a5d6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a5da:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a5de:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400a5e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a5e4:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400a5e6:	3b01      	subs	r3, #1
3400a5e8:	041b      	lsls	r3, r3, #16
3400a5ea:	4313      	orrs	r3, r2
3400a5ec:	4a8d      	ldr	r2, [pc, #564]	@ (3400a824 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3400a5ee:	430b      	orrs	r3, r1
3400a5f0:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400a5f4:	f7fe f81a 	bl	3400862c <LL_RCC_IC14_Enable>
3400a5f8:	e008      	b.n	3400a60c <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    }
    else if (PeriphClkInit->Uart4ClockSelection == RCC_UART4CLKSOURCE_CLKP)
3400a5fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a5fe:	f8d3 215c 	ldr.w	r2, [r3, #348]	@ 0x15c
3400a602:	4b8a      	ldr	r3, [pc, #552]	@ (3400a82c <HAL_RCCEx_PeriphCLKConfig+0x2120>)
3400a604:	429a      	cmp	r2, r3
3400a606:	d101      	bne.n	3400a60c <HAL_RCCEx_PeriphCLKConfig+0x1f00>
    {
      LL_RCC_CLKP_Enable();
3400a608:	f7fe f872 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART4 clock */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
3400a60c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a610:	f8d3 315c 	ldr.w	r3, [r3, #348]	@ 0x15c
3400a614:	4618      	mov	r0, r3
3400a616:	f7fd ff24 	bl	34008462 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART5 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
3400a61a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a61e:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a622:	2100      	movs	r1, #0
3400a624:	6539      	str	r1, [r7, #80]	@ 0x50
3400a626:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3400a62a:	657b      	str	r3, [r7, #84]	@ 0x54
3400a62c:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	@ 0x50
3400a630:	4603      	mov	r3, r0
3400a632:	460a      	mov	r2, r1
3400a634:	4313      	orrs	r3, r2
3400a636:	d04b      	beq.n	3400a6d0 <HAL_RCCEx_PeriphCLKConfig+0x1fc4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC9)
3400a638:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a63c:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3400a640:	4b7b      	ldr	r3, [pc, #492]	@ (3400a830 <HAL_RCCEx_PeriphCLKConfig+0x2124>)
3400a642:	429a      	cmp	r2, r3
3400a644:	d116      	bne.n	3400a674 <HAL_RCCEx_PeriphCLKConfig+0x1f68>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400a646:	4b77      	ldr	r3, [pc, #476]	@ (3400a824 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3400a648:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400a64c:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a650:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a654:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a658:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400a65a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a65e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400a660:	3b01      	subs	r3, #1
3400a662:	041b      	lsls	r3, r3, #16
3400a664:	4313      	orrs	r3, r2
3400a666:	4a6f      	ldr	r2, [pc, #444]	@ (3400a824 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3400a668:	430b      	orrs	r3, r1
3400a66a:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400a66e:	f7fd ffa5 	bl	340085bc <LL_RCC_IC9_Enable>
3400a672:	e026      	b.n	3400a6c2 <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_IC14)
3400a674:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a678:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3400a67c:	4b6d      	ldr	r3, [pc, #436]	@ (3400a834 <HAL_RCCEx_PeriphCLKConfig+0x2128>)
3400a67e:	429a      	cmp	r2, r3
3400a680:	d116      	bne.n	3400a6b0 <HAL_RCCEx_PeriphCLKConfig+0x1fa4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400a682:	4b68      	ldr	r3, [pc, #416]	@ (3400a824 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3400a684:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400a688:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a68c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a690:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a694:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400a696:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a69a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400a69c:	3b01      	subs	r3, #1
3400a69e:	041b      	lsls	r3, r3, #16
3400a6a0:	4313      	orrs	r3, r2
3400a6a2:	4a60      	ldr	r2, [pc, #384]	@ (3400a824 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3400a6a4:	430b      	orrs	r3, r1
3400a6a6:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400a6aa:	f7fd ffbf 	bl	3400862c <LL_RCC_IC14_Enable>
3400a6ae:	e008      	b.n	3400a6c2 <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    }
    else if (PeriphClkInit->Uart5ClockSelection == RCC_UART5CLKSOURCE_CLKP)
3400a6b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a6b4:	f8d3 2160 	ldr.w	r2, [r3, #352]	@ 0x160
3400a6b8:	4b5f      	ldr	r3, [pc, #380]	@ (3400a838 <HAL_RCCEx_PeriphCLKConfig+0x212c>)
3400a6ba:	429a      	cmp	r2, r3
3400a6bc:	d101      	bne.n	3400a6c2 <HAL_RCCEx_PeriphCLKConfig+0x1fb6>
    {
      LL_RCC_CLKP_Enable();
3400a6be:	f7fe f817 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART5 clock */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
3400a6c2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a6c6:	f8d3 3160 	ldr.w	r3, [r3, #352]	@ 0x160
3400a6ca:	4618      	mov	r0, r3
3400a6cc:	f7fd fec9 	bl	34008462 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
3400a6d0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a6d4:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a6d8:	2100      	movs	r1, #0
3400a6da:	64b9      	str	r1, [r7, #72]	@ 0x48
3400a6dc:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
3400a6e0:	64fb      	str	r3, [r7, #76]	@ 0x4c
3400a6e2:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	@ 0x48
3400a6e6:	4603      	mov	r3, r0
3400a6e8:	460a      	mov	r2, r1
3400a6ea:	4313      	orrs	r3, r2
3400a6ec:	d04b      	beq.n	3400a786 <HAL_RCCEx_PeriphCLKConfig+0x207a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC9)
3400a6ee:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a6f2:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3400a6f6:	4b51      	ldr	r3, [pc, #324]	@ (3400a83c <HAL_RCCEx_PeriphCLKConfig+0x2130>)
3400a6f8:	429a      	cmp	r2, r3
3400a6fa:	d116      	bne.n	3400a72a <HAL_RCCEx_PeriphCLKConfig+0x201e>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400a6fc:	4b49      	ldr	r3, [pc, #292]	@ (3400a824 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3400a6fe:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400a702:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a706:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a70a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a70e:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400a710:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a714:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400a716:	3b01      	subs	r3, #1
3400a718:	041b      	lsls	r3, r3, #16
3400a71a:	4313      	orrs	r3, r2
3400a71c:	4a41      	ldr	r2, [pc, #260]	@ (3400a824 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3400a71e:	430b      	orrs	r3, r1
3400a720:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400a724:	f7fd ff4a 	bl	340085bc <LL_RCC_IC9_Enable>
3400a728:	e026      	b.n	3400a778 <HAL_RCCEx_PeriphCLKConfig+0x206c>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_IC14)
3400a72a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a72e:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3400a732:	4b43      	ldr	r3, [pc, #268]	@ (3400a840 <HAL_RCCEx_PeriphCLKConfig+0x2134>)
3400a734:	429a      	cmp	r2, r3
3400a736:	d116      	bne.n	3400a766 <HAL_RCCEx_PeriphCLKConfig+0x205a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400a738:	4b3a      	ldr	r3, [pc, #232]	@ (3400a824 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3400a73a:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400a73e:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a742:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a746:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a74a:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400a74c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a750:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400a752:	3b01      	subs	r3, #1
3400a754:	041b      	lsls	r3, r3, #16
3400a756:	4313      	orrs	r3, r2
3400a758:	4a32      	ldr	r2, [pc, #200]	@ (3400a824 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3400a75a:	430b      	orrs	r3, r1
3400a75c:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400a760:	f7fd ff64 	bl	3400862c <LL_RCC_IC14_Enable>
3400a764:	e008      	b.n	3400a778 <HAL_RCCEx_PeriphCLKConfig+0x206c>
    }
    else if (PeriphClkInit->Usart6ClockSelection == RCC_USART6CLKSOURCE_CLKP)
3400a766:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a76a:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
3400a76e:	4b35      	ldr	r3, [pc, #212]	@ (3400a844 <HAL_RCCEx_PeriphCLKConfig+0x2138>)
3400a770:	429a      	cmp	r2, r3
3400a772:	d101      	bne.n	3400a778 <HAL_RCCEx_PeriphCLKConfig+0x206c>
    {
      LL_RCC_CLKP_Enable();
3400a774:	f7fd ffbc 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART6 clock */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
3400a778:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a77c:	f8d3 3164 	ldr.w	r3, [r3, #356]	@ 0x164
3400a780:	4618      	mov	r0, r3
3400a782:	f7fd fe6e 	bl	34008462 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART7 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
3400a786:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a78a:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a78e:	2100      	movs	r1, #0
3400a790:	6439      	str	r1, [r7, #64]	@ 0x40
3400a792:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
3400a796:	647b      	str	r3, [r7, #68]	@ 0x44
3400a798:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	@ 0x40
3400a79c:	4603      	mov	r3, r0
3400a79e:	460a      	mov	r2, r1
3400a7a0:	4313      	orrs	r3, r2
3400a7a2:	d065      	beq.n	3400a870 <HAL_RCCEx_PeriphCLKConfig+0x2164>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC9)
3400a7a4:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a7a8:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
3400a7ac:	4b26      	ldr	r3, [pc, #152]	@ (3400a848 <HAL_RCCEx_PeriphCLKConfig+0x213c>)
3400a7ae:	429a      	cmp	r2, r3
3400a7b0:	d116      	bne.n	3400a7e0 <HAL_RCCEx_PeriphCLKConfig+0x20d4>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400a7b2:	4b1c      	ldr	r3, [pc, #112]	@ (3400a824 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3400a7b4:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400a7b8:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a7bc:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a7c0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a7c4:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400a7c6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a7ca:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400a7cc:	3b01      	subs	r3, #1
3400a7ce:	041b      	lsls	r3, r3, #16
3400a7d0:	4313      	orrs	r3, r2
3400a7d2:	4a14      	ldr	r2, [pc, #80]	@ (3400a824 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3400a7d4:	430b      	orrs	r3, r1
3400a7d6:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400a7da:	f7fd feef 	bl	340085bc <LL_RCC_IC9_Enable>
3400a7de:	e040      	b.n	3400a862 <HAL_RCCEx_PeriphCLKConfig+0x2156>
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_IC14)
3400a7e0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a7e4:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
3400a7e8:	4b18      	ldr	r3, [pc, #96]	@ (3400a84c <HAL_RCCEx_PeriphCLKConfig+0x2140>)
3400a7ea:	429a      	cmp	r2, r3
3400a7ec:	d130      	bne.n	3400a850 <HAL_RCCEx_PeriphCLKConfig+0x2144>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400a7ee:	4b0d      	ldr	r3, [pc, #52]	@ (3400a824 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3400a7f0:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400a7f4:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a7f8:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a7fc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a800:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400a802:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a806:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400a808:	3b01      	subs	r3, #1
3400a80a:	041b      	lsls	r3, r3, #16
3400a80c:	4313      	orrs	r3, r2
3400a80e:	4a05      	ldr	r2, [pc, #20]	@ (3400a824 <HAL_RCCEx_PeriphCLKConfig+0x2118>)
3400a810:	430b      	orrs	r3, r1
3400a812:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400a816:	f7fd ff09 	bl	3400862c <LL_RCC_IC14_Enable>
3400a81a:	e022      	b.n	3400a862 <HAL_RCCEx_PeriphCLKConfig+0x2156>
3400a81c:	07010830 	.word	0x07010830
3400a820:	07020c30 	.word	0x07020c30
3400a824:	56028000 	.word	0x56028000
3400a828:	07030c30 	.word	0x07030c30
3400a82c:	07010c30 	.word	0x07010c30
3400a830:	07021030 	.word	0x07021030
3400a834:	07031030 	.word	0x07031030
3400a838:	07011030 	.word	0x07011030
3400a83c:	07021430 	.word	0x07021430
3400a840:	07031430 	.word	0x07031430
3400a844:	07011430 	.word	0x07011430
3400a848:	07021830 	.word	0x07021830
3400a84c:	07031830 	.word	0x07031830
    }
    else if (PeriphClkInit->Uart7ClockSelection == RCC_UART7CLKSOURCE_CLKP)
3400a850:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a854:	f8d3 2168 	ldr.w	r2, [r3, #360]	@ 0x168
3400a858:	4bc8      	ldr	r3, [pc, #800]	@ (3400ab7c <HAL_RCCEx_PeriphCLKConfig+0x2470>)
3400a85a:	429a      	cmp	r2, r3
3400a85c:	d101      	bne.n	3400a862 <HAL_RCCEx_PeriphCLKConfig+0x2156>
    {
      LL_RCC_CLKP_Enable();
3400a85e:	f7fd ff47 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART7 clock */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
3400a862:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a866:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
3400a86a:	4618      	mov	r0, r3
3400a86c:	f7fd fdf9 	bl	34008462 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART8 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
3400a870:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a874:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a878:	2100      	movs	r1, #0
3400a87a:	63b9      	str	r1, [r7, #56]	@ 0x38
3400a87c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
3400a880:	63fb      	str	r3, [r7, #60]	@ 0x3c
3400a882:	e9d7 010e 	ldrd	r0, r1, [r7, #56]	@ 0x38
3400a886:	4603      	mov	r3, r0
3400a888:	460a      	mov	r2, r1
3400a88a:	4313      	orrs	r3, r2
3400a88c:	d04b      	beq.n	3400a926 <HAL_RCCEx_PeriphCLKConfig+0x221a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC9)
3400a88e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a892:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3400a896:	4bba      	ldr	r3, [pc, #744]	@ (3400ab80 <HAL_RCCEx_PeriphCLKConfig+0x2474>)
3400a898:	429a      	cmp	r2, r3
3400a89a:	d116      	bne.n	3400a8ca <HAL_RCCEx_PeriphCLKConfig+0x21be>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400a89c:	4bb9      	ldr	r3, [pc, #740]	@ (3400ab84 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400a89e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400a8a2:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a8a6:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a8aa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a8ae:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400a8b0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a8b4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400a8b6:	3b01      	subs	r3, #1
3400a8b8:	041b      	lsls	r3, r3, #16
3400a8ba:	4313      	orrs	r3, r2
3400a8bc:	4ab1      	ldr	r2, [pc, #708]	@ (3400ab84 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400a8be:	430b      	orrs	r3, r1
3400a8c0:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400a8c4:	f7fd fe7a 	bl	340085bc <LL_RCC_IC9_Enable>
3400a8c8:	e026      	b.n	3400a918 <HAL_RCCEx_PeriphCLKConfig+0x220c>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_IC14)
3400a8ca:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a8ce:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3400a8d2:	4bad      	ldr	r3, [pc, #692]	@ (3400ab88 <HAL_RCCEx_PeriphCLKConfig+0x247c>)
3400a8d4:	429a      	cmp	r2, r3
3400a8d6:	d116      	bne.n	3400a906 <HAL_RCCEx_PeriphCLKConfig+0x21fa>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400a8d8:	4baa      	ldr	r3, [pc, #680]	@ (3400ab84 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400a8da:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400a8de:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a8e2:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a8e6:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a8ea:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400a8ec:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a8f0:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400a8f2:	3b01      	subs	r3, #1
3400a8f4:	041b      	lsls	r3, r3, #16
3400a8f6:	4313      	orrs	r3, r2
3400a8f8:	4aa2      	ldr	r2, [pc, #648]	@ (3400ab84 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400a8fa:	430b      	orrs	r3, r1
3400a8fc:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400a900:	f7fd fe94 	bl	3400862c <LL_RCC_IC14_Enable>
3400a904:	e008      	b.n	3400a918 <HAL_RCCEx_PeriphCLKConfig+0x220c>
    }
    else if (PeriphClkInit->Uart8ClockSelection == RCC_UART8CLKSOURCE_CLKP)
3400a906:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a90a:	f8d3 216c 	ldr.w	r2, [r3, #364]	@ 0x16c
3400a90e:	4b9f      	ldr	r3, [pc, #636]	@ (3400ab8c <HAL_RCCEx_PeriphCLKConfig+0x2480>)
3400a910:	429a      	cmp	r2, r3
3400a912:	d101      	bne.n	3400a918 <HAL_RCCEx_PeriphCLKConfig+0x220c>
    {
      LL_RCC_CLKP_Enable();
3400a914:	f7fd feec 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART8 clock */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
3400a918:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a91c:	f8d3 316c 	ldr.w	r3, [r3, #364]	@ 0x16c
3400a920:	4618      	mov	r0, r3
3400a922:	f7fd fd9e 	bl	34008462 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- UART9 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_UART9) == RCC_PERIPHCLK_UART9)
3400a926:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a92a:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a92e:	2100      	movs	r1, #0
3400a930:	6339      	str	r1, [r7, #48]	@ 0x30
3400a932:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
3400a936:	637b      	str	r3, [r7, #52]	@ 0x34
3400a938:	e9d7 010c 	ldrd	r0, r1, [r7, #48]	@ 0x30
3400a93c:	4603      	mov	r3, r0
3400a93e:	460a      	mov	r2, r1
3400a940:	4313      	orrs	r3, r2
3400a942:	d04b      	beq.n	3400a9dc <HAL_RCCEx_PeriphCLKConfig+0x22d0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART9CLKSOURCE(PeriphClkInit->Uart9ClockSelection));

    if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC9)
3400a944:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a948:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3400a94c:	4a90      	ldr	r2, [pc, #576]	@ (3400ab90 <HAL_RCCEx_PeriphCLKConfig+0x2484>)
3400a94e:	4293      	cmp	r3, r2
3400a950:	d116      	bne.n	3400a980 <HAL_RCCEx_PeriphCLKConfig+0x2274>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400a952:	4b8c      	ldr	r3, [pc, #560]	@ (3400ab84 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400a954:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400a958:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a95c:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a960:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a964:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
3400a966:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a96a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
3400a96c:	3b01      	subs	r3, #1
3400a96e:	041b      	lsls	r3, r3, #16
3400a970:	4313      	orrs	r3, r2
3400a972:	4a84      	ldr	r2, [pc, #528]	@ (3400ab84 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400a974:	430b      	orrs	r3, r1
3400a976:	f8c2 30e4 	str.w	r3, [r2, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400a97a:	f7fd fe1f 	bl	340085bc <LL_RCC_IC9_Enable>
3400a97e:	e026      	b.n	3400a9ce <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_IC14)
3400a980:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a984:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3400a988:	4a82      	ldr	r2, [pc, #520]	@ (3400ab94 <HAL_RCCEx_PeriphCLKConfig+0x2488>)
3400a98a:	4293      	cmp	r3, r2
3400a98c:	d116      	bne.n	3400a9bc <HAL_RCCEx_PeriphCLKConfig+0x22b0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400a98e:	4b7d      	ldr	r3, [pc, #500]	@ (3400ab84 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400a990:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400a994:	f023 5143 	bic.w	r1, r3, #817889280	@ 0x30c00000
3400a998:	f421 117c 	bic.w	r1, r1, #4128768	@ 0x3f0000
3400a99c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a9a0:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
3400a9a2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a9a6:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
3400a9a8:	3b01      	subs	r3, #1
3400a9aa:	041b      	lsls	r3, r3, #16
3400a9ac:	4313      	orrs	r3, r2
3400a9ae:	4a75      	ldr	r2, [pc, #468]	@ (3400ab84 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400a9b0:	430b      	orrs	r3, r1
3400a9b2:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400a9b6:	f7fd fe39 	bl	3400862c <LL_RCC_IC14_Enable>
3400a9ba:	e008      	b.n	3400a9ce <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    }
    else if (PeriphClkInit->Uart9ClockSelection == RCC_UART9CLKSOURCE_CLKP)
3400a9bc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a9c0:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3400a9c4:	4a74      	ldr	r2, [pc, #464]	@ (3400ab98 <HAL_RCCEx_PeriphCLKConfig+0x248c>)
3400a9c6:	4293      	cmp	r3, r2
3400a9c8:	d101      	bne.n	3400a9ce <HAL_RCCEx_PeriphCLKConfig+0x22c2>
    {
      LL_RCC_CLKP_Enable();
3400a9ca:	f7fd fe91 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of UART9 clock */
    __HAL_RCC_UART9_CONFIG(PeriphClkInit->Uart9ClockSelection);
3400a9ce:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a9d2:	f8d3 3170 	ldr.w	r3, [r3, #368]	@ 0x170
3400a9d6:	4618      	mov	r0, r3
3400a9d8:	f7fd fd43 	bl	34008462 <LL_RCC_SetUSARTClockSource>
  }

  /*-------------------------- USART10 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART10) == RCC_PERIPHCLK_USART10)
3400a9dc:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a9e0:	e9d3 2300 	ldrd	r2, r3, [r3]
3400a9e4:	2100      	movs	r1, #0
3400a9e6:	62b9      	str	r1, [r7, #40]	@ 0x28
3400a9e8:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
3400a9ec:	62fb      	str	r3, [r7, #44]	@ 0x2c
3400a9ee:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
3400a9f2:	4603      	mov	r3, r0
3400a9f4:	460a      	mov	r2, r1
3400a9f6:	4313      	orrs	r3, r2
3400a9f8:	d04b      	beq.n	3400aa92 <HAL_RCCEx_PeriphCLKConfig+0x2386>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART10CLKSOURCE(PeriphClkInit->Usart10ClockSelection));

    if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC9)
3400a9fa:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400a9fe:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
3400aa02:	4a66      	ldr	r2, [pc, #408]	@ (3400ab9c <HAL_RCCEx_PeriphCLKConfig+0x2490>)
3400aa04:	4293      	cmp	r3, r2
3400aa06:	d116      	bne.n	3400aa36 <HAL_RCCEx_PeriphCLKConfig+0x232a>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC9].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC9].ClockDivider));

      /* Set IC9 configuration */
      MODIFY_REG(RCC->IC9CFGR, RCC_IC9CFGR_IC9SEL | RCC_IC9CFGR_IC9INT,
3400aa08:	4b5e      	ldr	r3, [pc, #376]	@ (3400ab84 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400aa0a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
3400aa0e:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400aa12:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400aa16:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
3400aa1a:	6c91      	ldr	r1, [r2, #72]	@ 0x48
3400aa1c:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
3400aa20:	6cd2      	ldr	r2, [r2, #76]	@ 0x4c
3400aa22:	3a01      	subs	r2, #1
3400aa24:	0412      	lsls	r2, r2, #16
3400aa26:	430a      	orrs	r2, r1
3400aa28:	4956      	ldr	r1, [pc, #344]	@ (3400ab84 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400aa2a:	4313      	orrs	r3, r2
3400aa2c:	f8c1 30e4 	str.w	r3, [r1, #228]	@ 0xe4
                 PeriphClkInit->ICSelection[RCC_IC9].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC9].ClockDivider - 1U) << RCC_IC9CFGR_IC9INT_Pos));

      LL_RCC_IC9_Enable();
3400aa30:	f7fd fdc4 	bl	340085bc <LL_RCC_IC9_Enable>
3400aa34:	e026      	b.n	3400aa84 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_IC14)
3400aa36:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400aa3a:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
3400aa3e:	4a58      	ldr	r2, [pc, #352]	@ (3400aba0 <HAL_RCCEx_PeriphCLKConfig+0x2494>)
3400aa40:	4293      	cmp	r3, r2
3400aa42:	d116      	bne.n	3400aa72 <HAL_RCCEx_PeriphCLKConfig+0x2366>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC14].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC14].ClockDivider));

      /* Set IC14 configuration */
      MODIFY_REG(RCC->IC14CFGR, RCC_IC14CFGR_IC14SEL | RCC_IC14CFGR_IC14INT,
3400aa44:	4b4f      	ldr	r3, [pc, #316]	@ (3400ab84 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400aa46:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
3400aa4a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400aa4e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400aa52:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
3400aa56:	6f11      	ldr	r1, [r2, #112]	@ 0x70
3400aa58:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
3400aa5c:	6f52      	ldr	r2, [r2, #116]	@ 0x74
3400aa5e:	3a01      	subs	r2, #1
3400aa60:	0412      	lsls	r2, r2, #16
3400aa62:	430a      	orrs	r2, r1
3400aa64:	4947      	ldr	r1, [pc, #284]	@ (3400ab84 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400aa66:	4313      	orrs	r3, r2
3400aa68:	f8c1 30f8 	str.w	r3, [r1, #248]	@ 0xf8
                 PeriphClkInit->ICSelection[RCC_IC14].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC14].ClockDivider - 1U) << RCC_IC14CFGR_IC14INT_Pos));

      LL_RCC_IC14_Enable();
3400aa6c:	f7fd fdde 	bl	3400862c <LL_RCC_IC14_Enable>
3400aa70:	e008      	b.n	3400aa84 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    }
    else if (PeriphClkInit->Usart10ClockSelection == RCC_USART10CLKSOURCE_CLKP)
3400aa72:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400aa76:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
3400aa7a:	4a4a      	ldr	r2, [pc, #296]	@ (3400aba4 <HAL_RCCEx_PeriphCLKConfig+0x2498>)
3400aa7c:	4293      	cmp	r3, r2
3400aa7e:	d101      	bne.n	3400aa84 <HAL_RCCEx_PeriphCLKConfig+0x2378>
    {
      LL_RCC_CLKP_Enable();
3400aa80:	f7fd fe36 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USART10 clock */
    __HAL_RCC_USART10_CONFIG(PeriphClkInit->Usart10ClockSelection);
3400aa84:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400aa88:	f8d3 3174 	ldr.w	r3, [r3, #372]	@ 0x174
3400aa8c:	4618      	mov	r0, r3
3400aa8e:	f7fd fce8 	bl	34008462 <LL_RCC_SetUSARTClockSource>
  }

  /*------------------------------ USBPHY1 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY1) == RCC_PERIPHCLK_USBPHY1)
3400aa92:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400aa96:	e9d3 2300 	ldrd	r2, r3, [r3]
3400aa9a:	2100      	movs	r1, #0
3400aa9c:	6239      	str	r1, [r7, #32]
3400aa9e:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
3400aaa2:	627b      	str	r3, [r7, #36]	@ 0x24
3400aaa4:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
3400aaa8:	4603      	mov	r3, r0
3400aaaa:	460a      	mov	r2, r1
3400aaac:	4313      	orrs	r3, r2
3400aaae:	d014      	beq.n	3400aada <HAL_RCCEx_PeriphCLKConfig+0x23ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY1CLKSOURCE(PeriphClkInit->UsbPhy1ClockSelection));

    /* Set the source of USBPHY1 clock*/
    __HAL_RCC_USBPHY1_CONFIG(PeriphClkInit->UsbPhy1ClockSelection);
3400aab0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400aab4:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3400aab8:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3400aabc:	4618      	mov	r0, r3
3400aabe:	f7fd fc78 	bl	340083b2 <LL_RCC_SetOTGPHYCKREFClockSource>
3400aac2:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400aac6:	f8d3 3178 	ldr.w	r3, [r3, #376]	@ 0x178
3400aaca:	0fdb      	lsrs	r3, r3, #31
3400aacc:	2b01      	cmp	r3, #1
3400aace:	d102      	bne.n	3400aad6 <HAL_RCCEx_PeriphCLKConfig+0x23ca>
3400aad0:	f7fd faee 	bl	340080b0 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
3400aad4:	e001      	b.n	3400aada <HAL_RCCEx_PeriphCLKConfig+0x23ce>
3400aad6:	f7fd fadb 	bl	34008090 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBPHY2 Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHY2) == RCC_PERIPHCLK_USBPHY2)
3400aada:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400aade:	e9d3 2300 	ldrd	r2, r3, [r3]
3400aae2:	2100      	movs	r1, #0
3400aae4:	61b9      	str	r1, [r7, #24]
3400aae6:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
3400aaea:	61fb      	str	r3, [r7, #28]
3400aaec:	e9d7 0106 	ldrd	r0, r1, [r7, #24]
3400aaf0:	4603      	mov	r3, r0
3400aaf2:	460a      	mov	r2, r1
3400aaf4:	4313      	orrs	r3, r2
3400aaf6:	d014      	beq.n	3400ab22 <HAL_RCCEx_PeriphCLKConfig+0x2416>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHY2CLKSOURCE(PeriphClkInit->UsbPhy2ClockSelection));

    /* Set the source of USBPHY2 clock*/
    __HAL_RCC_USBPHY2_CONFIG(PeriphClkInit->UsbPhy2ClockSelection);
3400aaf8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400aafc:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
3400ab00:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3400ab04:	4618      	mov	r0, r3
3400ab06:	f7fd fc54 	bl	340083b2 <LL_RCC_SetOTGPHYCKREFClockSource>
3400ab0a:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400ab0e:	f8d3 3180 	ldr.w	r3, [r3, #384]	@ 0x180
3400ab12:	0fdb      	lsrs	r3, r3, #31
3400ab14:	2b01      	cmp	r3, #1
3400ab16:	d102      	bne.n	3400ab1e <HAL_RCCEx_PeriphCLKConfig+0x2412>
3400ab18:	f7fd faca 	bl	340080b0 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
3400ab1c:	e001      	b.n	3400ab22 <HAL_RCCEx_PeriphCLKConfig+0x2416>
3400ab1e:	f7fd fab7 	bl	34008090 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS1 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS1) == RCC_PERIPHCLK_USBOTGHS1)
3400ab22:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400ab26:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ab2a:	2100      	movs	r1, #0
3400ab2c:	6139      	str	r1, [r7, #16]
3400ab2e:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
3400ab32:	617b      	str	r3, [r7, #20]
3400ab34:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
3400ab38:	4603      	mov	r3, r0
3400ab3a:	460a      	mov	r2, r1
3400ab3c:	4313      	orrs	r3, r2
3400ab3e:	d053      	beq.n	3400abe8 <HAL_RCCEx_PeriphCLKConfig+0x24dc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS1CLKSOURCE(PeriphClkInit->UsbOtgHs1ClockSelection));

    if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_IC15)
3400ab40:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400ab44:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
3400ab48:	4a17      	ldr	r2, [pc, #92]	@ (3400aba8 <HAL_RCCEx_PeriphCLKConfig+0x249c>)
3400ab4a:	4293      	cmp	r3, r2
3400ab4c:	d12e      	bne.n	3400abac <HAL_RCCEx_PeriphCLKConfig+0x24a0>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400ab4e:	4b0d      	ldr	r3, [pc, #52]	@ (3400ab84 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400ab50:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400ab54:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ab58:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ab5c:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
3400ab60:	6f91      	ldr	r1, [r2, #120]	@ 0x78
3400ab62:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
3400ab66:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
3400ab68:	3a01      	subs	r2, #1
3400ab6a:	0412      	lsls	r2, r2, #16
3400ab6c:	430a      	orrs	r2, r1
3400ab6e:	4905      	ldr	r1, [pc, #20]	@ (3400ab84 <HAL_RCCEx_PeriphCLKConfig+0x2478>)
3400ab70:	4313      	orrs	r3, r2
3400ab72:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400ab76:	f7fd fd67 	bl	34008648 <LL_RCC_IC15_Enable>
3400ab7a:	e020      	b.n	3400abbe <HAL_RCCEx_PeriphCLKConfig+0x24b2>
3400ab7c:	07011830 	.word	0x07011830
3400ab80:	07021c30 	.word	0x07021c30
3400ab84:	56028000 	.word	0x56028000
3400ab88:	07031c30 	.word	0x07031c30
3400ab8c:	07011c30 	.word	0x07011c30
3400ab90:	07020034 	.word	0x07020034
3400ab94:	07030034 	.word	0x07030034
3400ab98:	07010034 	.word	0x07010034
3400ab9c:	07020434 	.word	0x07020434
3400aba0:	07030434 	.word	0x07030434
3400aba4:	07010434 	.word	0x07010434
3400aba8:	03020c14 	.word	0x03020c14
    }
    else if (PeriphClkInit->UsbOtgHs1ClockSelection == RCC_USBOTGHS1CLKSOURCE_CLKP)
3400abac:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400abb0:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
3400abb4:	4a43      	ldr	r2, [pc, #268]	@ (3400acc4 <HAL_RCCEx_PeriphCLKConfig+0x25b8>)
3400abb6:	4293      	cmp	r3, r2
3400abb8:	d101      	bne.n	3400abbe <HAL_RCCEx_PeriphCLKConfig+0x24b2>
    {
      LL_RCC_CLKP_Enable();
3400abba:	f7fd fd99 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS1 clock */
    __HAL_RCC_USBOTGHS1_CONFIG(PeriphClkInit->UsbOtgHs1ClockSelection);
3400abbe:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400abc2:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
3400abc6:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3400abca:	4618      	mov	r0, r3
3400abcc:	f7fd fbe6 	bl	3400839c <LL_RCC_SetOTGPHYClockSource>
3400abd0:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400abd4:	f8d3 317c 	ldr.w	r3, [r3, #380]	@ 0x17c
3400abd8:	0fdb      	lsrs	r3, r3, #31
3400abda:	2b01      	cmp	r3, #1
3400abdc:	d102      	bne.n	3400abe4 <HAL_RCCEx_PeriphCLKConfig+0x24d8>
3400abde:	f7fd fa67 	bl	340080b0 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
3400abe2:	e001      	b.n	3400abe8 <HAL_RCCEx_PeriphCLKConfig+0x24dc>
3400abe4:	f7fd fa54 	bl	34008090 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------ USBOTGHS2 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGHS2) == RCC_PERIPHCLK_USBOTGHS2)
3400abe8:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400abec:	e9d3 2300 	ldrd	r2, r3, [r3]
3400abf0:	2100      	movs	r1, #0
3400abf2:	60b9      	str	r1, [r7, #8]
3400abf4:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
3400abf8:	60fb      	str	r3, [r7, #12]
3400abfa:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
3400abfe:	4603      	mov	r3, r0
3400ac00:	460a      	mov	r2, r1
3400ac02:	4313      	orrs	r3, r2
3400ac04:	d03b      	beq.n	3400ac7e <HAL_RCCEx_PeriphCLKConfig+0x2572>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGHS2CLKSOURCE(PeriphClkInit->UsbOtgHs2ClockSelection));

    if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_IC15)
3400ac06:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400ac0a:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
3400ac0e:	4a2e      	ldr	r2, [pc, #184]	@ (3400acc8 <HAL_RCCEx_PeriphCLKConfig+0x25bc>)
3400ac10:	4293      	cmp	r3, r2
3400ac12:	d116      	bne.n	3400ac42 <HAL_RCCEx_PeriphCLKConfig+0x2536>
      /* Check the parameters */
      assert_param(IS_RCC_ICCLKSOURCE(PeriphClkInit->ICSelection[RCC_IC15].ClockSelection));
      assert_param(IS_RCC_ICCLKDIVIDER(PeriphClkInit->ICSelection[RCC_IC15].ClockDivider));

      /* Set IC15 configuration */
      MODIFY_REG(RCC->IC15CFGR, RCC_IC15CFGR_IC15SEL | RCC_IC15CFGR_IC15INT,
3400ac14:	4b2d      	ldr	r3, [pc, #180]	@ (3400accc <HAL_RCCEx_PeriphCLKConfig+0x25c0>)
3400ac16:	f8d3 30fc 	ldr.w	r3, [r3, #252]	@ 0xfc
3400ac1a:	f023 5343 	bic.w	r3, r3, #817889280	@ 0x30c00000
3400ac1e:	f423 137c 	bic.w	r3, r3, #4128768	@ 0x3f0000
3400ac22:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
3400ac26:	6f91      	ldr	r1, [r2, #120]	@ 0x78
3400ac28:	f8d7 21b4 	ldr.w	r2, [r7, #436]	@ 0x1b4
3400ac2c:	6fd2      	ldr	r2, [r2, #124]	@ 0x7c
3400ac2e:	3a01      	subs	r2, #1
3400ac30:	0412      	lsls	r2, r2, #16
3400ac32:	430a      	orrs	r2, r1
3400ac34:	4925      	ldr	r1, [pc, #148]	@ (3400accc <HAL_RCCEx_PeriphCLKConfig+0x25c0>)
3400ac36:	4313      	orrs	r3, r2
3400ac38:	f8c1 30fc 	str.w	r3, [r1, #252]	@ 0xfc
                 PeriphClkInit->ICSelection[RCC_IC15].ClockSelection | \
                 ((PeriphClkInit->ICSelection[RCC_IC15].ClockDivider - 1U) << RCC_IC15CFGR_IC15INT_Pos));

      LL_RCC_IC15_Enable();
3400ac3c:	f7fd fd04 	bl	34008648 <LL_RCC_IC15_Enable>
3400ac40:	e008      	b.n	3400ac54 <HAL_RCCEx_PeriphCLKConfig+0x2548>
    }
    else if (PeriphClkInit->UsbOtgHs2ClockSelection == RCC_USBOTGHS2CLKSOURCE_CLKP)
3400ac42:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400ac46:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
3400ac4a:	4a21      	ldr	r2, [pc, #132]	@ (3400acd0 <HAL_RCCEx_PeriphCLKConfig+0x25c4>)
3400ac4c:	4293      	cmp	r3, r2
3400ac4e:	d101      	bne.n	3400ac54 <HAL_RCCEx_PeriphCLKConfig+0x2548>
    {
      LL_RCC_CLKP_Enable();
3400ac50:	f7fd fd4e 	bl	340086f0 <LL_RCC_CLKP_Enable>
    {
      /* No specific enable to do on other sources */
    }

    /* Set the source of USBOTGHS2 clock */
    __HAL_RCC_USBOTGHS2_CONFIG(PeriphClkInit->UsbOtgHs2ClockSelection);
3400ac54:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400ac58:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
3400ac5c:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
3400ac60:	4618      	mov	r0, r3
3400ac62:	f7fd fb9b 	bl	3400839c <LL_RCC_SetOTGPHYClockSource>
3400ac66:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400ac6a:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
3400ac6e:	0fdb      	lsrs	r3, r3, #31
3400ac70:	2b01      	cmp	r3, #1
3400ac72:	d102      	bne.n	3400ac7a <HAL_RCCEx_PeriphCLKConfig+0x256e>
3400ac74:	f7fd fa1c 	bl	340080b0 <LL_RCC_HSE_SelectHSEDiv2AsDiv2Clock>
3400ac78:	e001      	b.n	3400ac7e <HAL_RCCEx_PeriphCLKConfig+0x2572>
3400ac7a:	f7fd fa09 	bl	34008090 <LL_RCC_HSE_SelectHSEAsDiv2Clock>
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
3400ac7e:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400ac82:	e9d3 2300 	ldrd	r2, r3, [r3]
3400ac86:	2100      	movs	r1, #0
3400ac88:	6039      	str	r1, [r7, #0]
3400ac8a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3400ac8e:	607b      	str	r3, [r7, #4]
3400ac90:	e9d7 0100 	ldrd	r0, r1, [r7]
3400ac94:	4603      	mov	r3, r0
3400ac96:	460a      	mov	r2, r1
3400ac98:	4313      	orrs	r3, r2
3400ac9a:	d006      	beq.n	3400acaa <HAL_RCCEx_PeriphCLKConfig+0x259e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER_CONFIG(PeriphClkInit->TIMPresSelection);
3400ac9c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	@ 0x1b4
3400aca0:	f8d3 318c 	ldr.w	r3, [r3, #396]	@ 0x18c
3400aca4:	4618      	mov	r0, r3
3400aca6:	f7fd fc2d 	bl	34008504 <LL_RCC_SetTIMPrescaler>
  }

  if (status == HAL_OK)
3400acaa:	f897 31c6 	ldrb.w	r3, [r7, #454]	@ 0x1c6
3400acae:	2b00      	cmp	r3, #0
3400acb0:	d101      	bne.n	3400acb6 <HAL_RCCEx_PeriphCLKConfig+0x25aa>
  {
    return HAL_OK;
3400acb2:	2300      	movs	r3, #0
3400acb4:	e000      	b.n	3400acb8 <HAL_RCCEx_PeriphCLKConfig+0x25ac>
  }
  return HAL_ERROR;
3400acb6:	2301      	movs	r3, #1
}
3400acb8:	4618      	mov	r0, r3
3400acba:	f507 77e4 	add.w	r7, r7, #456	@ 0x1c8
3400acbe:	46bd      	mov	sp, r7
3400acc0:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
3400acc4:	03010c14 	.word	0x03010c14
3400acc8:	03021414 	.word	0x03021414
3400accc:	56028000 	.word	0x56028000
3400acd0:	03011414 	.word	0x03011414

3400acd4 <msdi_openfn>:

/*
 * Open function
 */
LOCAL ER msdi_openfn( ID devid, UINT omode, T_MSDI *msdi )
{
3400acd4:	b580      	push	{r7, lr}
3400acd6:	b086      	sub	sp, #24
3400acd8:	af00      	add	r7, sp, #0
3400acda:	60f8      	str	r0, [r7, #12]
3400acdc:	60b9      	str	r1, [r7, #8]
3400acde:	607a      	str	r2, [r7, #4]
	ER	err;

	if ( msdi->dmsdi.openfn == NULL ) return E_OK;
3400ace0:	687b      	ldr	r3, [r7, #4]
3400ace2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3400ace4:	2b00      	cmp	r3, #0
3400ace6:	d101      	bne.n	3400acec <msdi_openfn+0x18>
3400ace8:	2300      	movs	r3, #0
3400acea:	e011      	b.n	3400ad10 <msdi_openfn+0x3c>

	Lock(&msdi->lock);
3400acec:	687b      	ldr	r3, [r7, #4]
3400acee:	3304      	adds	r3, #4
3400acf0:	4618      	mov	r0, r3
3400acf2:	f003 fa85 	bl	3400e200 <Lock>
	err = (*msdi->dmsdi.openfn)(devid, omode, msdi);
3400acf6:	687b      	ldr	r3, [r7, #4]
3400acf8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3400acfa:	687a      	ldr	r2, [r7, #4]
3400acfc:	68b9      	ldr	r1, [r7, #8]
3400acfe:	68f8      	ldr	r0, [r7, #12]
3400ad00:	4798      	blx	r3
3400ad02:	6178      	str	r0, [r7, #20]
	Unlock(&msdi->lock);
3400ad04:	687b      	ldr	r3, [r7, #4]
3400ad06:	3304      	adds	r3, #4
3400ad08:	4618      	mov	r0, r3
3400ad0a:	f003 fa8f 	bl	3400e22c <Unlock>

	return err;
3400ad0e:	697b      	ldr	r3, [r7, #20]
}
3400ad10:	4618      	mov	r0, r3
3400ad12:	3718      	adds	r7, #24
3400ad14:	46bd      	mov	sp, r7
3400ad16:	bd80      	pop	{r7, pc}

3400ad18 <msdi_closefn>:

/*
 * Close cunction
 */
LOCAL ER msdi_closefn( ID devid, UINT option, T_MSDI *msdi )
{
3400ad18:	b580      	push	{r7, lr}
3400ad1a:	b086      	sub	sp, #24
3400ad1c:	af00      	add	r7, sp, #0
3400ad1e:	60f8      	str	r0, [r7, #12]
3400ad20:	60b9      	str	r1, [r7, #8]
3400ad22:	607a      	str	r2, [r7, #4]
	ER	err;

	if ( msdi->dmsdi.closefn == NULL ) return E_OK;
3400ad24:	687b      	ldr	r3, [r7, #4]
3400ad26:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400ad28:	2b00      	cmp	r3, #0
3400ad2a:	d101      	bne.n	3400ad30 <msdi_closefn+0x18>
3400ad2c:	2300      	movs	r3, #0
3400ad2e:	e011      	b.n	3400ad54 <msdi_closefn+0x3c>

	Lock(&msdi->lock);
3400ad30:	687b      	ldr	r3, [r7, #4]
3400ad32:	3304      	adds	r3, #4
3400ad34:	4618      	mov	r0, r3
3400ad36:	f003 fa63 	bl	3400e200 <Lock>
	err = (*msdi->dmsdi.closefn)(devid, option, msdi);
3400ad3a:	687b      	ldr	r3, [r7, #4]
3400ad3c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400ad3e:	687a      	ldr	r2, [r7, #4]
3400ad40:	68b9      	ldr	r1, [r7, #8]
3400ad42:	68f8      	ldr	r0, [r7, #12]
3400ad44:	4798      	blx	r3
3400ad46:	6178      	str	r0, [r7, #20]
	Unlock(&msdi->lock);
3400ad48:	687b      	ldr	r3, [r7, #4]
3400ad4a:	3304      	adds	r3, #4
3400ad4c:	4618      	mov	r0, r3
3400ad4e:	f003 fa6d 	bl	3400e22c <Unlock>

	return err;
3400ad52:	697b      	ldr	r3, [r7, #20]
}
3400ad54:	4618      	mov	r0, r3
3400ad56:	3718      	adds	r7, #24
3400ad58:	46bd      	mov	sp, r7
3400ad5a:	bd80      	pop	{r7, pc}

3400ad5c <msdi_execfn>:

/*
 * Processing start function
 */
LOCAL ER msdi_execfn( T_DEVREQ *req, TMO tmout, T_MSDI *msdi )
{
3400ad5c:	b580      	push	{r7, lr}
3400ad5e:	b086      	sub	sp, #24
3400ad60:	af00      	add	r7, sp, #0
3400ad62:	60f8      	str	r0, [r7, #12]
3400ad64:	60b9      	str	r1, [r7, #8]
3400ad66:	607a      	str	r2, [r7, #4]
	INT	(*fp)( T_DEVREQ*, T_MSDI* );
	ER	err;

	fp = ( req->cmd == TDC_READ )? msdi->dmsdi.readfn: msdi->dmsdi.writefn;
3400ad68:	68fb      	ldr	r3, [r7, #12]
3400ad6a:	7b1b      	ldrb	r3, [r3, #12]
3400ad6c:	f003 030f 	and.w	r3, r3, #15
3400ad70:	b2db      	uxtb	r3, r3
3400ad72:	2b01      	cmp	r3, #1
3400ad74:	d102      	bne.n	3400ad7c <msdi_execfn+0x20>
3400ad76:	687b      	ldr	r3, [r7, #4]
3400ad78:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400ad7a:	e001      	b.n	3400ad80 <msdi_execfn+0x24>
3400ad7c:	687b      	ldr	r3, [r7, #4]
3400ad7e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400ad80:	617b      	str	r3, [r7, #20]
	if ( fp == NULL ) return E_NOSPT;
3400ad82:	697b      	ldr	r3, [r7, #20]
3400ad84:	2b00      	cmp	r3, #0
3400ad86:	d102      	bne.n	3400ad8e <msdi_execfn+0x32>
3400ad88:	f06f 0308 	mvn.w	r3, #8
3400ad8c:	e01d      	b.n	3400adca <msdi_execfn+0x6e>

	if ( req->start >= 0 && msdi->dmsdi.blksz <= 0) return E_NOSPT;
3400ad8e:	68fb      	ldr	r3, [r7, #12]
3400ad90:	691b      	ldr	r3, [r3, #16]
3400ad92:	2b00      	cmp	r3, #0
3400ad94:	db06      	blt.n	3400ada4 <msdi_execfn+0x48>
3400ad96:	687b      	ldr	r3, [r7, #4]
3400ad98:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400ad9a:	2b00      	cmp	r3, #0
3400ad9c:	dc02      	bgt.n	3400ada4 <msdi_execfn+0x48>
3400ad9e:	f06f 0308 	mvn.w	r3, #8
3400ada2:	e012      	b.n	3400adca <msdi_execfn+0x6e>

	/* I/O processing */
	Lock(&msdi->lock);
3400ada4:	687b      	ldr	r3, [r7, #4]
3400ada6:	3304      	adds	r3, #4
3400ada8:	4618      	mov	r0, r3
3400adaa:	f003 fa29 	bl	3400e200 <Lock>
	err = (*fp)(req, msdi);
3400adae:	697b      	ldr	r3, [r7, #20]
3400adb0:	6879      	ldr	r1, [r7, #4]
3400adb2:	68f8      	ldr	r0, [r7, #12]
3400adb4:	4798      	blx	r3
3400adb6:	6138      	str	r0, [r7, #16]
	Unlock(&msdi->lock);
3400adb8:	687b      	ldr	r3, [r7, #4]
3400adba:	3304      	adds	r3, #4
3400adbc:	4618      	mov	r0, r3
3400adbe:	f003 fa35 	bl	3400e22c <Unlock>

	req->error = err;
3400adc2:	68fb      	ldr	r3, [r7, #12]
3400adc4:	693a      	ldr	r2, [r7, #16]
3400adc6:	621a      	str	r2, [r3, #32]
	return E_OK;
3400adc8:	2300      	movs	r3, #0
}
3400adca:	4618      	mov	r0, r3
3400adcc:	3718      	adds	r7, #24
3400adce:	46bd      	mov	sp, r7
3400add0:	bd80      	pop	{r7, pc}

3400add2 <msdi_waitfn>:

/*
 * Wait-for-completion function
 */
LOCAL INT msdi_waitfn( T_DEVREQ *req, INT nreq, TMO tmout, T_MSDI *msdi )
{
3400add2:	b480      	push	{r7}
3400add4:	b085      	sub	sp, #20
3400add6:	af00      	add	r7, sp, #0
3400add8:	60f8      	str	r0, [r7, #12]
3400adda:	60b9      	str	r1, [r7, #8]
3400addc:	607a      	str	r2, [r7, #4]
3400adde:	603b      	str	r3, [r7, #0]
	return 0;
3400ade0:	2300      	movs	r3, #0
}
3400ade2:	4618      	mov	r0, r3
3400ade4:	3714      	adds	r7, #20
3400ade6:	46bd      	mov	sp, r7
3400ade8:	f85d 7b04 	ldr.w	r7, [sp], #4
3400adec:	4770      	bx	lr

3400adee <msdi_abortfn>:

/*
 * Abort processing function
 */
LOCAL ER msdi_abortfn( ID tskid, T_DEVREQ *req, INT nreq, T_MSDI *msdi )
{
3400adee:	b480      	push	{r7}
3400adf0:	b085      	sub	sp, #20
3400adf2:	af00      	add	r7, sp, #0
3400adf4:	60f8      	str	r0, [r7, #12]
3400adf6:	60b9      	str	r1, [r7, #8]
3400adf8:	607a      	str	r2, [r7, #4]
3400adfa:	603b      	str	r3, [r7, #0]
	return E_OK;
3400adfc:	2300      	movs	r3, #0
}
3400adfe:	4618      	mov	r0, r3
3400ae00:	3714      	adds	r7, #20
3400ae02:	46bd      	mov	sp, r7
3400ae04:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ae08:	4770      	bx	lr

3400ae0a <msdi_eventfn>:

/*
 * Event function
 */
LOCAL INT msdi_eventfn( INT evttyp, void *evtinf, T_MSDI *msdi )
{
3400ae0a:	b580      	push	{r7, lr}
3400ae0c:	b086      	sub	sp, #24
3400ae0e:	af00      	add	r7, sp, #0
3400ae10:	60f8      	str	r0, [r7, #12]
3400ae12:	60b9      	str	r1, [r7, #8]
3400ae14:	607a      	str	r2, [r7, #4]
	INT	ret;

	if ( msdi->dmsdi.eventfn == NULL ) return E_OK;
3400ae16:	687b      	ldr	r3, [r7, #4]
3400ae18:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400ae1a:	2b00      	cmp	r3, #0
3400ae1c:	d101      	bne.n	3400ae22 <msdi_eventfn+0x18>
3400ae1e:	2300      	movs	r3, #0
3400ae20:	e011      	b.n	3400ae46 <msdi_eventfn+0x3c>

	Lock(&msdi->lock);
3400ae22:	687b      	ldr	r3, [r7, #4]
3400ae24:	3304      	adds	r3, #4
3400ae26:	4618      	mov	r0, r3
3400ae28:	f003 f9ea 	bl	3400e200 <Lock>
	ret = (*msdi->dmsdi.eventfn)(evttyp, evtinf, msdi);
3400ae2c:	687b      	ldr	r3, [r7, #4]
3400ae2e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400ae30:	687a      	ldr	r2, [r7, #4]
3400ae32:	68b9      	ldr	r1, [r7, #8]
3400ae34:	68f8      	ldr	r0, [r7, #12]
3400ae36:	4798      	blx	r3
3400ae38:	6178      	str	r0, [r7, #20]
	Unlock(&msdi->lock);
3400ae3a:	687b      	ldr	r3, [r7, #4]
3400ae3c:	3304      	adds	r3, #4
3400ae3e:	4618      	mov	r0, r3
3400ae40:	f003 f9f4 	bl	3400e22c <Unlock>

	return ret;
3400ae44:	697b      	ldr	r3, [r7, #20]
}
3400ae46:	4618      	mov	r0, r3
3400ae48:	3718      	adds	r7, #24
3400ae4a:	46bd      	mov	sp, r7
3400ae4c:	bd80      	pop	{r7, pc}
	...

3400ae50 <msdi_def_dev>:

/*
 * SDI Device registration
 */
EXPORT ER msdi_def_dev( T_DMSDI *dmsdi, T_IDEV *idev, T_MSDI **p_msdi )
{
3400ae50:	b5b0      	push	{r4, r5, r7, lr}
3400ae52:	b092      	sub	sp, #72	@ 0x48
3400ae54:	af00      	add	r7, sp, #0
3400ae56:	60f8      	str	r0, [r7, #12]
3400ae58:	60b9      	str	r1, [r7, #8]
3400ae5a:	607a      	str	r2, [r7, #4]
	T_MSDI	*msdi;
	T_DDEV	ddev;
	ER	err;

	/* Create "SDI"*/
	msdi = Kmalloc(sizeof(T_MSDI));
3400ae5c:	2044      	movs	r0, #68	@ 0x44
3400ae5e:	f003 fb6f 	bl	3400e540 <Kmalloc>
3400ae62:	6438      	str	r0, [r7, #64]	@ 0x40
	if ( msdi == NULL ) {
3400ae64:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400ae66:	2b00      	cmp	r3, #0
3400ae68:	d103      	bne.n	3400ae72 <msdi_def_dev+0x22>
		err = E_NOMEM;
3400ae6a:	f06f 0320 	mvn.w	r3, #32
3400ae6e:	647b      	str	r3, [r7, #68]	@ 0x44
		goto err_ret1;
3400ae70:	e054      	b.n	3400af1c <msdi_def_dev+0xcc>
	}

	msdi->dmsdi = *dmsdi;		/* Structure Copy */
3400ae72:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400ae74:	68fa      	ldr	r2, [r7, #12]
3400ae76:	f103 0410 	add.w	r4, r3, #16
3400ae7a:	4615      	mov	r5, r2
3400ae7c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3400ae7e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3400ae80:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3400ae82:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3400ae84:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3400ae86:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3400ae88:	682b      	ldr	r3, [r5, #0]
3400ae8a:	6023      	str	r3, [r4, #0]

	/* Create the lock for exclusive access control */
	err = CreateLock(&msdi->lock, dmsdi->devnm);
3400ae8c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400ae8e:	1d1a      	adds	r2, r3, #4
3400ae90:	68fb      	ldr	r3, [r7, #12]
3400ae92:	3304      	adds	r3, #4
3400ae94:	4619      	mov	r1, r3
3400ae96:	4610      	mov	r0, r2
3400ae98:	f003 f9dc 	bl	3400e254 <CreateLock>
3400ae9c:	6478      	str	r0, [r7, #68]	@ 0x44
	if ( err < E_OK ) goto err_ret2;
3400ae9e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3400aea0:	2b00      	cmp	r3, #0
3400aea2:	db37      	blt.n	3400af14 <msdi_def_dev+0xc4>

	/* Device registration */
	ddev.exinf   = msdi;
3400aea4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400aea6:	617b      	str	r3, [r7, #20]
	ddev.drvatr  = dmsdi->drvatr;
3400aea8:	68fb      	ldr	r3, [r7, #12]
3400aeaa:	691b      	ldr	r3, [r3, #16]
3400aeac:	61bb      	str	r3, [r7, #24]
	ddev.devatr  = dmsdi->devatr;
3400aeae:	68fb      	ldr	r3, [r7, #12]
3400aeb0:	695b      	ldr	r3, [r3, #20]
3400aeb2:	61fb      	str	r3, [r7, #28]
	ddev.nsub    = dmsdi->nsub;
3400aeb4:	68fb      	ldr	r3, [r7, #12]
3400aeb6:	699b      	ldr	r3, [r3, #24]
3400aeb8:	623b      	str	r3, [r7, #32]
	ddev.blksz   = dmsdi->blksz;
3400aeba:	68fb      	ldr	r3, [r7, #12]
3400aebc:	69db      	ldr	r3, [r3, #28]
3400aebe:	627b      	str	r3, [r7, #36]	@ 0x24
	ddev.openfn  = (FP)msdi_openfn;
3400aec0:	4b19      	ldr	r3, [pc, #100]	@ (3400af28 <msdi_def_dev+0xd8>)
3400aec2:	62bb      	str	r3, [r7, #40]	@ 0x28
	ddev.closefn = (FP)msdi_closefn;
3400aec4:	4b19      	ldr	r3, [pc, #100]	@ (3400af2c <msdi_def_dev+0xdc>)
3400aec6:	62fb      	str	r3, [r7, #44]	@ 0x2c
	ddev.execfn  = (FP)msdi_execfn;
3400aec8:	4b19      	ldr	r3, [pc, #100]	@ (3400af30 <msdi_def_dev+0xe0>)
3400aeca:	633b      	str	r3, [r7, #48]	@ 0x30
	ddev.waitfn  = (FP)msdi_waitfn;
3400aecc:	4b19      	ldr	r3, [pc, #100]	@ (3400af34 <msdi_def_dev+0xe4>)
3400aece:	637b      	str	r3, [r7, #52]	@ 0x34
	ddev.abortfn = (FP)msdi_abortfn;
3400aed0:	4b19      	ldr	r3, [pc, #100]	@ (3400af38 <msdi_def_dev+0xe8>)
3400aed2:	63bb      	str	r3, [r7, #56]	@ 0x38
	ddev.eventfn = (FP)msdi_eventfn;
3400aed4:	4b19      	ldr	r3, [pc, #100]	@ (3400af3c <msdi_def_dev+0xec>)
3400aed6:	63fb      	str	r3, [r7, #60]	@ 0x3c

	err = tk_def_dev(msdi->dmsdi.devnm, &ddev, idev);
3400aed8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400aeda:	3314      	adds	r3, #20
3400aedc:	f107 0114 	add.w	r1, r7, #20
3400aee0:	68ba      	ldr	r2, [r7, #8]
3400aee2:	4618      	mov	r0, r3
3400aee4:	f000 f9ca 	bl	3400b27c <tk_def_dev>
3400aee8:	6478      	str	r0, [r7, #68]	@ 0x44
	if ( err < E_OK )	goto err_ret3;
3400aeea:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3400aeec:	2b00      	cmp	r3, #0
3400aeee:	db0a      	blt.n	3400af06 <msdi_def_dev+0xb6>
	
	msdi->devid = (ID)err;
3400aef0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400aef2:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
3400aef4:	601a      	str	r2, [r3, #0]
	if(p_msdi != NULL) {
3400aef6:	687b      	ldr	r3, [r7, #4]
3400aef8:	2b00      	cmp	r3, #0
3400aefa:	d002      	beq.n	3400af02 <msdi_def_dev+0xb2>
		*p_msdi = msdi;
3400aefc:	687b      	ldr	r3, [r7, #4]
3400aefe:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
3400af00:	601a      	str	r2, [r3, #0]
	}

	return E_OK;
3400af02:	2300      	movs	r3, #0
3400af04:	e00b      	b.n	3400af1e <msdi_def_dev+0xce>
	if ( err < E_OK )	goto err_ret3;
3400af06:	bf00      	nop

err_ret3:
	DeleteLock(&msdi->lock);
3400af08:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
3400af0a:	3304      	adds	r3, #4
3400af0c:	4618      	mov	r0, r3
3400af0e:	f003 f9df 	bl	3400e2d0 <DeleteLock>
3400af12:	e000      	b.n	3400af16 <msdi_def_dev+0xc6>
	if ( err < E_OK ) goto err_ret2;
3400af14:	bf00      	nop
err_ret2:
	Kfree(msdi);
3400af16:	6c38      	ldr	r0, [r7, #64]	@ 0x40
3400af18:	f003 fb1f 	bl	3400e55a <Kfree>
err_ret1:
	return err;
3400af1c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
}
3400af1e:	4618      	mov	r0, r3
3400af20:	3748      	adds	r7, #72	@ 0x48
3400af22:	46bd      	mov	sp, r7
3400af24:	bdb0      	pop	{r4, r5, r7, pc}
3400af26:	bf00      	nop
3400af28:	3400acd5 	.word	0x3400acd5
3400af2c:	3400ad19 	.word	0x3400ad19
3400af30:	3400ad5d 	.word	0x3400ad5d
3400af34:	3400add3 	.word	0x3400add3
3400af38:	3400adef 	.word	0x3400adef
3400af3c:	3400ae0b 	.word	0x3400ae0b

3400af40 <start_system>:
 * Start System
 *	Start each subsystem and each device driver.
 *	Return from function after starting.
 */
LOCAL ER start_system( void )
{
3400af40:	b580      	push	{r7, lr}
3400af42:	b082      	sub	sp, #8
3400af44:	af00      	add	r7, sp, #0
	ER	ercd;

#if USE_DEVICE
	/* Initialize Device manager */
	ercd = knl_initialize_devmgr();
3400af46:	f000 fa83 	bl	3400b450 <knl_initialize_devmgr>
3400af4a:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) return ercd;
3400af4c:	687b      	ldr	r3, [r7, #4]
3400af4e:	2b00      	cmp	r3, #0
3400af50:	da01      	bge.n	3400af56 <start_system+0x16>
3400af52:	687b      	ldr	r3, [r7, #4]
3400af54:	e003      	b.n	3400af5e <start_system+0x1e>
#endif

	/* Start system dependent sequence */
	ercd = knl_start_device();
3400af56:	f004 fdb1 	bl	3400fabc <knl_start_device>
3400af5a:	6078      	str	r0, [r7, #4]

	return ercd;
3400af5c:	687b      	ldr	r3, [r7, #4]
}
3400af5e:	4618      	mov	r0, r3
3400af60:	3708      	adds	r7, #8
3400af62:	46bd      	mov	sp, r7
3400af64:	bd80      	pop	{r7, pc}
	...

3400af68 <shutdown_system>:
 *		-3 : Normal re-start		(Boot -> Start)
 *
 *	fin are not always supported.
 */
LOCAL void shutdown_system( INT fin )
{
3400af68:	b580      	push	{r7, lr}
3400af6a:	b082      	sub	sp, #8
3400af6c:	af00      	add	r7, sp, #0
3400af6e:	6078      	str	r0, [r7, #4]
#if USE_SHUTDOWN
	/* Platform dependent finalize sequence */
	knl_finish_device();
3400af70:	f004 fddc 	bl	3400fb2c <knl_finish_device>

	/* Shutdown message output */
	if ( fin >= 0 ) {
3400af74:	687b      	ldr	r3, [r7, #4]
3400af76:	2b00      	cmp	r3, #0
3400af78:	db02      	blt.n	3400af80 <shutdown_system+0x18>
		SYSTEM_MESSAGE("\n<< SYSTEM SHUTDOWN >>\n");
3400af7a:	4807      	ldr	r0, [pc, #28]	@ (3400af98 <shutdown_system+0x30>)
3400af7c:	f003 fb22 	bl	3400e5c4 <tm_putstring>
	}

	if ( fin < 0 ) {
3400af80:	687b      	ldr	r3, [r7, #4]
3400af82:	2b00      	cmp	r3, #0
3400af84:	da02      	bge.n	3400af8c <shutdown_system+0x24>
		/* Re-start sequence (platform dependent) */
		knl_restart_hw(fin);
3400af86:	6878      	ldr	r0, [r7, #4]
3400af88:	f004 fde6 	bl	3400fb58 <knl_restart_hw>
	}

	knl_tkernel_exit();		/* Stop system */
3400af8c:	f000 f894 	bl	3400b0b8 <knl_tkernel_exit>
	DISABLE_INTERRUPT;
	for(;;) {
		;
	}
#endif /* USE_SHUTDOWN */
}
3400af90:	bf00      	nop
3400af92:	3708      	adds	r7, #8
3400af94:	46bd      	mov	sp, r7
3400af96:	bd80      	pop	{r7, pc}
3400af98:	3400fd78 	.word	0x3400fd78

3400af9c <init_task_main>:

/*
 * Initial task main
 */
LOCAL void init_task_main(void)
{
3400af9c:	b580      	push	{r7, lr}
3400af9e:	b082      	sub	sp, #8
3400afa0:	af00      	add	r7, sp, #0
	INT	fin = 1;
3400afa2:	2301      	movs	r3, #1
3400afa4:	607b      	str	r3, [r7, #4]
	ER	ercd;

	ercd = start_system();		/* Start Sub-system & device driver */
3400afa6:	f7ff ffcb 	bl	3400af40 <start_system>
3400afaa:	6038      	str	r0, [r7, #0]
	if(ercd  >= E_OK) {
3400afac:	683b      	ldr	r3, [r7, #0]
3400afae:	2b00      	cmp	r3, #0
3400afb0:	db0b      	blt.n	3400afca <init_task_main+0x2e>

#if (USE_SYSTEM_MESSAGE && USE_TMONITOR)
		tm_printf((UB*)"\n\nmicroT-Kernel Version %x.%02x\n\n", VER_MAJOR, VER_MINOR);
3400afb2:	2200      	movs	r2, #0
3400afb4:	2103      	movs	r1, #3
3400afb6:	480a      	ldr	r0, [pc, #40]	@ (3400afe0 <init_task_main+0x44>)
3400afb8:	f003 fea4 	bl	3400ed04 <tm_printf>

#if USE_USERINIT
		/* Perform user defined initialization sequence */
		fin = (*(MAIN_FP)RI_USERINIT)(0, NULL);
#endif
		if ( fin > 0 ) {
3400afbc:	687b      	ldr	r3, [r7, #4]
3400afbe:	2b00      	cmp	r3, #0
3400afc0:	dd06      	ble.n	3400afd0 <init_task_main+0x34>
			fin = usermain();	/* User Main Program */
3400afc2:	f7f5 fd67 	bl	34000a94 <usermain>
3400afc6:	6078      	str	r0, [r7, #4]
3400afc8:	e002      	b.n	3400afd0 <init_task_main+0x34>
		/* Perform user defined finalization sequence */
		(*(MAIN_FP)RI_USERINIT)(-1, NULL);
#endif

	} else {
		SYSTEM_MESSAGE("!ERROR! Init Task start\n");	/* Start message */
3400afca:	4806      	ldr	r0, [pc, #24]	@ (3400afe4 <init_task_main+0x48>)
3400afcc:	f003 fafa 	bl	3400e5c4 <tm_putstring>
	}

	shutdown_system(fin);	/* Never return */
3400afd0:	6878      	ldr	r0, [r7, #4]
3400afd2:	f7ff ffc9 	bl	3400af68 <shutdown_system>
}
3400afd6:	bf00      	nop
3400afd8:	3708      	adds	r7, #8
3400afda:	46bd      	mov	sp, r7
3400afdc:	bd80      	pop	{r7, pc}
3400afde:	bf00      	nop
3400afe0:	3400fd90 	.word	0x3400fd90
3400afe4:	3400fdb4 	.word	0x3400fdb4

3400afe8 <knl_main>:
#ifndef ADD_PREFIX_KNL_TO_GLOBAL_NAME
EXPORT INT main( void )
#else
EXPORT INT knl_main( void )
#endif	/* ADD_PREFIX_KNL_TO_GLOBAL_NAME */
{
3400afe8:	b580      	push	{r7, lr}
3400afea:	b082      	sub	sp, #8
3400afec:	af00      	add	r7, sp, #0
	ER	ercd;

	DISABLE_INTERRUPT;
3400afee:	f004 fe08 	bl	3400fc02 <disint>

#if USE_TMONITOR
	/* Initialize T-Monitor Compatible Library */
	libtm_init();
3400aff2:	f003 fabd 	bl	3400e570 <libtm_init>
#endif

#if USE_IMALLOC
	/* Initialize Internal memory allocation (Imalloc) */
	ercd = knl_init_Imalloc();
3400aff6:	f001 fac3 	bl	3400c580 <knl_init_Imalloc>
3400affa:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
3400affc:	687b      	ldr	r3, [r7, #4]
3400affe:	2b00      	cmp	r3, #0
3400b000:	da03      	bge.n	3400b00a <knl_main+0x22>
		SYSTEM_MESSAGE("!ERROR! init_Imalloc\n");
3400b002:	4825      	ldr	r0, [pc, #148]	@ (3400b098 <knl_main+0xb0>)
3400b004:	f003 fade 	bl	3400e5c4 <tm_putstring>
		goto err_ret;
3400b008:	e044      	b.n	3400b094 <knl_main+0xac>
	}
#endif /* USE_IMALLOC */

	/* Initialize Device before micro T-Kernel starts */
	ercd = knl_init_device();
3400b00a:	f004 fd4f 	bl	3400faac <knl_init_device>
3400b00e:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
3400b010:	687b      	ldr	r3, [r7, #4]
3400b012:	2b00      	cmp	r3, #0
3400b014:	da03      	bge.n	3400b01e <knl_main+0x36>
		SYSTEM_MESSAGE("!ERROR! init_device\n");
3400b016:	4821      	ldr	r0, [pc, #132]	@ (3400b09c <knl_main+0xb4>)
3400b018:	f003 fad4 	bl	3400e5c4 <tm_putstring>
		goto err_ret;
3400b01c:	e03a      	b.n	3400b094 <knl_main+0xac>
	}

	/* Interrupt initialize */
	ercd = knl_init_interrupt();
3400b01e:	f003 ff51 	bl	3400eec4 <knl_init_interrupt>
3400b022:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
3400b024:	687b      	ldr	r3, [r7, #4]
3400b026:	2b00      	cmp	r3, #0
3400b028:	da03      	bge.n	3400b032 <knl_main+0x4a>
		SYSTEM_MESSAGE("!ERROR! init_initialize\n");
3400b02a:	481d      	ldr	r0, [pc, #116]	@ (3400b0a0 <knl_main+0xb8>)
3400b02c:	f003 faca 	bl	3400e5c4 <tm_putstring>
		goto err_ret;
3400b030:	e030      	b.n	3400b094 <knl_main+0xac>
	}

	/* Initialize Kernel-objects  */
	ercd = knl_init_object();
3400b032:	f002 fde3 	bl	3400dbfc <knl_init_object>
3400b036:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
3400b038:	687b      	ldr	r3, [r7, #4]
3400b03a:	2b00      	cmp	r3, #0
3400b03c:	da03      	bge.n	3400b046 <knl_main+0x5e>
		SYSTEM_MESSAGE("!ERROR! kernel object initialize\n");
3400b03e:	4819      	ldr	r0, [pc, #100]	@ (3400b0a4 <knl_main+0xbc>)
3400b040:	f003 fac0 	bl	3400e5c4 <tm_putstring>
		goto err_ret1;
3400b044:	e024      	b.n	3400b090 <knl_main+0xa8>
	}

	/* Start System Timer */
	ercd = knl_timer_startup();
3400b046:	f002 fce1 	bl	3400da0c <knl_timer_startup>
3400b04a:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
3400b04c:	687b      	ldr	r3, [r7, #4]
3400b04e:	2b00      	cmp	r3, #0
3400b050:	da03      	bge.n	3400b05a <knl_main+0x72>
		SYSTEM_MESSAGE("!ERROR! System timer startup\n");
3400b052:	4815      	ldr	r0, [pc, #84]	@ (3400b0a8 <knl_main+0xc0>)
3400b054:	f003 fab6 	bl	3400e5c4 <tm_putstring>
		goto err_ret1;
3400b058:	e01a      	b.n	3400b090 <knl_main+0xa8>
	}

	/* Create & start initial task */
	ercd = tk_cre_tsk((CONST T_CTSK *)&knl_init_ctsk);
3400b05a:	4814      	ldr	r0, [pc, #80]	@ (3400b0ac <knl_main+0xc4>)
3400b05c:	f002 f972 	bl	3400d344 <tk_cre_tsk>
3400b060:	6078      	str	r0, [r7, #4]
	if ( ercd >= E_OK ) {
3400b062:	687b      	ldr	r3, [r7, #4]
3400b064:	2b00      	cmp	r3, #0
3400b066:	db0e      	blt.n	3400b086 <knl_main+0x9e>
		ercd = tk_sta_tsk((ID)ercd, 0);
3400b068:	2100      	movs	r1, #0
3400b06a:	6878      	ldr	r0, [r7, #4]
3400b06c:	f002 fa18 	bl	3400d4a0 <tk_sta_tsk>
3400b070:	6078      	str	r0, [r7, #4]
		if ( ercd >= E_OK ) {
3400b072:	687b      	ldr	r3, [r7, #4]
3400b074:	2b00      	cmp	r3, #0
3400b076:	db02      	blt.n	3400b07e <knl_main+0x96>
			knl_force_dispatch();
3400b078:	f003 fe6c 	bl	3400ed54 <knl_force_dispatch>
3400b07c:	e006      	b.n	3400b08c <knl_main+0xa4>
			/**** Start Initial Task. ****/
			/**** No return ****/
		} else {
			SYSTEM_MESSAGE("!ERROR! Initial Task can not start\n");
3400b07e:	480c      	ldr	r0, [pc, #48]	@ (3400b0b0 <knl_main+0xc8>)
3400b080:	f003 faa0 	bl	3400e5c4 <tm_putstring>
3400b084:	e002      	b.n	3400b08c <knl_main+0xa4>
		}
	} else {
		SYSTEM_MESSAGE("!ERROR! Initial Task can not creat\n");
3400b086:	480b      	ldr	r0, [pc, #44]	@ (3400b0b4 <knl_main+0xcc>)
3400b088:	f003 fa9c 	bl	3400e5c4 <tm_putstring>
	}

	/* After this, Error handling */

#if USE_SHUTDOWN
	knl_timer_shutdown();	/* Stop System timer */
3400b08c:	f002 fcdc 	bl	3400da48 <knl_timer_shutdown>
err_ret1:
	knl_shutdown_hw();	/* Hardware-dependent Finalization */
3400b090:	f004 fd5b 	bl	3400fb4a <knl_shutdown_hw>
#else
err_ret1:
#endif /* USE_SHUTDOWN */

err_ret:
	while(1);
3400b094:	bf00      	nop
3400b096:	e7fd      	b.n	3400b094 <knl_main+0xac>
3400b098:	3400fdd0 	.word	0x3400fdd0
3400b09c:	3400fde8 	.word	0x3400fde8
3400b0a0:	3400fe00 	.word	0x3400fe00
3400b0a4:	3400fe1c 	.word	0x3400fe1c
3400b0a8:	3400fe40 	.word	0x3400fe40
3400b0ac:	34010078 	.word	0x34010078
3400b0b0:	3400fe60 	.word	0x3400fe60
3400b0b4:	3400fe84 	.word	0x3400fe84

3400b0b8 <knl_tkernel_exit>:
/*
 * Exit micro T-Kernel from Initial Task.
 */
#if USE_SHUTDOWN
EXPORT void knl_tkernel_exit( void )
{
3400b0b8:	b580      	push	{r7, lr}
3400b0ba:	af00      	add	r7, sp, #0
	knl_timer_shutdown();	/* Stop System timer */
3400b0bc:	f002 fcc4 	bl	3400da48 <knl_timer_shutdown>
	knl_shutdown_hw();	/* Hardware-dependent Finalization */
3400b0c0:	f004 fd43 	bl	3400fb4a <knl_shutdown_hw>
	/**** No return ****/

	while(1);
3400b0c4:	bf00      	nop
3400b0c6:	e7fd      	b.n	3400b0c4 <knl_tkernel_exit+0xc>

3400b0c8 <QueInit>:

/*
 * Queue initialization 
 */
Inline void QueInit( QUEUE *que )
{
3400b0c8:	b480      	push	{r7}
3400b0ca:	b083      	sub	sp, #12
3400b0cc:	af00      	add	r7, sp, #0
3400b0ce:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400b0d0:	687b      	ldr	r3, [r7, #4]
3400b0d2:	687a      	ldr	r2, [r7, #4]
3400b0d4:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400b0d6:	687b      	ldr	r3, [r7, #4]
3400b0d8:	687a      	ldr	r2, [r7, #4]
3400b0da:	605a      	str	r2, [r3, #4]
}
3400b0dc:	bf00      	nop
3400b0de:	370c      	adds	r7, #12
3400b0e0:	46bd      	mov	sp, r7
3400b0e2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b0e6:	4770      	bx	lr

3400b0e8 <isQueEmpty>:

/*
 * TRUE if the queue is empty 
 */
Inline BOOL isQueEmpty( QUEUE *que )
{
3400b0e8:	b480      	push	{r7}
3400b0ea:	b083      	sub	sp, #12
3400b0ec:	af00      	add	r7, sp, #0
3400b0ee:	6078      	str	r0, [r7, #4]
	return ( que->next == que )? TRUE: FALSE;
3400b0f0:	687b      	ldr	r3, [r7, #4]
3400b0f2:	681b      	ldr	r3, [r3, #0]
3400b0f4:	687a      	ldr	r2, [r7, #4]
3400b0f6:	429a      	cmp	r2, r3
3400b0f8:	bf0c      	ite	eq
3400b0fa:	2301      	moveq	r3, #1
3400b0fc:	2300      	movne	r3, #0
3400b0fe:	b2db      	uxtb	r3, r3
}
3400b100:	4618      	mov	r0, r3
3400b102:	370c      	adds	r7, #12
3400b104:	46bd      	mov	sp, r7
3400b106:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b10a:	4770      	bx	lr

3400b10c <QueInsert>:
/*
 * Insert in queue 
 *	Inserts entry directly prior to que 
 */
Inline void QueInsert( QUEUE *entry, QUEUE *que )
{
3400b10c:	b480      	push	{r7}
3400b10e:	b083      	sub	sp, #12
3400b110:	af00      	add	r7, sp, #0
3400b112:	6078      	str	r0, [r7, #4]
3400b114:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400b116:	683b      	ldr	r3, [r7, #0]
3400b118:	685a      	ldr	r2, [r3, #4]
3400b11a:	687b      	ldr	r3, [r7, #4]
3400b11c:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400b11e:	687b      	ldr	r3, [r7, #4]
3400b120:	683a      	ldr	r2, [r7, #0]
3400b122:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400b124:	683b      	ldr	r3, [r7, #0]
3400b126:	685b      	ldr	r3, [r3, #4]
3400b128:	687a      	ldr	r2, [r7, #4]
3400b12a:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400b12c:	683b      	ldr	r3, [r7, #0]
3400b12e:	687a      	ldr	r2, [r7, #4]
3400b130:	605a      	str	r2, [r3, #4]
}
3400b132:	bf00      	nop
3400b134:	370c      	adds	r7, #12
3400b136:	46bd      	mov	sp, r7
3400b138:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b13c:	4770      	bx	lr

3400b13e <QueRemove>:
 * Delete from queue 
 *	Deletes entry from queue 
 *	No action is performed if entry is empty. 
 */
Inline void QueRemove( QUEUE *entry )
{
3400b13e:	b480      	push	{r7}
3400b140:	b083      	sub	sp, #12
3400b142:	af00      	add	r7, sp, #0
3400b144:	6078      	str	r0, [r7, #4]
	if ( entry->next != entry ) {
3400b146:	687b      	ldr	r3, [r7, #4]
3400b148:	681b      	ldr	r3, [r3, #0]
3400b14a:	687a      	ldr	r2, [r7, #4]
3400b14c:	429a      	cmp	r2, r3
3400b14e:	d009      	beq.n	3400b164 <QueRemove+0x26>
		entry->prev->next = (struct queue*) entry->next;
3400b150:	687b      	ldr	r3, [r7, #4]
3400b152:	685b      	ldr	r3, [r3, #4]
3400b154:	687a      	ldr	r2, [r7, #4]
3400b156:	6812      	ldr	r2, [r2, #0]
3400b158:	601a      	str	r2, [r3, #0]
		entry->next->prev = (struct queue*) entry->prev;
3400b15a:	687b      	ldr	r3, [r7, #4]
3400b15c:	681b      	ldr	r3, [r3, #0]
3400b15e:	687a      	ldr	r2, [r7, #4]
3400b160:	6852      	ldr	r2, [r2, #4]
3400b162:	605a      	str	r2, [r3, #4]
	}
}
3400b164:	bf00      	nop
3400b166:	370c      	adds	r7, #12
3400b168:	46bd      	mov	sp, r7
3400b16a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b16e:	4770      	bx	lr

3400b170 <QueRemoveNext>:
 *	Deletes the entry directly after que from the queue,
 *	and returns the deleted entry.
 *	Returns NULL if que is empty.
 */
Inline QUEUE* QueRemoveNext( QUEUE *que )
{
3400b170:	b480      	push	{r7}
3400b172:	b085      	sub	sp, #20
3400b174:	af00      	add	r7, sp, #0
3400b176:	6078      	str	r0, [r7, #4]
	QUEUE	*entry;

	if ( que->next == que ) {
3400b178:	687b      	ldr	r3, [r7, #4]
3400b17a:	681b      	ldr	r3, [r3, #0]
3400b17c:	687a      	ldr	r2, [r7, #4]
3400b17e:	429a      	cmp	r2, r3
3400b180:	d101      	bne.n	3400b186 <QueRemoveNext+0x16>
		return NULL;
3400b182:	2300      	movs	r3, #0
3400b184:	e00b      	b.n	3400b19e <QueRemoveNext+0x2e>
	}

	entry = que->next;
3400b186:	687b      	ldr	r3, [r7, #4]
3400b188:	681b      	ldr	r3, [r3, #0]
3400b18a:	60fb      	str	r3, [r7, #12]
	que->next = (struct queue*)entry->next;
3400b18c:	68fb      	ldr	r3, [r7, #12]
3400b18e:	681a      	ldr	r2, [r3, #0]
3400b190:	687b      	ldr	r3, [r7, #4]
3400b192:	601a      	str	r2, [r3, #0]
	entry->next->prev = que;
3400b194:	68fb      	ldr	r3, [r7, #12]
3400b196:	681b      	ldr	r3, [r3, #0]
3400b198:	687a      	ldr	r2, [r7, #4]
3400b19a:	605a      	str	r2, [r3, #4]

	return entry;
3400b19c:	68fb      	ldr	r3, [r7, #12]
}
3400b19e:	4618      	mov	r0, r3
3400b1a0:	3714      	adds	r7, #20
3400b1a2:	46bd      	mov	sp, r7
3400b1a4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b1a8:	4770      	bx	lr
	...

3400b1ac <knl_searchDevCB>:

/*
 * Search registration device
 */
EXPORT DevCB* knl_searchDevCB( CONST UB *devnm )
{
3400b1ac:	b580      	push	{r7, lr}
3400b1ae:	b084      	sub	sp, #16
3400b1b0:	af00      	add	r7, sp, #0
3400b1b2:	6078      	str	r0, [r7, #4]
	QUEUE	*q;
	DevCB	*devcb;

	for ( q = knl_UsedDevCB.next; q != &knl_UsedDevCB; q = q->next ) {
3400b1b4:	4b11      	ldr	r3, [pc, #68]	@ (3400b1fc <knl_searchDevCB+0x50>)
3400b1b6:	681b      	ldr	r3, [r3, #0]
3400b1b8:	60fb      	str	r3, [r7, #12]
3400b1ba:	e015      	b.n	3400b1e8 <knl_searchDevCB+0x3c>
		devcb = (DevCB*)q;
3400b1bc:	68fb      	ldr	r3, [r7, #12]
3400b1be:	60bb      	str	r3, [r7, #8]

		if ( devcb->devnm[0] == devnm[0] && knl_strcmp((char*)devcb->devnm, (char*)devnm) == 0 ) {
3400b1c0:	68bb      	ldr	r3, [r7, #8]
3400b1c2:	7a1a      	ldrb	r2, [r3, #8]
3400b1c4:	687b      	ldr	r3, [r7, #4]
3400b1c6:	781b      	ldrb	r3, [r3, #0]
3400b1c8:	429a      	cmp	r2, r3
3400b1ca:	d10a      	bne.n	3400b1e2 <knl_searchDevCB+0x36>
3400b1cc:	68bb      	ldr	r3, [r7, #8]
3400b1ce:	3308      	adds	r3, #8
3400b1d0:	6879      	ldr	r1, [r7, #4]
3400b1d2:	4618      	mov	r0, r3
3400b1d4:	f002 ffc5 	bl	3400e162 <knl_strcmp>
3400b1d8:	4603      	mov	r3, r0
3400b1da:	2b00      	cmp	r3, #0
3400b1dc:	d101      	bne.n	3400b1e2 <knl_searchDevCB+0x36>
			return devcb; /* Found */
3400b1de:	68bb      	ldr	r3, [r7, #8]
3400b1e0:	e007      	b.n	3400b1f2 <knl_searchDevCB+0x46>
	for ( q = knl_UsedDevCB.next; q != &knl_UsedDevCB; q = q->next ) {
3400b1e2:	68fb      	ldr	r3, [r7, #12]
3400b1e4:	681b      	ldr	r3, [r3, #0]
3400b1e6:	60fb      	str	r3, [r7, #12]
3400b1e8:	68fb      	ldr	r3, [r7, #12]
3400b1ea:	4a04      	ldr	r2, [pc, #16]	@ (3400b1fc <knl_searchDevCB+0x50>)
3400b1ec:	4293      	cmp	r3, r2
3400b1ee:	d1e5      	bne.n	3400b1bc <knl_searchDevCB+0x10>
		}
	}

	return NULL;
3400b1f0:	2300      	movs	r3, #0
}
3400b1f2:	4618      	mov	r0, r3
3400b1f4:	3710      	adds	r7, #16
3400b1f6:	46bd      	mov	sp, r7
3400b1f8:	bd80      	pop	{r7, pc}
3400b1fa:	bf00      	nop
3400b1fc:	34011784 	.word	0x34011784

3400b200 <newDevCB>:

/*
 * Get DevCB for new registration
 */
LOCAL DevCB* newDevCB( CONST UB *devnm )
{
3400b200:	b580      	push	{r7, lr}
3400b202:	b084      	sub	sp, #16
3400b204:	af00      	add	r7, sp, #0
3400b206:	6078      	str	r0, [r7, #4]
	DevCB	*devcb;

	devcb = (DevCB*)QueRemoveNext(&knl_FreeDevCB);
3400b208:	480f      	ldr	r0, [pc, #60]	@ (3400b248 <newDevCB+0x48>)
3400b20a:	f7ff ffb1 	bl	3400b170 <QueRemoveNext>
3400b20e:	60f8      	str	r0, [r7, #12]
	if ( devcb == NULL ) {
3400b210:	68fb      	ldr	r3, [r7, #12]
3400b212:	2b00      	cmp	r3, #0
3400b214:	d101      	bne.n	3400b21a <newDevCB+0x1a>
		return NULL; /* No space */
3400b216:	2300      	movs	r3, #0
3400b218:	e011      	b.n	3400b23e <newDevCB+0x3e>
	}

	knl_strncpy((char*)devcb->devnm, (char*)devnm, L_DEVNM+1);
3400b21a:	68fb      	ldr	r3, [r7, #12]
3400b21c:	3308      	adds	r3, #8
3400b21e:	2209      	movs	r2, #9
3400b220:	6879      	ldr	r1, [r7, #4]
3400b222:	4618      	mov	r0, r3
3400b224:	f002 ff74 	bl	3400e110 <knl_strncpy>
	QueInit(&devcb->openq);
3400b228:	68fb      	ldr	r3, [r7, #12]
3400b22a:	3340      	adds	r3, #64	@ 0x40
3400b22c:	4618      	mov	r0, r3
3400b22e:	f7ff ff4b 	bl	3400b0c8 <QueInit>

	QueInsert(&devcb->q, &knl_UsedDevCB);
3400b232:	68fb      	ldr	r3, [r7, #12]
3400b234:	4905      	ldr	r1, [pc, #20]	@ (3400b24c <newDevCB+0x4c>)
3400b236:	4618      	mov	r0, r3
3400b238:	f7ff ff68 	bl	3400b10c <QueInsert>

	return devcb;
3400b23c:	68fb      	ldr	r3, [r7, #12]
}
3400b23e:	4618      	mov	r0, r3
3400b240:	3710      	adds	r7, #16
3400b242:	46bd      	mov	sp, r7
3400b244:	bd80      	pop	{r7, pc}
3400b246:	bf00      	nop
3400b248:	3401178c 	.word	0x3401178c
3400b24c:	34011784 	.word	0x34011784

3400b250 <delDevCB>:

/*
 * Free DevCB
 */
LOCAL void delDevCB( DevCB *devcb )
{
3400b250:	b580      	push	{r7, lr}
3400b252:	b082      	sub	sp, #8
3400b254:	af00      	add	r7, sp, #0
3400b256:	6078      	str	r0, [r7, #4]
	QueRemove(&devcb->q);
3400b258:	687b      	ldr	r3, [r7, #4]
3400b25a:	4618      	mov	r0, r3
3400b25c:	f7ff ff6f 	bl	3400b13e <QueRemove>
	QueInsert(&devcb->q, &knl_FreeDevCB);
3400b260:	687b      	ldr	r3, [r7, #4]
3400b262:	4905      	ldr	r1, [pc, #20]	@ (3400b278 <delDevCB+0x28>)
3400b264:	4618      	mov	r0, r3
3400b266:	f7ff ff51 	bl	3400b10c <QueInsert>
	devcb->devnm[0] = '\0';
3400b26a:	687b      	ldr	r3, [r7, #4]
3400b26c:	2200      	movs	r2, #0
3400b26e:	721a      	strb	r2, [r3, #8]
}
3400b270:	bf00      	nop
3400b272:	3708      	adds	r7, #8
3400b274:	46bd      	mov	sp, r7
3400b276:	bd80      	pop	{r7, pc}
3400b278:	3401178c 	.word	0x3401178c

3400b27c <tk_def_dev>:

/*
 * Device registration
 */
SYSCALL ID tk_def_dev( CONST UB *devnm, CONST T_DDEV *pk_ddev, T_IDEV *pk_idev )
{
3400b27c:	b5b0      	push	{r4, r5, r7, lr}
3400b27e:	b088      	sub	sp, #32
3400b280:	af00      	add	r7, sp, #0
3400b282:	60f8      	str	r0, [r7, #12]
3400b284:	60b9      	str	r1, [r7, #8]
3400b286:	607a      	str	r2, [r7, #4]
	DevCB	*devcb;
	INT	len;
	ER	ercd;

	LockREG();
3400b288:	2101      	movs	r1, #1
3400b28a:	484f      	ldr	r0, [pc, #316]	@ (3400b3c8 <tk_def_dev+0x14c>)
3400b28c:	f003 f8c9 	bl	3400e422 <MLock>

	len = knl_strlen((char*)devnm);
3400b290:	68f8      	ldr	r0, [r7, #12]
3400b292:	f002 ff15 	bl	3400e0c0 <knl_strlen>
3400b296:	61b8      	str	r0, [r7, #24]
	if ( len == 0 || len > L_DEVNM ) {
3400b298:	69bb      	ldr	r3, [r7, #24]
3400b29a:	2b00      	cmp	r3, #0
3400b29c:	d002      	beq.n	3400b2a4 <tk_def_dev+0x28>
3400b29e:	69bb      	ldr	r3, [r7, #24]
3400b2a0:	2b08      	cmp	r3, #8
3400b2a2:	dd03      	ble.n	3400b2ac <tk_def_dev+0x30>
		ercd = E_PAR;
3400b2a4:	f06f 0310 	mvn.w	r3, #16
3400b2a8:	617b      	str	r3, [r7, #20]
		goto err_ret1;
3400b2aa:	e084      	b.n	3400b3b6 <tk_def_dev+0x13a>
	}

	if ( pk_ddev != NULL ) {
3400b2ac:	68bb      	ldr	r3, [r7, #8]
3400b2ae:	2b00      	cmp	r3, #0
3400b2b0:	d027      	beq.n	3400b302 <tk_def_dev+0x86>
		if ( pk_ddev->nsub < 0 || pk_ddev->nsub > MAX_UNIT ) {
3400b2b2:	68bb      	ldr	r3, [r7, #8]
3400b2b4:	68db      	ldr	r3, [r3, #12]
3400b2b6:	2b00      	cmp	r3, #0
3400b2b8:	db03      	blt.n	3400b2c2 <tk_def_dev+0x46>
3400b2ba:	68bb      	ldr	r3, [r7, #8]
3400b2bc:	68db      	ldr	r3, [r3, #12]
3400b2be:	2bff      	cmp	r3, #255	@ 0xff
3400b2c0:	dd03      	ble.n	3400b2ca <tk_def_dev+0x4e>
			ercd = E_PAR;
3400b2c2:	f06f 0310 	mvn.w	r3, #16
3400b2c6:	617b      	str	r3, [r7, #20]
			goto err_ret1;
3400b2c8:	e075      	b.n	3400b3b6 <tk_def_dev+0x13a>
		}

		/* Make sure that the length of the logical device name
		   does not exceed the character limit */
		if ( pk_ddev->nsub > 0   ) {
3400b2ca:	68bb      	ldr	r3, [r7, #8]
3400b2cc:	68db      	ldr	r3, [r3, #12]
3400b2ce:	2b00      	cmp	r3, #0
3400b2d0:	dd02      	ble.n	3400b2d8 <tk_def_dev+0x5c>
			++len;
3400b2d2:	69bb      	ldr	r3, [r7, #24]
3400b2d4:	3301      	adds	r3, #1
3400b2d6:	61bb      	str	r3, [r7, #24]
		}
		if ( pk_ddev->nsub > 10  ) {
3400b2d8:	68bb      	ldr	r3, [r7, #8]
3400b2da:	68db      	ldr	r3, [r3, #12]
3400b2dc:	2b0a      	cmp	r3, #10
3400b2de:	dd02      	ble.n	3400b2e6 <tk_def_dev+0x6a>
			++len;
3400b2e0:	69bb      	ldr	r3, [r7, #24]
3400b2e2:	3301      	adds	r3, #1
3400b2e4:	61bb      	str	r3, [r7, #24]
		}
		if ( pk_ddev->nsub > 100 ) {
3400b2e6:	68bb      	ldr	r3, [r7, #8]
3400b2e8:	68db      	ldr	r3, [r3, #12]
3400b2ea:	2b64      	cmp	r3, #100	@ 0x64
3400b2ec:	dd02      	ble.n	3400b2f4 <tk_def_dev+0x78>
			++len;
3400b2ee:	69bb      	ldr	r3, [r7, #24]
3400b2f0:	3301      	adds	r3, #1
3400b2f2:	61bb      	str	r3, [r7, #24]
		}
		if ( len > L_DEVNM ) {
3400b2f4:	69bb      	ldr	r3, [r7, #24]
3400b2f6:	2b08      	cmp	r3, #8
3400b2f8:	dd03      	ble.n	3400b302 <tk_def_dev+0x86>
			ercd = E_PAR;
3400b2fa:	f06f 0310 	mvn.w	r3, #16
3400b2fe:	617b      	str	r3, [r7, #20]
			goto err_ret1;
3400b300:	e059      	b.n	3400b3b6 <tk_def_dev+0x13a>
		}
	}

	LockDM();
3400b302:	2100      	movs	r1, #0
3400b304:	4830      	ldr	r0, [pc, #192]	@ (3400b3c8 <tk_def_dev+0x14c>)
3400b306:	f003 f88c 	bl	3400e422 <MLock>

	/* Search whether 'devnm' device is registered */
	devcb = knl_searchDevCB(devnm);
3400b30a:	68f8      	ldr	r0, [r7, #12]
3400b30c:	f7ff ff4e 	bl	3400b1ac <knl_searchDevCB>
3400b310:	61f8      	str	r0, [r7, #28]
	if ( devcb == NULL ) {
3400b312:	69fb      	ldr	r3, [r7, #28]
3400b314:	2b00      	cmp	r3, #0
3400b316:	d111      	bne.n	3400b33c <tk_def_dev+0xc0>
		if ( pk_ddev == NULL ) {
3400b318:	68bb      	ldr	r3, [r7, #8]
3400b31a:	2b00      	cmp	r3, #0
3400b31c:	d103      	bne.n	3400b326 <tk_def_dev+0xaa>
			ercd = E_NOEXS;
3400b31e:	f06f 0329 	mvn.w	r3, #41	@ 0x29
3400b322:	617b      	str	r3, [r7, #20]
			goto err_ret2;
3400b324:	e043      	b.n	3400b3ae <tk_def_dev+0x132>
		}

		/* Get 'devcb' for new registration because it is not
		   registered */
		devcb = newDevCB(devnm);
3400b326:	68f8      	ldr	r0, [r7, #12]
3400b328:	f7ff ff6a 	bl	3400b200 <newDevCB>
3400b32c:	61f8      	str	r0, [r7, #28]
		if ( devcb == NULL ) {
3400b32e:	69fb      	ldr	r3, [r7, #28]
3400b330:	2b00      	cmp	r3, #0
3400b332:	d103      	bne.n	3400b33c <tk_def_dev+0xc0>
			ercd = E_LIMIT;
3400b334:	f06f 0321 	mvn.w	r3, #33	@ 0x21
3400b338:	617b      	str	r3, [r7, #20]
			goto err_ret2;
3400b33a:	e038      	b.n	3400b3ae <tk_def_dev+0x132>
		}
	}

	if ( pk_ddev != NULL ) {
3400b33c:	68bb      	ldr	r3, [r7, #8]
3400b33e:	2b00      	cmp	r3, #0
3400b340:	d014      	beq.n	3400b36c <tk_def_dev+0xf0>
		/* Set/update device registration information */
		devcb->ddev = *pk_ddev;
3400b342:	69fb      	ldr	r3, [r7, #28]
3400b344:	68ba      	ldr	r2, [r7, #8]
3400b346:	f103 0414 	add.w	r4, r3, #20
3400b34a:	4615      	mov	r5, r2
3400b34c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3400b34e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3400b350:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3400b352:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3400b354:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
3400b358:	e884 0007 	stmia.w	r4, {r0, r1, r2}

		if ( pk_idev != NULL ) {
3400b35c:	687b      	ldr	r3, [r7, #4]
3400b35e:	2b00      	cmp	r3, #0
3400b360:	d013      	beq.n	3400b38a <tk_def_dev+0x10e>
			/* Device initial setting information */
			*pk_idev = knl_DefaultIDev;
3400b362:	687b      	ldr	r3, [r7, #4]
3400b364:	4a19      	ldr	r2, [pc, #100]	@ (3400b3cc <tk_def_dev+0x150>)
3400b366:	6812      	ldr	r2, [r2, #0]
3400b368:	601a      	str	r2, [r3, #0]
3400b36a:	e00e      	b.n	3400b38a <tk_def_dev+0x10e>
		}
	} else {
		if ( !isQueEmpty(&devcb->openq) ) {
3400b36c:	69fb      	ldr	r3, [r7, #28]
3400b36e:	3340      	adds	r3, #64	@ 0x40
3400b370:	4618      	mov	r0, r3
3400b372:	f7ff feb9 	bl	3400b0e8 <isQueEmpty>
3400b376:	4603      	mov	r3, r0
3400b378:	2b00      	cmp	r3, #0
3400b37a:	d103      	bne.n	3400b384 <tk_def_dev+0x108>
			/* In use (open) */
			ercd = E_BUSY;
3400b37c:	f06f 0340 	mvn.w	r3, #64	@ 0x40
3400b380:	617b      	str	r3, [r7, #20]
			goto err_ret2;
3400b382:	e014      	b.n	3400b3ae <tk_def_dev+0x132>
		}

		/* Device unregistration */
		delDevCB(devcb);
3400b384:	69f8      	ldr	r0, [r7, #28]
3400b386:	f7ff ff63 	bl	3400b250 <delDevCB>
	}

	UnlockDM();
3400b38a:	2100      	movs	r1, #0
3400b38c:	480e      	ldr	r0, [pc, #56]	@ (3400b3c8 <tk_def_dev+0x14c>)
3400b38e:	f003 f858 	bl	3400e442 <MUnlock>
	UnlockREG();
3400b392:	2101      	movs	r1, #1
3400b394:	480c      	ldr	r0, [pc, #48]	@ (3400b3c8 <tk_def_dev+0x14c>)
3400b396:	f003 f854 	bl	3400e442 <MUnlock>

	return DID(devcb);
3400b39a:	69fb      	ldr	r3, [r7, #28]
3400b39c:	4a0c      	ldr	r2, [pc, #48]	@ (3400b3d0 <tk_def_dev+0x154>)
3400b39e:	1a9b      	subs	r3, r3, r2
3400b3a0:	10db      	asrs	r3, r3, #3
3400b3a2:	4a0c      	ldr	r2, [pc, #48]	@ (3400b3d4 <tk_def_dev+0x158>)
3400b3a4:	fb02 f303 	mul.w	r3, r2, r3
3400b3a8:	3301      	adds	r3, #1
3400b3aa:	021b      	lsls	r3, r3, #8
3400b3ac:	e008      	b.n	3400b3c0 <tk_def_dev+0x144>

err_ret2:
	UnlockDM();
3400b3ae:	2100      	movs	r1, #0
3400b3b0:	4805      	ldr	r0, [pc, #20]	@ (3400b3c8 <tk_def_dev+0x14c>)
3400b3b2:	f003 f846 	bl	3400e442 <MUnlock>
err_ret1:
	UnlockREG();
3400b3b6:	2101      	movs	r1, #1
3400b3b8:	4803      	ldr	r0, [pc, #12]	@ (3400b3c8 <tk_def_dev+0x14c>)
3400b3ba:	f003 f842 	bl	3400e442 <MUnlock>
	return ercd;
3400b3be:	697b      	ldr	r3, [r7, #20]
}
3400b3c0:	4618      	mov	r0, r3
3400b3c2:	3720      	adds	r7, #32
3400b3c4:	46bd      	mov	sp, r7
3400b3c6:	bdb0      	pop	{r4, r5, r7, pc}
3400b3c8:	34011530 	.word	0x34011530
3400b3cc:	34011540 	.word	0x34011540
3400b3d0:	34011544 	.word	0x34011544
3400b3d4:	38e38e39 	.word	0x38e38e39

3400b3d8 <initDevCB>:

/*
 * Initialization of device registration information table
 */
LOCAL ER initDevCB( void )
{
3400b3d8:	b580      	push	{r7, lr}
3400b3da:	b082      	sub	sp, #8
3400b3dc:	af00      	add	r7, sp, #0
	DevCB	*devcb;
	INT	num = MAX_REGDEV;
3400b3de:	2308      	movs	r3, #8
3400b3e0:	603b      	str	r3, [r7, #0]

	QueInit(&knl_UsedDevCB);
3400b3e2:	480f      	ldr	r0, [pc, #60]	@ (3400b420 <initDevCB+0x48>)
3400b3e4:	f7ff fe70 	bl	3400b0c8 <QueInit>
	QueInit(&knl_FreeDevCB);
3400b3e8:	480e      	ldr	r0, [pc, #56]	@ (3400b424 <initDevCB+0x4c>)
3400b3ea:	f7ff fe6d 	bl	3400b0c8 <QueInit>

	devcb = knl_DevCBtbl;
3400b3ee:	4b0e      	ldr	r3, [pc, #56]	@ (3400b428 <initDevCB+0x50>)
3400b3f0:	607b      	str	r3, [r7, #4]
	while ( num-- > 0 ) {
3400b3f2:	e00a      	b.n	3400b40a <initDevCB+0x32>
		QueInsert(&devcb->q, &knl_FreeDevCB);
3400b3f4:	687b      	ldr	r3, [r7, #4]
3400b3f6:	490b      	ldr	r1, [pc, #44]	@ (3400b424 <initDevCB+0x4c>)
3400b3f8:	4618      	mov	r0, r3
3400b3fa:	f7ff fe87 	bl	3400b10c <QueInsert>
		devcb->devnm[0] = '\0';
3400b3fe:	687b      	ldr	r3, [r7, #4]
3400b400:	2200      	movs	r2, #0
3400b402:	721a      	strb	r2, [r3, #8]
		devcb++;
3400b404:	687b      	ldr	r3, [r7, #4]
3400b406:	3348      	adds	r3, #72	@ 0x48
3400b408:	607b      	str	r3, [r7, #4]
	while ( num-- > 0 ) {
3400b40a:	683b      	ldr	r3, [r7, #0]
3400b40c:	1e5a      	subs	r2, r3, #1
3400b40e:	603a      	str	r2, [r7, #0]
3400b410:	2b00      	cmp	r3, #0
3400b412:	dcef      	bgt.n	3400b3f4 <initDevCB+0x1c>
	}

	return E_OK;
3400b414:	2300      	movs	r3, #0
}
3400b416:	4618      	mov	r0, r3
3400b418:	3708      	adds	r7, #8
3400b41a:	46bd      	mov	sp, r7
3400b41c:	bd80      	pop	{r7, pc}
3400b41e:	bf00      	nop
3400b420:	34011784 	.word	0x34011784
3400b424:	3401178c 	.word	0x3401178c
3400b428:	34011544 	.word	0x34011544

3400b42c <initIDev>:

/*
 * Initialization of device initial setting information
 */
LOCAL ER initIDev( void )
{
3400b42c:	b480      	push	{r7}
3400b42e:	b083      	sub	sp, #12
3400b430:	af00      	add	r7, sp, #0
	if ( ercd < E_OK ) {
		knl_DefaultIDev.evtmbfid = 0;
		goto err_ret;
	}
#else	/* Do not use message buffer for event notification */
	ercd = E_OK;
3400b432:	2300      	movs	r3, #0
3400b434:	607b      	str	r3, [r7, #4]
#endif
	knl_DefaultIDev.evtmbfid = ercd;
3400b436:	4a05      	ldr	r2, [pc, #20]	@ (3400b44c <initIDev+0x20>)
3400b438:	687b      	ldr	r3, [r7, #4]
3400b43a:	6013      	str	r3, [r2, #0]

#if DEVT_MBFSZ0 >= 0
err_ret:
#endif
	return ercd;
3400b43c:	687b      	ldr	r3, [r7, #4]
}
3400b43e:	4618      	mov	r0, r3
3400b440:	370c      	adds	r7, #12
3400b442:	46bd      	mov	sp, r7
3400b444:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b448:	4770      	bx	lr
3400b44a:	bf00      	nop
3400b44c:	34011540 	.word	0x34011540

3400b450 <knl_initialize_devmgr>:

/*
 * Initialization of Device management
 */
EXPORT ER knl_initialize_devmgr( void )
{
3400b450:	b580      	push	{r7, lr}
3400b452:	b082      	sub	sp, #8
3400b454:	af00      	add	r7, sp, #0
	ER	ercd;

	/* Generate lock for device management exclusive control */
	ercd = CreateMLock(&knl_DevMgrLock, (UB*)OBJNAME_DMLOCK);
3400b456:	4916      	ldr	r1, [pc, #88]	@ (3400b4b0 <knl_initialize_devmgr+0x60>)
3400b458:	4816      	ldr	r0, [pc, #88]	@ (3400b4b4 <knl_initialize_devmgr+0x64>)
3400b45a:	f003 f815 	bl	3400e488 <CreateMLock>
3400b45e:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
3400b460:	687b      	ldr	r3, [r7, #4]
3400b462:	2b00      	cmp	r3, #0
3400b464:	db15      	blt.n	3400b492 <knl_initialize_devmgr+0x42>
		goto err_ret;
	}

	/* Generate device registration information table */
	ercd = initDevCB();
3400b466:	f7ff ffb7 	bl	3400b3d8 <initDevCB>
3400b46a:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
3400b46c:	687b      	ldr	r3, [r7, #4]
3400b46e:	2b00      	cmp	r3, #0
3400b470:	db11      	blt.n	3400b496 <knl_initialize_devmgr+0x46>
		goto err_ret;
	}

	/* Initialization of device input/output-related */
	ercd = knl_initDevIO();
3400b472:	f000 fabf 	bl	3400b9f4 <knl_initDevIO>
3400b476:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
3400b478:	687b      	ldr	r3, [r7, #4]
3400b47a:	2b00      	cmp	r3, #0
3400b47c:	db0d      	blt.n	3400b49a <knl_initialize_devmgr+0x4a>
		goto err_ret;
	}

	/* Initialization of device initial setting information */
	ercd = initIDev();
3400b47e:	f7ff ffd5 	bl	3400b42c <initIDev>
3400b482:	6078      	str	r0, [r7, #4]
	if ( ercd < E_OK ) {
3400b484:	687b      	ldr	r3, [r7, #4]
3400b486:	2b00      	cmp	r3, #0
3400b488:	db09      	blt.n	3400b49e <knl_initialize_devmgr+0x4e>
		goto err_ret;
	}

	knl_devmgr_startup();
3400b48a:	f000 fa5f 	bl	3400b94c <knl_devmgr_startup>

	return E_OK;
3400b48e:	2300      	movs	r3, #0
3400b490:	e009      	b.n	3400b4a6 <knl_initialize_devmgr+0x56>
		goto err_ret;
3400b492:	bf00      	nop
3400b494:	e004      	b.n	3400b4a0 <knl_initialize_devmgr+0x50>
		goto err_ret;
3400b496:	bf00      	nop
3400b498:	e002      	b.n	3400b4a0 <knl_initialize_devmgr+0x50>
		goto err_ret;
3400b49a:	bf00      	nop
3400b49c:	e000      	b.n	3400b4a0 <knl_initialize_devmgr+0x50>
		goto err_ret;
3400b49e:	bf00      	nop

err_ret:
	knl_finish_devmgr();
3400b4a0:	f000 f816 	bl	3400b4d0 <knl_finish_devmgr>
	return ercd;
3400b4a4:	687b      	ldr	r3, [r7, #4]
}
3400b4a6:	4618      	mov	r0, r3
3400b4a8:	3708      	adds	r7, #8
3400b4aa:	46bd      	mov	sp, r7
3400b4ac:	bd80      	pop	{r7, pc}
3400b4ae:	bf00      	nop
3400b4b0:	3400fea8 	.word	0x3400fea8
3400b4b4:	34011530 	.word	0x34011530

3400b4b8 <delIDev>:

/*
 * Unregister device initial setting information
 */
LOCAL ER delIDev( void )
{
3400b4b8:	b480      	push	{r7}
3400b4ba:	b083      	sub	sp, #12
3400b4bc:	af00      	add	r7, sp, #0
	ER	ercd = E_OK;
3400b4be:	2300      	movs	r3, #0
3400b4c0:	607b      	str	r3, [r7, #4]
	}


#endif /* DEVT_MBFSZ0 >= 0 */

	return ercd;
3400b4c2:	687b      	ldr	r3, [r7, #4]
}
3400b4c4:	4618      	mov	r0, r3
3400b4c6:	370c      	adds	r7, #12
3400b4c8:	46bd      	mov	sp, r7
3400b4ca:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b4ce:	4770      	bx	lr

3400b4d0 <knl_finish_devmgr>:

/*
 * Finalization sequence of system management 
 */
EXPORT ER knl_finish_devmgr( void )
{
3400b4d0:	b580      	push	{r7, lr}
3400b4d2:	b082      	sub	sp, #8
3400b4d4:	af00      	add	r7, sp, #0
	ER	ercd;

	knl_devmgr_cleanup();
3400b4d6:	f000 fa4f 	bl	3400b978 <knl_devmgr_cleanup>

	/* Unregister device initial setting information */
	ercd = delIDev();
3400b4da:	f7ff ffed 	bl	3400b4b8 <delIDev>
3400b4de:	6078      	str	r0, [r7, #4]

	/* Finalization sequence of device input/output-related */
	ercd = knl_finishDevIO();
3400b4e0:	f000 fad2 	bl	3400ba88 <knl_finishDevIO>
3400b4e4:	6078      	str	r0, [r7, #4]

	/* Delete lock for device management exclusive control */
	DeleteMLock(&knl_DevMgrLock);
3400b4e6:	4804      	ldr	r0, [pc, #16]	@ (3400b4f8 <knl_finish_devmgr+0x28>)
3400b4e8:	f003 f80c 	bl	3400e504 <DeleteMLock>

	return ercd;
3400b4ec:	687b      	ldr	r3, [r7, #4]
}
3400b4ee:	4618      	mov	r0, r3
3400b4f0:	3708      	adds	r7, #8
3400b4f2:	46bd      	mov	sp, r7
3400b4f4:	bd80      	pop	{r7, pc}
3400b4f6:	bf00      	nop
3400b4f8:	34011530 	.word	0x34011530

3400b4fc <QueInit>:
{
3400b4fc:	b480      	push	{r7}
3400b4fe:	b083      	sub	sp, #12
3400b500:	af00      	add	r7, sp, #0
3400b502:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400b504:	687b      	ldr	r3, [r7, #4]
3400b506:	687a      	ldr	r2, [r7, #4]
3400b508:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400b50a:	687b      	ldr	r3, [r7, #4]
3400b50c:	687a      	ldr	r2, [r7, #4]
3400b50e:	605a      	str	r2, [r3, #4]
}
3400b510:	bf00      	nop
3400b512:	370c      	adds	r7, #12
3400b514:	46bd      	mov	sp, r7
3400b516:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b51a:	4770      	bx	lr

3400b51c <isQueEmpty>:
{
3400b51c:	b480      	push	{r7}
3400b51e:	b083      	sub	sp, #12
3400b520:	af00      	add	r7, sp, #0
3400b522:	6078      	str	r0, [r7, #4]
	return ( que->next == que )? TRUE: FALSE;
3400b524:	687b      	ldr	r3, [r7, #4]
3400b526:	681b      	ldr	r3, [r3, #0]
3400b528:	687a      	ldr	r2, [r7, #4]
3400b52a:	429a      	cmp	r2, r3
3400b52c:	bf0c      	ite	eq
3400b52e:	2301      	moveq	r3, #1
3400b530:	2300      	movne	r3, #0
3400b532:	b2db      	uxtb	r3, r3
}
3400b534:	4618      	mov	r0, r3
3400b536:	370c      	adds	r7, #12
3400b538:	46bd      	mov	sp, r7
3400b53a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b53e:	4770      	bx	lr

3400b540 <QueInsert>:
{
3400b540:	b480      	push	{r7}
3400b542:	b083      	sub	sp, #12
3400b544:	af00      	add	r7, sp, #0
3400b546:	6078      	str	r0, [r7, #4]
3400b548:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400b54a:	683b      	ldr	r3, [r7, #0]
3400b54c:	685a      	ldr	r2, [r3, #4]
3400b54e:	687b      	ldr	r3, [r7, #4]
3400b550:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400b552:	687b      	ldr	r3, [r7, #4]
3400b554:	683a      	ldr	r2, [r7, #0]
3400b556:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400b558:	683b      	ldr	r3, [r7, #0]
3400b55a:	685b      	ldr	r3, [r3, #4]
3400b55c:	687a      	ldr	r2, [r7, #4]
3400b55e:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400b560:	683b      	ldr	r3, [r7, #0]
3400b562:	687a      	ldr	r2, [r7, #4]
3400b564:	605a      	str	r2, [r3, #4]
}
3400b566:	bf00      	nop
3400b568:	370c      	adds	r7, #12
3400b56a:	46bd      	mov	sp, r7
3400b56c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b570:	4770      	bx	lr

3400b572 <QueRemove>:
{
3400b572:	b480      	push	{r7}
3400b574:	b083      	sub	sp, #12
3400b576:	af00      	add	r7, sp, #0
3400b578:	6078      	str	r0, [r7, #4]
	if ( entry->next != entry ) {
3400b57a:	687b      	ldr	r3, [r7, #4]
3400b57c:	681b      	ldr	r3, [r3, #0]
3400b57e:	687a      	ldr	r2, [r7, #4]
3400b580:	429a      	cmp	r2, r3
3400b582:	d009      	beq.n	3400b598 <QueRemove+0x26>
		entry->prev->next = (struct queue*) entry->next;
3400b584:	687b      	ldr	r3, [r7, #4]
3400b586:	685b      	ldr	r3, [r3, #4]
3400b588:	687a      	ldr	r2, [r7, #4]
3400b58a:	6812      	ldr	r2, [r2, #0]
3400b58c:	601a      	str	r2, [r3, #0]
		entry->next->prev = (struct queue*) entry->prev;
3400b58e:	687b      	ldr	r3, [r7, #4]
3400b590:	681b      	ldr	r3, [r3, #0]
3400b592:	687a      	ldr	r2, [r7, #4]
3400b594:	6852      	ldr	r2, [r2, #4]
3400b596:	605a      	str	r2, [r3, #4]
}
3400b598:	bf00      	nop
3400b59a:	370c      	adds	r7, #12
3400b59c:	46bd      	mov	sp, r7
3400b59e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b5a2:	4770      	bx	lr

3400b5a4 <knl_delOpnCB>:

/*
 * Free open management block
 */
EXPORT void knl_delOpnCB( OpnCB *opncb, BOOL free )
{
3400b5a4:	b580      	push	{r7, lr}
3400b5a6:	b082      	sub	sp, #8
3400b5a8:	af00      	add	r7, sp, #0
3400b5aa:	6078      	str	r0, [r7, #4]
3400b5ac:	6039      	str	r1, [r7, #0]
	QueRemove(&opncb->q);
3400b5ae:	687b      	ldr	r3, [r7, #4]
3400b5b0:	4618      	mov	r0, r3
3400b5b2:	f7ff ffde 	bl	3400b572 <QueRemove>
	QueRemove(&opncb->resq);
3400b5b6:	687b      	ldr	r3, [r7, #4]
3400b5b8:	3308      	adds	r3, #8
3400b5ba:	4618      	mov	r0, r3
3400b5bc:	f7ff ffd9 	bl	3400b572 <QueRemove>

	if ( free ) {
3400b5c0:	683b      	ldr	r3, [r7, #0]
3400b5c2:	2b00      	cmp	r3, #0
3400b5c4:	d004      	beq.n	3400b5d0 <knl_delOpnCB+0x2c>
		QueInsert(&opncb->q, &knl_FreeOpnCB);
3400b5c6:	687b      	ldr	r3, [r7, #4]
3400b5c8:	4905      	ldr	r1, [pc, #20]	@ (3400b5e0 <knl_delOpnCB+0x3c>)
3400b5ca:	4618      	mov	r0, r3
3400b5cc:	f7ff ffb8 	bl	3400b540 <QueInsert>
	}
	opncb->resid = 0;
3400b5d0:	687b      	ldr	r3, [r7, #4]
3400b5d2:	2200      	movs	r2, #0
3400b5d4:	611a      	str	r2, [r3, #16]
}
3400b5d6:	bf00      	nop
3400b5d8:	3708      	adds	r7, #8
3400b5da:	46bd      	mov	sp, r7
3400b5dc:	bd80      	pop	{r7, pc}
3400b5de:	bf00      	nop
3400b5e0:	34011b94 	.word	0x34011b94

3400b5e4 <knl_delReqCB>:

/*
 * Free request management block
 */
EXPORT void knl_delReqCB( ReqCB *reqcb )
{
3400b5e4:	b580      	push	{r7, lr}
3400b5e6:	b082      	sub	sp, #8
3400b5e8:	af00      	add	r7, sp, #0
3400b5ea:	6078      	str	r0, [r7, #4]
	QueRemove(&reqcb->q);
3400b5ec:	687b      	ldr	r3, [r7, #4]
3400b5ee:	4618      	mov	r0, r3
3400b5f0:	f7ff ffbf 	bl	3400b572 <QueRemove>

	QueInsert(&reqcb->q, &knl_FreeReqCB);
3400b5f4:	687b      	ldr	r3, [r7, #4]
3400b5f6:	4905      	ldr	r1, [pc, #20]	@ (3400b60c <knl_delReqCB+0x28>)
3400b5f8:	4618      	mov	r0, r3
3400b5fa:	f7ff ffa1 	bl	3400b540 <QueInsert>
	reqcb->opncb = NULL;
3400b5fe:	687b      	ldr	r3, [r7, #4]
3400b600:	2200      	movs	r2, #0
3400b602:	609a      	str	r2, [r3, #8]
}
3400b604:	bf00      	nop
3400b606:	3708      	adds	r7, #8
3400b608:	46bd      	mov	sp, r7
3400b60a:	bd80      	pop	{r7, pc}
3400b60c:	34011edc 	.word	0x34011edc

3400b610 <knl_chkopen>:

/*
 * TRUE if specified device is open.
 */
EXPORT BOOL knl_chkopen( DevCB *devcb, INT unitno )
{
3400b610:	b480      	push	{r7}
3400b612:	b085      	sub	sp, #20
3400b614:	af00      	add	r7, sp, #0
3400b616:	6078      	str	r0, [r7, #4]
3400b618:	6039      	str	r1, [r7, #0]
	QUEUE	*q;

	for ( q = devcb->openq.next; q != &devcb->openq; q = q->next ) {
3400b61a:	687b      	ldr	r3, [r7, #4]
3400b61c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400b61e:	60fb      	str	r3, [r7, #12]
3400b620:	e009      	b.n	3400b636 <knl_chkopen+0x26>
		if ( ((OpnCB*)q)->unitno == unitno ) {
3400b622:	68fb      	ldr	r3, [r7, #12]
3400b624:	699b      	ldr	r3, [r3, #24]
3400b626:	683a      	ldr	r2, [r7, #0]
3400b628:	429a      	cmp	r2, r3
3400b62a:	d101      	bne.n	3400b630 <knl_chkopen+0x20>
			return TRUE;
3400b62c:	2301      	movs	r3, #1
3400b62e:	e008      	b.n	3400b642 <knl_chkopen+0x32>
	for ( q = devcb->openq.next; q != &devcb->openq; q = q->next ) {
3400b630:	68fb      	ldr	r3, [r7, #12]
3400b632:	681b      	ldr	r3, [r3, #0]
3400b634:	60fb      	str	r3, [r7, #12]
3400b636:	687b      	ldr	r3, [r7, #4]
3400b638:	3340      	adds	r3, #64	@ 0x40
3400b63a:	68fa      	ldr	r2, [r7, #12]
3400b63c:	429a      	cmp	r2, r3
3400b63e:	d1f0      	bne.n	3400b622 <knl_chkopen+0x12>
		}
	}
	return FALSE;
3400b640:	2300      	movs	r3, #0
}
3400b642:	4618      	mov	r0, r3
3400b644:	3714      	adds	r7, #20
3400b646:	46bd      	mov	sp, r7
3400b648:	f85d 7b04 	ldr.w	r7, [sp], #4
3400b64c:	4770      	bx	lr
	...

3400b650 <abort_allrequest>:

/*
 * Abort all requests
 */
LOCAL void abort_allrequest( OpnCB *opncb )
{
3400b650:	b590      	push	{r4, r7, lr}
3400b652:	b089      	sub	sp, #36	@ 0x24
3400b654:	af00      	add	r7, sp, #0
3400b656:	6078      	str	r0, [r7, #4]
	DevCB	*devcb;
	ReqCB	*reqcb;
	QUEUE	*q;

	/* If 'execfn' and 'waitfn' are called, execute abort request. */
	LockDM();
3400b658:	2100      	movs	r1, #0
3400b65a:	4876      	ldr	r0, [pc, #472]	@ (3400b834 <abort_allrequest+0x1e4>)
3400b65c:	f002 fee1 	bl	3400e422 <MLock>

	devcb = opncb->devcb;
3400b660:	687b      	ldr	r3, [r7, #4]
3400b662:	695b      	ldr	r3, [r3, #20]
3400b664:	61bb      	str	r3, [r7, #24]
	abortfn = (ABTFN)devcb->ddev.abortfn;
3400b666:	69bb      	ldr	r3, [r7, #24]
3400b668:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400b66a:	617b      	str	r3, [r7, #20]
	waitfn  = (WAIFN)devcb->ddev.waitfn;
3400b66c:	69bb      	ldr	r3, [r7, #24]
3400b66e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400b670:	613b      	str	r3, [r7, #16]
	exinf   = devcb->ddev.exinf;
3400b672:	69bb      	ldr	r3, [r7, #24]
3400b674:	695b      	ldr	r3, [r3, #20]
3400b676:	60fb      	str	r3, [r7, #12]

	opncb->abort_tskid = tk_get_tid();
3400b678:	f001 ff86 	bl	3400d588 <tk_get_tid>
3400b67c:	4602      	mov	r2, r0
3400b67e:	687b      	ldr	r3, [r7, #4]
3400b680:	635a      	str	r2, [r3, #52]	@ 0x34
	opncb->abort_cnt = 0;
3400b682:	687b      	ldr	r3, [r7, #4]
3400b684:	2200      	movs	r2, #0
3400b686:	639a      	str	r2, [r3, #56]	@ 0x38

	if ( opncb->nwaireq > 0 ) {
3400b688:	687b      	ldr	r3, [r7, #4]
3400b68a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3400b68c:	2b00      	cmp	r3, #0
3400b68e:	dd2e      	ble.n	3400b6ee <abort_allrequest+0x9e>
		/* Multiple requests wait */
		reqcb = DEVREQ_REQCB(opncb->waireqlst);
3400b690:	687b      	ldr	r3, [r7, #4]
3400b692:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400b694:	3b10      	subs	r3, #16
3400b696:	60bb      	str	r3, [r7, #8]

		/* Device driver call */
		DISABLE_INTERRUPT;
3400b698:	f004 fab3 	bl	3400fc02 <disint>
		knl_ctxtsk->sysmode++;
3400b69c:	4b66      	ldr	r3, [pc, #408]	@ (3400b838 <abort_allrequest+0x1e8>)
3400b69e:	681b      	ldr	r3, [r3, #0]
3400b6a0:	f9b3 2022 	ldrsh.w	r2, [r3, #34]	@ 0x22
3400b6a4:	b292      	uxth	r2, r2
3400b6a6:	3201      	adds	r2, #1
3400b6a8:	b292      	uxth	r2, r2
3400b6aa:	b212      	sxth	r2, r2
3400b6ac:	845a      	strh	r2, [r3, #34]	@ 0x22
		ENABLE_INTERRUPT;
3400b6ae:	2000      	movs	r0, #0
3400b6b0:	f004 fa8b 	bl	3400fbca <set_basepri>
		(*abortfn)(reqcb->tskid, opncb->waireqlst, opncb->nwaireq, exinf);
3400b6b4:	68bb      	ldr	r3, [r7, #8]
3400b6b6:	68d8      	ldr	r0, [r3, #12]
3400b6b8:	687b      	ldr	r3, [r7, #4]
3400b6ba:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
3400b6bc:	687b      	ldr	r3, [r7, #4]
3400b6be:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
3400b6c0:	697c      	ldr	r4, [r7, #20]
3400b6c2:	68fb      	ldr	r3, [r7, #12]
3400b6c4:	47a0      	blx	r4
		DISABLE_INTERRUPT;
3400b6c6:	f004 fa9c 	bl	3400fc02 <disint>
		knl_ctxtsk->sysmode--;
3400b6ca:	4b5b      	ldr	r3, [pc, #364]	@ (3400b838 <abort_allrequest+0x1e8>)
3400b6cc:	681b      	ldr	r3, [r3, #0]
3400b6ce:	f9b3 2022 	ldrsh.w	r2, [r3, #34]	@ 0x22
3400b6d2:	b292      	uxth	r2, r2
3400b6d4:	3a01      	subs	r2, #1
3400b6d6:	b292      	uxth	r2, r2
3400b6d8:	b212      	sxth	r2, r2
3400b6da:	845a      	strh	r2, [r3, #34]	@ 0x22
		ENABLE_INTERRUPT;
3400b6dc:	2000      	movs	r0, #0
3400b6de:	f004 fa74 	bl	3400fbca <set_basepri>

		opncb->abort_cnt++;
3400b6e2:	687b      	ldr	r3, [r7, #4]
3400b6e4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400b6e6:	1c5a      	adds	r2, r3, #1
3400b6e8:	687b      	ldr	r3, [r7, #4]
3400b6ea:	639a      	str	r2, [r3, #56]	@ 0x38
3400b6ec:	e042      	b.n	3400b774 <abort_allrequest+0x124>
	} else {
		/* Start request or single request wait */
		for ( q = opncb->requestq.next; q != &opncb->requestq; q = q->next ) {
3400b6ee:	687b      	ldr	r3, [r7, #4]
3400b6f0:	6a1b      	ldr	r3, [r3, #32]
3400b6f2:	61fb      	str	r3, [r7, #28]
3400b6f4:	e039      	b.n	3400b76a <abort_allrequest+0x11a>
			reqcb = (ReqCB*)q;
3400b6f6:	69fb      	ldr	r3, [r7, #28]
3400b6f8:	60bb      	str	r3, [r7, #8]
			if ( reqcb->tskid == 0 ) {
3400b6fa:	68bb      	ldr	r3, [r7, #8]
3400b6fc:	68db      	ldr	r3, [r3, #12]
3400b6fe:	2b00      	cmp	r3, #0
3400b700:	d02f      	beq.n	3400b762 <abort_allrequest+0x112>
				continue;
			}

			reqcb->req.abort = TRUE;
3400b702:	68ba      	ldr	r2, [r7, #8]
3400b704:	7f13      	ldrb	r3, [r2, #28]
3400b706:	f043 0310 	orr.w	r3, r3, #16
3400b70a:	7713      	strb	r3, [r2, #28]

			/* Device driver call */
			DISABLE_INTERRUPT;
3400b70c:	f004 fa79 	bl	3400fc02 <disint>
			knl_ctxtsk->sysmode++;
3400b710:	4b49      	ldr	r3, [pc, #292]	@ (3400b838 <abort_allrequest+0x1e8>)
3400b712:	681b      	ldr	r3, [r3, #0]
3400b714:	f9b3 2022 	ldrsh.w	r2, [r3, #34]	@ 0x22
3400b718:	b292      	uxth	r2, r2
3400b71a:	3201      	adds	r2, #1
3400b71c:	b292      	uxth	r2, r2
3400b71e:	b212      	sxth	r2, r2
3400b720:	845a      	strh	r2, [r3, #34]	@ 0x22
			ENABLE_INTERRUPT;
3400b722:	2000      	movs	r0, #0
3400b724:	f004 fa51 	bl	3400fbca <set_basepri>
			(*abortfn)(reqcb->tskid, &reqcb->req, 1, exinf);
3400b728:	68bb      	ldr	r3, [r7, #8]
3400b72a:	68d8      	ldr	r0, [r3, #12]
3400b72c:	68bb      	ldr	r3, [r7, #8]
3400b72e:	f103 0110 	add.w	r1, r3, #16
3400b732:	697c      	ldr	r4, [r7, #20]
3400b734:	68fb      	ldr	r3, [r7, #12]
3400b736:	2201      	movs	r2, #1
3400b738:	47a0      	blx	r4
			DISABLE_INTERRUPT;
3400b73a:	f004 fa62 	bl	3400fc02 <disint>
			knl_ctxtsk->sysmode--;
3400b73e:	4b3e      	ldr	r3, [pc, #248]	@ (3400b838 <abort_allrequest+0x1e8>)
3400b740:	681b      	ldr	r3, [r3, #0]
3400b742:	f9b3 2022 	ldrsh.w	r2, [r3, #34]	@ 0x22
3400b746:	b292      	uxth	r2, r2
3400b748:	3a01      	subs	r2, #1
3400b74a:	b292      	uxth	r2, r2
3400b74c:	b212      	sxth	r2, r2
3400b74e:	845a      	strh	r2, [r3, #34]	@ 0x22
			ENABLE_INTERRUPT;
3400b750:	2000      	movs	r0, #0
3400b752:	f004 fa3a 	bl	3400fbca <set_basepri>

			opncb->abort_cnt++;
3400b756:	687b      	ldr	r3, [r7, #4]
3400b758:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400b75a:	1c5a      	adds	r2, r3, #1
3400b75c:	687b      	ldr	r3, [r7, #4]
3400b75e:	639a      	str	r2, [r3, #56]	@ 0x38
3400b760:	e000      	b.n	3400b764 <abort_allrequest+0x114>
				continue;
3400b762:	bf00      	nop
		for ( q = opncb->requestq.next; q != &opncb->requestq; q = q->next ) {
3400b764:	69fb      	ldr	r3, [r7, #28]
3400b766:	681b      	ldr	r3, [r3, #0]
3400b768:	61fb      	str	r3, [r7, #28]
3400b76a:	687b      	ldr	r3, [r7, #4]
3400b76c:	3320      	adds	r3, #32
3400b76e:	69fa      	ldr	r2, [r7, #28]
3400b770:	429a      	cmp	r2, r3
3400b772:	d1c0      	bne.n	3400b6f6 <abort_allrequest+0xa6>
		}
	}

	UnlockDM();
3400b774:	2100      	movs	r1, #0
3400b776:	482f      	ldr	r0, [pc, #188]	@ (3400b834 <abort_allrequest+0x1e4>)
3400b778:	f002 fe63 	bl	3400e442 <MUnlock>

	if ( opncb->abort_cnt > 0 ) {
3400b77c:	687b      	ldr	r3, [r7, #4]
3400b77e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
3400b780:	2b00      	cmp	r3, #0
3400b782:	dd07      	ble.n	3400b794 <abort_allrequest+0x144>
		/* Wait for completion of abort request processing */
		tk_wai_sem(opncb->abort_semid, 1, TMO_FEVR);
3400b784:	687b      	ldr	r3, [r7, #4]
3400b786:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400b788:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
3400b78c:	2101      	movs	r1, #1
3400b78e:	4618      	mov	r0, r3
3400b790:	f001 faca 	bl	3400cd28 <tk_wai_sem>
	}
	opncb->abort_tskid = 0;
3400b794:	687b      	ldr	r3, [r7, #4]
3400b796:	2200      	movs	r2, #0
3400b798:	635a      	str	r2, [r3, #52]	@ 0x34

	/* Abort remaining requests and wait for completion */
	LockDM();
3400b79a:	2100      	movs	r1, #0
3400b79c:	4825      	ldr	r0, [pc, #148]	@ (3400b834 <abort_allrequest+0x1e4>)
3400b79e:	f002 fe40 	bl	3400e422 <MLock>
	while ( !isQueEmpty(&opncb->requestq) ) {
3400b7a2:	e037      	b.n	3400b814 <abort_allrequest+0x1c4>
		reqcb = (ReqCB*)opncb->requestq.next;
3400b7a4:	687b      	ldr	r3, [r7, #4]
3400b7a6:	6a1b      	ldr	r3, [r3, #32]
3400b7a8:	60bb      	str	r3, [r7, #8]
		reqcb->req.abort = TRUE;
3400b7aa:	68ba      	ldr	r2, [r7, #8]
3400b7ac:	7f13      	ldrb	r3, [r2, #28]
3400b7ae:	f043 0310 	orr.w	r3, r3, #16
3400b7b2:	7713      	strb	r3, [r2, #28]

		UnlockDM();
3400b7b4:	2100      	movs	r1, #0
3400b7b6:	481f      	ldr	r0, [pc, #124]	@ (3400b834 <abort_allrequest+0x1e4>)
3400b7b8:	f002 fe43 	bl	3400e442 <MUnlock>

		/* Device driver call */
		DISABLE_INTERRUPT;
3400b7bc:	f004 fa21 	bl	3400fc02 <disint>
		knl_ctxtsk->sysmode++;
3400b7c0:	4b1d      	ldr	r3, [pc, #116]	@ (3400b838 <abort_allrequest+0x1e8>)
3400b7c2:	681b      	ldr	r3, [r3, #0]
3400b7c4:	f9b3 2022 	ldrsh.w	r2, [r3, #34]	@ 0x22
3400b7c8:	b292      	uxth	r2, r2
3400b7ca:	3201      	adds	r2, #1
3400b7cc:	b292      	uxth	r2, r2
3400b7ce:	b212      	sxth	r2, r2
3400b7d0:	845a      	strh	r2, [r3, #34]	@ 0x22
		ENABLE_INTERRUPT;
3400b7d2:	2000      	movs	r0, #0
3400b7d4:	f004 f9f9 	bl	3400fbca <set_basepri>
		(*waitfn)(&reqcb->req, 1, TMO_FEVR, exinf);
3400b7d8:	68bb      	ldr	r3, [r7, #8]
3400b7da:	f103 0010 	add.w	r0, r3, #16
3400b7de:	693c      	ldr	r4, [r7, #16]
3400b7e0:	68fb      	ldr	r3, [r7, #12]
3400b7e2:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
3400b7e6:	2101      	movs	r1, #1
3400b7e8:	47a0      	blx	r4
		DISABLE_INTERRUPT;
3400b7ea:	f004 fa0a 	bl	3400fc02 <disint>
		knl_ctxtsk->sysmode--;
3400b7ee:	4b12      	ldr	r3, [pc, #72]	@ (3400b838 <abort_allrequest+0x1e8>)
3400b7f0:	681b      	ldr	r3, [r3, #0]
3400b7f2:	f9b3 2022 	ldrsh.w	r2, [r3, #34]	@ 0x22
3400b7f6:	b292      	uxth	r2, r2
3400b7f8:	3a01      	subs	r2, #1
3400b7fa:	b292      	uxth	r2, r2
3400b7fc:	b212      	sxth	r2, r2
3400b7fe:	845a      	strh	r2, [r3, #34]	@ 0x22
		ENABLE_INTERRUPT;
3400b800:	2000      	movs	r0, #0
3400b802:	f004 f9e2 	bl	3400fbca <set_basepri>

		LockDM();
3400b806:	2100      	movs	r1, #0
3400b808:	480a      	ldr	r0, [pc, #40]	@ (3400b834 <abort_allrequest+0x1e4>)
3400b80a:	f002 fe0a 	bl	3400e422 <MLock>

		/* Unregister completed request */
		knl_delReqCB(reqcb);
3400b80e:	68b8      	ldr	r0, [r7, #8]
3400b810:	f7ff fee8 	bl	3400b5e4 <knl_delReqCB>
	while ( !isQueEmpty(&opncb->requestq) ) {
3400b814:	687b      	ldr	r3, [r7, #4]
3400b816:	3320      	adds	r3, #32
3400b818:	4618      	mov	r0, r3
3400b81a:	f7ff fe7f 	bl	3400b51c <isQueEmpty>
3400b81e:	4603      	mov	r3, r0
3400b820:	2b00      	cmp	r3, #0
3400b822:	d0bf      	beq.n	3400b7a4 <abort_allrequest+0x154>
	}
	UnlockDM();
3400b824:	2100      	movs	r1, #0
3400b826:	4803      	ldr	r0, [pc, #12]	@ (3400b834 <abort_allrequest+0x1e4>)
3400b828:	f002 fe0b 	bl	3400e442 <MUnlock>
}
3400b82c:	bf00      	nop
3400b82e:	3724      	adds	r7, #36	@ 0x24
3400b830:	46bd      	mov	sp, r7
3400b832:	bd90      	pop	{r4, r7, pc}
3400b834:	34011530 	.word	0x34011530
3400b838:	34012800 	.word	0x34012800

3400b83c <knl_close_device>:

/*
 * Device close processing
 */
EXPORT ER knl_close_device( OpnCB *opncb, UINT option )
{
3400b83c:	b580      	push	{r7, lr}
3400b83e:	b088      	sub	sp, #32
3400b840:	af00      	add	r7, sp, #0
3400b842:	6078      	str	r0, [r7, #4]
3400b844:	6039      	str	r1, [r7, #0]
	CLSFN	closefn;
	void	*exinf;
	ID	devid;
	DevCB	*devcb;
	INT	unitno;
	ER	ercd = E_OK;
3400b846:	2300      	movs	r3, #0
3400b848:	61bb      	str	r3, [r7, #24]

	/* Abort all requests during processing */
	abort_allrequest(opncb);
3400b84a:	6878      	ldr	r0, [r7, #4]
3400b84c:	f7ff ff00 	bl	3400b650 <abort_allrequest>

	LockDM();
3400b850:	2100      	movs	r1, #0
3400b852:	4839      	ldr	r0, [pc, #228]	@ (3400b938 <knl_close_device+0xfc>)
3400b854:	f002 fde5 	bl	3400e422 <MLock>

	devcb  = opncb->devcb;
3400b858:	687b      	ldr	r3, [r7, #4]
3400b85a:	695b      	ldr	r3, [r3, #20]
3400b85c:	617b      	str	r3, [r7, #20]
	unitno = opncb->unitno;
3400b85e:	687b      	ldr	r3, [r7, #4]
3400b860:	699b      	ldr	r3, [r3, #24]
3400b862:	613b      	str	r3, [r7, #16]
	closefn = (CLSFN)devcb->ddev.closefn;
3400b864:	697b      	ldr	r3, [r7, #20]
3400b866:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400b868:	61fb      	str	r3, [r7, #28]
	exinf = devcb->ddev.exinf;
3400b86a:	697b      	ldr	r3, [r7, #20]
3400b86c:	695b      	ldr	r3, [r3, #20]
3400b86e:	60fb      	str	r3, [r7, #12]
	devid = DEVID(devcb, unitno);
3400b870:	697b      	ldr	r3, [r7, #20]
3400b872:	4a32      	ldr	r2, [pc, #200]	@ (3400b93c <knl_close_device+0x100>)
3400b874:	1a9b      	subs	r3, r3, r2
3400b876:	10db      	asrs	r3, r3, #3
3400b878:	4a31      	ldr	r2, [pc, #196]	@ (3400b940 <knl_close_device+0x104>)
3400b87a:	fb02 f303 	mul.w	r3, r2, r3
3400b87e:	3301      	adds	r3, #1
3400b880:	021b      	lsls	r3, r3, #8
3400b882:	693a      	ldr	r2, [r7, #16]
3400b884:	4413      	add	r3, r2
3400b886:	60bb      	str	r3, [r7, #8]

	/* Delete semaphore for completion check of abortion */
	tk_del_sem(opncb->abort_semid);
3400b888:	687b      	ldr	r3, [r7, #4]
3400b88a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400b88c:	4618      	mov	r0, r3
3400b88e:	f001 f923 	bl	3400cad8 <tk_del_sem>

	/* Free open management block */
	knl_delOpnCB(opncb, FALSE);
3400b892:	2100      	movs	r1, #0
3400b894:	6878      	ldr	r0, [r7, #4]
3400b896:	f7ff fe85 	bl	3400b5a4 <knl_delOpnCB>

	/* Is device driver call required? */
	if ( knl_chkopen(devcb, unitno) ) {
3400b89a:	6939      	ldr	r1, [r7, #16]
3400b89c:	6978      	ldr	r0, [r7, #20]
3400b89e:	f7ff feb7 	bl	3400b610 <knl_chkopen>
3400b8a2:	4603      	mov	r3, r0
3400b8a4:	2b00      	cmp	r3, #0
3400b8a6:	d00b      	beq.n	3400b8c0 <knl_close_device+0x84>
		option &= ~TD_EJECT;
3400b8a8:	683b      	ldr	r3, [r7, #0]
3400b8aa:	f023 0301 	bic.w	r3, r3, #1
3400b8ae:	603b      	str	r3, [r7, #0]
		if ( (devcb->ddev.drvatr & TDA_OPENREQ) == 0 ) {
3400b8b0:	697b      	ldr	r3, [r7, #20]
3400b8b2:	699b      	ldr	r3, [r3, #24]
3400b8b4:	f003 0301 	and.w	r3, r3, #1
3400b8b8:	2b00      	cmp	r3, #0
3400b8ba:	d101      	bne.n	3400b8c0 <knl_close_device+0x84>
			closefn = NULL;
3400b8bc:	2300      	movs	r3, #0
3400b8be:	61fb      	str	r3, [r7, #28]
		}
	}

	UnlockDM();
3400b8c0:	2100      	movs	r1, #0
3400b8c2:	481d      	ldr	r0, [pc, #116]	@ (3400b938 <knl_close_device+0xfc>)
3400b8c4:	f002 fdbd 	bl	3400e442 <MUnlock>

	if ( closefn != NULL ) {
3400b8c8:	69fb      	ldr	r3, [r7, #28]
3400b8ca:	2b00      	cmp	r3, #0
3400b8cc:	d021      	beq.n	3400b912 <knl_close_device+0xd6>
		/* Device driver call */
		DISABLE_INTERRUPT;
3400b8ce:	f004 f998 	bl	3400fc02 <disint>
		knl_ctxtsk->sysmode++;
3400b8d2:	4b1c      	ldr	r3, [pc, #112]	@ (3400b944 <knl_close_device+0x108>)
3400b8d4:	681b      	ldr	r3, [r3, #0]
3400b8d6:	f9b3 2022 	ldrsh.w	r2, [r3, #34]	@ 0x22
3400b8da:	b292      	uxth	r2, r2
3400b8dc:	3201      	adds	r2, #1
3400b8de:	b292      	uxth	r2, r2
3400b8e0:	b212      	sxth	r2, r2
3400b8e2:	845a      	strh	r2, [r3, #34]	@ 0x22
		ENABLE_INTERRUPT;
3400b8e4:	2000      	movs	r0, #0
3400b8e6:	f004 f970 	bl	3400fbca <set_basepri>
		ercd = (*closefn)(devid, option, exinf);
3400b8ea:	69fb      	ldr	r3, [r7, #28]
3400b8ec:	68fa      	ldr	r2, [r7, #12]
3400b8ee:	6839      	ldr	r1, [r7, #0]
3400b8f0:	68b8      	ldr	r0, [r7, #8]
3400b8f2:	4798      	blx	r3
3400b8f4:	61b8      	str	r0, [r7, #24]
		DISABLE_INTERRUPT;
3400b8f6:	f004 f984 	bl	3400fc02 <disint>
		knl_ctxtsk->sysmode--;
3400b8fa:	4b12      	ldr	r3, [pc, #72]	@ (3400b944 <knl_close_device+0x108>)
3400b8fc:	681b      	ldr	r3, [r3, #0]
3400b8fe:	f9b3 2022 	ldrsh.w	r2, [r3, #34]	@ 0x22
3400b902:	b292      	uxth	r2, r2
3400b904:	3a01      	subs	r2, #1
3400b906:	b292      	uxth	r2, r2
3400b908:	b212      	sxth	r2, r2
3400b90a:	845a      	strh	r2, [r3, #34]	@ 0x22
		ENABLE_INTERRUPT;
3400b90c:	2000      	movs	r0, #0
3400b90e:	f004 f95c 	bl	3400fbca <set_basepri>
	}

	LockDM();
3400b912:	2100      	movs	r1, #0
3400b914:	4808      	ldr	r0, [pc, #32]	@ (3400b938 <knl_close_device+0xfc>)
3400b916:	f002 fd84 	bl	3400e422 <MLock>
	/* Return open management block to FreeQue */
	QueInsert(&opncb->q, &knl_FreeOpnCB);
3400b91a:	687b      	ldr	r3, [r7, #4]
3400b91c:	490a      	ldr	r1, [pc, #40]	@ (3400b948 <knl_close_device+0x10c>)
3400b91e:	4618      	mov	r0, r3
3400b920:	f7ff fe0e 	bl	3400b540 <QueInsert>
	UnlockDM();
3400b924:	2100      	movs	r1, #0
3400b926:	4804      	ldr	r0, [pc, #16]	@ (3400b938 <knl_close_device+0xfc>)
3400b928:	f002 fd8b 	bl	3400e442 <MUnlock>

	return ercd;
3400b92c:	69bb      	ldr	r3, [r7, #24]
}
3400b92e:	4618      	mov	r0, r3
3400b930:	3720      	adds	r7, #32
3400b932:	46bd      	mov	sp, r7
3400b934:	bd80      	pop	{r7, pc}
3400b936:	bf00      	nop
3400b938:	34011530 	.word	0x34011530
3400b93c:	34011544 	.word	0x34011544
3400b940:	38e38e39 	.word	0x38e38e39
3400b944:	34012800 	.word	0x34012800
3400b948:	34011b94 	.word	0x34011b94

3400b94c <knl_devmgr_startup>:

/*
 * Device management startup function
 */
EXPORT void knl_devmgr_startup( void )
{
3400b94c:	b580      	push	{r7, lr}
3400b94e:	af00      	add	r7, sp, #0
	LockDM();
3400b950:	2100      	movs	r1, #0
3400b952:	4807      	ldr	r0, [pc, #28]	@ (3400b970 <knl_devmgr_startup+0x24>)
3400b954:	f002 fd65 	bl	3400e422 <MLock>

	/* Initialization of open device management queue */
	QueInit(&(knl_resource_control_block.openq));
3400b958:	4806      	ldr	r0, [pc, #24]	@ (3400b974 <knl_devmgr_startup+0x28>)
3400b95a:	f7ff fdcf 	bl	3400b4fc <QueInit>
	knl_resource_control_block.dissus = 0;
3400b95e:	4b05      	ldr	r3, [pc, #20]	@ (3400b974 <knl_devmgr_startup+0x28>)
3400b960:	2200      	movs	r2, #0
3400b962:	609a      	str	r2, [r3, #8]
	
	UnlockDM();
3400b964:	2100      	movs	r1, #0
3400b966:	4802      	ldr	r0, [pc, #8]	@ (3400b970 <knl_devmgr_startup+0x24>)
3400b968:	f002 fd6b 	bl	3400e442 <MUnlock>

	return;
3400b96c:	bf00      	nop
}
3400b96e:	bd80      	pop	{r7, pc}
3400b970:	34011530 	.word	0x34011530
3400b974:	34011ee4 	.word	0x34011ee4

3400b978 <knl_devmgr_cleanup>:

/*
 * Device management cleanup function
 */
EXPORT void knl_devmgr_cleanup( void )
{
3400b978:	b580      	push	{r7, lr}
3400b97a:	b082      	sub	sp, #8
3400b97c:	af00      	add	r7, sp, #0
	OpnCB	*opncb;

	/* Do nothing if it is not used even once */
	if ( knl_resource_control_block.openq.next == NULL ) {
3400b97e:	4b1a      	ldr	r3, [pc, #104]	@ (3400b9e8 <knl_devmgr_cleanup+0x70>)
3400b980:	681b      	ldr	r3, [r3, #0]
3400b982:	2b00      	cmp	r3, #0
3400b984:	d02c      	beq.n	3400b9e0 <knl_devmgr_cleanup+0x68>
		return;
	}

	LockDM();
3400b986:	2100      	movs	r1, #0
3400b988:	4818      	ldr	r0, [pc, #96]	@ (3400b9ec <knl_devmgr_cleanup+0x74>)
3400b98a:	f002 fd4a 	bl	3400e422 <MLock>

	/* Free suspend disable request */
	knl_DisSusCnt -= knl_resource_control_block.dissus;
3400b98e:	4b18      	ldr	r3, [pc, #96]	@ (3400b9f0 <knl_devmgr_cleanup+0x78>)
3400b990:	681a      	ldr	r2, [r3, #0]
3400b992:	4b15      	ldr	r3, [pc, #84]	@ (3400b9e8 <knl_devmgr_cleanup+0x70>)
3400b994:	689b      	ldr	r3, [r3, #8]
3400b996:	1ad3      	subs	r3, r2, r3
3400b998:	4a15      	ldr	r2, [pc, #84]	@ (3400b9f0 <knl_devmgr_cleanup+0x78>)
3400b99a:	6013      	str	r3, [r2, #0]
	knl_resource_control_block.dissus = 0;
3400b99c:	4b12      	ldr	r3, [pc, #72]	@ (3400b9e8 <knl_devmgr_cleanup+0x70>)
3400b99e:	2200      	movs	r2, #0
3400b9a0:	609a      	str	r2, [r3, #8]

	/* Close all open devices */
	while ( !isQueEmpty(&(knl_resource_control_block.openq)) ) {
3400b9a2:	e012      	b.n	3400b9ca <knl_devmgr_cleanup+0x52>
		opncb = RESQ_OPNCB(knl_resource_control_block.openq.next);
3400b9a4:	4b10      	ldr	r3, [pc, #64]	@ (3400b9e8 <knl_devmgr_cleanup+0x70>)
3400b9a6:	681b      	ldr	r3, [r3, #0]
3400b9a8:	3b08      	subs	r3, #8
3400b9aa:	607b      	str	r3, [r7, #4]

		/* Indicate that it is during close processing */
		opncb->resid = 0;
3400b9ac:	687b      	ldr	r3, [r7, #4]
3400b9ae:	2200      	movs	r2, #0
3400b9b0:	611a      	str	r2, [r3, #16]

		UnlockDM();
3400b9b2:	2100      	movs	r1, #0
3400b9b4:	480d      	ldr	r0, [pc, #52]	@ (3400b9ec <knl_devmgr_cleanup+0x74>)
3400b9b6:	f002 fd44 	bl	3400e442 <MUnlock>

		/* Device close processing */
		knl_close_device(opncb, 0);
3400b9ba:	2100      	movs	r1, #0
3400b9bc:	6878      	ldr	r0, [r7, #4]
3400b9be:	f7ff ff3d 	bl	3400b83c <knl_close_device>

		LockDM();
3400b9c2:	2100      	movs	r1, #0
3400b9c4:	4809      	ldr	r0, [pc, #36]	@ (3400b9ec <knl_devmgr_cleanup+0x74>)
3400b9c6:	f002 fd2c 	bl	3400e422 <MLock>
	while ( !isQueEmpty(&(knl_resource_control_block.openq)) ) {
3400b9ca:	4807      	ldr	r0, [pc, #28]	@ (3400b9e8 <knl_devmgr_cleanup+0x70>)
3400b9cc:	f7ff fda6 	bl	3400b51c <isQueEmpty>
3400b9d0:	4603      	mov	r3, r0
3400b9d2:	2b00      	cmp	r3, #0
3400b9d4:	d0e6      	beq.n	3400b9a4 <knl_devmgr_cleanup+0x2c>
	}
	UnlockDM();
3400b9d6:	2100      	movs	r1, #0
3400b9d8:	4804      	ldr	r0, [pc, #16]	@ (3400b9ec <knl_devmgr_cleanup+0x74>)
3400b9da:	f002 fd32 	bl	3400e442 <MUnlock>

	return;
3400b9de:	e000      	b.n	3400b9e2 <knl_devmgr_cleanup+0x6a>
		return;
3400b9e0:	bf00      	nop
}
3400b9e2:	3708      	adds	r7, #8
3400b9e4:	46bd      	mov	sp, r7
3400b9e6:	bd80      	pop	{r7, pc}
3400b9e8:	34011ee4 	.word	0x34011ee4
3400b9ec:	34011530 	.word	0x34011530
3400b9f0:	340113e0 	.word	0x340113e0

3400b9f4 <knl_initDevIO>:

/*
 * Initialization sequence of device input/output-related
 */
EXPORT ER knl_initDevIO( void )
{
3400b9f4:	b580      	push	{r7, lr}
3400b9f6:	b082      	sub	sp, #8
3400b9f8:	af00      	add	r7, sp, #0
	INT	i;

	QueInit(&knl_FreeOpnCB);
3400b9fa:	481f      	ldr	r0, [pc, #124]	@ (3400ba78 <knl_initDevIO+0x84>)
3400b9fc:	f7ff fd7e 	bl	3400b4fc <QueInit>
	for ( i = 0; i < MAX_OPNDEV; ++i ) {
3400ba00:	2300      	movs	r3, #0
3400ba02:	607b      	str	r3, [r7, #4]
3400ba04:	e011      	b.n	3400ba2a <knl_initDevIO+0x36>
		knl_OpnCBtbl[i].resid = 0;
3400ba06:	4a1d      	ldr	r2, [pc, #116]	@ (3400ba7c <knl_initDevIO+0x88>)
3400ba08:	687b      	ldr	r3, [r7, #4]
3400ba0a:	019b      	lsls	r3, r3, #6
3400ba0c:	4413      	add	r3, r2
3400ba0e:	3310      	adds	r3, #16
3400ba10:	2200      	movs	r2, #0
3400ba12:	601a      	str	r2, [r3, #0]
		QueInsert(&knl_OpnCBtbl[i].q, &knl_FreeOpnCB);
3400ba14:	687b      	ldr	r3, [r7, #4]
3400ba16:	019b      	lsls	r3, r3, #6
3400ba18:	4a18      	ldr	r2, [pc, #96]	@ (3400ba7c <knl_initDevIO+0x88>)
3400ba1a:	4413      	add	r3, r2
3400ba1c:	4916      	ldr	r1, [pc, #88]	@ (3400ba78 <knl_initDevIO+0x84>)
3400ba1e:	4618      	mov	r0, r3
3400ba20:	f7ff fd8e 	bl	3400b540 <QueInsert>
	for ( i = 0; i < MAX_OPNDEV; ++i ) {
3400ba24:	687b      	ldr	r3, [r7, #4]
3400ba26:	3301      	adds	r3, #1
3400ba28:	607b      	str	r3, [r7, #4]
3400ba2a:	687b      	ldr	r3, [r7, #4]
3400ba2c:	2b0f      	cmp	r3, #15
3400ba2e:	ddea      	ble.n	3400ba06 <knl_initDevIO+0x12>
	}

	QueInit(&knl_FreeReqCB);
3400ba30:	4813      	ldr	r0, [pc, #76]	@ (3400ba80 <knl_initDevIO+0x8c>)
3400ba32:	f7ff fd63 	bl	3400b4fc <QueInit>
	for ( i = 0; i < MAX_REQDEV; ++i ) {
3400ba36:	2300      	movs	r3, #0
3400ba38:	607b      	str	r3, [r7, #4]
3400ba3a:	e015      	b.n	3400ba68 <knl_initDevIO+0x74>
		knl_ReqCBtbl[i].opncb = NULL;
3400ba3c:	4a11      	ldr	r2, [pc, #68]	@ (3400ba84 <knl_initDevIO+0x90>)
3400ba3e:	687b      	ldr	r3, [r7, #4]
3400ba40:	2134      	movs	r1, #52	@ 0x34
3400ba42:	fb01 f303 	mul.w	r3, r1, r3
3400ba46:	4413      	add	r3, r2
3400ba48:	3308      	adds	r3, #8
3400ba4a:	2200      	movs	r2, #0
3400ba4c:	601a      	str	r2, [r3, #0]
		QueInsert(&knl_ReqCBtbl[i].q, &knl_FreeReqCB);
3400ba4e:	687b      	ldr	r3, [r7, #4]
3400ba50:	2234      	movs	r2, #52	@ 0x34
3400ba52:	fb02 f303 	mul.w	r3, r2, r3
3400ba56:	4a0b      	ldr	r2, [pc, #44]	@ (3400ba84 <knl_initDevIO+0x90>)
3400ba58:	4413      	add	r3, r2
3400ba5a:	4909      	ldr	r1, [pc, #36]	@ (3400ba80 <knl_initDevIO+0x8c>)
3400ba5c:	4618      	mov	r0, r3
3400ba5e:	f7ff fd6f 	bl	3400b540 <QueInsert>
	for ( i = 0; i < MAX_REQDEV; ++i ) {
3400ba62:	687b      	ldr	r3, [r7, #4]
3400ba64:	3301      	adds	r3, #1
3400ba66:	607b      	str	r3, [r7, #4]
3400ba68:	687b      	ldr	r3, [r7, #4]
3400ba6a:	2b0f      	cmp	r3, #15
3400ba6c:	dde6      	ble.n	3400ba3c <knl_initDevIO+0x48>
	}

	return E_OK;
3400ba6e:	2300      	movs	r3, #0
}
3400ba70:	4618      	mov	r0, r3
3400ba72:	3708      	adds	r7, #8
3400ba74:	46bd      	mov	sp, r7
3400ba76:	bd80      	pop	{r7, pc}
3400ba78:	34011b94 	.word	0x34011b94
3400ba7c:	34011794 	.word	0x34011794
3400ba80:	34011edc 	.word	0x34011edc
3400ba84:	34011b9c 	.word	0x34011b9c

3400ba88 <knl_finishDevIO>:

/*
 * Finalization sequence of device input/output-related
 */
EXPORT ER knl_finishDevIO( void )
{
3400ba88:	b480      	push	{r7}
3400ba8a:	af00      	add	r7, sp, #0
	return E_OK;
3400ba8c:	2300      	movs	r3, #0
}
3400ba8e:	4618      	mov	r0, r3
3400ba90:	46bd      	mov	sp, r7
3400ba92:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ba96:	4770      	bx	lr

3400ba98 <QueInit>:
{
3400ba98:	b480      	push	{r7}
3400ba9a:	b083      	sub	sp, #12
3400ba9c:	af00      	add	r7, sp, #0
3400ba9e:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400baa0:	687b      	ldr	r3, [r7, #4]
3400baa2:	687a      	ldr	r2, [r7, #4]
3400baa4:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400baa6:	687b      	ldr	r3, [r7, #4]
3400baa8:	687a      	ldr	r2, [r7, #4]
3400baaa:	605a      	str	r2, [r3, #4]
}
3400baac:	bf00      	nop
3400baae:	370c      	adds	r7, #12
3400bab0:	46bd      	mov	sp, r7
3400bab2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400bab6:	4770      	bx	lr

3400bab8 <isQueEmpty>:
{
3400bab8:	b480      	push	{r7}
3400baba:	b083      	sub	sp, #12
3400babc:	af00      	add	r7, sp, #0
3400babe:	6078      	str	r0, [r7, #4]
	return ( que->next == que )? TRUE: FALSE;
3400bac0:	687b      	ldr	r3, [r7, #4]
3400bac2:	681b      	ldr	r3, [r3, #0]
3400bac4:	687a      	ldr	r2, [r7, #4]
3400bac6:	429a      	cmp	r2, r3
3400bac8:	bf0c      	ite	eq
3400baca:	2301      	moveq	r3, #1
3400bacc:	2300      	movne	r3, #0
3400bace:	b2db      	uxtb	r3, r3
}
3400bad0:	4618      	mov	r0, r3
3400bad2:	370c      	adds	r7, #12
3400bad4:	46bd      	mov	sp, r7
3400bad6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400bada:	4770      	bx	lr

3400badc <QueInsert>:
{
3400badc:	b480      	push	{r7}
3400bade:	b083      	sub	sp, #12
3400bae0:	af00      	add	r7, sp, #0
3400bae2:	6078      	str	r0, [r7, #4]
3400bae4:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400bae6:	683b      	ldr	r3, [r7, #0]
3400bae8:	685a      	ldr	r2, [r3, #4]
3400baea:	687b      	ldr	r3, [r7, #4]
3400baec:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400baee:	687b      	ldr	r3, [r7, #4]
3400baf0:	683a      	ldr	r2, [r7, #0]
3400baf2:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400baf4:	683b      	ldr	r3, [r7, #0]
3400baf6:	685b      	ldr	r3, [r3, #4]
3400baf8:	687a      	ldr	r2, [r7, #4]
3400bafa:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400bafc:	683b      	ldr	r3, [r7, #0]
3400bafe:	687a      	ldr	r2, [r7, #4]
3400bb00:	605a      	str	r2, [r3, #4]
}
3400bb02:	bf00      	nop
3400bb04:	370c      	adds	r7, #12
3400bb06:	46bd      	mov	sp, r7
3400bb08:	f85d 7b04 	ldr.w	r7, [sp], #4
3400bb0c:	4770      	bx	lr

3400bb0e <QueRemoveNext>:
{
3400bb0e:	b480      	push	{r7}
3400bb10:	b085      	sub	sp, #20
3400bb12:	af00      	add	r7, sp, #0
3400bb14:	6078      	str	r0, [r7, #4]
	if ( que->next == que ) {
3400bb16:	687b      	ldr	r3, [r7, #4]
3400bb18:	681b      	ldr	r3, [r3, #0]
3400bb1a:	687a      	ldr	r2, [r7, #4]
3400bb1c:	429a      	cmp	r2, r3
3400bb1e:	d101      	bne.n	3400bb24 <QueRemoveNext+0x16>
		return NULL;
3400bb20:	2300      	movs	r3, #0
3400bb22:	e00b      	b.n	3400bb3c <QueRemoveNext+0x2e>
	entry = que->next;
3400bb24:	687b      	ldr	r3, [r7, #4]
3400bb26:	681b      	ldr	r3, [r3, #0]
3400bb28:	60fb      	str	r3, [r7, #12]
	que->next = (struct queue*)entry->next;
3400bb2a:	68fb      	ldr	r3, [r7, #12]
3400bb2c:	681a      	ldr	r2, [r3, #0]
3400bb2e:	687b      	ldr	r3, [r7, #4]
3400bb30:	601a      	str	r2, [r3, #0]
	entry->next->prev = que;
3400bb32:	68fb      	ldr	r3, [r7, #12]
3400bb34:	681b      	ldr	r3, [r3, #0]
3400bb36:	687a      	ldr	r2, [r7, #4]
3400bb38:	605a      	str	r2, [r3, #4]
	return entry;
3400bb3a:	68fb      	ldr	r3, [r7, #12]
}
3400bb3c:	4618      	mov	r0, r3
3400bb3e:	3714      	adds	r7, #20
3400bb40:	46bd      	mov	sp, r7
3400bb42:	f85d 7b04 	ldr.w	r7, [sp], #4
3400bb46:	4770      	bx	lr

3400bb48 <knl_isTaskIndependent>:

/*
 * If it is the task-independent part, TRUE
 */
Inline BOOL knl_isTaskIndependent( void )
{
3400bb48:	b480      	push	{r7}
3400bb4a:	af00      	add	r7, sp, #0
	return ( knl_taskindp > 0 )? TRUE: FALSE;
3400bb4c:	4b05      	ldr	r3, [pc, #20]	@ (3400bb64 <knl_isTaskIndependent+0x1c>)
3400bb4e:	681b      	ldr	r3, [r3, #0]
3400bb50:	2b00      	cmp	r3, #0
3400bb52:	bfcc      	ite	gt
3400bb54:	2301      	movgt	r3, #1
3400bb56:	2300      	movle	r3, #0
3400bb58:	b2db      	uxtb	r3, r3
}
3400bb5a:	4618      	mov	r0, r3
3400bb5c:	46bd      	mov	sp, r7
3400bb5e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400bb62:	4770      	bx	lr
3400bb64:	340114e8 	.word	0x340114e8

3400bb68 <knl_eventflag_cond>:

/*
 * Check for event flag wait release condition
 */
Inline BOOL knl_eventflag_cond( FLGCB *flgcb, UINT waiptn, UINT wfmode )
{
3400bb68:	b480      	push	{r7}
3400bb6a:	b085      	sub	sp, #20
3400bb6c:	af00      	add	r7, sp, #0
3400bb6e:	60f8      	str	r0, [r7, #12]
3400bb70:	60b9      	str	r1, [r7, #8]
3400bb72:	607a      	str	r2, [r7, #4]
	if ( (wfmode & TWF_ORW) != 0 ) {
3400bb74:	687b      	ldr	r3, [r7, #4]
3400bb76:	f003 0301 	and.w	r3, r3, #1
3400bb7a:	2b00      	cmp	r3, #0
3400bb7c:	d009      	beq.n	3400bb92 <knl_eventflag_cond+0x2a>
		return ( (flgcb->flgptn & waiptn) != 0 );
3400bb7e:	68fb      	ldr	r3, [r7, #12]
3400bb80:	695a      	ldr	r2, [r3, #20]
3400bb82:	68bb      	ldr	r3, [r7, #8]
3400bb84:	4013      	ands	r3, r2
3400bb86:	2b00      	cmp	r3, #0
3400bb88:	bf14      	ite	ne
3400bb8a:	2301      	movne	r3, #1
3400bb8c:	2300      	moveq	r3, #0
3400bb8e:	b2db      	uxtb	r3, r3
3400bb90:	e009      	b.n	3400bba6 <knl_eventflag_cond+0x3e>
	} else {
		return ( (flgcb->flgptn & waiptn) == waiptn );
3400bb92:	68fb      	ldr	r3, [r7, #12]
3400bb94:	695a      	ldr	r2, [r3, #20]
3400bb96:	68bb      	ldr	r3, [r7, #8]
3400bb98:	4013      	ands	r3, r2
3400bb9a:	68ba      	ldr	r2, [r7, #8]
3400bb9c:	429a      	cmp	r2, r3
3400bb9e:	bf0c      	ite	eq
3400bba0:	2301      	moveq	r3, #1
3400bba2:	2300      	movne	r3, #0
3400bba4:	b2db      	uxtb	r3, r3
	}
}
3400bba6:	4618      	mov	r0, r3
3400bba8:	3714      	adds	r7, #20
3400bbaa:	46bd      	mov	sp, r7
3400bbac:	f85d 7b04 	ldr.w	r7, [sp], #4
3400bbb0:	4770      	bx	lr
	...

3400bbb4 <knl_eventflag_initialize>:

/*
 * Initialization of event flag control block 
 */
EXPORT ER knl_eventflag_initialize( void )
{
3400bbb4:	b580      	push	{r7, lr}
3400bbb6:	b082      	sub	sp, #8
3400bbb8:	af00      	add	r7, sp, #0
	if ( NUM_FLGID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_flgcb);
3400bbba:	480e      	ldr	r0, [pc, #56]	@ (3400bbf4 <knl_eventflag_initialize+0x40>)
3400bbbc:	f7ff ff6c 	bl	3400ba98 <QueInit>
	end = knl_flgcb_table + NUM_FLGID;
3400bbc0:	4b0d      	ldr	r3, [pc, #52]	@ (3400bbf8 <knl_eventflag_initialize+0x44>)
3400bbc2:	603b      	str	r3, [r7, #0]
	for ( flgcb = knl_flgcb_table; flgcb < end; flgcb++ ) {
3400bbc4:	4b0d      	ldr	r3, [pc, #52]	@ (3400bbfc <knl_eventflag_initialize+0x48>)
3400bbc6:	607b      	str	r3, [r7, #4]
3400bbc8:	e00a      	b.n	3400bbe0 <knl_eventflag_initialize+0x2c>
		flgcb->flgid = 0;
3400bbca:	687b      	ldr	r3, [r7, #4]
3400bbcc:	2200      	movs	r2, #0
3400bbce:	609a      	str	r2, [r3, #8]
		QueInsert(&flgcb->wait_queue, &knl_free_flgcb);
3400bbd0:	687b      	ldr	r3, [r7, #4]
3400bbd2:	4908      	ldr	r1, [pc, #32]	@ (3400bbf4 <knl_eventflag_initialize+0x40>)
3400bbd4:	4618      	mov	r0, r3
3400bbd6:	f7ff ff81 	bl	3400badc <QueInsert>
	for ( flgcb = knl_flgcb_table; flgcb < end; flgcb++ ) {
3400bbda:	687b      	ldr	r3, [r7, #4]
3400bbdc:	3318      	adds	r3, #24
3400bbde:	607b      	str	r3, [r7, #4]
3400bbe0:	687a      	ldr	r2, [r7, #4]
3400bbe2:	683b      	ldr	r3, [r7, #0]
3400bbe4:	429a      	cmp	r2, r3
3400bbe6:	d3f0      	bcc.n	3400bbca <knl_eventflag_initialize+0x16>
	}

	return E_OK;
3400bbe8:	2300      	movs	r3, #0
}
3400bbea:	4618      	mov	r0, r3
3400bbec:	3708      	adds	r7, #8
3400bbee:	46bd      	mov	sp, r7
3400bbf0:	bd80      	pop	{r7, pc}
3400bbf2:	bf00      	nop
3400bbf4:	34012070 	.word	0x34012070
3400bbf8:	34012070 	.word	0x34012070
3400bbfc:	34011ef0 	.word	0x34011ef0

3400bc00 <tk_cre_flg>:

/*
 * Create event flag
 */
SYSCALL ID tk_cre_flg( CONST T_CFLG *pk_cflg )
{
3400bc00:	b580      	push	{r7, lr}
3400bc02:	b088      	sub	sp, #32
3400bc04:	af00      	add	r7, sp, #0
3400bc06:	6078      	str	r0, [r7, #4]
#if CHK_RSATR
	const ATR VALID_FLGATR = {
3400bc08:	2309      	movs	r3, #9
3400bc0a:	61bb      	str	r3, [r7, #24]
#endif
	FLGCB	*flgcb;
	ID	flgid;
	ER	ercd;

	CHECK_RSATR(pk_cflg->flgatr, VALID_FLGATR);
3400bc0c:	687b      	ldr	r3, [r7, #4]
3400bc0e:	685a      	ldr	r2, [r3, #4]
3400bc10:	69bb      	ldr	r3, [r7, #24]
3400bc12:	43db      	mvns	r3, r3
3400bc14:	4013      	ands	r3, r2
3400bc16:	2b00      	cmp	r3, #0
3400bc18:	d002      	beq.n	3400bc20 <tk_cre_flg+0x20>
3400bc1a:	f06f 030a 	mvn.w	r3, #10
3400bc1e:	e03e      	b.n	3400bc9e <tk_cre_flg+0x9e>

	BEGIN_CRITICAL_SECTION;
3400bc20:	f003 ffef 	bl	3400fc02 <disint>
3400bc24:	6178      	str	r0, [r7, #20]
	/* Get control block from FreeQue */
	flgcb = (FLGCB*)QueRemoveNext(&knl_free_flgcb);
3400bc26:	4820      	ldr	r0, [pc, #128]	@ (3400bca8 <tk_cre_flg+0xa8>)
3400bc28:	f7ff ff71 	bl	3400bb0e <QueRemoveNext>
3400bc2c:	6138      	str	r0, [r7, #16]
	if ( flgcb == NULL ) {
3400bc2e:	693b      	ldr	r3, [r7, #16]
3400bc30:	2b00      	cmp	r3, #0
3400bc32:	d103      	bne.n	3400bc3c <tk_cre_flg+0x3c>
		ercd = E_LIMIT;
3400bc34:	f06f 0321 	mvn.w	r3, #33	@ 0x21
3400bc38:	61fb      	str	r3, [r7, #28]
3400bc3a:	e01d      	b.n	3400bc78 <tk_cre_flg+0x78>
	} else {
		flgid = ID_FLG(flgcb - knl_flgcb_table);
3400bc3c:	693b      	ldr	r3, [r7, #16]
3400bc3e:	4a1b      	ldr	r2, [pc, #108]	@ (3400bcac <tk_cre_flg+0xac>)
3400bc40:	1a9b      	subs	r3, r3, r2
3400bc42:	10db      	asrs	r3, r3, #3
3400bc44:	4a1a      	ldr	r2, [pc, #104]	@ (3400bcb0 <tk_cre_flg+0xb0>)
3400bc46:	fb02 f303 	mul.w	r3, r2, r3
3400bc4a:	3301      	adds	r3, #1
3400bc4c:	60fb      	str	r3, [r7, #12]

		/* Initialize control block */
		QueInit(&flgcb->wait_queue);
3400bc4e:	693b      	ldr	r3, [r7, #16]
3400bc50:	4618      	mov	r0, r3
3400bc52:	f7ff ff21 	bl	3400ba98 <QueInit>
		flgcb->flgid = flgid;
3400bc56:	693b      	ldr	r3, [r7, #16]
3400bc58:	68fa      	ldr	r2, [r7, #12]
3400bc5a:	609a      	str	r2, [r3, #8]
		flgcb->exinf = pk_cflg->exinf;
3400bc5c:	687b      	ldr	r3, [r7, #4]
3400bc5e:	681a      	ldr	r2, [r3, #0]
3400bc60:	693b      	ldr	r3, [r7, #16]
3400bc62:	60da      	str	r2, [r3, #12]
		flgcb->flgatr = pk_cflg->flgatr;
3400bc64:	687b      	ldr	r3, [r7, #4]
3400bc66:	685a      	ldr	r2, [r3, #4]
3400bc68:	693b      	ldr	r3, [r7, #16]
3400bc6a:	611a      	str	r2, [r3, #16]
		flgcb->flgptn = pk_cflg->iflgptn;
3400bc6c:	687b      	ldr	r3, [r7, #4]
3400bc6e:	689a      	ldr	r2, [r3, #8]
3400bc70:	693b      	ldr	r3, [r7, #16]
3400bc72:	615a      	str	r2, [r3, #20]
		if ( (pk_cflg->flgatr & TA_DSNAME) != 0 ) {
			knl_strncpy((char*)flgcb->name, (char*)pk_cflg->dsname,
				OBJECT_NAME_LENGTH);
		}
#endif
		ercd = flgid;
3400bc74:	68fb      	ldr	r3, [r7, #12]
3400bc76:	61fb      	str	r3, [r7, #28]
	}
	END_CRITICAL_SECTION;
3400bc78:	697b      	ldr	r3, [r7, #20]
3400bc7a:	2b00      	cmp	r3, #0
3400bc7c:	d10b      	bne.n	3400bc96 <tk_cre_flg+0x96>
3400bc7e:	4b0d      	ldr	r3, [pc, #52]	@ (3400bcb4 <tk_cre_flg+0xb4>)
3400bc80:	681a      	ldr	r2, [r3, #0]
3400bc82:	4b0d      	ldr	r3, [pc, #52]	@ (3400bcb8 <tk_cre_flg+0xb8>)
3400bc84:	681b      	ldr	r3, [r3, #0]
3400bc86:	429a      	cmp	r2, r3
3400bc88:	d005      	beq.n	3400bc96 <tk_cre_flg+0x96>
3400bc8a:	4b0c      	ldr	r3, [pc, #48]	@ (3400bcbc <tk_cre_flg+0xbc>)
3400bc8c:	681b      	ldr	r3, [r3, #0]
3400bc8e:	2b00      	cmp	r3, #0
3400bc90:	d101      	bne.n	3400bc96 <tk_cre_flg+0x96>
3400bc92:	f003 f877 	bl	3400ed84 <knl_dispatch>
3400bc96:	6978      	ldr	r0, [r7, #20]
3400bc98:	f003 ff97 	bl	3400fbca <set_basepri>

	return ercd;
3400bc9c:	69fb      	ldr	r3, [r7, #28]
}
3400bc9e:	4618      	mov	r0, r3
3400bca0:	3720      	adds	r7, #32
3400bca2:	46bd      	mov	sp, r7
3400bca4:	bd80      	pop	{r7, pc}
3400bca6:	bf00      	nop
3400bca8:	34012070 	.word	0x34012070
3400bcac:	34011ef0 	.word	0x34011ef0
3400bcb0:	aaaaaaab 	.word	0xaaaaaaab
3400bcb4:	34012800 	.word	0x34012800
3400bcb8:	34012804 	.word	0x34012804
3400bcbc:	340127fc 	.word	0x340127fc

3400bcc0 <tk_del_flg>:
#ifdef USE_FUNC_TK_DEL_FLG
/*
 * Delete event flag
 */
SYSCALL ER tk_del_flg( ID flgid )
{
3400bcc0:	b580      	push	{r7, lr}
3400bcc2:	b086      	sub	sp, #24
3400bcc4:	af00      	add	r7, sp, #0
3400bcc6:	6078      	str	r0, [r7, #4]
	FLGCB	*flgcb;
	ER	ercd = E_OK;
3400bcc8:	2300      	movs	r3, #0
3400bcca:	617b      	str	r3, [r7, #20]

	CHECK_FLGID(flgid);
3400bccc:	687b      	ldr	r3, [r7, #4]
3400bcce:	2b00      	cmp	r3, #0
3400bcd0:	dd02      	ble.n	3400bcd8 <tk_del_flg+0x18>
3400bcd2:	687b      	ldr	r3, [r7, #4]
3400bcd4:	2b10      	cmp	r3, #16
3400bcd6:	dd02      	ble.n	3400bcde <tk_del_flg+0x1e>
3400bcd8:	f06f 0311 	mvn.w	r3, #17
3400bcdc:	e032      	b.n	3400bd44 <tk_del_flg+0x84>

	flgcb = get_flgcb(flgid);
3400bcde:	687b      	ldr	r3, [r7, #4]
3400bce0:	1e5a      	subs	r2, r3, #1
3400bce2:	4613      	mov	r3, r2
3400bce4:	005b      	lsls	r3, r3, #1
3400bce6:	4413      	add	r3, r2
3400bce8:	00db      	lsls	r3, r3, #3
3400bcea:	4a18      	ldr	r2, [pc, #96]	@ (3400bd4c <tk_del_flg+0x8c>)
3400bcec:	4413      	add	r3, r2
3400bcee:	613b      	str	r3, [r7, #16]

	BEGIN_CRITICAL_SECTION;
3400bcf0:	f003 ff87 	bl	3400fc02 <disint>
3400bcf4:	60f8      	str	r0, [r7, #12]
	if ( flgcb->flgid == 0 ) {
3400bcf6:	693b      	ldr	r3, [r7, #16]
3400bcf8:	689b      	ldr	r3, [r3, #8]
3400bcfa:	2b00      	cmp	r3, #0
3400bcfc:	d103      	bne.n	3400bd06 <tk_del_flg+0x46>
		ercd = E_NOEXS;
3400bcfe:	f06f 0329 	mvn.w	r3, #41	@ 0x29
3400bd02:	617b      	str	r3, [r7, #20]
3400bd04:	e00b      	b.n	3400bd1e <tk_del_flg+0x5e>
	} else {
		/* Release wait state of task (E_DLT) */
		knl_wait_delete(&flgcb->wait_queue);
3400bd06:	693b      	ldr	r3, [r7, #16]
3400bd08:	4618      	mov	r0, r3
3400bd0a:	f002 f901 	bl	3400df10 <knl_wait_delete>

		/* Return to FreeQue */
		QueInsert(&flgcb->wait_queue, &knl_free_flgcb);
3400bd0e:	693b      	ldr	r3, [r7, #16]
3400bd10:	490f      	ldr	r1, [pc, #60]	@ (3400bd50 <tk_del_flg+0x90>)
3400bd12:	4618      	mov	r0, r3
3400bd14:	f7ff fee2 	bl	3400badc <QueInsert>
		flgcb->flgid = 0;
3400bd18:	693b      	ldr	r3, [r7, #16]
3400bd1a:	2200      	movs	r2, #0
3400bd1c:	609a      	str	r2, [r3, #8]
	}
	END_CRITICAL_SECTION;
3400bd1e:	68fb      	ldr	r3, [r7, #12]
3400bd20:	2b00      	cmp	r3, #0
3400bd22:	d10b      	bne.n	3400bd3c <tk_del_flg+0x7c>
3400bd24:	4b0b      	ldr	r3, [pc, #44]	@ (3400bd54 <tk_del_flg+0x94>)
3400bd26:	681a      	ldr	r2, [r3, #0]
3400bd28:	4b0b      	ldr	r3, [pc, #44]	@ (3400bd58 <tk_del_flg+0x98>)
3400bd2a:	681b      	ldr	r3, [r3, #0]
3400bd2c:	429a      	cmp	r2, r3
3400bd2e:	d005      	beq.n	3400bd3c <tk_del_flg+0x7c>
3400bd30:	4b0a      	ldr	r3, [pc, #40]	@ (3400bd5c <tk_del_flg+0x9c>)
3400bd32:	681b      	ldr	r3, [r3, #0]
3400bd34:	2b00      	cmp	r3, #0
3400bd36:	d101      	bne.n	3400bd3c <tk_del_flg+0x7c>
3400bd38:	f003 f824 	bl	3400ed84 <knl_dispatch>
3400bd3c:	68f8      	ldr	r0, [r7, #12]
3400bd3e:	f003 ff44 	bl	3400fbca <set_basepri>

	return ercd;
3400bd42:	697b      	ldr	r3, [r7, #20]
}
3400bd44:	4618      	mov	r0, r3
3400bd46:	3718      	adds	r7, #24
3400bd48:	46bd      	mov	sp, r7
3400bd4a:	bd80      	pop	{r7, pc}
3400bd4c:	34011ef0 	.word	0x34011ef0
3400bd50:	34012070 	.word	0x34012070
3400bd54:	34012800 	.word	0x34012800
3400bd58:	34012804 	.word	0x34012804
3400bd5c:	340127fc 	.word	0x340127fc

3400bd60 <tk_set_flg>:

/*
 * Event flag set
 */
SYSCALL ER tk_set_flg( ID flgid, UINT setptn )
{
3400bd60:	b580      	push	{r7, lr}
3400bd62:	b08a      	sub	sp, #40	@ 0x28
3400bd64:	af00      	add	r7, sp, #0
3400bd66:	6078      	str	r0, [r7, #4]
3400bd68:	6039      	str	r1, [r7, #0]
	FLGCB	*flgcb;
	TCB	*tcb;
	QUEUE	*queue;
	UINT	wfmode, waiptn;
	ER	ercd = E_OK;
3400bd6a:	2300      	movs	r3, #0
3400bd6c:	623b      	str	r3, [r7, #32]

	CHECK_FLGID(flgid);
3400bd6e:	687b      	ldr	r3, [r7, #4]
3400bd70:	2b00      	cmp	r3, #0
3400bd72:	dd02      	ble.n	3400bd7a <tk_set_flg+0x1a>
3400bd74:	687b      	ldr	r3, [r7, #4]
3400bd76:	2b10      	cmp	r3, #16
3400bd78:	dd02      	ble.n	3400bd80 <tk_set_flg+0x20>
3400bd7a:	f06f 0311 	mvn.w	r3, #17
3400bd7e:	e06a      	b.n	3400be56 <tk_set_flg+0xf6>

	flgcb = get_flgcb(flgid);
3400bd80:	687b      	ldr	r3, [r7, #4]
3400bd82:	1e5a      	subs	r2, r3, #1
3400bd84:	4613      	mov	r3, r2
3400bd86:	005b      	lsls	r3, r3, #1
3400bd88:	4413      	add	r3, r2
3400bd8a:	00db      	lsls	r3, r3, #3
3400bd8c:	4a34      	ldr	r2, [pc, #208]	@ (3400be60 <tk_set_flg+0x100>)
3400bd8e:	4413      	add	r3, r2
3400bd90:	61fb      	str	r3, [r7, #28]

	BEGIN_CRITICAL_SECTION;
3400bd92:	f003 ff36 	bl	3400fc02 <disint>
3400bd96:	61b8      	str	r0, [r7, #24]
	if ( flgcb->flgid == 0 ) {
3400bd98:	69fb      	ldr	r3, [r7, #28]
3400bd9a:	689b      	ldr	r3, [r3, #8]
3400bd9c:	2b00      	cmp	r3, #0
3400bd9e:	d103      	bne.n	3400bda8 <tk_set_flg+0x48>
		ercd = E_NOEXS;
3400bda0:	f06f 0329 	mvn.w	r3, #41	@ 0x29
3400bda4:	623b      	str	r3, [r7, #32]
		goto error_exit;
3400bda6:	e043      	b.n	3400be30 <tk_set_flg+0xd0>
	}

	/* Set event flag */
	flgcb->flgptn |= setptn;
3400bda8:	69fb      	ldr	r3, [r7, #28]
3400bdaa:	695a      	ldr	r2, [r3, #20]
3400bdac:	683b      	ldr	r3, [r7, #0]
3400bdae:	431a      	orrs	r2, r3
3400bdb0:	69fb      	ldr	r3, [r7, #28]
3400bdb2:	615a      	str	r2, [r3, #20]

	/* Search task which should be released */
	queue = flgcb->wait_queue.next;
3400bdb4:	69fb      	ldr	r3, [r7, #28]
3400bdb6:	681b      	ldr	r3, [r3, #0]
3400bdb8:	627b      	str	r3, [r7, #36]	@ 0x24
	while ( queue != &flgcb->wait_queue ) {
3400bdba:	e033      	b.n	3400be24 <tk_set_flg+0xc4>
		tcb = (TCB*)queue;
3400bdbc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400bdbe:	617b      	str	r3, [r7, #20]
		queue = queue->next;
3400bdc0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400bdc2:	681b      	ldr	r3, [r3, #0]
3400bdc4:	627b      	str	r3, [r7, #36]	@ 0x24

		/* Meet condition for release wait? */
		waiptn = tcb->winfo.flg.waiptn;
3400bdc6:	697b      	ldr	r3, [r7, #20]
3400bdc8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400bdca:	613b      	str	r3, [r7, #16]
		wfmode = tcb->winfo.flg.wfmode;
3400bdcc:	697b      	ldr	r3, [r7, #20]
3400bdce:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
3400bdd0:	60fb      	str	r3, [r7, #12]
		if ( knl_eventflag_cond(flgcb, waiptn, wfmode) ) {
3400bdd2:	68fa      	ldr	r2, [r7, #12]
3400bdd4:	6939      	ldr	r1, [r7, #16]
3400bdd6:	69f8      	ldr	r0, [r7, #28]
3400bdd8:	f7ff fec6 	bl	3400bb68 <knl_eventflag_cond>
3400bddc:	4603      	mov	r3, r0
3400bdde:	2b00      	cmp	r3, #0
3400bde0:	d020      	beq.n	3400be24 <tk_set_flg+0xc4>

			/* Release wait */
			*tcb->winfo.flg.p_flgptn = flgcb->flgptn;
3400bde2:	697b      	ldr	r3, [r7, #20]
3400bde4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
3400bde6:	69fa      	ldr	r2, [r7, #28]
3400bde8:	6952      	ldr	r2, [r2, #20]
3400bdea:	601a      	str	r2, [r3, #0]
			knl_wait_release_ok(tcb);
3400bdec:	6978      	ldr	r0, [r7, #20]
3400bdee:	f002 f802 	bl	3400ddf6 <knl_wait_release_ok>

			/* Clear event flag */
			if ( (wfmode & TWF_BITCLR) != 0 ) {
3400bdf2:	68fb      	ldr	r3, [r7, #12]
3400bdf4:	f003 0320 	and.w	r3, r3, #32
3400bdf8:	2b00      	cmp	r3, #0
3400bdfa:	d00a      	beq.n	3400be12 <tk_set_flg+0xb2>
				if ( (flgcb->flgptn &= ~waiptn) == 0 ) {
3400bdfc:	69fb      	ldr	r3, [r7, #28]
3400bdfe:	695a      	ldr	r2, [r3, #20]
3400be00:	693b      	ldr	r3, [r7, #16]
3400be02:	43db      	mvns	r3, r3
3400be04:	401a      	ands	r2, r3
3400be06:	69fb      	ldr	r3, [r7, #28]
3400be08:	615a      	str	r2, [r3, #20]
3400be0a:	69fb      	ldr	r3, [r7, #28]
3400be0c:	695b      	ldr	r3, [r3, #20]
3400be0e:	2b00      	cmp	r3, #0
3400be10:	d00d      	beq.n	3400be2e <tk_set_flg+0xce>
					break;
				}
			}
			if ( (wfmode & TWF_CLR) != 0 ) {
3400be12:	68fb      	ldr	r3, [r7, #12]
3400be14:	f003 0310 	and.w	r3, r3, #16
3400be18:	2b00      	cmp	r3, #0
3400be1a:	d003      	beq.n	3400be24 <tk_set_flg+0xc4>
				flgcb->flgptn = 0;
3400be1c:	69fb      	ldr	r3, [r7, #28]
3400be1e:	2200      	movs	r2, #0
3400be20:	615a      	str	r2, [r3, #20]
				break;
3400be22:	e005      	b.n	3400be30 <tk_set_flg+0xd0>
	while ( queue != &flgcb->wait_queue ) {
3400be24:	69fb      	ldr	r3, [r7, #28]
3400be26:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
3400be28:	429a      	cmp	r2, r3
3400be2a:	d1c7      	bne.n	3400bdbc <tk_set_flg+0x5c>
			}
		}
	}

    error_exit:
3400be2c:	e000      	b.n	3400be30 <tk_set_flg+0xd0>
					break;
3400be2e:	bf00      	nop
	END_CRITICAL_SECTION;
3400be30:	69bb      	ldr	r3, [r7, #24]
3400be32:	2b00      	cmp	r3, #0
3400be34:	d10b      	bne.n	3400be4e <tk_set_flg+0xee>
3400be36:	4b0b      	ldr	r3, [pc, #44]	@ (3400be64 <tk_set_flg+0x104>)
3400be38:	681a      	ldr	r2, [r3, #0]
3400be3a:	4b0b      	ldr	r3, [pc, #44]	@ (3400be68 <tk_set_flg+0x108>)
3400be3c:	681b      	ldr	r3, [r3, #0]
3400be3e:	429a      	cmp	r2, r3
3400be40:	d005      	beq.n	3400be4e <tk_set_flg+0xee>
3400be42:	4b0a      	ldr	r3, [pc, #40]	@ (3400be6c <tk_set_flg+0x10c>)
3400be44:	681b      	ldr	r3, [r3, #0]
3400be46:	2b00      	cmp	r3, #0
3400be48:	d101      	bne.n	3400be4e <tk_set_flg+0xee>
3400be4a:	f002 ff9b 	bl	3400ed84 <knl_dispatch>
3400be4e:	69b8      	ldr	r0, [r7, #24]
3400be50:	f003 febb 	bl	3400fbca <set_basepri>

	return ercd;
3400be54:	6a3b      	ldr	r3, [r7, #32]
}
3400be56:	4618      	mov	r0, r3
3400be58:	3728      	adds	r7, #40	@ 0x28
3400be5a:	46bd      	mov	sp, r7
3400be5c:	bd80      	pop	{r7, pc}
3400be5e:	bf00      	nop
3400be60:	34011ef0 	.word	0x34011ef0
3400be64:	34012800 	.word	0x34012800
3400be68:	34012804 	.word	0x34012804
3400be6c:	340127fc 	.word	0x340127fc

3400be70 <tk_clr_flg>:

/*
 * Clear event flag 
 */
SYSCALL ER tk_clr_flg( ID flgid, UINT clrptn )
{
3400be70:	b580      	push	{r7, lr}
3400be72:	b086      	sub	sp, #24
3400be74:	af00      	add	r7, sp, #0
3400be76:	6078      	str	r0, [r7, #4]
3400be78:	6039      	str	r1, [r7, #0]
	FLGCB	*flgcb;
	ER	ercd = E_OK;
3400be7a:	2300      	movs	r3, #0
3400be7c:	617b      	str	r3, [r7, #20]

	CHECK_FLGID(flgid);
3400be7e:	687b      	ldr	r3, [r7, #4]
3400be80:	2b00      	cmp	r3, #0
3400be82:	dd02      	ble.n	3400be8a <tk_clr_flg+0x1a>
3400be84:	687b      	ldr	r3, [r7, #4]
3400be86:	2b10      	cmp	r3, #16
3400be88:	dd02      	ble.n	3400be90 <tk_clr_flg+0x20>
3400be8a:	f06f 0311 	mvn.w	r3, #17
3400be8e:	e02c      	b.n	3400beea <tk_clr_flg+0x7a>

	flgcb = get_flgcb(flgid);
3400be90:	687b      	ldr	r3, [r7, #4]
3400be92:	1e5a      	subs	r2, r3, #1
3400be94:	4613      	mov	r3, r2
3400be96:	005b      	lsls	r3, r3, #1
3400be98:	4413      	add	r3, r2
3400be9a:	00db      	lsls	r3, r3, #3
3400be9c:	4a15      	ldr	r2, [pc, #84]	@ (3400bef4 <tk_clr_flg+0x84>)
3400be9e:	4413      	add	r3, r2
3400bea0:	613b      	str	r3, [r7, #16]

	BEGIN_CRITICAL_SECTION;
3400bea2:	f003 feae 	bl	3400fc02 <disint>
3400bea6:	60f8      	str	r0, [r7, #12]
	if ( flgcb->flgid == 0 ) {
3400bea8:	693b      	ldr	r3, [r7, #16]
3400beaa:	689b      	ldr	r3, [r3, #8]
3400beac:	2b00      	cmp	r3, #0
3400beae:	d103      	bne.n	3400beb8 <tk_clr_flg+0x48>
		ercd = E_NOEXS;
3400beb0:	f06f 0329 	mvn.w	r3, #41	@ 0x29
3400beb4:	617b      	str	r3, [r7, #20]
3400beb6:	e005      	b.n	3400bec4 <tk_clr_flg+0x54>
	} else {
		flgcb->flgptn &= clrptn;
3400beb8:	693b      	ldr	r3, [r7, #16]
3400beba:	695a      	ldr	r2, [r3, #20]
3400bebc:	683b      	ldr	r3, [r7, #0]
3400bebe:	401a      	ands	r2, r3
3400bec0:	693b      	ldr	r3, [r7, #16]
3400bec2:	615a      	str	r2, [r3, #20]
	}
	END_CRITICAL_SECTION;
3400bec4:	68fb      	ldr	r3, [r7, #12]
3400bec6:	2b00      	cmp	r3, #0
3400bec8:	d10b      	bne.n	3400bee2 <tk_clr_flg+0x72>
3400beca:	4b0b      	ldr	r3, [pc, #44]	@ (3400bef8 <tk_clr_flg+0x88>)
3400becc:	681a      	ldr	r2, [r3, #0]
3400bece:	4b0b      	ldr	r3, [pc, #44]	@ (3400befc <tk_clr_flg+0x8c>)
3400bed0:	681b      	ldr	r3, [r3, #0]
3400bed2:	429a      	cmp	r2, r3
3400bed4:	d005      	beq.n	3400bee2 <tk_clr_flg+0x72>
3400bed6:	4b0a      	ldr	r3, [pc, #40]	@ (3400bf00 <tk_clr_flg+0x90>)
3400bed8:	681b      	ldr	r3, [r3, #0]
3400beda:	2b00      	cmp	r3, #0
3400bedc:	d101      	bne.n	3400bee2 <tk_clr_flg+0x72>
3400bede:	f002 ff51 	bl	3400ed84 <knl_dispatch>
3400bee2:	68f8      	ldr	r0, [r7, #12]
3400bee4:	f003 fe71 	bl	3400fbca <set_basepri>

	return ercd;
3400bee8:	697b      	ldr	r3, [r7, #20]
}
3400beea:	4618      	mov	r0, r3
3400beec:	3718      	adds	r7, #24
3400beee:	46bd      	mov	sp, r7
3400bef0:	bd80      	pop	{r7, pc}
3400bef2:	bf00      	nop
3400bef4:	34011ef0 	.word	0x34011ef0
3400bef8:	34012800 	.word	0x34012800
3400befc:	34012804 	.word	0x34012804
3400bf00:	340127fc 	.word	0x340127fc

3400bf04 <flg_chg_pri>:

/*
 * Processing if the priority of wait task changes
 */
LOCAL void flg_chg_pri( TCB *tcb, INT oldpri )
{
3400bf04:	b580      	push	{r7, lr}
3400bf06:	b084      	sub	sp, #16
3400bf08:	af00      	add	r7, sp, #0
3400bf0a:	6078      	str	r0, [r7, #4]
3400bf0c:	6039      	str	r1, [r7, #0]
	FLGCB	*flgcb;

	flgcb = get_flgcb(tcb->wid);
3400bf0e:	687b      	ldr	r3, [r7, #4]
3400bf10:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3400bf12:	1e5a      	subs	r2, r3, #1
3400bf14:	4613      	mov	r3, r2
3400bf16:	005b      	lsls	r3, r3, #1
3400bf18:	4413      	add	r3, r2
3400bf1a:	00db      	lsls	r3, r3, #3
3400bf1c:	4a05      	ldr	r2, [pc, #20]	@ (3400bf34 <flg_chg_pri+0x30>)
3400bf1e:	4413      	add	r3, r2
3400bf20:	60fb      	str	r3, [r7, #12]
	knl_gcb_change_priority((GCB*)flgcb, tcb);
3400bf22:	6879      	ldr	r1, [r7, #4]
3400bf24:	68f8      	ldr	r0, [r7, #12]
3400bf26:	f002 f845 	bl	3400dfb4 <knl_gcb_change_priority>
}
3400bf2a:	bf00      	nop
3400bf2c:	3710      	adds	r7, #16
3400bf2e:	46bd      	mov	sp, r7
3400bf30:	bd80      	pop	{r7, pc}
3400bf32:	bf00      	nop
3400bf34:	34011ef0 	.word	0x34011ef0

3400bf38 <tk_wai_flg>:

/*
 * Event flag wait
 */
SYSCALL ER tk_wai_flg( ID flgid, UINT waiptn, UINT wfmode, UINT *p_flgptn, TMO tmout )
{
3400bf38:	b580      	push	{r7, lr}
3400bf3a:	b088      	sub	sp, #32
3400bf3c:	af00      	add	r7, sp, #0
3400bf3e:	60f8      	str	r0, [r7, #12]
3400bf40:	60b9      	str	r1, [r7, #8]
3400bf42:	607a      	str	r2, [r7, #4]
3400bf44:	603b      	str	r3, [r7, #0]
	FLGCB	*flgcb;
	ER	ercd = E_OK;
3400bf46:	2300      	movs	r3, #0
3400bf48:	617b      	str	r3, [r7, #20]

	CHECK_FLGID(flgid);
3400bf4a:	68fb      	ldr	r3, [r7, #12]
3400bf4c:	2b00      	cmp	r3, #0
3400bf4e:	dd02      	ble.n	3400bf56 <tk_wai_flg+0x1e>
3400bf50:	68fb      	ldr	r3, [r7, #12]
3400bf52:	2b10      	cmp	r3, #16
3400bf54:	dd02      	ble.n	3400bf5c <tk_wai_flg+0x24>
3400bf56:	f06f 0311 	mvn.w	r3, #17
3400bf5a:	e0a3      	b.n	3400c0a4 <tk_wai_flg+0x16c>
	CHECK_PAR(waiptn != 0);
3400bf5c:	68bb      	ldr	r3, [r7, #8]
3400bf5e:	2b00      	cmp	r3, #0
3400bf60:	d102      	bne.n	3400bf68 <tk_wai_flg+0x30>
3400bf62:	f06f 0310 	mvn.w	r3, #16
3400bf66:	e09d      	b.n	3400c0a4 <tk_wai_flg+0x16c>
	CHECK_PAR((wfmode & ~(TWF_ORW|TWF_CLR|TWF_BITCLR)) == 0);
3400bf68:	687b      	ldr	r3, [r7, #4]
3400bf6a:	f023 0331 	bic.w	r3, r3, #49	@ 0x31
3400bf6e:	2b00      	cmp	r3, #0
3400bf70:	d002      	beq.n	3400bf78 <tk_wai_flg+0x40>
3400bf72:	f06f 0310 	mvn.w	r3, #16
3400bf76:	e095      	b.n	3400c0a4 <tk_wai_flg+0x16c>
	CHECK_TMOUT(tmout);
3400bf78:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400bf7a:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
3400bf7e:	da02      	bge.n	3400bf86 <tk_wai_flg+0x4e>
3400bf80:	f06f 0310 	mvn.w	r3, #16
3400bf84:	e08e      	b.n	3400c0a4 <tk_wai_flg+0x16c>
	CHECK_DISPATCH();
3400bf86:	4b49      	ldr	r3, [pc, #292]	@ (3400c0ac <tk_wai_flg+0x174>)
3400bf88:	681b      	ldr	r3, [r3, #0]
3400bf8a:	2b00      	cmp	r3, #0
3400bf8c:	d10d      	bne.n	3400bfaa <tk_wai_flg+0x72>
3400bf8e:	f7ff fddb 	bl	3400bb48 <knl_isTaskIndependent>
3400bf92:	4603      	mov	r3, r0
3400bf94:	2b00      	cmp	r3, #0
3400bf96:	d108      	bne.n	3400bfaa <tk_wai_flg+0x72>
3400bf98:	4b45      	ldr	r3, [pc, #276]	@ (3400c0b0 <tk_wai_flg+0x178>)
3400bf9a:	681b      	ldr	r3, [r3, #0]
3400bf9c:	2b00      	cmp	r3, #0
3400bf9e:	d004      	beq.n	3400bfaa <tk_wai_flg+0x72>
3400bfa0:	f003 fe22 	bl	3400fbe8 <get_basepri>
3400bfa4:	4603      	mov	r3, r0
3400bfa6:	2b00      	cmp	r3, #0
3400bfa8:	d002      	beq.n	3400bfb0 <tk_wai_flg+0x78>
3400bfaa:	f06f 0318 	mvn.w	r3, #24
3400bfae:	e079      	b.n	3400c0a4 <tk_wai_flg+0x16c>

	flgcb = get_flgcb(flgid);
3400bfb0:	68fb      	ldr	r3, [r7, #12]
3400bfb2:	1e5a      	subs	r2, r3, #1
3400bfb4:	4613      	mov	r3, r2
3400bfb6:	005b      	lsls	r3, r3, #1
3400bfb8:	4413      	add	r3, r2
3400bfba:	00db      	lsls	r3, r3, #3
3400bfbc:	4a3d      	ldr	r2, [pc, #244]	@ (3400c0b4 <tk_wai_flg+0x17c>)
3400bfbe:	4413      	add	r3, r2
3400bfc0:	61fb      	str	r3, [r7, #28]

	BEGIN_CRITICAL_SECTION;
3400bfc2:	f003 fe1e 	bl	3400fc02 <disint>
3400bfc6:	61b8      	str	r0, [r7, #24]
	if ( flgcb->flgid == 0 ) {
3400bfc8:	69fb      	ldr	r3, [r7, #28]
3400bfca:	689b      	ldr	r3, [r3, #8]
3400bfcc:	2b00      	cmp	r3, #0
3400bfce:	d103      	bne.n	3400bfd8 <tk_wai_flg+0xa0>
		ercd = E_NOEXS;
3400bfd0:	f06f 0329 	mvn.w	r3, #41	@ 0x29
3400bfd4:	617b      	str	r3, [r7, #20]
		goto error_exit;
3400bfd6:	e052      	b.n	3400c07e <tk_wai_flg+0x146>
	}
	if ( (flgcb->flgatr & TA_WMUL) == 0 && !isQueEmpty(&flgcb->wait_queue) ) {
3400bfd8:	69fb      	ldr	r3, [r7, #28]
3400bfda:	691b      	ldr	r3, [r3, #16]
3400bfdc:	f003 0308 	and.w	r3, r3, #8
3400bfe0:	2b00      	cmp	r3, #0
3400bfe2:	d10a      	bne.n	3400bffa <tk_wai_flg+0xc2>
3400bfe4:	69fb      	ldr	r3, [r7, #28]
3400bfe6:	4618      	mov	r0, r3
3400bfe8:	f7ff fd66 	bl	3400bab8 <isQueEmpty>
3400bfec:	4603      	mov	r3, r0
3400bfee:	2b00      	cmp	r3, #0
3400bff0:	d103      	bne.n	3400bffa <tk_wai_flg+0xc2>
		/* Disable multiple tasks wait */
		ercd = E_OBJ;
3400bff2:	f06f 0328 	mvn.w	r3, #40	@ 0x28
3400bff6:	617b      	str	r3, [r7, #20]
		goto error_exit;
3400bff8:	e041      	b.n	3400c07e <tk_wai_flg+0x146>
	}

	/* Meet condition for release wait? */
	if ( knl_eventflag_cond(flgcb, waiptn, wfmode) ) {
3400bffa:	687a      	ldr	r2, [r7, #4]
3400bffc:	68b9      	ldr	r1, [r7, #8]
3400bffe:	69f8      	ldr	r0, [r7, #28]
3400c000:	f7ff fdb2 	bl	3400bb68 <knl_eventflag_cond>
3400c004:	4603      	mov	r3, r0
3400c006:	2b00      	cmp	r3, #0
3400c008:	d018      	beq.n	3400c03c <tk_wai_flg+0x104>
		*p_flgptn = flgcb->flgptn;
3400c00a:	69fb      	ldr	r3, [r7, #28]
3400c00c:	695a      	ldr	r2, [r3, #20]
3400c00e:	683b      	ldr	r3, [r7, #0]
3400c010:	601a      	str	r2, [r3, #0]

		/* Clear event flag */
		if ( (wfmode & TWF_BITCLR) != 0 ) {
3400c012:	687b      	ldr	r3, [r7, #4]
3400c014:	f003 0320 	and.w	r3, r3, #32
3400c018:	2b00      	cmp	r3, #0
3400c01a:	d006      	beq.n	3400c02a <tk_wai_flg+0xf2>
			flgcb->flgptn &= ~waiptn;
3400c01c:	69fb      	ldr	r3, [r7, #28]
3400c01e:	695a      	ldr	r2, [r3, #20]
3400c020:	68bb      	ldr	r3, [r7, #8]
3400c022:	43db      	mvns	r3, r3
3400c024:	401a      	ands	r2, r3
3400c026:	69fb      	ldr	r3, [r7, #28]
3400c028:	615a      	str	r2, [r3, #20]
		}
		if ( (wfmode & TWF_CLR) != 0 ) {
3400c02a:	687b      	ldr	r3, [r7, #4]
3400c02c:	f003 0310 	and.w	r3, r3, #16
3400c030:	2b00      	cmp	r3, #0
3400c032:	d024      	beq.n	3400c07e <tk_wai_flg+0x146>
			flgcb->flgptn = 0;
3400c034:	69fb      	ldr	r3, [r7, #28]
3400c036:	2200      	movs	r2, #0
3400c038:	615a      	str	r2, [r3, #20]
3400c03a:	e020      	b.n	3400c07e <tk_wai_flg+0x146>
		}
	} else {
		/* Ready for wait */
		knl_ctxtsk->wspec = ( (flgcb->flgatr & TA_TPRI) != 0 )?
3400c03c:	69fb      	ldr	r3, [r7, #28]
3400c03e:	691b      	ldr	r3, [r3, #16]
3400c040:	f003 0301 	and.w	r3, r3, #1
					&knl_wspec_flg_tpri: &knl_wspec_flg_tfifo;
3400c044:	2b00      	cmp	r3, #0
3400c046:	d001      	beq.n	3400c04c <tk_wai_flg+0x114>
3400c048:	4a1b      	ldr	r2, [pc, #108]	@ (3400c0b8 <tk_wai_flg+0x180>)
3400c04a:	e000      	b.n	3400c04e <tk_wai_flg+0x116>
3400c04c:	4a1b      	ldr	r2, [pc, #108]	@ (3400c0bc <tk_wai_flg+0x184>)
		knl_ctxtsk->wspec = ( (flgcb->flgatr & TA_TPRI) != 0 )?
3400c04e:	4b18      	ldr	r3, [pc, #96]	@ (3400c0b0 <tk_wai_flg+0x178>)
3400c050:	681b      	ldr	r3, [r3, #0]
3400c052:	62da      	str	r2, [r3, #44]	@ 0x2c
		knl_ctxtsk->wercd = &ercd;
3400c054:	4b16      	ldr	r3, [pc, #88]	@ (3400c0b0 <tk_wai_flg+0x178>)
3400c056:	681b      	ldr	r3, [r3, #0]
3400c058:	f107 0214 	add.w	r2, r7, #20
3400c05c:	63da      	str	r2, [r3, #60]	@ 0x3c
		knl_ctxtsk->winfo.flg.waiptn = waiptn;
3400c05e:	4b14      	ldr	r3, [pc, #80]	@ (3400c0b0 <tk_wai_flg+0x178>)
3400c060:	681b      	ldr	r3, [r3, #0]
3400c062:	68ba      	ldr	r2, [r7, #8]
3400c064:	641a      	str	r2, [r3, #64]	@ 0x40
		knl_ctxtsk->winfo.flg.wfmode = wfmode;
3400c066:	4b12      	ldr	r3, [pc, #72]	@ (3400c0b0 <tk_wai_flg+0x178>)
3400c068:	681b      	ldr	r3, [r3, #0]
3400c06a:	687a      	ldr	r2, [r7, #4]
3400c06c:	645a      	str	r2, [r3, #68]	@ 0x44
		knl_ctxtsk->winfo.flg.p_flgptn = p_flgptn;
3400c06e:	4b10      	ldr	r3, [pc, #64]	@ (3400c0b0 <tk_wai_flg+0x178>)
3400c070:	681b      	ldr	r3, [r3, #0]
3400c072:	683a      	ldr	r2, [r7, #0]
3400c074:	649a      	str	r2, [r3, #72]	@ 0x48
		knl_gcb_make_wait((GCB*)flgcb, tmout);
3400c076:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
3400c078:	69f8      	ldr	r0, [r7, #28]
3400c07a:	f001 ff65 	bl	3400df48 <knl_gcb_make_wait>
	}

    error_exit:
	END_CRITICAL_SECTION;
3400c07e:	69bb      	ldr	r3, [r7, #24]
3400c080:	2b00      	cmp	r3, #0
3400c082:	d10b      	bne.n	3400c09c <tk_wai_flg+0x164>
3400c084:	4b0a      	ldr	r3, [pc, #40]	@ (3400c0b0 <tk_wai_flg+0x178>)
3400c086:	681a      	ldr	r2, [r3, #0]
3400c088:	4b0d      	ldr	r3, [pc, #52]	@ (3400c0c0 <tk_wai_flg+0x188>)
3400c08a:	681b      	ldr	r3, [r3, #0]
3400c08c:	429a      	cmp	r2, r3
3400c08e:	d005      	beq.n	3400c09c <tk_wai_flg+0x164>
3400c090:	4b06      	ldr	r3, [pc, #24]	@ (3400c0ac <tk_wai_flg+0x174>)
3400c092:	681b      	ldr	r3, [r3, #0]
3400c094:	2b00      	cmp	r3, #0
3400c096:	d101      	bne.n	3400c09c <tk_wai_flg+0x164>
3400c098:	f002 fe74 	bl	3400ed84 <knl_dispatch>
3400c09c:	69b8      	ldr	r0, [r7, #24]
3400c09e:	f003 fd94 	bl	3400fbca <set_basepri>

	return ercd;
3400c0a2:	697b      	ldr	r3, [r7, #20]
}
3400c0a4:	4618      	mov	r0, r3
3400c0a6:	3720      	adds	r7, #32
3400c0a8:	46bd      	mov	sp, r7
3400c0aa:	bd80      	pop	{r7, pc}
3400c0ac:	340127fc 	.word	0x340127fc
3400c0b0:	34012800 	.word	0x34012800
3400c0b4:	34011ef0 	.word	0x34011ef0
3400c0b8:	3401009c 	.word	0x3401009c
3400c0bc:	34010090 	.word	0x34010090
3400c0c0:	34012804 	.word	0x34012804

3400c0c4 <QueInit>:
{
3400c0c4:	b480      	push	{r7}
3400c0c6:	b083      	sub	sp, #12
3400c0c8:	af00      	add	r7, sp, #0
3400c0ca:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400c0cc:	687b      	ldr	r3, [r7, #4]
3400c0ce:	687a      	ldr	r2, [r7, #4]
3400c0d0:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400c0d2:	687b      	ldr	r3, [r7, #4]
3400c0d4:	687a      	ldr	r2, [r7, #4]
3400c0d6:	605a      	str	r2, [r3, #4]
}
3400c0d8:	bf00      	nop
3400c0da:	370c      	adds	r7, #12
3400c0dc:	46bd      	mov	sp, r7
3400c0de:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c0e2:	4770      	bx	lr

3400c0e4 <QueInsert>:
{
3400c0e4:	b480      	push	{r7}
3400c0e6:	b083      	sub	sp, #12
3400c0e8:	af00      	add	r7, sp, #0
3400c0ea:	6078      	str	r0, [r7, #4]
3400c0ec:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400c0ee:	683b      	ldr	r3, [r7, #0]
3400c0f0:	685a      	ldr	r2, [r3, #4]
3400c0f2:	687b      	ldr	r3, [r7, #4]
3400c0f4:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400c0f6:	687b      	ldr	r3, [r7, #4]
3400c0f8:	683a      	ldr	r2, [r7, #0]
3400c0fa:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400c0fc:	683b      	ldr	r3, [r7, #0]
3400c0fe:	685b      	ldr	r3, [r3, #4]
3400c100:	687a      	ldr	r2, [r7, #4]
3400c102:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400c104:	683b      	ldr	r3, [r7, #0]
3400c106:	687a      	ldr	r2, [r7, #4]
3400c108:	605a      	str	r2, [r3, #4]
}
3400c10a:	bf00      	nop
3400c10c:	370c      	adds	r7, #12
3400c10e:	46bd      	mov	sp, r7
3400c110:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c114:	4770      	bx	lr
	...

3400c118 <knl_mailbox_initialize>:

/*
 * Initialization of mailbox control block 
 */
EXPORT ER knl_mailbox_initialize( void )
{
3400c118:	b580      	push	{r7, lr}
3400c11a:	b082      	sub	sp, #8
3400c11c:	af00      	add	r7, sp, #0
	if ( NUM_MBXID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_mbxcb);
3400c11e:	480e      	ldr	r0, [pc, #56]	@ (3400c158 <knl_mailbox_initialize+0x40>)
3400c120:	f7ff ffd0 	bl	3400c0c4 <QueInit>
	end = knl_mbxcb_table + NUM_MBXID;
3400c124:	4b0d      	ldr	r3, [pc, #52]	@ (3400c15c <knl_mailbox_initialize+0x44>)
3400c126:	603b      	str	r3, [r7, #0]
	for ( mbxcb = knl_mbxcb_table; mbxcb < end; mbxcb++ ) {
3400c128:	4b0d      	ldr	r3, [pc, #52]	@ (3400c160 <knl_mailbox_initialize+0x48>)
3400c12a:	607b      	str	r3, [r7, #4]
3400c12c:	e00a      	b.n	3400c144 <knl_mailbox_initialize+0x2c>
		mbxcb->mbxid = 0;
3400c12e:	687b      	ldr	r3, [r7, #4]
3400c130:	2200      	movs	r2, #0
3400c132:	609a      	str	r2, [r3, #8]
		QueInsert(&mbxcb->wait_queue, &knl_free_mbxcb);
3400c134:	687b      	ldr	r3, [r7, #4]
3400c136:	4908      	ldr	r1, [pc, #32]	@ (3400c158 <knl_mailbox_initialize+0x40>)
3400c138:	4618      	mov	r0, r3
3400c13a:	f7ff ffd3 	bl	3400c0e4 <QueInsert>
	for ( mbxcb = knl_mbxcb_table; mbxcb < end; mbxcb++ ) {
3400c13e:	687b      	ldr	r3, [r7, #4]
3400c140:	331c      	adds	r3, #28
3400c142:	607b      	str	r3, [r7, #4]
3400c144:	687a      	ldr	r2, [r7, #4]
3400c146:	683b      	ldr	r3, [r7, #0]
3400c148:	429a      	cmp	r2, r3
3400c14a:	d3f0      	bcc.n	3400c12e <knl_mailbox_initialize+0x16>
	}

	return E_OK;
3400c14c:	2300      	movs	r3, #0
}
3400c14e:	4618      	mov	r0, r3
3400c150:	3708      	adds	r7, #8
3400c152:	46bd      	mov	sp, r7
3400c154:	bd80      	pop	{r7, pc}
3400c156:	bf00      	nop
3400c158:	34012158 	.word	0x34012158
3400c15c:	34012158 	.word	0x34012158
3400c160:	34012078 	.word	0x34012078

3400c164 <QueInit>:
{
3400c164:	b480      	push	{r7}
3400c166:	b083      	sub	sp, #12
3400c168:	af00      	add	r7, sp, #0
3400c16a:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400c16c:	687b      	ldr	r3, [r7, #4]
3400c16e:	687a      	ldr	r2, [r7, #4]
3400c170:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400c172:	687b      	ldr	r3, [r7, #4]
3400c174:	687a      	ldr	r2, [r7, #4]
3400c176:	605a      	str	r2, [r3, #4]
}
3400c178:	bf00      	nop
3400c17a:	370c      	adds	r7, #12
3400c17c:	46bd      	mov	sp, r7
3400c17e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c182:	4770      	bx	lr

3400c184 <QueInsert>:
{
3400c184:	b480      	push	{r7}
3400c186:	b083      	sub	sp, #12
3400c188:	af00      	add	r7, sp, #0
3400c18a:	6078      	str	r0, [r7, #4]
3400c18c:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400c18e:	683b      	ldr	r3, [r7, #0]
3400c190:	685a      	ldr	r2, [r3, #4]
3400c192:	687b      	ldr	r3, [r7, #4]
3400c194:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400c196:	687b      	ldr	r3, [r7, #4]
3400c198:	683a      	ldr	r2, [r7, #0]
3400c19a:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400c19c:	683b      	ldr	r3, [r7, #0]
3400c19e:	685b      	ldr	r3, [r3, #4]
3400c1a0:	687a      	ldr	r2, [r7, #4]
3400c1a2:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400c1a4:	683b      	ldr	r3, [r7, #0]
3400c1a6:	687a      	ldr	r2, [r7, #4]
3400c1a8:	605a      	str	r2, [r3, #4]
}
3400c1aa:	bf00      	nop
3400c1ac:	370c      	adds	r7, #12
3400c1ae:	46bd      	mov	sp, r7
3400c1b0:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c1b4:	4770      	bx	lr

3400c1b6 <QueRemove>:
{
3400c1b6:	b480      	push	{r7}
3400c1b8:	b083      	sub	sp, #12
3400c1ba:	af00      	add	r7, sp, #0
3400c1bc:	6078      	str	r0, [r7, #4]
	if ( entry->next != entry ) {
3400c1be:	687b      	ldr	r3, [r7, #4]
3400c1c0:	681b      	ldr	r3, [r3, #0]
3400c1c2:	687a      	ldr	r2, [r7, #4]
3400c1c4:	429a      	cmp	r2, r3
3400c1c6:	d009      	beq.n	3400c1dc <QueRemove+0x26>
		entry->prev->next = (struct queue*) entry->next;
3400c1c8:	687b      	ldr	r3, [r7, #4]
3400c1ca:	685b      	ldr	r3, [r3, #4]
3400c1cc:	687a      	ldr	r2, [r7, #4]
3400c1ce:	6812      	ldr	r2, [r2, #0]
3400c1d0:	601a      	str	r2, [r3, #0]
		entry->next->prev = (struct queue*) entry->prev;
3400c1d2:	687b      	ldr	r3, [r7, #4]
3400c1d4:	681b      	ldr	r3, [r3, #0]
3400c1d6:	687a      	ldr	r2, [r7, #4]
3400c1d8:	6852      	ldr	r2, [r2, #4]
3400c1da:	605a      	str	r2, [r3, #4]
}
3400c1dc:	bf00      	nop
3400c1de:	370c      	adds	r7, #12
3400c1e0:	46bd      	mov	sp, r7
3400c1e2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c1e6:	4770      	bx	lr

3400c1e8 <knl_searchFreeArea>:
 *	or larger than
 *      'blksz' but closest.
 *	If it does not exist, return '&imacb->freeque'.
 */
EXPORT QUEUE* knl_searchFreeArea( IMACB *imacb, W blksz )
{
3400c1e8:	b480      	push	{r7}
3400c1ea:	b085      	sub	sp, #20
3400c1ec:	af00      	add	r7, sp, #0
3400c1ee:	6078      	str	r0, [r7, #4]
3400c1f0:	6039      	str	r1, [r7, #0]
	QUEUE	*q = &imacb->freeque;
3400c1f2:	687b      	ldr	r3, [r7, #4]
3400c1f4:	330c      	adds	r3, #12
3400c1f6:	60fb      	str	r3, [r7, #12]

	/* For area whose memory pool size is less than 1/4,
	   search from smaller size.
	   Otherwise, search from larger size. */
	if ( blksz > imacb->memsz / 4 ) {
3400c1f8:	687b      	ldr	r3, [r7, #4]
3400c1fa:	681b      	ldr	r3, [r3, #0]
3400c1fc:	2b00      	cmp	r3, #0
3400c1fe:	da00      	bge.n	3400c202 <knl_searchFreeArea+0x1a>
3400c200:	3303      	adds	r3, #3
3400c202:	109b      	asrs	r3, r3, #2
3400c204:	461a      	mov	r2, r3
3400c206:	683b      	ldr	r3, [r7, #0]
3400c208:	4293      	cmp	r3, r2
3400c20a:	dd2b      	ble.n	3400c264 <knl_searchFreeArea+0x7c>
		/* Search from larger size. */
		W fsz = 0;
3400c20c:	2300      	movs	r3, #0
3400c20e:	60bb      	str	r3, [r7, #8]
		while ( (q = q->prev) != &imacb->freeque ) {
3400c210:	e010      	b.n	3400c234 <knl_searchFreeArea+0x4c>
			fsz = FreeSize(q);
3400c212:	68fb      	ldr	r3, [r7, #12]
3400c214:	3308      	adds	r3, #8
3400c216:	685b      	ldr	r3, [r3, #4]
3400c218:	60bb      	str	r3, [r7, #8]
			if ( fsz <= blksz ) {
3400c21a:	68ba      	ldr	r2, [r7, #8]
3400c21c:	683b      	ldr	r3, [r7, #0]
3400c21e:	429a      	cmp	r2, r3
3400c220:	dc08      	bgt.n	3400c234 <knl_searchFreeArea+0x4c>
				return ( fsz < blksz )? q->next: q;
3400c222:	68ba      	ldr	r2, [r7, #8]
3400c224:	683b      	ldr	r3, [r7, #0]
3400c226:	429a      	cmp	r2, r3
3400c228:	da02      	bge.n	3400c230 <knl_searchFreeArea+0x48>
3400c22a:	68fb      	ldr	r3, [r7, #12]
3400c22c:	681b      	ldr	r3, [r3, #0]
3400c22e:	e024      	b.n	3400c27a <knl_searchFreeArea+0x92>
3400c230:	68fb      	ldr	r3, [r7, #12]
3400c232:	e022      	b.n	3400c27a <knl_searchFreeArea+0x92>
		while ( (q = q->prev) != &imacb->freeque ) {
3400c234:	68fb      	ldr	r3, [r7, #12]
3400c236:	685b      	ldr	r3, [r3, #4]
3400c238:	60fb      	str	r3, [r7, #12]
3400c23a:	687b      	ldr	r3, [r7, #4]
3400c23c:	330c      	adds	r3, #12
3400c23e:	68fa      	ldr	r2, [r7, #12]
3400c240:	429a      	cmp	r2, r3
3400c242:	d1e6      	bne.n	3400c212 <knl_searchFreeArea+0x2a>
			}
		}
		return ( fsz >= blksz )? q->next: q;
3400c244:	68ba      	ldr	r2, [r7, #8]
3400c246:	683b      	ldr	r3, [r7, #0]
3400c248:	429a      	cmp	r2, r3
3400c24a:	db02      	blt.n	3400c252 <knl_searchFreeArea+0x6a>
3400c24c:	68fb      	ldr	r3, [r7, #12]
3400c24e:	681b      	ldr	r3, [r3, #0]
3400c250:	e013      	b.n	3400c27a <knl_searchFreeArea+0x92>
3400c252:	68fb      	ldr	r3, [r7, #12]
3400c254:	e011      	b.n	3400c27a <knl_searchFreeArea+0x92>
	} else {
		/* Search from smaller size. */
		while ( (q = q->next) != &imacb->freeque ) {
			if ( FreeSize(q) >= blksz ) {
3400c256:	68fb      	ldr	r3, [r7, #12]
3400c258:	3308      	adds	r3, #8
3400c25a:	685b      	ldr	r3, [r3, #4]
3400c25c:	461a      	mov	r2, r3
3400c25e:	683b      	ldr	r3, [r7, #0]
3400c260:	4293      	cmp	r3, r2
3400c262:	dd08      	ble.n	3400c276 <knl_searchFreeArea+0x8e>
		while ( (q = q->next) != &imacb->freeque ) {
3400c264:	68fb      	ldr	r3, [r7, #12]
3400c266:	681b      	ldr	r3, [r3, #0]
3400c268:	60fb      	str	r3, [r7, #12]
3400c26a:	687b      	ldr	r3, [r7, #4]
3400c26c:	330c      	adds	r3, #12
3400c26e:	68fa      	ldr	r2, [r7, #12]
3400c270:	429a      	cmp	r2, r3
3400c272:	d1f0      	bne.n	3400c256 <knl_searchFreeArea+0x6e>
3400c274:	e000      	b.n	3400c278 <knl_searchFreeArea+0x90>
				break;
3400c276:	bf00      	nop
			}
		}
		return q;
3400c278:	68fb      	ldr	r3, [r7, #12]
	}
}
3400c27a:	4618      	mov	r0, r3
3400c27c:	3714      	adds	r7, #20
3400c27e:	46bd      	mov	sp, r7
3400c280:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c284:	4770      	bx	lr

3400c286 <knl_appendFreeArea>:
 *	|   +-----------------------+	    +-----------------------+
 *	|   | AreaQue		    |	    | AreaQue		    |
 *	v   +-----------------------+	    +-----------------------+
 */
EXPORT void knl_appendFreeArea( IMACB *imacb, QUEUE *aq )
{
3400c286:	b580      	push	{r7, lr}
3400c288:	b084      	sub	sp, #16
3400c28a:	af00      	add	r7, sp, #0
3400c28c:	6078      	str	r0, [r7, #4]
3400c28e:	6039      	str	r1, [r7, #0]
	QUEUE	*fq;
	W	size = AreaSize(aq);
3400c290:	683b      	ldr	r3, [r7, #0]
3400c292:	681a      	ldr	r2, [r3, #0]
3400c294:	683b      	ldr	r3, [r7, #0]
3400c296:	3308      	adds	r3, #8
3400c298:	1ad3      	subs	r3, r2, r3
3400c29a:	60fb      	str	r3, [r7, #12]
	/* Registration position search */
	/*  Search the free area whose size is equal to 'blksz',
	 *  or larger than 'blksz' but closest.
	 *  If it does not exist, return '&imacb->freeque'.
	 */
	fq = knl_searchFreeArea(imacb, size);
3400c29c:	68f9      	ldr	r1, [r7, #12]
3400c29e:	6878      	ldr	r0, [r7, #4]
3400c2a0:	f7ff ffa2 	bl	3400c1e8 <knl_searchFreeArea>
3400c2a4:	60b8      	str	r0, [r7, #8]

	/* Register */
	clrAreaFlag(aq, AREA_USE);
3400c2a6:	683b      	ldr	r3, [r7, #0]
3400c2a8:	685b      	ldr	r3, [r3, #4]
3400c2aa:	f023 0301 	bic.w	r3, r3, #1
3400c2ae:	461a      	mov	r2, r3
3400c2b0:	683b      	ldr	r3, [r7, #0]
3400c2b2:	605a      	str	r2, [r3, #4]
	if ( fq != &imacb->freeque && FreeSize(fq) == size ) {
3400c2b4:	687b      	ldr	r3, [r7, #4]
3400c2b6:	330c      	adds	r3, #12
3400c2b8:	68ba      	ldr	r2, [r7, #8]
3400c2ba:	429a      	cmp	r2, r3
3400c2bc:	d027      	beq.n	3400c30e <knl_appendFreeArea+0x88>
3400c2be:	68bb      	ldr	r3, [r7, #8]
3400c2c0:	3308      	adds	r3, #8
3400c2c2:	685b      	ldr	r3, [r3, #4]
3400c2c4:	461a      	mov	r2, r3
3400c2c6:	68fb      	ldr	r3, [r7, #12]
3400c2c8:	4293      	cmp	r3, r2
3400c2ca:	d120      	bne.n	3400c30e <knl_appendFreeArea+0x88>
		/* FreeQue Same size */
		(aq + 2)->next = (fq + 1)->next;
3400c2cc:	68bb      	ldr	r3, [r7, #8]
3400c2ce:	f103 0208 	add.w	r2, r3, #8
3400c2d2:	683b      	ldr	r3, [r7, #0]
3400c2d4:	3310      	adds	r3, #16
3400c2d6:	6812      	ldr	r2, [r2, #0]
3400c2d8:	601a      	str	r2, [r3, #0]
		(fq + 1)->next = aq + 2;
3400c2da:	68bb      	ldr	r3, [r7, #8]
3400c2dc:	3308      	adds	r3, #8
3400c2de:	683a      	ldr	r2, [r7, #0]
3400c2e0:	3210      	adds	r2, #16
3400c2e2:	601a      	str	r2, [r3, #0]
		(aq + 2)->prev = fq + 1;
3400c2e4:	683b      	ldr	r3, [r7, #0]
3400c2e6:	3310      	adds	r3, #16
3400c2e8:	68ba      	ldr	r2, [r7, #8]
3400c2ea:	3208      	adds	r2, #8
3400c2ec:	605a      	str	r2, [r3, #4]
		if( (aq + 2)->next != NULL ) {
3400c2ee:	683b      	ldr	r3, [r7, #0]
3400c2f0:	3310      	adds	r3, #16
3400c2f2:	681b      	ldr	r3, [r3, #0]
3400c2f4:	2b00      	cmp	r3, #0
3400c2f6:	d005      	beq.n	3400c304 <knl_appendFreeArea+0x7e>
			(aq + 2)->next->prev = aq + 2;
3400c2f8:	683b      	ldr	r3, [r7, #0]
3400c2fa:	3310      	adds	r3, #16
3400c2fc:	681b      	ldr	r3, [r3, #0]
3400c2fe:	683a      	ldr	r2, [r7, #0]
3400c300:	3210      	adds	r2, #16
3400c302:	605a      	str	r2, [r3, #4]
		}
		(aq + 1)->next = NULL;
3400c304:	683b      	ldr	r3, [r7, #0]
3400c306:	3308      	adds	r3, #8
3400c308:	2200      	movs	r2, #0
3400c30a:	601a      	str	r2, [r3, #0]
3400c30c:	e00e      	b.n	3400c32c <knl_appendFreeArea+0xa6>
	} else {
		/* FreeQue Size order */
		QueInsert(aq + 1, fq);
3400c30e:	683b      	ldr	r3, [r7, #0]
3400c310:	3308      	adds	r3, #8
3400c312:	68b9      	ldr	r1, [r7, #8]
3400c314:	4618      	mov	r0, r3
3400c316:	f7ff ff35 	bl	3400c184 <QueInsert>
		(aq + 2)->next = NULL;
3400c31a:	683b      	ldr	r3, [r7, #0]
3400c31c:	3310      	adds	r3, #16
3400c31e:	2200      	movs	r2, #0
3400c320:	601a      	str	r2, [r3, #0]
		(aq + 2)->prev = (QUEUE*)size;
3400c322:	683b      	ldr	r3, [r7, #0]
3400c324:	3310      	adds	r3, #16
3400c326:	68fa      	ldr	r2, [r7, #12]
3400c328:	605a      	str	r2, [r3, #4]
	}
}
3400c32a:	bf00      	nop
3400c32c:	bf00      	nop
3400c32e:	3710      	adds	r7, #16
3400c330:	46bd      	mov	sp, r7
3400c332:	bd80      	pop	{r7, pc}

3400c334 <knl_removeFreeQue>:

/*
 * Delete from FreeQue
 */
EXPORT void knl_removeFreeQue( QUEUE *fq )
{
3400c334:	b580      	push	{r7, lr}
3400c336:	b082      	sub	sp, #8
3400c338:	af00      	add	r7, sp, #0
3400c33a:	6078      	str	r0, [r7, #4]
	if ( fq->next == NULL ) {	/* FreeQue Same size */
3400c33c:	687b      	ldr	r3, [r7, #4]
3400c33e:	681b      	ldr	r3, [r3, #0]
3400c340:	2b00      	cmp	r3, #0
3400c342:	d115      	bne.n	3400c370 <knl_removeFreeQue+0x3c>
		(fq + 1)->prev->next = (fq + 1)->next;
3400c344:	687b      	ldr	r3, [r7, #4]
3400c346:	f103 0208 	add.w	r2, r3, #8
3400c34a:	687b      	ldr	r3, [r7, #4]
3400c34c:	3308      	adds	r3, #8
3400c34e:	685b      	ldr	r3, [r3, #4]
3400c350:	6812      	ldr	r2, [r2, #0]
3400c352:	601a      	str	r2, [r3, #0]
		if ( (fq + 1)->next != NULL ) {
3400c354:	687b      	ldr	r3, [r7, #4]
3400c356:	3308      	adds	r3, #8
3400c358:	681b      	ldr	r3, [r3, #0]
3400c35a:	2b00      	cmp	r3, #0
3400c35c:	d020      	beq.n	3400c3a0 <knl_removeFreeQue+0x6c>
			(fq + 1)->next->prev = (fq + 1)->prev;
3400c35e:	687b      	ldr	r3, [r7, #4]
3400c360:	f103 0208 	add.w	r2, r3, #8
3400c364:	687b      	ldr	r3, [r7, #4]
3400c366:	3308      	adds	r3, #8
3400c368:	681b      	ldr	r3, [r3, #0]
3400c36a:	6852      	ldr	r2, [r2, #4]
3400c36c:	605a      	str	r2, [r3, #4]
			QueInsert((fq + 1)->next - 1, fq);
			(fq + 1)->next->prev = (fq + 1)->prev;
		}
		QueRemove(fq);
	}
}
3400c36e:	e017      	b.n	3400c3a0 <knl_removeFreeQue+0x6c>
		if ( (fq + 1)->next != NULL ) {		/* having FreeQue Same size */
3400c370:	687b      	ldr	r3, [r7, #4]
3400c372:	3308      	adds	r3, #8
3400c374:	681b      	ldr	r3, [r3, #0]
3400c376:	2b00      	cmp	r3, #0
3400c378:	d00f      	beq.n	3400c39a <knl_removeFreeQue+0x66>
			QueInsert((fq + 1)->next - 1, fq);
3400c37a:	687b      	ldr	r3, [r7, #4]
3400c37c:	3308      	adds	r3, #8
3400c37e:	681b      	ldr	r3, [r3, #0]
3400c380:	3b08      	subs	r3, #8
3400c382:	6879      	ldr	r1, [r7, #4]
3400c384:	4618      	mov	r0, r3
3400c386:	f7ff fefd 	bl	3400c184 <QueInsert>
			(fq + 1)->next->prev = (fq + 1)->prev;
3400c38a:	687b      	ldr	r3, [r7, #4]
3400c38c:	f103 0208 	add.w	r2, r3, #8
3400c390:	687b      	ldr	r3, [r7, #4]
3400c392:	3308      	adds	r3, #8
3400c394:	681b      	ldr	r3, [r3, #0]
3400c396:	6852      	ldr	r2, [r2, #4]
3400c398:	605a      	str	r2, [r3, #4]
		QueRemove(fq);
3400c39a:	6878      	ldr	r0, [r7, #4]
3400c39c:	f7ff ff0b 	bl	3400c1b6 <QueRemove>
}
3400c3a0:	bf00      	nop
3400c3a2:	3708      	adds	r7, #8
3400c3a4:	46bd      	mov	sp, r7
3400c3a6:	bd80      	pop	{r7, pc}

3400c3a8 <knl_insertAreaQue>:
/*
 * Register area
 *	Insert 'ent' just after 'que.'
 */
EXPORT void knl_insertAreaQue( QUEUE *que, QUEUE *ent )
{
3400c3a8:	b480      	push	{r7}
3400c3aa:	b083      	sub	sp, #12
3400c3ac:	af00      	add	r7, sp, #0
3400c3ae:	6078      	str	r0, [r7, #4]
3400c3b0:	6039      	str	r1, [r7, #0]
	ent->prev = que;
3400c3b2:	683b      	ldr	r3, [r7, #0]
3400c3b4:	687a      	ldr	r2, [r7, #4]
3400c3b6:	605a      	str	r2, [r3, #4]
	ent->next = que->next;
3400c3b8:	687b      	ldr	r3, [r7, #4]
3400c3ba:	681a      	ldr	r2, [r3, #0]
3400c3bc:	683b      	ldr	r3, [r7, #0]
3400c3be:	601a      	str	r2, [r3, #0]
	Assign(que->next->prev, ent);
3400c3c0:	687b      	ldr	r3, [r7, #4]
3400c3c2:	681b      	ldr	r3, [r3, #0]
3400c3c4:	685b      	ldr	r3, [r3, #4]
3400c3c6:	f003 0201 	and.w	r2, r3, #1
3400c3ca:	683b      	ldr	r3, [r7, #0]
3400c3cc:	431a      	orrs	r2, r3
3400c3ce:	687b      	ldr	r3, [r7, #4]
3400c3d0:	681b      	ldr	r3, [r3, #0]
3400c3d2:	605a      	str	r2, [r3, #4]
	que->next = ent;
3400c3d4:	687b      	ldr	r3, [r7, #4]
3400c3d6:	683a      	ldr	r2, [r7, #0]
3400c3d8:	601a      	str	r2, [r3, #0]
}
3400c3da:	bf00      	nop
3400c3dc:	370c      	adds	r7, #12
3400c3de:	46bd      	mov	sp, r7
3400c3e0:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c3e4:	4770      	bx	lr

3400c3e6 <knl_removeAreaQue>:

/*
 * Delete area
 */
EXPORT void knl_removeAreaQue( QUEUE *aq )
{
3400c3e6:	b480      	push	{r7}
3400c3e8:	b083      	sub	sp, #12
3400c3ea:	af00      	add	r7, sp, #0
3400c3ec:	6078      	str	r0, [r7, #4]
	Mask(aq->prev)->next = aq->next;
3400c3ee:	687b      	ldr	r3, [r7, #4]
3400c3f0:	685b      	ldr	r3, [r3, #4]
3400c3f2:	f023 0301 	bic.w	r3, r3, #1
3400c3f6:	461a      	mov	r2, r3
3400c3f8:	687b      	ldr	r3, [r7, #4]
3400c3fa:	681b      	ldr	r3, [r3, #0]
3400c3fc:	6013      	str	r3, [r2, #0]
	Assign(aq->next->prev, Mask(aq->prev));
3400c3fe:	687b      	ldr	r3, [r7, #4]
3400c400:	681b      	ldr	r3, [r3, #0]
3400c402:	685b      	ldr	r3, [r3, #4]
3400c404:	f003 0201 	and.w	r2, r3, #1
3400c408:	687b      	ldr	r3, [r7, #4]
3400c40a:	685b      	ldr	r3, [r3, #4]
3400c40c:	f023 0301 	bic.w	r3, r3, #1
3400c410:	431a      	orrs	r2, r3
3400c412:	687b      	ldr	r3, [r7, #4]
3400c414:	681b      	ldr	r3, [r3, #0]
3400c416:	605a      	str	r2, [r3, #4]
}
3400c418:	bf00      	nop
3400c41a:	370c      	adds	r7, #12
3400c41c:	46bd      	mov	sp, r7
3400c41e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c422:	4770      	bx	lr

3400c424 <knl_Imalloc>:

/*
 * Memory allocate
 */
EXPORT void* knl_Imalloc( SZ size )
{
3400c424:	b580      	push	{r7, lr}
3400c426:	b086      	sub	sp, #24
3400c428:	af00      	add	r7, sp, #0
3400c42a:	6078      	str	r0, [r7, #4]
	QUEUE	*q, *aq, *aq2;
	UINT	imask;

	/* If it is smaller than the minimum fragment size,
	   allocate the minimum size to it. */
	if( size <= 0 ) {
3400c42c:	687b      	ldr	r3, [r7, #4]
3400c42e:	2b00      	cmp	r3, #0
3400c430:	dc01      	bgt.n	3400c436 <knl_Imalloc+0x12>
		return (void *)NULL;
3400c432:	2300      	movs	r3, #0
3400c434:	e045      	b.n	3400c4c2 <knl_Imalloc+0x9e>
	} else 	if ( size < MIN_FRAGMENT ) {
3400c436:	687b      	ldr	r3, [r7, #4]
3400c438:	2b0f      	cmp	r3, #15
3400c43a:	d802      	bhi.n	3400c442 <knl_Imalloc+0x1e>
		size = MIN_FRAGMENT;
3400c43c:	2310      	movs	r3, #16
3400c43e:	607b      	str	r3, [r7, #4]
3400c440:	e004      	b.n	3400c44c <knl_Imalloc+0x28>
	} else {
		size = ROUND(size);
3400c442:	687b      	ldr	r3, [r7, #4]
3400c444:	3307      	adds	r3, #7
3400c446:	f023 0307 	bic.w	r3, r3, #7
3400c44a:	607b      	str	r3, [r7, #4]
	}

	DI(imask);  /* Exclusive control by interrupt disable */
3400c44c:	f003 fbd9 	bl	3400fc02 <disint>
3400c450:	6138      	str	r0, [r7, #16]

	/* Search FreeQue */
	q = knl_searchFreeArea(knl_imacb, size);
3400c452:	4b1e      	ldr	r3, [pc, #120]	@ (3400c4cc <knl_Imalloc+0xa8>)
3400c454:	681b      	ldr	r3, [r3, #0]
3400c456:	6879      	ldr	r1, [r7, #4]
3400c458:	4618      	mov	r0, r3
3400c45a:	f7ff fec5 	bl	3400c1e8 <knl_searchFreeArea>
3400c45e:	6178      	str	r0, [r7, #20]
	if ( q == &(knl_imacb->freeque) ) {
3400c460:	4b1a      	ldr	r3, [pc, #104]	@ (3400c4cc <knl_Imalloc+0xa8>)
3400c462:	681b      	ldr	r3, [r3, #0]
3400c464:	330c      	adds	r3, #12
3400c466:	697a      	ldr	r2, [r7, #20]
3400c468:	429a      	cmp	r2, r3
3400c46a:	d102      	bne.n	3400c472 <knl_Imalloc+0x4e>
		q = NULL; /* Insufficient memory */
3400c46c:	2300      	movs	r3, #0
3400c46e:	617b      	str	r3, [r7, #20]
		goto err_ret;
3400c470:	e023      	b.n	3400c4ba <knl_Imalloc+0x96>
	}

	/* There is free area: Split from FreeQue once */
	knl_removeFreeQue(q);
3400c472:	6978      	ldr	r0, [r7, #20]
3400c474:	f7ff ff5e 	bl	3400c334 <knl_removeFreeQue>

	aq = q - 1;
3400c478:	697b      	ldr	r3, [r7, #20]
3400c47a:	3b08      	subs	r3, #8
3400c47c:	60fb      	str	r3, [r7, #12]

	/* If there are fragments smaller than the minimum fragment size,
	   allocate them also */
	if ( FreeSize(q) - size >= MIN_FRAGMENT + sizeof(QUEUE) ) {
3400c47e:	697b      	ldr	r3, [r7, #20]
3400c480:	3308      	adds	r3, #8
3400c482:	685b      	ldr	r3, [r3, #4]
3400c484:	461a      	mov	r2, r3
3400c486:	687b      	ldr	r3, [r7, #4]
3400c488:	1ad3      	subs	r3, r2, r3
3400c48a:	2b17      	cmp	r3, #23
3400c48c:	d90e      	bls.n	3400c4ac <knl_Imalloc+0x88>

		/* Divide area into 2 */
		aq2 = (QUEUE*)((VB*)(aq + 1) + size);
3400c48e:	687b      	ldr	r3, [r7, #4]
3400c490:	3308      	adds	r3, #8
3400c492:	68fa      	ldr	r2, [r7, #12]
3400c494:	4413      	add	r3, r2
3400c496:	60bb      	str	r3, [r7, #8]
		knl_insertAreaQue(aq, aq2);
3400c498:	68b9      	ldr	r1, [r7, #8]
3400c49a:	68f8      	ldr	r0, [r7, #12]
3400c49c:	f7ff ff84 	bl	3400c3a8 <knl_insertAreaQue>

		/* Register remaining area to FreeQue */
		knl_appendFreeArea(knl_imacb, aq2);
3400c4a0:	4b0a      	ldr	r3, [pc, #40]	@ (3400c4cc <knl_Imalloc+0xa8>)
3400c4a2:	681b      	ldr	r3, [r3, #0]
3400c4a4:	68b9      	ldr	r1, [r7, #8]
3400c4a6:	4618      	mov	r0, r3
3400c4a8:	f7ff feed 	bl	3400c286 <knl_appendFreeArea>
	}
	setAreaFlag(aq, AREA_USE);
3400c4ac:	68fb      	ldr	r3, [r7, #12]
3400c4ae:	685b      	ldr	r3, [r3, #4]
3400c4b0:	f043 0301 	orr.w	r3, r3, #1
3400c4b4:	461a      	mov	r2, r3
3400c4b6:	68fb      	ldr	r3, [r7, #12]
3400c4b8:	605a      	str	r2, [r3, #4]

err_ret:
	EI(imask);
3400c4ba:	6938      	ldr	r0, [r7, #16]
3400c4bc:	f003 fb85 	bl	3400fbca <set_basepri>

	return (void *)q;
3400c4c0:	697b      	ldr	r3, [r7, #20]
}
3400c4c2:	4618      	mov	r0, r3
3400c4c4:	3718      	adds	r7, #24
3400c4c6:	46bd      	mov	sp, r7
3400c4c8:	bd80      	pop	{r7, pc}
3400c4ca:	bf00      	nop
3400c4cc:	34012160 	.word	0x34012160

3400c4d0 <knl_Ifree>:

/*
 * Free memory
 */
EXPORT void  knl_Ifree( void *ptr )
{
3400c4d0:	b580      	push	{r7, lr}
3400c4d2:	b084      	sub	sp, #16
3400c4d4:	af00      	add	r7, sp, #0
3400c4d6:	6078      	str	r0, [r7, #4]
	QUEUE	*aq;
	UINT	imask;

	DI(imask);  /* Exclusive control by interrupt disable */
3400c4d8:	f003 fb93 	bl	3400fc02 <disint>
3400c4dc:	60b8      	str	r0, [r7, #8]

	aq = (QUEUE*)ptr - 1;
3400c4de:	687b      	ldr	r3, [r7, #4]
3400c4e0:	3b08      	subs	r3, #8
3400c4e2:	60fb      	str	r3, [r7, #12]
	clrAreaFlag(aq, AREA_USE);
3400c4e4:	68fb      	ldr	r3, [r7, #12]
3400c4e6:	685b      	ldr	r3, [r3, #4]
3400c4e8:	f023 0301 	bic.w	r3, r3, #1
3400c4ec:	461a      	mov	r2, r3
3400c4ee:	68fb      	ldr	r3, [r7, #12]
3400c4f0:	605a      	str	r2, [r3, #4]

	if ( !chkAreaFlag(aq->next, AREA_USE) ) {
3400c4f2:	68fb      	ldr	r3, [r7, #12]
3400c4f4:	681b      	ldr	r3, [r3, #0]
3400c4f6:	685b      	ldr	r3, [r3, #4]
3400c4f8:	f003 0301 	and.w	r3, r3, #1
3400c4fc:	2b00      	cmp	r3, #0
3400c4fe:	d10a      	bne.n	3400c516 <knl_Ifree+0x46>
		/* Merge with free area in after location */
		knl_removeFreeQue(aq->next + 1);
3400c500:	68fb      	ldr	r3, [r7, #12]
3400c502:	681b      	ldr	r3, [r3, #0]
3400c504:	3308      	adds	r3, #8
3400c506:	4618      	mov	r0, r3
3400c508:	f7ff ff14 	bl	3400c334 <knl_removeFreeQue>
		knl_removeAreaQue(aq->next);
3400c50c:	68fb      	ldr	r3, [r7, #12]
3400c50e:	681b      	ldr	r3, [r3, #0]
3400c510:	4618      	mov	r0, r3
3400c512:	f7ff ff68 	bl	3400c3e6 <knl_removeAreaQue>
	}

	if ( !chkAreaFlag(aq->prev, AREA_USE) ) {
3400c516:	68fb      	ldr	r3, [r7, #12]
3400c518:	685b      	ldr	r3, [r3, #4]
3400c51a:	685b      	ldr	r3, [r3, #4]
3400c51c:	f003 0301 	and.w	r3, r3, #1
3400c520:	2b00      	cmp	r3, #0
3400c522:	d10c      	bne.n	3400c53e <knl_Ifree+0x6e>
		/* Merge with free area in front location */
		aq = aq->prev;
3400c524:	68fb      	ldr	r3, [r7, #12]
3400c526:	685b      	ldr	r3, [r3, #4]
3400c528:	60fb      	str	r3, [r7, #12]
		knl_removeFreeQue(aq + 1);
3400c52a:	68fb      	ldr	r3, [r7, #12]
3400c52c:	3308      	adds	r3, #8
3400c52e:	4618      	mov	r0, r3
3400c530:	f7ff ff00 	bl	3400c334 <knl_removeFreeQue>
		knl_removeAreaQue(aq->next);
3400c534:	68fb      	ldr	r3, [r7, #12]
3400c536:	681b      	ldr	r3, [r3, #0]
3400c538:	4618      	mov	r0, r3
3400c53a:	f7ff ff54 	bl	3400c3e6 <knl_removeAreaQue>
	}

	knl_appendFreeArea(knl_imacb, aq);
3400c53e:	4b06      	ldr	r3, [pc, #24]	@ (3400c558 <knl_Ifree+0x88>)
3400c540:	681b      	ldr	r3, [r3, #0]
3400c542:	68f9      	ldr	r1, [r7, #12]
3400c544:	4618      	mov	r0, r3
3400c546:	f7ff fe9e 	bl	3400c286 <knl_appendFreeArea>

	EI(imask);
3400c54a:	68b8      	ldr	r0, [r7, #8]
3400c54c:	f003 fb3d 	bl	3400fbca <set_basepri>
}
3400c550:	bf00      	nop
3400c552:	3710      	adds	r7, #16
3400c554:	46bd      	mov	sp, r7
3400c556:	bd80      	pop	{r7, pc}
3400c558:	34012160 	.word	0x34012160

3400c55c <initIMACB>:

/*
 * IMACB Initialization 
 */
LOCAL void initIMACB( void )
{
3400c55c:	b580      	push	{r7, lr}
3400c55e:	af00      	add	r7, sp, #0
	QueInit(&(knl_imacb->areaque));
3400c560:	4b06      	ldr	r3, [pc, #24]	@ (3400c57c <initIMACB+0x20>)
3400c562:	681b      	ldr	r3, [r3, #0]
3400c564:	3304      	adds	r3, #4
3400c566:	4618      	mov	r0, r3
3400c568:	f7ff fdfc 	bl	3400c164 <QueInit>
	QueInit(&(knl_imacb->freeque));
3400c56c:	4b03      	ldr	r3, [pc, #12]	@ (3400c57c <initIMACB+0x20>)
3400c56e:	681b      	ldr	r3, [r3, #0]
3400c570:	330c      	adds	r3, #12
3400c572:	4618      	mov	r0, r3
3400c574:	f7ff fdf6 	bl	3400c164 <QueInit>
}
3400c578:	bf00      	nop
3400c57a:	bd80      	pop	{r7, pc}
3400c57c:	34012160 	.word	0x34012160

3400c580 <knl_init_Imalloc>:

/*
 * Imalloc initial setting 
 */
EXPORT ER knl_init_Imalloc( void )
{
3400c580:	b580      	push	{r7, lr}
3400c582:	b082      	sub	sp, #8
3400c584:	af00      	add	r7, sp, #0
	QUEUE	*top, *end;

	/* Align top with 4 byte unit alignment for IMACB */
	knl_lowmem_top = (void *)(((UW)knl_lowmem_top + 3) & ~0x00000003UL);
3400c586:	4b2e      	ldr	r3, [pc, #184]	@ (3400c640 <knl_init_Imalloc+0xc0>)
3400c588:	681b      	ldr	r3, [r3, #0]
3400c58a:	3303      	adds	r3, #3
3400c58c:	f023 0303 	bic.w	r3, r3, #3
3400c590:	461a      	mov	r2, r3
3400c592:	4b2b      	ldr	r3, [pc, #172]	@ (3400c640 <knl_init_Imalloc+0xc0>)
3400c594:	601a      	str	r2, [r3, #0]
	knl_imacb = (IMACB*)knl_lowmem_top;
3400c596:	4b2a      	ldr	r3, [pc, #168]	@ (3400c640 <knl_init_Imalloc+0xc0>)
3400c598:	681b      	ldr	r3, [r3, #0]
3400c59a:	4a2a      	ldr	r2, [pc, #168]	@ (3400c644 <knl_init_Imalloc+0xc4>)
3400c59c:	6013      	str	r3, [r2, #0]
	knl_lowmem_top = (void *)((UW)knl_lowmem_top + sizeof(IMACB));
3400c59e:	4b28      	ldr	r3, [pc, #160]	@ (3400c640 <knl_init_Imalloc+0xc0>)
3400c5a0:	681b      	ldr	r3, [r3, #0]
3400c5a2:	3314      	adds	r3, #20
3400c5a4:	461a      	mov	r2, r3
3400c5a6:	4b26      	ldr	r3, [pc, #152]	@ (3400c640 <knl_init_Imalloc+0xc0>)
3400c5a8:	601a      	str	r2, [r3, #0]

	/* Align top with 8 byte unit alignment */
	knl_lowmem_top = (void *)(((UW)knl_lowmem_top + 7) & ~0x00000007UL);
3400c5aa:	4b25      	ldr	r3, [pc, #148]	@ (3400c640 <knl_init_Imalloc+0xc0>)
3400c5ac:	681b      	ldr	r3, [r3, #0]
3400c5ae:	3307      	adds	r3, #7
3400c5b0:	f023 0307 	bic.w	r3, r3, #7
3400c5b4:	461a      	mov	r2, r3
3400c5b6:	4b22      	ldr	r3, [pc, #136]	@ (3400c640 <knl_init_Imalloc+0xc0>)
3400c5b8:	601a      	str	r2, [r3, #0]
	top = (QUEUE*)knl_lowmem_top;
3400c5ba:	4b21      	ldr	r3, [pc, #132]	@ (3400c640 <knl_init_Imalloc+0xc0>)
3400c5bc:	681b      	ldr	r3, [r3, #0]
3400c5be:	607b      	str	r3, [r7, #4]
	knl_imacb->memsz = (W)((UW)knl_lowmem_limit - (UW)knl_lowmem_top - sizeof(QUEUE)*2);
3400c5c0:	4b21      	ldr	r3, [pc, #132]	@ (3400c648 <knl_init_Imalloc+0xc8>)
3400c5c2:	681b      	ldr	r3, [r3, #0]
3400c5c4:	461a      	mov	r2, r3
3400c5c6:	4b1e      	ldr	r3, [pc, #120]	@ (3400c640 <knl_init_Imalloc+0xc0>)
3400c5c8:	681b      	ldr	r3, [r3, #0]
3400c5ca:	1ad3      	subs	r3, r2, r3
3400c5cc:	f1a3 0210 	sub.w	r2, r3, #16
3400c5d0:	4b1c      	ldr	r3, [pc, #112]	@ (3400c644 <knl_init_Imalloc+0xc4>)
3400c5d2:	681b      	ldr	r3, [r3, #0]
3400c5d4:	601a      	str	r2, [r3, #0]

	knl_lowmem_top = knl_lowmem_limit;  /* Update memory free space */
3400c5d6:	4b1c      	ldr	r3, [pc, #112]	@ (3400c648 <knl_init_Imalloc+0xc8>)
3400c5d8:	681b      	ldr	r3, [r3, #0]
3400c5da:	4a19      	ldr	r2, [pc, #100]	@ (3400c640 <knl_init_Imalloc+0xc0>)
3400c5dc:	6013      	str	r3, [r2, #0]

	initIMACB();
3400c5de:	f7ff ffbd 	bl	3400c55c <initIMACB>

	/* Register on AreaQue */
	end = (QUEUE*)((VB*)top + knl_imacb->memsz) + 1;
3400c5e2:	4b18      	ldr	r3, [pc, #96]	@ (3400c644 <knl_init_Imalloc+0xc4>)
3400c5e4:	681b      	ldr	r3, [r3, #0]
3400c5e6:	681b      	ldr	r3, [r3, #0]
3400c5e8:	3308      	adds	r3, #8
3400c5ea:	687a      	ldr	r2, [r7, #4]
3400c5ec:	4413      	add	r3, r2
3400c5ee:	603b      	str	r3, [r7, #0]
	knl_insertAreaQue(&knl_imacb->areaque, end);
3400c5f0:	4b14      	ldr	r3, [pc, #80]	@ (3400c644 <knl_init_Imalloc+0xc4>)
3400c5f2:	681b      	ldr	r3, [r3, #0]
3400c5f4:	3304      	adds	r3, #4
3400c5f6:	6839      	ldr	r1, [r7, #0]
3400c5f8:	4618      	mov	r0, r3
3400c5fa:	f7ff fed5 	bl	3400c3a8 <knl_insertAreaQue>
	knl_insertAreaQue(&knl_imacb->areaque, top);
3400c5fe:	4b11      	ldr	r3, [pc, #68]	@ (3400c644 <knl_init_Imalloc+0xc4>)
3400c600:	681b      	ldr	r3, [r3, #0]
3400c602:	3304      	adds	r3, #4
3400c604:	6879      	ldr	r1, [r7, #4]
3400c606:	4618      	mov	r0, r3
3400c608:	f7ff fece 	bl	3400c3a8 <knl_insertAreaQue>
	setAreaFlag(end, AREA_USE);
3400c60c:	683b      	ldr	r3, [r7, #0]
3400c60e:	685b      	ldr	r3, [r3, #4]
3400c610:	f043 0301 	orr.w	r3, r3, #1
3400c614:	461a      	mov	r2, r3
3400c616:	683b      	ldr	r3, [r7, #0]
3400c618:	605a      	str	r2, [r3, #4]
	setAreaFlag(&knl_imacb->areaque, AREA_USE);
3400c61a:	4b0a      	ldr	r3, [pc, #40]	@ (3400c644 <knl_init_Imalloc+0xc4>)
3400c61c:	681b      	ldr	r3, [r3, #0]
3400c61e:	689b      	ldr	r3, [r3, #8]
3400c620:	f043 0201 	orr.w	r2, r3, #1
3400c624:	4b07      	ldr	r3, [pc, #28]	@ (3400c644 <knl_init_Imalloc+0xc4>)
3400c626:	681b      	ldr	r3, [r3, #0]
3400c628:	609a      	str	r2, [r3, #8]

	knl_appendFreeArea(knl_imacb, top);
3400c62a:	4b06      	ldr	r3, [pc, #24]	@ (3400c644 <knl_init_Imalloc+0xc4>)
3400c62c:	681b      	ldr	r3, [r3, #0]
3400c62e:	6879      	ldr	r1, [r7, #4]
3400c630:	4618      	mov	r0, r3
3400c632:	f7ff fe28 	bl	3400c286 <knl_appendFreeArea>

	return E_OK;
3400c636:	2300      	movs	r3, #0
}
3400c638:	4618      	mov	r0, r3
3400c63a:	3708      	adds	r7, #8
3400c63c:	46bd      	mov	sp, r7
3400c63e:	bd80      	pop	{r7, pc}
3400c640:	340114f4 	.word	0x340114f4
3400c644:	34012160 	.word	0x34012160
3400c648:	340114f8 	.word	0x340114f8

3400c64c <QueInit>:
{
3400c64c:	b480      	push	{r7}
3400c64e:	b083      	sub	sp, #12
3400c650:	af00      	add	r7, sp, #0
3400c652:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400c654:	687b      	ldr	r3, [r7, #4]
3400c656:	687a      	ldr	r2, [r7, #4]
3400c658:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400c65a:	687b      	ldr	r3, [r7, #4]
3400c65c:	687a      	ldr	r2, [r7, #4]
3400c65e:	605a      	str	r2, [r3, #4]
}
3400c660:	bf00      	nop
3400c662:	370c      	adds	r7, #12
3400c664:	46bd      	mov	sp, r7
3400c666:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c66a:	4770      	bx	lr

3400c66c <QueInsert>:
{
3400c66c:	b480      	push	{r7}
3400c66e:	b083      	sub	sp, #12
3400c670:	af00      	add	r7, sp, #0
3400c672:	6078      	str	r0, [r7, #4]
3400c674:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400c676:	683b      	ldr	r3, [r7, #0]
3400c678:	685a      	ldr	r2, [r3, #4]
3400c67a:	687b      	ldr	r3, [r7, #4]
3400c67c:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400c67e:	687b      	ldr	r3, [r7, #4]
3400c680:	683a      	ldr	r2, [r7, #0]
3400c682:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400c684:	683b      	ldr	r3, [r7, #0]
3400c686:	685b      	ldr	r3, [r3, #4]
3400c688:	687a      	ldr	r2, [r7, #4]
3400c68a:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400c68c:	683b      	ldr	r3, [r7, #0]
3400c68e:	687a      	ldr	r2, [r7, #4]
3400c690:	605a      	str	r2, [r3, #4]
}
3400c692:	bf00      	nop
3400c694:	370c      	adds	r7, #12
3400c696:	46bd      	mov	sp, r7
3400c698:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c69c:	4770      	bx	lr

3400c69e <knl_InitOBJLOCK>:
typedef struct objlock {
	QUEUE		wtskq;		/* Wait task queue */
} OBJLOCK;

Inline void knl_InitOBJLOCK( OBJLOCK *loc )
{
3400c69e:	b480      	push	{r7}
3400c6a0:	b083      	sub	sp, #12
3400c6a2:	af00      	add	r7, sp, #0
3400c6a4:	6078      	str	r0, [r7, #4]
	loc->wtskq.next = NULL;
3400c6a6:	687b      	ldr	r3, [r7, #4]
3400c6a8:	2200      	movs	r2, #0
3400c6aa:	601a      	str	r2, [r3, #0]
}
3400c6ac:	bf00      	nop
3400c6ae:	370c      	adds	r7, #12
3400c6b0:	46bd      	mov	sp, r7
3400c6b2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c6b6:	4770      	bx	lr

3400c6b8 <knl_fix_memorypool_initialize>:

/*
 * Initialization of fixed size memory pool control block
 */
EXPORT ER knl_fix_memorypool_initialize( void )
{
3400c6b8:	b580      	push	{r7, lr}
3400c6ba:	b082      	sub	sp, #8
3400c6bc:	af00      	add	r7, sp, #0
	if ( NUM_MPFID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_mpfcb);
3400c6be:	4810      	ldr	r0, [pc, #64]	@ (3400c700 <knl_fix_memorypool_initialize+0x48>)
3400c6c0:	f7ff ffc4 	bl	3400c64c <QueInit>
	end = knl_mpfcb_table + NUM_MPFID;
3400c6c4:	4b0f      	ldr	r3, [pc, #60]	@ (3400c704 <knl_fix_memorypool_initialize+0x4c>)
3400c6c6:	603b      	str	r3, [r7, #0]
	for ( mpfcb = knl_mpfcb_table; mpfcb < end; mpfcb++ ) {
3400c6c8:	4b0f      	ldr	r3, [pc, #60]	@ (3400c708 <knl_fix_memorypool_initialize+0x50>)
3400c6ca:	607b      	str	r3, [r7, #4]
3400c6cc:	e00f      	b.n	3400c6ee <knl_fix_memorypool_initialize+0x36>
		mpfcb->mpfid = 0;
3400c6ce:	687b      	ldr	r3, [r7, #4]
3400c6d0:	2200      	movs	r2, #0
3400c6d2:	609a      	str	r2, [r3, #8]
		knl_InitOBJLOCK(&mpfcb->lock);
3400c6d4:	687b      	ldr	r3, [r7, #4]
3400c6d6:	3330      	adds	r3, #48	@ 0x30
3400c6d8:	4618      	mov	r0, r3
3400c6da:	f7ff ffe0 	bl	3400c69e <knl_InitOBJLOCK>
		QueInsert(&mpfcb->wait_queue, &knl_free_mpfcb);
3400c6de:	687b      	ldr	r3, [r7, #4]
3400c6e0:	4907      	ldr	r1, [pc, #28]	@ (3400c700 <knl_fix_memorypool_initialize+0x48>)
3400c6e2:	4618      	mov	r0, r3
3400c6e4:	f7ff ffc2 	bl	3400c66c <QueInsert>
	for ( mpfcb = knl_mpfcb_table; mpfcb < end; mpfcb++ ) {
3400c6e8:	687b      	ldr	r3, [r7, #4]
3400c6ea:	3338      	adds	r3, #56	@ 0x38
3400c6ec:	607b      	str	r3, [r7, #4]
3400c6ee:	687a      	ldr	r2, [r7, #4]
3400c6f0:	683b      	ldr	r3, [r7, #0]
3400c6f2:	429a      	cmp	r2, r3
3400c6f4:	d3eb      	bcc.n	3400c6ce <knl_fix_memorypool_initialize+0x16>
	}

	return E_OK;
3400c6f6:	2300      	movs	r3, #0
}
3400c6f8:	4618      	mov	r0, r3
3400c6fa:	3708      	adds	r7, #8
3400c6fc:	46bd      	mov	sp, r7
3400c6fe:	bd80      	pop	{r7, pc}
3400c700:	34012324 	.word	0x34012324
3400c704:	34012324 	.word	0x34012324
3400c708:	34012164 	.word	0x34012164

3400c70c <QueInit>:
{
3400c70c:	b480      	push	{r7}
3400c70e:	b083      	sub	sp, #12
3400c710:	af00      	add	r7, sp, #0
3400c712:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400c714:	687b      	ldr	r3, [r7, #4]
3400c716:	687a      	ldr	r2, [r7, #4]
3400c718:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400c71a:	687b      	ldr	r3, [r7, #4]
3400c71c:	687a      	ldr	r2, [r7, #4]
3400c71e:	605a      	str	r2, [r3, #4]
}
3400c720:	bf00      	nop
3400c722:	370c      	adds	r7, #12
3400c724:	46bd      	mov	sp, r7
3400c726:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c72a:	4770      	bx	lr

3400c72c <QueInsert>:
{
3400c72c:	b480      	push	{r7}
3400c72e:	b083      	sub	sp, #12
3400c730:	af00      	add	r7, sp, #0
3400c732:	6078      	str	r0, [r7, #4]
3400c734:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400c736:	683b      	ldr	r3, [r7, #0]
3400c738:	685a      	ldr	r2, [r3, #4]
3400c73a:	687b      	ldr	r3, [r7, #4]
3400c73c:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400c73e:	687b      	ldr	r3, [r7, #4]
3400c740:	683a      	ldr	r2, [r7, #0]
3400c742:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400c744:	683b      	ldr	r3, [r7, #0]
3400c746:	685b      	ldr	r3, [r3, #4]
3400c748:	687a      	ldr	r2, [r7, #4]
3400c74a:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400c74c:	683b      	ldr	r3, [r7, #0]
3400c74e:	687a      	ldr	r2, [r7, #4]
3400c750:	605a      	str	r2, [r3, #4]
}
3400c752:	bf00      	nop
3400c754:	370c      	adds	r7, #12
3400c756:	46bd      	mov	sp, r7
3400c758:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c75c:	4770      	bx	lr
	...

3400c760 <knl_memorypool_initialize>:

/*
 * Initialization of variable size memory pool control block
 */
EXPORT ER knl_memorypool_initialize( void )
{
3400c760:	b580      	push	{r7, lr}
3400c762:	b082      	sub	sp, #8
3400c764:	af00      	add	r7, sp, #0
	if ( NUM_MPLID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_mplcb);
3400c766:	480e      	ldr	r0, [pc, #56]	@ (3400c7a0 <knl_memorypool_initialize+0x40>)
3400c768:	f7ff ffd0 	bl	3400c70c <QueInit>
	end = knl_mplcb_table + NUM_MPLID;
3400c76c:	4b0d      	ldr	r3, [pc, #52]	@ (3400c7a4 <knl_memorypool_initialize+0x44>)
3400c76e:	603b      	str	r3, [r7, #0]
	for ( mplcb = knl_mplcb_table; mplcb < end; mplcb++ ) {
3400c770:	4b0d      	ldr	r3, [pc, #52]	@ (3400c7a8 <knl_memorypool_initialize+0x48>)
3400c772:	607b      	str	r3, [r7, #4]
3400c774:	e00a      	b.n	3400c78c <knl_memorypool_initialize+0x2c>
		mplcb->mplid = 0;
3400c776:	687b      	ldr	r3, [r7, #4]
3400c778:	2200      	movs	r2, #0
3400c77a:	609a      	str	r2, [r3, #8]
		QueInsert(&mplcb->wait_queue, &knl_free_mplcb);
3400c77c:	687b      	ldr	r3, [r7, #4]
3400c77e:	4908      	ldr	r1, [pc, #32]	@ (3400c7a0 <knl_memorypool_initialize+0x40>)
3400c780:	4618      	mov	r0, r3
3400c782:	f7ff ffd3 	bl	3400c72c <QueInsert>
	for ( mplcb = knl_mplcb_table; mplcb < end; mplcb++ ) {
3400c786:	687b      	ldr	r3, [r7, #4]
3400c788:	3334      	adds	r3, #52	@ 0x34
3400c78a:	607b      	str	r3, [r7, #4]
3400c78c:	687a      	ldr	r2, [r7, #4]
3400c78e:	683b      	ldr	r3, [r7, #0]
3400c790:	429a      	cmp	r2, r3
3400c792:	d3f0      	bcc.n	3400c776 <knl_memorypool_initialize+0x16>
	}

	return E_OK;
3400c794:	2300      	movs	r3, #0
}
3400c796:	4618      	mov	r0, r3
3400c798:	3708      	adds	r7, #8
3400c79a:	46bd      	mov	sp, r7
3400c79c:	bd80      	pop	{r7, pc}
3400c79e:	bf00      	nop
3400c7a0:	340123fc 	.word	0x340123fc
3400c7a4:	340123fc 	.word	0x340123fc
3400c7a8:	3401232c 	.word	0x3401232c

3400c7ac <QueInit>:
{
3400c7ac:	b480      	push	{r7}
3400c7ae:	b083      	sub	sp, #12
3400c7b0:	af00      	add	r7, sp, #0
3400c7b2:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400c7b4:	687b      	ldr	r3, [r7, #4]
3400c7b6:	687a      	ldr	r2, [r7, #4]
3400c7b8:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400c7ba:	687b      	ldr	r3, [r7, #4]
3400c7bc:	687a      	ldr	r2, [r7, #4]
3400c7be:	605a      	str	r2, [r3, #4]
}
3400c7c0:	bf00      	nop
3400c7c2:	370c      	adds	r7, #12
3400c7c4:	46bd      	mov	sp, r7
3400c7c6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c7ca:	4770      	bx	lr

3400c7cc <QueInsert>:
{
3400c7cc:	b480      	push	{r7}
3400c7ce:	b083      	sub	sp, #12
3400c7d0:	af00      	add	r7, sp, #0
3400c7d2:	6078      	str	r0, [r7, #4]
3400c7d4:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400c7d6:	683b      	ldr	r3, [r7, #0]
3400c7d8:	685a      	ldr	r2, [r3, #4]
3400c7da:	687b      	ldr	r3, [r7, #4]
3400c7dc:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400c7de:	687b      	ldr	r3, [r7, #4]
3400c7e0:	683a      	ldr	r2, [r7, #0]
3400c7e2:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400c7e4:	683b      	ldr	r3, [r7, #0]
3400c7e6:	685b      	ldr	r3, [r3, #4]
3400c7e8:	687a      	ldr	r2, [r7, #4]
3400c7ea:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400c7ec:	683b      	ldr	r3, [r7, #0]
3400c7ee:	687a      	ldr	r2, [r7, #4]
3400c7f0:	605a      	str	r2, [r3, #4]
}
3400c7f2:	bf00      	nop
3400c7f4:	370c      	adds	r7, #12
3400c7f6:	46bd      	mov	sp, r7
3400c7f8:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c7fc:	4770      	bx	lr
	...

3400c800 <knl_messagebuffer_initialize>:

/*
 * Initialization of message buffer control block 
 */
EXPORT ER knl_messagebuffer_initialize( void )
{
3400c800:	b580      	push	{r7, lr}
3400c802:	b082      	sub	sp, #8
3400c804:	af00      	add	r7, sp, #0
	if ( NUM_MBFID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_mbfcb);
3400c806:	480e      	ldr	r0, [pc, #56]	@ (3400c840 <knl_messagebuffer_initialize+0x40>)
3400c808:	f7ff ffd0 	bl	3400c7ac <QueInit>
	end = knl_mbfcb_table + NUM_MBFID;
3400c80c:	4b0d      	ldr	r3, [pc, #52]	@ (3400c844 <knl_messagebuffer_initialize+0x44>)
3400c80e:	603b      	str	r3, [r7, #0]
	for ( mbfcb = knl_mbfcb_table; mbfcb < end; mbfcb++ ) {
3400c810:	4b0d      	ldr	r3, [pc, #52]	@ (3400c848 <knl_messagebuffer_initialize+0x48>)
3400c812:	607b      	str	r3, [r7, #4]
3400c814:	e00a      	b.n	3400c82c <knl_messagebuffer_initialize+0x2c>
		mbfcb->mbfid = 0;
3400c816:	687b      	ldr	r3, [r7, #4]
3400c818:	2200      	movs	r2, #0
3400c81a:	609a      	str	r2, [r3, #8]
		QueInsert(&mbfcb->send_queue, &knl_free_mbfcb);
3400c81c:	687b      	ldr	r3, [r7, #4]
3400c81e:	4908      	ldr	r1, [pc, #32]	@ (3400c840 <knl_messagebuffer_initialize+0x40>)
3400c820:	4618      	mov	r0, r3
3400c822:	f7ff ffd3 	bl	3400c7cc <QueInsert>
	for ( mbfcb = knl_mbfcb_table; mbfcb < end; mbfcb++ ) {
3400c826:	687b      	ldr	r3, [r7, #4]
3400c828:	3334      	adds	r3, #52	@ 0x34
3400c82a:	607b      	str	r3, [r7, #4]
3400c82c:	687a      	ldr	r2, [r7, #4]
3400c82e:	683b      	ldr	r3, [r7, #0]
3400c830:	429a      	cmp	r2, r3
3400c832:	d3f0      	bcc.n	3400c816 <knl_messagebuffer_initialize+0x16>
	}

	return E_OK;
3400c834:	2300      	movs	r3, #0
}
3400c836:	4618      	mov	r0, r3
3400c838:	3708      	adds	r7, #8
3400c83a:	46bd      	mov	sp, r7
3400c83c:	bd80      	pop	{r7, pc}
3400c83e:	bf00      	nop
3400c840:	340125a4 	.word	0x340125a4
3400c844:	340125a4 	.word	0x340125a4
3400c848:	34012404 	.word	0x34012404

3400c84c <QueInit>:
{
3400c84c:	b480      	push	{r7}
3400c84e:	b083      	sub	sp, #12
3400c850:	af00      	add	r7, sp, #0
3400c852:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400c854:	687b      	ldr	r3, [r7, #4]
3400c856:	687a      	ldr	r2, [r7, #4]
3400c858:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400c85a:	687b      	ldr	r3, [r7, #4]
3400c85c:	687a      	ldr	r2, [r7, #4]
3400c85e:	605a      	str	r2, [r3, #4]
}
3400c860:	bf00      	nop
3400c862:	370c      	adds	r7, #12
3400c864:	46bd      	mov	sp, r7
3400c866:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c86a:	4770      	bx	lr

3400c86c <QueInsert>:
{
3400c86c:	b480      	push	{r7}
3400c86e:	b083      	sub	sp, #12
3400c870:	af00      	add	r7, sp, #0
3400c872:	6078      	str	r0, [r7, #4]
3400c874:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400c876:	683b      	ldr	r3, [r7, #0]
3400c878:	685a      	ldr	r2, [r3, #4]
3400c87a:	687b      	ldr	r3, [r7, #4]
3400c87c:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400c87e:	687b      	ldr	r3, [r7, #4]
3400c880:	683a      	ldr	r2, [r7, #0]
3400c882:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400c884:	683b      	ldr	r3, [r7, #0]
3400c886:	685b      	ldr	r3, [r3, #4]
3400c888:	687a      	ldr	r2, [r7, #4]
3400c88a:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400c88c:	683b      	ldr	r3, [r7, #0]
3400c88e:	687a      	ldr	r2, [r7, #4]
3400c890:	605a      	str	r2, [r3, #4]
}
3400c892:	bf00      	nop
3400c894:	370c      	adds	r7, #12
3400c896:	46bd      	mov	sp, r7
3400c898:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c89c:	4770      	bx	lr
	...

3400c8a0 <knl_mutex_initialize>:

/*
 * Initialization of mutex control block 
 */
EXPORT ER knl_mutex_initialize(void)
{
3400c8a0:	b580      	push	{r7, lr}
3400c8a2:	b082      	sub	sp, #8
3400c8a4:	af00      	add	r7, sp, #0
	if ( NUM_MTXID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_mtxcb);
3400c8a6:	480e      	ldr	r0, [pc, #56]	@ (3400c8e0 <knl_mutex_initialize+0x40>)
3400c8a8:	f7ff ffd0 	bl	3400c84c <QueInit>
	end = knl_mtxcb_table + NUM_MTXID;
3400c8ac:	4b0d      	ldr	r3, [pc, #52]	@ (3400c8e4 <knl_mutex_initialize+0x44>)
3400c8ae:	603b      	str	r3, [r7, #0]
	for( mtxcb = knl_mtxcb_table; mtxcb < end; mtxcb++ ) {
3400c8b0:	4b0d      	ldr	r3, [pc, #52]	@ (3400c8e8 <knl_mutex_initialize+0x48>)
3400c8b2:	607b      	str	r3, [r7, #4]
3400c8b4:	e00a      	b.n	3400c8cc <knl_mutex_initialize+0x2c>
		mtxcb->mtxid = 0;
3400c8b6:	687b      	ldr	r3, [r7, #4]
3400c8b8:	2200      	movs	r2, #0
3400c8ba:	609a      	str	r2, [r3, #8]
		QueInsert(&mtxcb->wait_queue, &knl_free_mtxcb);
3400c8bc:	687b      	ldr	r3, [r7, #4]
3400c8be:	4908      	ldr	r1, [pc, #32]	@ (3400c8e0 <knl_mutex_initialize+0x40>)
3400c8c0:	4618      	mov	r0, r3
3400c8c2:	f7ff ffd3 	bl	3400c86c <QueInsert>
	for( mtxcb = knl_mtxcb_table; mtxcb < end; mtxcb++ ) {
3400c8c6:	687b      	ldr	r3, [r7, #4]
3400c8c8:	3320      	adds	r3, #32
3400c8ca:	607b      	str	r3, [r7, #4]
3400c8cc:	687a      	ldr	r2, [r7, #4]
3400c8ce:	683b      	ldr	r3, [r7, #0]
3400c8d0:	429a      	cmp	r2, r3
3400c8d2:	d3f0      	bcc.n	3400c8b6 <knl_mutex_initialize+0x16>
	}

	return E_OK;
3400c8d4:	2300      	movs	r3, #0
}
3400c8d6:	4618      	mov	r0, r3
3400c8d8:	3708      	adds	r7, #8
3400c8da:	46bd      	mov	sp, r7
3400c8dc:	bd80      	pop	{r7, pc}
3400c8de:	bf00      	nop
3400c8e0:	3401262c 	.word	0x3401262c
3400c8e4:	3401262c 	.word	0x3401262c
3400c8e8:	340125ac 	.word	0x340125ac

3400c8ec <QueInit>:
{
3400c8ec:	b480      	push	{r7}
3400c8ee:	b083      	sub	sp, #12
3400c8f0:	af00      	add	r7, sp, #0
3400c8f2:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400c8f4:	687b      	ldr	r3, [r7, #4]
3400c8f6:	687a      	ldr	r2, [r7, #4]
3400c8f8:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400c8fa:	687b      	ldr	r3, [r7, #4]
3400c8fc:	687a      	ldr	r2, [r7, #4]
3400c8fe:	605a      	str	r2, [r3, #4]
}
3400c900:	bf00      	nop
3400c902:	370c      	adds	r7, #12
3400c904:	46bd      	mov	sp, r7
3400c906:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c90a:	4770      	bx	lr

3400c90c <QueInsert>:
{
3400c90c:	b480      	push	{r7}
3400c90e:	b083      	sub	sp, #12
3400c910:	af00      	add	r7, sp, #0
3400c912:	6078      	str	r0, [r7, #4]
3400c914:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400c916:	683b      	ldr	r3, [r7, #0]
3400c918:	685a      	ldr	r2, [r3, #4]
3400c91a:	687b      	ldr	r3, [r7, #4]
3400c91c:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400c91e:	687b      	ldr	r3, [r7, #4]
3400c920:	683a      	ldr	r2, [r7, #0]
3400c922:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400c924:	683b      	ldr	r3, [r7, #0]
3400c926:	685b      	ldr	r3, [r3, #4]
3400c928:	687a      	ldr	r2, [r7, #4]
3400c92a:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400c92c:	683b      	ldr	r3, [r7, #0]
3400c92e:	687a      	ldr	r2, [r7, #4]
3400c930:	605a      	str	r2, [r3, #4]
}
3400c932:	bf00      	nop
3400c934:	370c      	adds	r7, #12
3400c936:	46bd      	mov	sp, r7
3400c938:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c93c:	4770      	bx	lr

3400c93e <QueRemoveNext>:
{
3400c93e:	b480      	push	{r7}
3400c940:	b085      	sub	sp, #20
3400c942:	af00      	add	r7, sp, #0
3400c944:	6078      	str	r0, [r7, #4]
	if ( que->next == que ) {
3400c946:	687b      	ldr	r3, [r7, #4]
3400c948:	681b      	ldr	r3, [r3, #0]
3400c94a:	687a      	ldr	r2, [r7, #4]
3400c94c:	429a      	cmp	r2, r3
3400c94e:	d101      	bne.n	3400c954 <QueRemoveNext+0x16>
		return NULL;
3400c950:	2300      	movs	r3, #0
3400c952:	e00b      	b.n	3400c96c <QueRemoveNext+0x2e>
	entry = que->next;
3400c954:	687b      	ldr	r3, [r7, #4]
3400c956:	681b      	ldr	r3, [r3, #0]
3400c958:	60fb      	str	r3, [r7, #12]
	que->next = (struct queue*)entry->next;
3400c95a:	68fb      	ldr	r3, [r7, #12]
3400c95c:	681a      	ldr	r2, [r3, #0]
3400c95e:	687b      	ldr	r3, [r7, #4]
3400c960:	601a      	str	r2, [r3, #0]
	entry->next->prev = que;
3400c962:	68fb      	ldr	r3, [r7, #12]
3400c964:	681b      	ldr	r3, [r3, #0]
3400c966:	687a      	ldr	r2, [r7, #4]
3400c968:	605a      	str	r2, [r3, #4]
	return entry;
3400c96a:	68fb      	ldr	r3, [r7, #12]
}
3400c96c:	4618      	mov	r0, r3
3400c96e:	3714      	adds	r7, #20
3400c970:	46bd      	mov	sp, r7
3400c972:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c976:	4770      	bx	lr

3400c978 <knl_isTaskIndependent>:
{
3400c978:	b480      	push	{r7}
3400c97a:	af00      	add	r7, sp, #0
	return ( knl_taskindp > 0 )? TRUE: FALSE;
3400c97c:	4b05      	ldr	r3, [pc, #20]	@ (3400c994 <knl_isTaskIndependent+0x1c>)
3400c97e:	681b      	ldr	r3, [r3, #0]
3400c980:	2b00      	cmp	r3, #0
3400c982:	bfcc      	ite	gt
3400c984:	2301      	movgt	r3, #1
3400c986:	2300      	movle	r3, #0
3400c988:	b2db      	uxtb	r3, r3
}
3400c98a:	4618      	mov	r0, r3
3400c98c:	46bd      	mov	sp, r7
3400c98e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400c992:	4770      	bx	lr
3400c994:	340114e8 	.word	0x340114e8

3400c998 <knl_semaphore_initialize>:

/* 
 * Initialization of semaphore control block 
 */
EXPORT ER knl_semaphore_initialize( void )
{
3400c998:	b580      	push	{r7, lr}
3400c99a:	b082      	sub	sp, #8
3400c99c:	af00      	add	r7, sp, #0
	if ( NUM_SEMID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_semcb);
3400c99e:	480e      	ldr	r0, [pc, #56]	@ (3400c9d8 <knl_semaphore_initialize+0x40>)
3400c9a0:	f7ff ffa4 	bl	3400c8ec <QueInit>
	end = knl_semcb_table + NUM_SEMID;
3400c9a4:	4b0d      	ldr	r3, [pc, #52]	@ (3400c9dc <knl_semaphore_initialize+0x44>)
3400c9a6:	603b      	str	r3, [r7, #0]
	for ( semcb = knl_semcb_table; semcb < end; semcb++ ) {
3400c9a8:	4b0d      	ldr	r3, [pc, #52]	@ (3400c9e0 <knl_semaphore_initialize+0x48>)
3400c9aa:	607b      	str	r3, [r7, #4]
3400c9ac:	e00a      	b.n	3400c9c4 <knl_semaphore_initialize+0x2c>
		semcb->semid = 0;
3400c9ae:	687b      	ldr	r3, [r7, #4]
3400c9b0:	2200      	movs	r2, #0
3400c9b2:	609a      	str	r2, [r3, #8]
		QueInsert(&semcb->wait_queue, &knl_free_semcb);
3400c9b4:	687b      	ldr	r3, [r7, #4]
3400c9b6:	4908      	ldr	r1, [pc, #32]	@ (3400c9d8 <knl_semaphore_initialize+0x40>)
3400c9b8:	4618      	mov	r0, r3
3400c9ba:	f7ff ffa7 	bl	3400c90c <QueInsert>
	for ( semcb = knl_semcb_table; semcb < end; semcb++ ) {
3400c9be:	687b      	ldr	r3, [r7, #4]
3400c9c0:	331c      	adds	r3, #28
3400c9c2:	607b      	str	r3, [r7, #4]
3400c9c4:	687a      	ldr	r2, [r7, #4]
3400c9c6:	683b      	ldr	r3, [r7, #0]
3400c9c8:	429a      	cmp	r2, r3
3400c9ca:	d3f0      	bcc.n	3400c9ae <knl_semaphore_initialize+0x16>
	}

	return E_OK;
3400c9cc:	2300      	movs	r3, #0
}
3400c9ce:	4618      	mov	r0, r3
3400c9d0:	3708      	adds	r7, #8
3400c9d2:	46bd      	mov	sp, r7
3400c9d4:	bd80      	pop	{r7, pc}
3400c9d6:	bf00      	nop
3400c9d8:	340127f4 	.word	0x340127f4
3400c9dc:	340127f4 	.word	0x340127f4
3400c9e0:	34012634 	.word	0x34012634

3400c9e4 <tk_cre_sem>:

/*
 * Create semaphore
 */
SYSCALL ID tk_cre_sem( CONST T_CSEM *pk_csem )
{
3400c9e4:	b580      	push	{r7, lr}
3400c9e6:	b088      	sub	sp, #32
3400c9e8:	af00      	add	r7, sp, #0
3400c9ea:	6078      	str	r0, [r7, #4]
#if CHK_RSATR
	const ATR VALID_SEMATR = {
3400c9ec:	2303      	movs	r3, #3
3400c9ee:	61bb      	str	r3, [r7, #24]
#endif
	SEMCB	*semcb;
	ID	semid;
	ER	ercd;

	CHECK_RSATR(pk_csem->sematr, VALID_SEMATR);
3400c9f0:	687b      	ldr	r3, [r7, #4]
3400c9f2:	685a      	ldr	r2, [r3, #4]
3400c9f4:	69bb      	ldr	r3, [r7, #24]
3400c9f6:	43db      	mvns	r3, r3
3400c9f8:	4013      	ands	r3, r2
3400c9fa:	2b00      	cmp	r3, #0
3400c9fc:	d002      	beq.n	3400ca04 <tk_cre_sem+0x20>
3400c9fe:	f06f 030a 	mvn.w	r3, #10
3400ca02:	e059      	b.n	3400cab8 <tk_cre_sem+0xd4>
	CHECK_PAR(pk_csem->isemcnt >= 0);
3400ca04:	687b      	ldr	r3, [r7, #4]
3400ca06:	689b      	ldr	r3, [r3, #8]
3400ca08:	2b00      	cmp	r3, #0
3400ca0a:	da02      	bge.n	3400ca12 <tk_cre_sem+0x2e>
3400ca0c:	f06f 0310 	mvn.w	r3, #16
3400ca10:	e052      	b.n	3400cab8 <tk_cre_sem+0xd4>
	CHECK_PAR(pk_csem->maxsem > 0);
3400ca12:	687b      	ldr	r3, [r7, #4]
3400ca14:	68db      	ldr	r3, [r3, #12]
3400ca16:	2b00      	cmp	r3, #0
3400ca18:	dc02      	bgt.n	3400ca20 <tk_cre_sem+0x3c>
3400ca1a:	f06f 0310 	mvn.w	r3, #16
3400ca1e:	e04b      	b.n	3400cab8 <tk_cre_sem+0xd4>
	CHECK_PAR(pk_csem->maxsem >= pk_csem->isemcnt);
3400ca20:	687b      	ldr	r3, [r7, #4]
3400ca22:	68da      	ldr	r2, [r3, #12]
3400ca24:	687b      	ldr	r3, [r7, #4]
3400ca26:	689b      	ldr	r3, [r3, #8]
3400ca28:	429a      	cmp	r2, r3
3400ca2a:	da02      	bge.n	3400ca32 <tk_cre_sem+0x4e>
3400ca2c:	f06f 0310 	mvn.w	r3, #16
3400ca30:	e042      	b.n	3400cab8 <tk_cre_sem+0xd4>

	BEGIN_CRITICAL_SECTION;
3400ca32:	f003 f8e6 	bl	3400fc02 <disint>
3400ca36:	6178      	str	r0, [r7, #20]
	/* Get control block from FreeQue */
	semcb = (SEMCB*)QueRemoveNext(&knl_free_semcb);
3400ca38:	4821      	ldr	r0, [pc, #132]	@ (3400cac0 <tk_cre_sem+0xdc>)
3400ca3a:	f7ff ff80 	bl	3400c93e <QueRemoveNext>
3400ca3e:	6138      	str	r0, [r7, #16]
	if ( semcb == NULL ) {
3400ca40:	693b      	ldr	r3, [r7, #16]
3400ca42:	2b00      	cmp	r3, #0
3400ca44:	d103      	bne.n	3400ca4e <tk_cre_sem+0x6a>
		ercd = E_LIMIT;
3400ca46:	f06f 0321 	mvn.w	r3, #33	@ 0x21
3400ca4a:	61fb      	str	r3, [r7, #28]
3400ca4c:	e021      	b.n	3400ca92 <tk_cre_sem+0xae>
	} else {
		semid = ID_SEM(semcb - knl_semcb_table);
3400ca4e:	693b      	ldr	r3, [r7, #16]
3400ca50:	4a1c      	ldr	r2, [pc, #112]	@ (3400cac4 <tk_cre_sem+0xe0>)
3400ca52:	1a9b      	subs	r3, r3, r2
3400ca54:	109b      	asrs	r3, r3, #2
3400ca56:	4a1c      	ldr	r2, [pc, #112]	@ (3400cac8 <tk_cre_sem+0xe4>)
3400ca58:	fb02 f303 	mul.w	r3, r2, r3
3400ca5c:	3301      	adds	r3, #1
3400ca5e:	60fb      	str	r3, [r7, #12]

		/* Initialize control block */
		QueInit(&semcb->wait_queue);
3400ca60:	693b      	ldr	r3, [r7, #16]
3400ca62:	4618      	mov	r0, r3
3400ca64:	f7ff ff42 	bl	3400c8ec <QueInit>
		semcb->semid = semid;
3400ca68:	693b      	ldr	r3, [r7, #16]
3400ca6a:	68fa      	ldr	r2, [r7, #12]
3400ca6c:	609a      	str	r2, [r3, #8]
		semcb->exinf = pk_csem->exinf;
3400ca6e:	687b      	ldr	r3, [r7, #4]
3400ca70:	681a      	ldr	r2, [r3, #0]
3400ca72:	693b      	ldr	r3, [r7, #16]
3400ca74:	60da      	str	r2, [r3, #12]
		semcb->sematr = pk_csem->sematr;
3400ca76:	687b      	ldr	r3, [r7, #4]
3400ca78:	685a      	ldr	r2, [r3, #4]
3400ca7a:	693b      	ldr	r3, [r7, #16]
3400ca7c:	611a      	str	r2, [r3, #16]
		semcb->semcnt = pk_csem->isemcnt;
3400ca7e:	687b      	ldr	r3, [r7, #4]
3400ca80:	689a      	ldr	r2, [r3, #8]
3400ca82:	693b      	ldr	r3, [r7, #16]
3400ca84:	615a      	str	r2, [r3, #20]
		semcb->maxsem = pk_csem->maxsem;
3400ca86:	687b      	ldr	r3, [r7, #4]
3400ca88:	68da      	ldr	r2, [r3, #12]
3400ca8a:	693b      	ldr	r3, [r7, #16]
3400ca8c:	619a      	str	r2, [r3, #24]
		if ( (pk_csem->sematr & TA_DSNAME) != 0 ) {
			knl_strncpy((char*)semcb->name, (char*)pk_csem->dsname,
				OBJECT_NAME_LENGTH);
		}
#endif
		ercd = semid;
3400ca8e:	68fb      	ldr	r3, [r7, #12]
3400ca90:	61fb      	str	r3, [r7, #28]
	}
	END_CRITICAL_SECTION;
3400ca92:	697b      	ldr	r3, [r7, #20]
3400ca94:	2b00      	cmp	r3, #0
3400ca96:	d10b      	bne.n	3400cab0 <tk_cre_sem+0xcc>
3400ca98:	4b0c      	ldr	r3, [pc, #48]	@ (3400cacc <tk_cre_sem+0xe8>)
3400ca9a:	681a      	ldr	r2, [r3, #0]
3400ca9c:	4b0c      	ldr	r3, [pc, #48]	@ (3400cad0 <tk_cre_sem+0xec>)
3400ca9e:	681b      	ldr	r3, [r3, #0]
3400caa0:	429a      	cmp	r2, r3
3400caa2:	d005      	beq.n	3400cab0 <tk_cre_sem+0xcc>
3400caa4:	4b0b      	ldr	r3, [pc, #44]	@ (3400cad4 <tk_cre_sem+0xf0>)
3400caa6:	681b      	ldr	r3, [r3, #0]
3400caa8:	2b00      	cmp	r3, #0
3400caaa:	d101      	bne.n	3400cab0 <tk_cre_sem+0xcc>
3400caac:	f002 f96a 	bl	3400ed84 <knl_dispatch>
3400cab0:	6978      	ldr	r0, [r7, #20]
3400cab2:	f003 f88a 	bl	3400fbca <set_basepri>

	return ercd;
3400cab6:	69fb      	ldr	r3, [r7, #28]
}
3400cab8:	4618      	mov	r0, r3
3400caba:	3720      	adds	r7, #32
3400cabc:	46bd      	mov	sp, r7
3400cabe:	bd80      	pop	{r7, pc}
3400cac0:	340127f4 	.word	0x340127f4
3400cac4:	34012634 	.word	0x34012634
3400cac8:	b6db6db7 	.word	0xb6db6db7
3400cacc:	34012800 	.word	0x34012800
3400cad0:	34012804 	.word	0x34012804
3400cad4:	340127fc 	.word	0x340127fc

3400cad8 <tk_del_sem>:
#ifdef USE_FUNC_TK_DEL_SEM
/*
 * Delete semaphore
 */
SYSCALL ER tk_del_sem( ID semid )
{
3400cad8:	b580      	push	{r7, lr}
3400cada:	b086      	sub	sp, #24
3400cadc:	af00      	add	r7, sp, #0
3400cade:	6078      	str	r0, [r7, #4]
	SEMCB	*semcb;
	ER	ercd = E_OK;
3400cae0:	2300      	movs	r3, #0
3400cae2:	617b      	str	r3, [r7, #20]

	CHECK_SEMID(semid);
3400cae4:	687b      	ldr	r3, [r7, #4]
3400cae6:	2b00      	cmp	r3, #0
3400cae8:	dd02      	ble.n	3400caf0 <tk_del_sem+0x18>
3400caea:	687b      	ldr	r3, [r7, #4]
3400caec:	2b10      	cmp	r3, #16
3400caee:	dd02      	ble.n	3400caf6 <tk_del_sem+0x1e>
3400caf0:	f06f 0311 	mvn.w	r3, #17
3400caf4:	e032      	b.n	3400cb5c <tk_del_sem+0x84>

	semcb = get_semcb(semid);
3400caf6:	687b      	ldr	r3, [r7, #4]
3400caf8:	1e5a      	subs	r2, r3, #1
3400cafa:	4613      	mov	r3, r2
3400cafc:	00db      	lsls	r3, r3, #3
3400cafe:	1a9b      	subs	r3, r3, r2
3400cb00:	009b      	lsls	r3, r3, #2
3400cb02:	4a18      	ldr	r2, [pc, #96]	@ (3400cb64 <tk_del_sem+0x8c>)
3400cb04:	4413      	add	r3, r2
3400cb06:	613b      	str	r3, [r7, #16]

	BEGIN_CRITICAL_SECTION;
3400cb08:	f003 f87b 	bl	3400fc02 <disint>
3400cb0c:	60f8      	str	r0, [r7, #12]
	if ( semcb->semid == 0 ) {
3400cb0e:	693b      	ldr	r3, [r7, #16]
3400cb10:	689b      	ldr	r3, [r3, #8]
3400cb12:	2b00      	cmp	r3, #0
3400cb14:	d103      	bne.n	3400cb1e <tk_del_sem+0x46>
		ercd = E_NOEXS;
3400cb16:	f06f 0329 	mvn.w	r3, #41	@ 0x29
3400cb1a:	617b      	str	r3, [r7, #20]
3400cb1c:	e00b      	b.n	3400cb36 <tk_del_sem+0x5e>
	} else {
		/* Release wait state of task (E_DLT) */
		knl_wait_delete(&semcb->wait_queue);
3400cb1e:	693b      	ldr	r3, [r7, #16]
3400cb20:	4618      	mov	r0, r3
3400cb22:	f001 f9f5 	bl	3400df10 <knl_wait_delete>

		/* Return to FreeQue */
		QueInsert(&semcb->wait_queue, &knl_free_semcb);
3400cb26:	693b      	ldr	r3, [r7, #16]
3400cb28:	490f      	ldr	r1, [pc, #60]	@ (3400cb68 <tk_del_sem+0x90>)
3400cb2a:	4618      	mov	r0, r3
3400cb2c:	f7ff feee 	bl	3400c90c <QueInsert>
		semcb->semid = 0;
3400cb30:	693b      	ldr	r3, [r7, #16]
3400cb32:	2200      	movs	r2, #0
3400cb34:	609a      	str	r2, [r3, #8]
	}
	END_CRITICAL_SECTION;
3400cb36:	68fb      	ldr	r3, [r7, #12]
3400cb38:	2b00      	cmp	r3, #0
3400cb3a:	d10b      	bne.n	3400cb54 <tk_del_sem+0x7c>
3400cb3c:	4b0b      	ldr	r3, [pc, #44]	@ (3400cb6c <tk_del_sem+0x94>)
3400cb3e:	681a      	ldr	r2, [r3, #0]
3400cb40:	4b0b      	ldr	r3, [pc, #44]	@ (3400cb70 <tk_del_sem+0x98>)
3400cb42:	681b      	ldr	r3, [r3, #0]
3400cb44:	429a      	cmp	r2, r3
3400cb46:	d005      	beq.n	3400cb54 <tk_del_sem+0x7c>
3400cb48:	4b0a      	ldr	r3, [pc, #40]	@ (3400cb74 <tk_del_sem+0x9c>)
3400cb4a:	681b      	ldr	r3, [r3, #0]
3400cb4c:	2b00      	cmp	r3, #0
3400cb4e:	d101      	bne.n	3400cb54 <tk_del_sem+0x7c>
3400cb50:	f002 f918 	bl	3400ed84 <knl_dispatch>
3400cb54:	68f8      	ldr	r0, [r7, #12]
3400cb56:	f003 f838 	bl	3400fbca <set_basepri>

	return ercd;
3400cb5a:	697b      	ldr	r3, [r7, #20]
}
3400cb5c:	4618      	mov	r0, r3
3400cb5e:	3718      	adds	r7, #24
3400cb60:	46bd      	mov	sp, r7
3400cb62:	bd80      	pop	{r7, pc}
3400cb64:	34012634 	.word	0x34012634
3400cb68:	340127f4 	.word	0x340127f4
3400cb6c:	34012800 	.word	0x34012800
3400cb70:	34012804 	.word	0x34012804
3400cb74:	340127fc 	.word	0x340127fc

3400cb78 <tk_sig_sem>:

/*
 * Signal semaphore
 */
SYSCALL ER tk_sig_sem( ID semid, INT cnt )
{
3400cb78:	b580      	push	{r7, lr}
3400cb7a:	b088      	sub	sp, #32
3400cb7c:	af00      	add	r7, sp, #0
3400cb7e:	6078      	str	r0, [r7, #4]
3400cb80:	6039      	str	r1, [r7, #0]
	SEMCB	*semcb;
	TCB	*tcb;
	QUEUE	*queue;
	ER	ercd = E_OK;
3400cb82:	2300      	movs	r3, #0
3400cb84:	61bb      	str	r3, [r7, #24]
    
	CHECK_SEMID(semid);
3400cb86:	687b      	ldr	r3, [r7, #4]
3400cb88:	2b00      	cmp	r3, #0
3400cb8a:	dd02      	ble.n	3400cb92 <tk_sig_sem+0x1a>
3400cb8c:	687b      	ldr	r3, [r7, #4]
3400cb8e:	2b10      	cmp	r3, #16
3400cb90:	dd02      	ble.n	3400cb98 <tk_sig_sem+0x20>
3400cb92:	f06f 0311 	mvn.w	r3, #17
3400cb96:	e06a      	b.n	3400cc6e <tk_sig_sem+0xf6>
	CHECK_PAR(cnt > 0);
3400cb98:	683b      	ldr	r3, [r7, #0]
3400cb9a:	2b00      	cmp	r3, #0
3400cb9c:	dc02      	bgt.n	3400cba4 <tk_sig_sem+0x2c>
3400cb9e:	f06f 0310 	mvn.w	r3, #16
3400cba2:	e064      	b.n	3400cc6e <tk_sig_sem+0xf6>

	semcb = get_semcb(semid);
3400cba4:	687b      	ldr	r3, [r7, #4]
3400cba6:	1e5a      	subs	r2, r3, #1
3400cba8:	4613      	mov	r3, r2
3400cbaa:	00db      	lsls	r3, r3, #3
3400cbac:	1a9b      	subs	r3, r3, r2
3400cbae:	009b      	lsls	r3, r3, #2
3400cbb0:	4a31      	ldr	r2, [pc, #196]	@ (3400cc78 <tk_sig_sem+0x100>)
3400cbb2:	4413      	add	r3, r2
3400cbb4:	617b      	str	r3, [r7, #20]

	BEGIN_CRITICAL_SECTION;
3400cbb6:	f003 f824 	bl	3400fc02 <disint>
3400cbba:	6138      	str	r0, [r7, #16]
	if ( semcb->semid == 0 ) {
3400cbbc:	697b      	ldr	r3, [r7, #20]
3400cbbe:	689b      	ldr	r3, [r3, #8]
3400cbc0:	2b00      	cmp	r3, #0
3400cbc2:	d103      	bne.n	3400cbcc <tk_sig_sem+0x54>
		ercd = E_NOEXS;
3400cbc4:	f06f 0329 	mvn.w	r3, #41	@ 0x29
3400cbc8:	61bb      	str	r3, [r7, #24]
		goto error_exit;
3400cbca:	e03d      	b.n	3400cc48 <tk_sig_sem+0xd0>
	}
	if ( cnt > (semcb->maxsem - semcb->semcnt) ) {
3400cbcc:	697b      	ldr	r3, [r7, #20]
3400cbce:	699a      	ldr	r2, [r3, #24]
3400cbd0:	697b      	ldr	r3, [r7, #20]
3400cbd2:	695b      	ldr	r3, [r3, #20]
3400cbd4:	1ad3      	subs	r3, r2, r3
3400cbd6:	683a      	ldr	r2, [r7, #0]
3400cbd8:	429a      	cmp	r2, r3
3400cbda:	dd03      	ble.n	3400cbe4 <tk_sig_sem+0x6c>
		ercd = E_QOVR;
3400cbdc:	f06f 032a 	mvn.w	r3, #42	@ 0x2a
3400cbe0:	61bb      	str	r3, [r7, #24]
		goto error_exit;
3400cbe2:	e031      	b.n	3400cc48 <tk_sig_sem+0xd0>
	}

	/* Return semaphore counts */
	semcb->semcnt += cnt;
3400cbe4:	697b      	ldr	r3, [r7, #20]
3400cbe6:	695a      	ldr	r2, [r3, #20]
3400cbe8:	683b      	ldr	r3, [r7, #0]
3400cbea:	441a      	add	r2, r3
3400cbec:	697b      	ldr	r3, [r7, #20]
3400cbee:	615a      	str	r2, [r3, #20]

	/* Search task that frees wait */
	queue = semcb->wait_queue.next;
3400cbf0:	697b      	ldr	r3, [r7, #20]
3400cbf2:	681b      	ldr	r3, [r3, #0]
3400cbf4:	61fb      	str	r3, [r7, #28]
	while ( queue != &semcb->wait_queue ) {
3400cbf6:	e021      	b.n	3400cc3c <tk_sig_sem+0xc4>
		tcb = (TCB*)queue;
3400cbf8:	69fb      	ldr	r3, [r7, #28]
3400cbfa:	60fb      	str	r3, [r7, #12]
		queue = queue->next;
3400cbfc:	69fb      	ldr	r3, [r7, #28]
3400cbfe:	681b      	ldr	r3, [r3, #0]
3400cc00:	61fb      	str	r3, [r7, #28]

		/* Meet condition for Releasing wait? */
		if ( semcb->semcnt < tcb->winfo.sem.cnt ) {
3400cc02:	697b      	ldr	r3, [r7, #20]
3400cc04:	695a      	ldr	r2, [r3, #20]
3400cc06:	68fb      	ldr	r3, [r7, #12]
3400cc08:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400cc0a:	429a      	cmp	r2, r3
3400cc0c:	da06      	bge.n	3400cc1c <tk_sig_sem+0xa4>
			if ( (semcb->sematr & TA_CNT) == 0 ) {
3400cc0e:	697b      	ldr	r3, [r7, #20]
3400cc10:	691b      	ldr	r3, [r3, #16]
3400cc12:	f003 0302 	and.w	r3, r3, #2
3400cc16:	2b00      	cmp	r3, #0
3400cc18:	d10f      	bne.n	3400cc3a <tk_sig_sem+0xc2>
				break;
3400cc1a:	e015      	b.n	3400cc48 <tk_sig_sem+0xd0>
			}
			continue;
		}

		/* Release wait */
		knl_wait_release_ok(tcb);
3400cc1c:	68f8      	ldr	r0, [r7, #12]
3400cc1e:	f001 f8ea 	bl	3400ddf6 <knl_wait_release_ok>

		semcb->semcnt -= tcb->winfo.sem.cnt;
3400cc22:	697b      	ldr	r3, [r7, #20]
3400cc24:	695a      	ldr	r2, [r3, #20]
3400cc26:	68fb      	ldr	r3, [r7, #12]
3400cc28:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400cc2a:	1ad2      	subs	r2, r2, r3
3400cc2c:	697b      	ldr	r3, [r7, #20]
3400cc2e:	615a      	str	r2, [r3, #20]
		if ( semcb->semcnt <= 0 ) {
3400cc30:	697b      	ldr	r3, [r7, #20]
3400cc32:	695b      	ldr	r3, [r3, #20]
3400cc34:	2b00      	cmp	r3, #0
3400cc36:	dd06      	ble.n	3400cc46 <tk_sig_sem+0xce>
3400cc38:	e000      	b.n	3400cc3c <tk_sig_sem+0xc4>
			continue;
3400cc3a:	bf00      	nop
	while ( queue != &semcb->wait_queue ) {
3400cc3c:	697b      	ldr	r3, [r7, #20]
3400cc3e:	69fa      	ldr	r2, [r7, #28]
3400cc40:	429a      	cmp	r2, r3
3400cc42:	d1d9      	bne.n	3400cbf8 <tk_sig_sem+0x80>
			break;
		}
	}

    error_exit:
3400cc44:	e000      	b.n	3400cc48 <tk_sig_sem+0xd0>
			break;
3400cc46:	bf00      	nop
	END_CRITICAL_SECTION;
3400cc48:	693b      	ldr	r3, [r7, #16]
3400cc4a:	2b00      	cmp	r3, #0
3400cc4c:	d10b      	bne.n	3400cc66 <tk_sig_sem+0xee>
3400cc4e:	4b0b      	ldr	r3, [pc, #44]	@ (3400cc7c <tk_sig_sem+0x104>)
3400cc50:	681a      	ldr	r2, [r3, #0]
3400cc52:	4b0b      	ldr	r3, [pc, #44]	@ (3400cc80 <tk_sig_sem+0x108>)
3400cc54:	681b      	ldr	r3, [r3, #0]
3400cc56:	429a      	cmp	r2, r3
3400cc58:	d005      	beq.n	3400cc66 <tk_sig_sem+0xee>
3400cc5a:	4b0a      	ldr	r3, [pc, #40]	@ (3400cc84 <tk_sig_sem+0x10c>)
3400cc5c:	681b      	ldr	r3, [r3, #0]
3400cc5e:	2b00      	cmp	r3, #0
3400cc60:	d101      	bne.n	3400cc66 <tk_sig_sem+0xee>
3400cc62:	f002 f88f 	bl	3400ed84 <knl_dispatch>
3400cc66:	6938      	ldr	r0, [r7, #16]
3400cc68:	f002 ffaf 	bl	3400fbca <set_basepri>

	return ercd;
3400cc6c:	69bb      	ldr	r3, [r7, #24]
}
3400cc6e:	4618      	mov	r0, r3
3400cc70:	3720      	adds	r7, #32
3400cc72:	46bd      	mov	sp, r7
3400cc74:	bd80      	pop	{r7, pc}
3400cc76:	bf00      	nop
3400cc78:	34012634 	.word	0x34012634
3400cc7c:	34012800 	.word	0x34012800
3400cc80:	34012804 	.word	0x34012804
3400cc84:	340127fc 	.word	0x340127fc

3400cc88 <sem_chg_pri>:

/*
 * Processing if the priority of wait task changes
 */
LOCAL void sem_chg_pri( TCB *tcb, INT oldpri )
{
3400cc88:	b580      	push	{r7, lr}
3400cc8a:	b086      	sub	sp, #24
3400cc8c:	af00      	add	r7, sp, #0
3400cc8e:	6078      	str	r0, [r7, #4]
3400cc90:	6039      	str	r1, [r7, #0]
	SEMCB	*semcb;
	QUEUE	*queue;
	TCB	*top;

	semcb = get_semcb(tcb->wid);
3400cc92:	687b      	ldr	r3, [r7, #4]
3400cc94:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
3400cc96:	1e5a      	subs	r2, r3, #1
3400cc98:	4613      	mov	r3, r2
3400cc9a:	00db      	lsls	r3, r3, #3
3400cc9c:	1a9b      	subs	r3, r3, r2
3400cc9e:	009b      	lsls	r3, r3, #2
3400cca0:	4a19      	ldr	r2, [pc, #100]	@ (3400cd08 <sem_chg_pri+0x80>)
3400cca2:	4413      	add	r3, r2
3400cca4:	613b      	str	r3, [r7, #16]
	if ( oldpri >= 0 ) {
3400cca6:	683b      	ldr	r3, [r7, #0]
3400cca8:	2b00      	cmp	r3, #0
3400ccaa:	db03      	blt.n	3400ccb4 <sem_chg_pri+0x2c>
		/* Reorder wait line */
		knl_gcb_change_priority((GCB*)semcb, tcb);
3400ccac:	6879      	ldr	r1, [r7, #4]
3400ccae:	6938      	ldr	r0, [r7, #16]
3400ccb0:	f001 f980 	bl	3400dfb4 <knl_gcb_change_priority>
	}

	if ( (semcb->sematr & TA_CNT) != 0 ) {
3400ccb4:	693b      	ldr	r3, [r7, #16]
3400ccb6:	691b      	ldr	r3, [r3, #16]
3400ccb8:	f003 0302 	and.w	r3, r3, #2
3400ccbc:	2b00      	cmp	r3, #0
3400ccbe:	d11d      	bne.n	3400ccfc <sem_chg_pri+0x74>
		return;
	}

	/* From the head task in a wait queue, allocate semaphore counts
	   and release wait state as much as possible */
	queue = semcb->wait_queue.next;
3400ccc0:	693b      	ldr	r3, [r7, #16]
3400ccc2:	681b      	ldr	r3, [r3, #0]
3400ccc4:	617b      	str	r3, [r7, #20]
	while ( queue != &semcb->wait_queue ) {
3400ccc6:	e014      	b.n	3400ccf2 <sem_chg_pri+0x6a>
		top = (TCB*)queue;
3400ccc8:	697b      	ldr	r3, [r7, #20]
3400ccca:	60fb      	str	r3, [r7, #12]
		queue = queue->next;
3400cccc:	697b      	ldr	r3, [r7, #20]
3400ccce:	681b      	ldr	r3, [r3, #0]
3400ccd0:	617b      	str	r3, [r7, #20]

		/* Meet condition for releasing wait? */
		if ( semcb->semcnt < top->winfo.sem.cnt ) {
3400ccd2:	693b      	ldr	r3, [r7, #16]
3400ccd4:	695a      	ldr	r2, [r3, #20]
3400ccd6:	68fb      	ldr	r3, [r7, #12]
3400ccd8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400ccda:	429a      	cmp	r2, r3
3400ccdc:	db10      	blt.n	3400cd00 <sem_chg_pri+0x78>
			break;
		}

		/* Release wait */
		knl_wait_release_ok(top);
3400ccde:	68f8      	ldr	r0, [r7, #12]
3400cce0:	f001 f889 	bl	3400ddf6 <knl_wait_release_ok>

		semcb->semcnt -= top->winfo.sem.cnt;
3400cce4:	693b      	ldr	r3, [r7, #16]
3400cce6:	695a      	ldr	r2, [r3, #20]
3400cce8:	68fb      	ldr	r3, [r7, #12]
3400ccea:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
3400ccec:	1ad2      	subs	r2, r2, r3
3400ccee:	693b      	ldr	r3, [r7, #16]
3400ccf0:	615a      	str	r2, [r3, #20]
	while ( queue != &semcb->wait_queue ) {
3400ccf2:	693b      	ldr	r3, [r7, #16]
3400ccf4:	697a      	ldr	r2, [r7, #20]
3400ccf6:	429a      	cmp	r2, r3
3400ccf8:	d1e6      	bne.n	3400ccc8 <sem_chg_pri+0x40>
3400ccfa:	e002      	b.n	3400cd02 <sem_chg_pri+0x7a>
		return;
3400ccfc:	bf00      	nop
3400ccfe:	e000      	b.n	3400cd02 <sem_chg_pri+0x7a>
			break;
3400cd00:	bf00      	nop
	}
}
3400cd02:	3718      	adds	r7, #24
3400cd04:	46bd      	mov	sp, r7
3400cd06:	bd80      	pop	{r7, pc}
3400cd08:	34012634 	.word	0x34012634

3400cd0c <sem_rel_wai>:

/*
 * Processing if the wait task is freed
 */
LOCAL void sem_rel_wai( TCB *tcb )
{
3400cd0c:	b580      	push	{r7, lr}
3400cd0e:	b082      	sub	sp, #8
3400cd10:	af00      	add	r7, sp, #0
3400cd12:	6078      	str	r0, [r7, #4]
	sem_chg_pri(tcb, -1);
3400cd14:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
3400cd18:	6878      	ldr	r0, [r7, #4]
3400cd1a:	f7ff ffb5 	bl	3400cc88 <sem_chg_pri>
}
3400cd1e:	bf00      	nop
3400cd20:	3708      	adds	r7, #8
3400cd22:	46bd      	mov	sp, r7
3400cd24:	bd80      	pop	{r7, pc}
	...

3400cd28 <tk_wai_sem>:

/*
 * Wait on semaphore
 */
SYSCALL ER tk_wai_sem( ID semid, INT cnt, TMO tmout )
{
3400cd28:	b580      	push	{r7, lr}
3400cd2a:	b088      	sub	sp, #32
3400cd2c:	af00      	add	r7, sp, #0
3400cd2e:	60f8      	str	r0, [r7, #12]
3400cd30:	60b9      	str	r1, [r7, #8]
3400cd32:	607a      	str	r2, [r7, #4]
	SEMCB	*semcb;
	ER	ercd = E_OK;
3400cd34:	2300      	movs	r3, #0
3400cd36:	617b      	str	r3, [r7, #20]

	CHECK_SEMID(semid);
3400cd38:	68fb      	ldr	r3, [r7, #12]
3400cd3a:	2b00      	cmp	r3, #0
3400cd3c:	dd02      	ble.n	3400cd44 <tk_wai_sem+0x1c>
3400cd3e:	68fb      	ldr	r3, [r7, #12]
3400cd40:	2b10      	cmp	r3, #16
3400cd42:	dd02      	ble.n	3400cd4a <tk_wai_sem+0x22>
3400cd44:	f06f 0311 	mvn.w	r3, #17
3400cd48:	e087      	b.n	3400ce5a <tk_wai_sem+0x132>
	CHECK_PAR(cnt > 0);
3400cd4a:	68bb      	ldr	r3, [r7, #8]
3400cd4c:	2b00      	cmp	r3, #0
3400cd4e:	dc02      	bgt.n	3400cd56 <tk_wai_sem+0x2e>
3400cd50:	f06f 0310 	mvn.w	r3, #16
3400cd54:	e081      	b.n	3400ce5a <tk_wai_sem+0x132>
	CHECK_TMOUT(tmout);
3400cd56:	687b      	ldr	r3, [r7, #4]
3400cd58:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
3400cd5c:	da02      	bge.n	3400cd64 <tk_wai_sem+0x3c>
3400cd5e:	f06f 0310 	mvn.w	r3, #16
3400cd62:	e07a      	b.n	3400ce5a <tk_wai_sem+0x132>
	CHECK_DISPATCH();
3400cd64:	4b3f      	ldr	r3, [pc, #252]	@ (3400ce64 <tk_wai_sem+0x13c>)
3400cd66:	681b      	ldr	r3, [r3, #0]
3400cd68:	2b00      	cmp	r3, #0
3400cd6a:	d10d      	bne.n	3400cd88 <tk_wai_sem+0x60>
3400cd6c:	f7ff fe04 	bl	3400c978 <knl_isTaskIndependent>
3400cd70:	4603      	mov	r3, r0
3400cd72:	2b00      	cmp	r3, #0
3400cd74:	d108      	bne.n	3400cd88 <tk_wai_sem+0x60>
3400cd76:	4b3c      	ldr	r3, [pc, #240]	@ (3400ce68 <tk_wai_sem+0x140>)
3400cd78:	681b      	ldr	r3, [r3, #0]
3400cd7a:	2b00      	cmp	r3, #0
3400cd7c:	d004      	beq.n	3400cd88 <tk_wai_sem+0x60>
3400cd7e:	f002 ff33 	bl	3400fbe8 <get_basepri>
3400cd82:	4603      	mov	r3, r0
3400cd84:	2b00      	cmp	r3, #0
3400cd86:	d002      	beq.n	3400cd8e <tk_wai_sem+0x66>
3400cd88:	f06f 0318 	mvn.w	r3, #24
3400cd8c:	e065      	b.n	3400ce5a <tk_wai_sem+0x132>

	semcb = get_semcb(semid);
3400cd8e:	68fb      	ldr	r3, [r7, #12]
3400cd90:	1e5a      	subs	r2, r3, #1
3400cd92:	4613      	mov	r3, r2
3400cd94:	00db      	lsls	r3, r3, #3
3400cd96:	1a9b      	subs	r3, r3, r2
3400cd98:	009b      	lsls	r3, r3, #2
3400cd9a:	4a34      	ldr	r2, [pc, #208]	@ (3400ce6c <tk_wai_sem+0x144>)
3400cd9c:	4413      	add	r3, r2
3400cd9e:	61fb      	str	r3, [r7, #28]

	BEGIN_CRITICAL_SECTION;
3400cda0:	f002 ff2f 	bl	3400fc02 <disint>
3400cda4:	61b8      	str	r0, [r7, #24]
	if ( semcb->semid == 0 ) {
3400cda6:	69fb      	ldr	r3, [r7, #28]
3400cda8:	689b      	ldr	r3, [r3, #8]
3400cdaa:	2b00      	cmp	r3, #0
3400cdac:	d103      	bne.n	3400cdb6 <tk_wai_sem+0x8e>
		ercd = E_NOEXS;
3400cdae:	f06f 0329 	mvn.w	r3, #41	@ 0x29
3400cdb2:	617b      	str	r3, [r7, #20]
		goto error_exit;
3400cdb4:	e03e      	b.n	3400ce34 <tk_wai_sem+0x10c>
	}
#if CHK_PAR
	if ( cnt > semcb->maxsem ) {
3400cdb6:	69fb      	ldr	r3, [r7, #28]
3400cdb8:	699b      	ldr	r3, [r3, #24]
3400cdba:	68ba      	ldr	r2, [r7, #8]
3400cdbc:	429a      	cmp	r2, r3
3400cdbe:	dd03      	ble.n	3400cdc8 <tk_wai_sem+0xa0>
		ercd = E_PAR;
3400cdc0:	f06f 0310 	mvn.w	r3, #16
3400cdc4:	617b      	str	r3, [r7, #20]
		goto error_exit;
3400cdc6:	e035      	b.n	3400ce34 <tk_wai_sem+0x10c>
	}
#endif

	if ( ((semcb->sematr & TA_CNT) != 0
3400cdc8:	69fb      	ldr	r3, [r7, #28]
3400cdca:	691b      	ldr	r3, [r3, #16]
3400cdcc:	f003 0302 	and.w	r3, r3, #2
3400cdd0:	2b00      	cmp	r3, #0
3400cdd2:	d10a      	bne.n	3400cdea <tk_wai_sem+0xc2>
	      || knl_gcb_top_of_wait_queue((GCB*)semcb, knl_ctxtsk) == knl_ctxtsk)
3400cdd4:	4b24      	ldr	r3, [pc, #144]	@ (3400ce68 <tk_wai_sem+0x140>)
3400cdd6:	681b      	ldr	r3, [r3, #0]
3400cdd8:	4619      	mov	r1, r3
3400cdda:	69f8      	ldr	r0, [r7, #28]
3400cddc:	f001 f8fc 	bl	3400dfd8 <knl_gcb_top_of_wait_queue>
3400cde0:	4602      	mov	r2, r0
3400cde2:	4b21      	ldr	r3, [pc, #132]	@ (3400ce68 <tk_wai_sem+0x140>)
3400cde4:	681b      	ldr	r3, [r3, #0]
3400cde6:	429a      	cmp	r2, r3
3400cde8:	d10b      	bne.n	3400ce02 <tk_wai_sem+0xda>
	  && semcb->semcnt >= cnt ) {
3400cdea:	69fb      	ldr	r3, [r7, #28]
3400cdec:	695b      	ldr	r3, [r3, #20]
3400cdee:	68ba      	ldr	r2, [r7, #8]
3400cdf0:	429a      	cmp	r2, r3
3400cdf2:	dc06      	bgt.n	3400ce02 <tk_wai_sem+0xda>
		/* Get semaphore count */
		semcb->semcnt -= cnt;
3400cdf4:	69fb      	ldr	r3, [r7, #28]
3400cdf6:	695a      	ldr	r2, [r3, #20]
3400cdf8:	68bb      	ldr	r3, [r7, #8]
3400cdfa:	1ad2      	subs	r2, r2, r3
3400cdfc:	69fb      	ldr	r3, [r7, #28]
3400cdfe:	615a      	str	r2, [r3, #20]
3400ce00:	e018      	b.n	3400ce34 <tk_wai_sem+0x10c>

	} else {
		/* Ready for wait */
		knl_ctxtsk->wspec = ( (semcb->sematr & TA_TPRI) != 0 )?
3400ce02:	69fb      	ldr	r3, [r7, #28]
3400ce04:	691b      	ldr	r3, [r3, #16]
3400ce06:	f003 0301 	and.w	r3, r3, #1
					&knl_wspec_sem_tpri: &knl_wspec_sem_tfifo;
3400ce0a:	2b00      	cmp	r3, #0
3400ce0c:	d001      	beq.n	3400ce12 <tk_wai_sem+0xea>
3400ce0e:	4a18      	ldr	r2, [pc, #96]	@ (3400ce70 <tk_wai_sem+0x148>)
3400ce10:	e000      	b.n	3400ce14 <tk_wai_sem+0xec>
3400ce12:	4a18      	ldr	r2, [pc, #96]	@ (3400ce74 <tk_wai_sem+0x14c>)
		knl_ctxtsk->wspec = ( (semcb->sematr & TA_TPRI) != 0 )?
3400ce14:	4b14      	ldr	r3, [pc, #80]	@ (3400ce68 <tk_wai_sem+0x140>)
3400ce16:	681b      	ldr	r3, [r3, #0]
3400ce18:	62da      	str	r2, [r3, #44]	@ 0x2c
		knl_ctxtsk->wercd = &ercd;
3400ce1a:	4b13      	ldr	r3, [pc, #76]	@ (3400ce68 <tk_wai_sem+0x140>)
3400ce1c:	681b      	ldr	r3, [r3, #0]
3400ce1e:	f107 0214 	add.w	r2, r7, #20
3400ce22:	63da      	str	r2, [r3, #60]	@ 0x3c
		knl_ctxtsk->winfo.sem.cnt = cnt;
3400ce24:	4b10      	ldr	r3, [pc, #64]	@ (3400ce68 <tk_wai_sem+0x140>)
3400ce26:	681b      	ldr	r3, [r3, #0]
3400ce28:	68ba      	ldr	r2, [r7, #8]
3400ce2a:	641a      	str	r2, [r3, #64]	@ 0x40
		knl_gcb_make_wait((GCB*)semcb, tmout);
3400ce2c:	6879      	ldr	r1, [r7, #4]
3400ce2e:	69f8      	ldr	r0, [r7, #28]
3400ce30:	f001 f88a 	bl	3400df48 <knl_gcb_make_wait>
	}

    error_exit:
	END_CRITICAL_SECTION;
3400ce34:	69bb      	ldr	r3, [r7, #24]
3400ce36:	2b00      	cmp	r3, #0
3400ce38:	d10b      	bne.n	3400ce52 <tk_wai_sem+0x12a>
3400ce3a:	4b0b      	ldr	r3, [pc, #44]	@ (3400ce68 <tk_wai_sem+0x140>)
3400ce3c:	681a      	ldr	r2, [r3, #0]
3400ce3e:	4b0e      	ldr	r3, [pc, #56]	@ (3400ce78 <tk_wai_sem+0x150>)
3400ce40:	681b      	ldr	r3, [r3, #0]
3400ce42:	429a      	cmp	r2, r3
3400ce44:	d005      	beq.n	3400ce52 <tk_wai_sem+0x12a>
3400ce46:	4b07      	ldr	r3, [pc, #28]	@ (3400ce64 <tk_wai_sem+0x13c>)
3400ce48:	681b      	ldr	r3, [r3, #0]
3400ce4a:	2b00      	cmp	r3, #0
3400ce4c:	d101      	bne.n	3400ce52 <tk_wai_sem+0x12a>
3400ce4e:	f001 ff99 	bl	3400ed84 <knl_dispatch>
3400ce52:	69b8      	ldr	r0, [r7, #24]
3400ce54:	f002 feb9 	bl	3400fbca <set_basepri>

	return ercd;
3400ce58:	697b      	ldr	r3, [r7, #20]
}
3400ce5a:	4618      	mov	r0, r3
3400ce5c:	3720      	adds	r7, #32
3400ce5e:	46bd      	mov	sp, r7
3400ce60:	bd80      	pop	{r7, pc}
3400ce62:	bf00      	nop
3400ce64:	340127fc 	.word	0x340127fc
3400ce68:	34012800 	.word	0x34012800
3400ce6c:	34012634 	.word	0x34012634
3400ce70:	340100b4 	.word	0x340100b4
3400ce74:	340100a8 	.word	0x340100a8
3400ce78:	34012804 	.word	0x34012804

3400ce7c <QueInit>:
{
3400ce7c:	b480      	push	{r7}
3400ce7e:	b083      	sub	sp, #12
3400ce80:	af00      	add	r7, sp, #0
3400ce82:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400ce84:	687b      	ldr	r3, [r7, #4]
3400ce86:	687a      	ldr	r2, [r7, #4]
3400ce88:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400ce8a:	687b      	ldr	r3, [r7, #4]
3400ce8c:	687a      	ldr	r2, [r7, #4]
3400ce8e:	605a      	str	r2, [r3, #4]
}
3400ce90:	bf00      	nop
3400ce92:	370c      	adds	r7, #12
3400ce94:	46bd      	mov	sp, r7
3400ce96:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ce9a:	4770      	bx	lr

3400ce9c <isQueEmpty>:
{
3400ce9c:	b480      	push	{r7}
3400ce9e:	b083      	sub	sp, #12
3400cea0:	af00      	add	r7, sp, #0
3400cea2:	6078      	str	r0, [r7, #4]
	return ( que->next == que )? TRUE: FALSE;
3400cea4:	687b      	ldr	r3, [r7, #4]
3400cea6:	681b      	ldr	r3, [r3, #0]
3400cea8:	687a      	ldr	r2, [r7, #4]
3400ceaa:	429a      	cmp	r2, r3
3400ceac:	bf0c      	ite	eq
3400ceae:	2301      	moveq	r3, #1
3400ceb0:	2300      	movne	r3, #0
3400ceb2:	b2db      	uxtb	r3, r3
}
3400ceb4:	4618      	mov	r0, r3
3400ceb6:	370c      	adds	r7, #12
3400ceb8:	46bd      	mov	sp, r7
3400ceba:	f85d 7b04 	ldr.w	r7, [sp], #4
3400cebe:	4770      	bx	lr

3400cec0 <QueInsert>:
{
3400cec0:	b480      	push	{r7}
3400cec2:	b083      	sub	sp, #12
3400cec4:	af00      	add	r7, sp, #0
3400cec6:	6078      	str	r0, [r7, #4]
3400cec8:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400ceca:	683b      	ldr	r3, [r7, #0]
3400cecc:	685a      	ldr	r2, [r3, #4]
3400cece:	687b      	ldr	r3, [r7, #4]
3400ced0:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400ced2:	687b      	ldr	r3, [r7, #4]
3400ced4:	683a      	ldr	r2, [r7, #0]
3400ced6:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400ced8:	683b      	ldr	r3, [r7, #0]
3400ceda:	685b      	ldr	r3, [r3, #4]
3400cedc:	687a      	ldr	r2, [r7, #4]
3400cede:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400cee0:	683b      	ldr	r3, [r7, #0]
3400cee2:	687a      	ldr	r2, [r7, #4]
3400cee4:	605a      	str	r2, [r3, #4]
}
3400cee6:	bf00      	nop
3400cee8:	370c      	adds	r7, #12
3400ceea:	46bd      	mov	sp, r7
3400ceec:	f85d 7b04 	ldr.w	r7, [sp], #4
3400cef0:	4770      	bx	lr

3400cef2 <QueRemove>:
{
3400cef2:	b480      	push	{r7}
3400cef4:	b083      	sub	sp, #12
3400cef6:	af00      	add	r7, sp, #0
3400cef8:	6078      	str	r0, [r7, #4]
	if ( entry->next != entry ) {
3400cefa:	687b      	ldr	r3, [r7, #4]
3400cefc:	681b      	ldr	r3, [r3, #0]
3400cefe:	687a      	ldr	r2, [r7, #4]
3400cf00:	429a      	cmp	r2, r3
3400cf02:	d009      	beq.n	3400cf18 <QueRemove+0x26>
		entry->prev->next = (struct queue*) entry->next;
3400cf04:	687b      	ldr	r3, [r7, #4]
3400cf06:	685b      	ldr	r3, [r3, #4]
3400cf08:	687a      	ldr	r2, [r7, #4]
3400cf0a:	6812      	ldr	r2, [r2, #0]
3400cf0c:	601a      	str	r2, [r3, #0]
		entry->next->prev = (struct queue*) entry->prev;
3400cf0e:	687b      	ldr	r3, [r7, #4]
3400cf10:	681b      	ldr	r3, [r3, #0]
3400cf12:	687a      	ldr	r2, [r7, #4]
3400cf14:	6852      	ldr	r2, [r2, #4]
3400cf16:	605a      	str	r2, [r3, #4]
}
3400cf18:	bf00      	nop
3400cf1a:	370c      	adds	r7, #12
3400cf1c:	46bd      	mov	sp, r7
3400cf1e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400cf22:	4770      	bx	lr

3400cf24 <knl_ready_queue_calc_top_priority>:

IMPORT RDYQUE	knl_ready_queue;

#if NUM_TSKPRI <= INT_BITWIDTH
Inline INT knl_ready_queue_calc_top_priority( UINT bitmap, INT pos )
{
3400cf24:	b480      	push	{r7}
3400cf26:	b083      	sub	sp, #12
3400cf28:	af00      	add	r7, sp, #0
3400cf2a:	6078      	str	r0, [r7, #4]
3400cf2c:	6039      	str	r1, [r7, #0]
	for ( ; pos < NUM_TSKPRI; pos++ ) {
3400cf2e:	e00b      	b.n	3400cf48 <knl_ready_queue_calc_top_priority+0x24>
		if ( bitmap & (1U << pos) ) {
3400cf30:	2201      	movs	r2, #1
3400cf32:	683b      	ldr	r3, [r7, #0]
3400cf34:	409a      	lsls	r2, r3
3400cf36:	687b      	ldr	r3, [r7, #4]
3400cf38:	4013      	ands	r3, r2
3400cf3a:	2b00      	cmp	r3, #0
3400cf3c:	d001      	beq.n	3400cf42 <knl_ready_queue_calc_top_priority+0x1e>
			return pos;
3400cf3e:	683b      	ldr	r3, [r7, #0]
3400cf40:	e006      	b.n	3400cf50 <knl_ready_queue_calc_top_priority+0x2c>
	for ( ; pos < NUM_TSKPRI; pos++ ) {
3400cf42:	683b      	ldr	r3, [r7, #0]
3400cf44:	3301      	adds	r3, #1
3400cf46:	603b      	str	r3, [r7, #0]
3400cf48:	683b      	ldr	r3, [r7, #0]
3400cf4a:	2b1f      	cmp	r3, #31
3400cf4c:	ddf0      	ble.n	3400cf30 <knl_ready_queue_calc_top_priority+0xc>
		}
	}
	return NUM_TSKPRI;
3400cf4e:	2320      	movs	r3, #32
}
3400cf50:	4618      	mov	r0, r3
3400cf52:	370c      	adds	r7, #12
3400cf54:	46bd      	mov	sp, r7
3400cf56:	f85d 7b04 	ldr.w	r7, [sp], #4
3400cf5a:	4770      	bx	lr

3400cf5c <knl_ready_queue_initialize>:

/*
 * Ready queue initialization
 */
Inline void knl_ready_queue_initialize( RDYQUE *rq )
{
3400cf5c:	b580      	push	{r7, lr}
3400cf5e:	b084      	sub	sp, #16
3400cf60:	af00      	add	r7, sp, #0
3400cf62:	6078      	str	r0, [r7, #4]
	INT	i;

	rq->top_priority = NUM_TSKPRI;
3400cf64:	687b      	ldr	r3, [r7, #4]
3400cf66:	2220      	movs	r2, #32
3400cf68:	601a      	str	r2, [r3, #0]
	for ( i = 0; i < NUM_TSKPRI; i++ ) {
3400cf6a:	2300      	movs	r3, #0
3400cf6c:	60fb      	str	r3, [r7, #12]
3400cf6e:	e00a      	b.n	3400cf86 <knl_ready_queue_initialize+0x2a>
		QueInit(&rq->tskque[i]);
3400cf70:	68fb      	ldr	r3, [r7, #12]
3400cf72:	00db      	lsls	r3, r3, #3
3400cf74:	687a      	ldr	r2, [r7, #4]
3400cf76:	4413      	add	r3, r2
3400cf78:	3304      	adds	r3, #4
3400cf7a:	4618      	mov	r0, r3
3400cf7c:	f7ff ff7e 	bl	3400ce7c <QueInit>
	for ( i = 0; i < NUM_TSKPRI; i++ ) {
3400cf80:	68fb      	ldr	r3, [r7, #12]
3400cf82:	3301      	adds	r3, #1
3400cf84:	60fb      	str	r3, [r7, #12]
3400cf86:	68fb      	ldr	r3, [r7, #12]
3400cf88:	2b1f      	cmp	r3, #31
3400cf8a:	ddf1      	ble.n	3400cf70 <knl_ready_queue_initialize+0x14>
	}
	rq->null = NULL;
3400cf8c:	687b      	ldr	r3, [r7, #4]
3400cf8e:	2200      	movs	r2, #0
3400cf90:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
	rq->klocktsk = NULL;
3400cf94:	687b      	ldr	r3, [r7, #4]
3400cf96:	2200      	movs	r2, #0
3400cf98:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
	knl_memset(rq->bitmap, 0, sizeof(rq->bitmap));
3400cf9c:	687b      	ldr	r3, [r7, #4]
3400cf9e:	f503 7384 	add.w	r3, r3, #264	@ 0x108
3400cfa2:	2204      	movs	r2, #4
3400cfa4:	2100      	movs	r1, #0
3400cfa6:	4618      	mov	r0, r3
3400cfa8:	f001 f83e 	bl	3400e028 <knl_memset>
}
3400cfac:	bf00      	nop
3400cfae:	3710      	adds	r7, #16
3400cfb0:	46bd      	mov	sp, r7
3400cfb2:	bd80      	pop	{r7, pc}

3400cfb4 <knl_ready_queue_top>:

/*
 * Return the highest priority task in ready queue
 */
Inline TCB* knl_ready_queue_top( RDYQUE *rq )
{
3400cfb4:	b480      	push	{r7}
3400cfb6:	b083      	sub	sp, #12
3400cfb8:	af00      	add	r7, sp, #0
3400cfba:	6078      	str	r0, [r7, #4]
	/* If there is a task at kernel lock, that is the highest priority task */
	if ( rq->klocktsk != NULL ) {
3400cfbc:	687b      	ldr	r3, [r7, #4]
3400cfbe:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3400cfc2:	2b00      	cmp	r3, #0
3400cfc4:	d003      	beq.n	3400cfce <knl_ready_queue_top+0x1a>
		return rq->klocktsk;
3400cfc6:	687b      	ldr	r3, [r7, #4]
3400cfc8:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3400cfcc:	e005      	b.n	3400cfda <knl_ready_queue_top+0x26>
	}

	return (TCB*)rq->tskque[rq->top_priority].next;
3400cfce:	687b      	ldr	r3, [r7, #4]
3400cfd0:	681b      	ldr	r3, [r3, #0]
3400cfd2:	687a      	ldr	r2, [r7, #4]
3400cfd4:	00db      	lsls	r3, r3, #3
3400cfd6:	4413      	add	r3, r2
3400cfd8:	685b      	ldr	r3, [r3, #4]
}
3400cfda:	4618      	mov	r0, r3
3400cfdc:	370c      	adds	r7, #12
3400cfde:	46bd      	mov	sp, r7
3400cfe0:	f85d 7b04 	ldr.w	r7, [sp], #4
3400cfe4:	4770      	bx	lr

3400cfe6 <knl_ready_queue_insert>:
 *	indicated with 'tcb'. Set the applicable bit in the bitmap area and 
 *	update 'top_priority' if necessary. When updating 'top_priority,' 
 *	return TRUE, otherwise FALSE.
 */
Inline BOOL knl_ready_queue_insert( RDYQUE *rq, TCB *tcb )
{
3400cfe6:	b580      	push	{r7, lr}
3400cfe8:	b084      	sub	sp, #16
3400cfea:	af00      	add	r7, sp, #0
3400cfec:	6078      	str	r0, [r7, #4]
3400cfee:	6039      	str	r1, [r7, #0]
	INT	priority = tcb->priority;
3400cff0:	683b      	ldr	r3, [r7, #0]
3400cff2:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
3400cff6:	60fb      	str	r3, [r7, #12]

	QueInsert(&tcb->tskque, &rq->tskque[priority]);
3400cff8:	6838      	ldr	r0, [r7, #0]
3400cffa:	68fb      	ldr	r3, [r7, #12]
3400cffc:	00db      	lsls	r3, r3, #3
3400cffe:	687a      	ldr	r2, [r7, #4]
3400d000:	4413      	add	r3, r2
3400d002:	3304      	adds	r3, #4
3400d004:	4619      	mov	r1, r3
3400d006:	f7ff ff5b 	bl	3400cec0 <QueInsert>
#if NUM_TSKPRI <= INT_BITWIDTH
	rq->bitmap[0] |= (1U << priority);
3400d00a:	687b      	ldr	r3, [r7, #4]
3400d00c:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3400d010:	2101      	movs	r1, #1
3400d012:	68fb      	ldr	r3, [r7, #12]
3400d014:	fa01 f303 	lsl.w	r3, r1, r3
3400d018:	431a      	orrs	r2, r3
3400d01a:	687b      	ldr	r3, [r7, #4]
3400d01c:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
#else
	knl_bitset(rq->bitmap, priority);
#endif

	if ( tcb->klocked ) {
3400d020:	683b      	ldr	r3, [r7, #0]
3400d022:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
3400d026:	f003 0302 	and.w	r3, r3, #2
3400d02a:	b2db      	uxtb	r3, r3
3400d02c:	2b00      	cmp	r3, #0
3400d02e:	d003      	beq.n	3400d038 <knl_ready_queue_insert+0x52>
		rq->klocktsk = tcb;
3400d030:	687b      	ldr	r3, [r7, #4]
3400d032:	683a      	ldr	r2, [r7, #0]
3400d034:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
	}

	if ( priority < rq->top_priority ) {
3400d038:	687b      	ldr	r3, [r7, #4]
3400d03a:	681b      	ldr	r3, [r3, #0]
3400d03c:	68fa      	ldr	r2, [r7, #12]
3400d03e:	429a      	cmp	r2, r3
3400d040:	da04      	bge.n	3400d04c <knl_ready_queue_insert+0x66>
		rq->top_priority = priority;
3400d042:	687b      	ldr	r3, [r7, #4]
3400d044:	68fa      	ldr	r2, [r7, #12]
3400d046:	601a      	str	r2, [r3, #0]
		return TRUE;
3400d048:	2301      	movs	r3, #1
3400d04a:	e000      	b.n	3400d04e <knl_ready_queue_insert+0x68>
	}
	return FALSE;
3400d04c:	2300      	movs	r3, #0
}
3400d04e:	4618      	mov	r0, r3
3400d050:	3710      	adds	r7, #16
3400d052:	46bd      	mov	sp, r7
3400d054:	bd80      	pop	{r7, pc}

3400d056 <knl_ready_queue_delete>:
 *	In addition, update 'top_priority' if the deleted task had the highest 
 *	priority. In such case, use the bitmap area to search the second
 *	highest priority task.
 */
Inline void knl_ready_queue_delete( RDYQUE *rq, TCB *tcb )
{
3400d056:	b580      	push	{r7, lr}
3400d058:	b084      	sub	sp, #16
3400d05a:	af00      	add	r7, sp, #0
3400d05c:	6078      	str	r0, [r7, #4]
3400d05e:	6039      	str	r1, [r7, #0]
	INT	priority = tcb->priority;
3400d060:	683b      	ldr	r3, [r7, #0]
3400d062:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
3400d066:	60fb      	str	r3, [r7, #12]
#if NUM_TSKPRI > INT_BITWIDTH
	INT	i;
#endif

	if ( rq->klocktsk == tcb ) {
3400d068:	687b      	ldr	r3, [r7, #4]
3400d06a:	f8d3 310c 	ldr.w	r3, [r3, #268]	@ 0x10c
3400d06e:	683a      	ldr	r2, [r7, #0]
3400d070:	429a      	cmp	r2, r3
3400d072:	d103      	bne.n	3400d07c <knl_ready_queue_delete+0x26>
		rq->klocktsk = NULL;
3400d074:	687b      	ldr	r3, [r7, #4]
3400d076:	2200      	movs	r2, #0
3400d078:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
	}

	QueRemove(&tcb->tskque);
3400d07c:	683b      	ldr	r3, [r7, #0]
3400d07e:	4618      	mov	r0, r3
3400d080:	f7ff ff37 	bl	3400cef2 <QueRemove>
	if ( tcb->klockwait ) {
3400d084:	683b      	ldr	r3, [r7, #0]
3400d086:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
3400d08a:	f003 0301 	and.w	r3, r3, #1
3400d08e:	b2db      	uxtb	r3, r3
3400d090:	2b00      	cmp	r3, #0
3400d092:	d007      	beq.n	3400d0a4 <knl_ready_queue_delete+0x4e>
		/* Delete from kernel lock wait queue */
		tcb->klockwait = FALSE;
3400d094:	683a      	ldr	r2, [r7, #0]
3400d096:	f892 3028 	ldrb.w	r3, [r2, #40]	@ 0x28
3400d09a:	f023 0301 	bic.w	r3, r3, #1
3400d09e:	f882 3028 	strb.w	r3, [r2, #40]	@ 0x28
		return;
3400d0a2:	e029      	b.n	3400d0f8 <knl_ready_queue_delete+0xa2>
	}
	if ( !isQueEmpty(&rq->tskque[priority]) ) {
3400d0a4:	68fb      	ldr	r3, [r7, #12]
3400d0a6:	00db      	lsls	r3, r3, #3
3400d0a8:	687a      	ldr	r2, [r7, #4]
3400d0aa:	4413      	add	r3, r2
3400d0ac:	3304      	adds	r3, #4
3400d0ae:	4618      	mov	r0, r3
3400d0b0:	f7ff fef4 	bl	3400ce9c <isQueEmpty>
3400d0b4:	4603      	mov	r3, r0
3400d0b6:	2b00      	cmp	r3, #0
3400d0b8:	d01b      	beq.n	3400d0f2 <knl_ready_queue_delete+0x9c>
		return;
	}

#if NUM_TSKPRI <= INT_BITWIDTH
	rq->bitmap[0] &= ~(1U << priority);
3400d0ba:	687b      	ldr	r3, [r7, #4]
3400d0bc:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
3400d0c0:	2101      	movs	r1, #1
3400d0c2:	68fb      	ldr	r3, [r7, #12]
3400d0c4:	fa01 f303 	lsl.w	r3, r1, r3
3400d0c8:	43db      	mvns	r3, r3
3400d0ca:	401a      	ands	r2, r3
3400d0cc:	687b      	ldr	r3, [r7, #4]
3400d0ce:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
#else
	knl_bitclr(rq->bitmap, priority);
#endif
	if ( priority != rq->top_priority ) {
3400d0d2:	687b      	ldr	r3, [r7, #4]
3400d0d4:	681b      	ldr	r3, [r3, #0]
3400d0d6:	68fa      	ldr	r2, [r7, #12]
3400d0d8:	429a      	cmp	r2, r3
3400d0da:	d10c      	bne.n	3400d0f6 <knl_ready_queue_delete+0xa0>
		return;
	}

#if NUM_TSKPRI <= INT_BITWIDTH
	rq->top_priority = knl_ready_queue_calc_top_priority(rq->bitmap[0], priority);
3400d0dc:	687b      	ldr	r3, [r7, #4]
3400d0de:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
3400d0e2:	68f9      	ldr	r1, [r7, #12]
3400d0e4:	4618      	mov	r0, r3
3400d0e6:	f7ff ff1d 	bl	3400cf24 <knl_ready_queue_calc_top_priority>
3400d0ea:	4602      	mov	r2, r0
3400d0ec:	687b      	ldr	r3, [r7, #4]
3400d0ee:	601a      	str	r2, [r3, #0]
3400d0f0:	e002      	b.n	3400d0f8 <knl_ready_queue_delete+0xa2>
		return;
3400d0f2:	bf00      	nop
3400d0f4:	e000      	b.n	3400d0f8 <knl_ready_queue_delete+0xa2>
		return;
3400d0f6:	bf00      	nop
		rq->top_priority = priority + i;
	} else {
		rq->top_priority = NUM_TSKPRI;
	}
#endif
}
3400d0f8:	3710      	adds	r7, #16
3400d0fa:	46bd      	mov	sp, r7
3400d0fc:	bd80      	pop	{r7, pc}

3400d0fe <knl_setup_context>:
/*
 * Create stack frame for task startup
 *	Call from 'make_dormant()'
 */
Inline void knl_setup_context( TCB *tcb )
{
3400d0fe:	b480      	push	{r7}
3400d100:	b085      	sub	sp, #20
3400d102:	af00      	add	r7, sp, #0
3400d104:	6078      	str	r0, [r7, #4]
	SStackFrame	*ssp;

	ssp = tcb->isstack;
3400d106:	687b      	ldr	r3, [r7, #4]
3400d108:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
3400d10a:	60fb      	str	r3, [r7, #12]
	ssp--;
3400d10c:	68fb      	ldr	r3, [r7, #12]
3400d10e:	3b44      	subs	r3, #68	@ 0x44
3400d110:	60fb      	str	r3, [r7, #12]

	/* CPU context initialization */
	ssp->exp_ret	= EXCRTN_CODE;
3400d112:	68fb      	ldr	r3, [r7, #12]
3400d114:	f06f 0206 	mvn.w	r2, #6
3400d118:	601a      	str	r2, [r3, #0]
	ssp->lr		= 0;
3400d11a:	68fb      	ldr	r3, [r7, #12]
3400d11c:	2200      	movs	r2, #0
3400d11e:	639a      	str	r2, [r3, #56]	@ 0x38
	ssp->xpsr	= 0x01000000;		/* Initial SR */
3400d120:	68fb      	ldr	r3, [r7, #12]
3400d122:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
3400d126:	641a      	str	r2, [r3, #64]	@ 0x40
	ssp->pc = (void*)((UW)tcb->task & ~0x00000001UL);	/* Task startup address */
3400d128:	687b      	ldr	r3, [r7, #4]
3400d12a:	695b      	ldr	r3, [r3, #20]
3400d12c:	f023 0301 	bic.w	r3, r3, #1
3400d130:	461a      	mov	r2, r3
3400d132:	68fb      	ldr	r3, [r7, #12]
3400d134:	63da      	str	r2, [r3, #60]	@ 0x3c

	tcb->tskctxb.ssp = ssp;		/* System stack pointer */
3400d136:	687b      	ldr	r3, [r7, #4]
3400d138:	68fa      	ldr	r2, [r7, #12]
3400d13a:	619a      	str	r2, [r3, #24]
	tcb->tskctxb.spsa = tcb->isstack - tcb->sstksz;
	tcb->tskctxb.spea = tcb->isstack + sizeof(UW) - 1;
#endif

#if USE_FPU && ALWAYS_FPU_ATR
	tcb->tskatr |= TA_FPU;		/* Always set the TA_FPU attribute on all tasks */
3400d13c:	687b      	ldr	r3, [r7, #4]
3400d13e:	691b      	ldr	r3, [r3, #16]
3400d140:	f443 5280 	orr.w	r2, r3, #4096	@ 0x1000
3400d144:	687b      	ldr	r3, [r7, #4]
3400d146:	611a      	str	r2, [r3, #16]
#endif
}
3400d148:	bf00      	nop
3400d14a:	3714      	adds	r7, #20
3400d14c:	46bd      	mov	sp, r7
3400d14e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d152:	4770      	bx	lr

3400d154 <knl_task_initialize>:

/*
 * TCB Initialization
 */
EXPORT ER knl_task_initialize( void )
{
3400d154:	b580      	push	{r7, lr}
3400d156:	b084      	sub	sp, #16
3400d158:	af00      	add	r7, sp, #0
	if ( NUM_TSKID < 1 ) {
		return E_SYS;
	}

	/* Initialize task execution control information */
	knl_ctxtsk = knl_schedtsk = NULL;
3400d15a:	4b19      	ldr	r3, [pc, #100]	@ (3400d1c0 <knl_task_initialize+0x6c>)
3400d15c:	2200      	movs	r2, #0
3400d15e:	601a      	str	r2, [r3, #0]
3400d160:	4b17      	ldr	r3, [pc, #92]	@ (3400d1c0 <knl_task_initialize+0x6c>)
3400d162:	681b      	ldr	r3, [r3, #0]
3400d164:	4a17      	ldr	r2, [pc, #92]	@ (3400d1c4 <knl_task_initialize+0x70>)
3400d166:	6013      	str	r3, [r2, #0]
	knl_ready_queue_initialize(&knl_ready_queue);
3400d168:	4817      	ldr	r0, [pc, #92]	@ (3400d1c8 <knl_task_initialize+0x74>)
3400d16a:	f7ff fef7 	bl	3400cf5c <knl_ready_queue_initialize>
	knl_dispatch_disabled = DDS_ENABLE;
3400d16e:	4b17      	ldr	r3, [pc, #92]	@ (3400d1cc <knl_task_initialize+0x78>)
3400d170:	2200      	movs	r2, #0
3400d172:	601a      	str	r2, [r3, #0]

	/* Register all TCBs onto FreeQue */
	QueInit(&knl_free_tcb);
3400d174:	4816      	ldr	r0, [pc, #88]	@ (3400d1d0 <knl_task_initialize+0x7c>)
3400d176:	f7ff fe81 	bl	3400ce7c <QueInit>
	for ( tcb = knl_tcb_table, i = 0; i < NUM_TSKID; tcb++, i++ ) {
3400d17a:	4b16      	ldr	r3, [pc, #88]	@ (3400d1d4 <knl_task_initialize+0x80>)
3400d17c:	60bb      	str	r3, [r7, #8]
3400d17e:	2300      	movs	r3, #0
3400d180:	60fb      	str	r3, [r7, #12]
3400d182:	e014      	b.n	3400d1ae <knl_task_initialize+0x5a>
		tskid = ID_TSK(i);
3400d184:	68fb      	ldr	r3, [r7, #12]
3400d186:	3301      	adds	r3, #1
3400d188:	607b      	str	r3, [r7, #4]
		tcb->tskid = tskid;
3400d18a:	68bb      	ldr	r3, [r7, #8]
3400d18c:	687a      	ldr	r2, [r7, #4]
3400d18e:	609a      	str	r2, [r3, #8]
		tcb->state = TS_NONEXIST;
3400d190:	68bb      	ldr	r3, [r7, #8]
3400d192:	2200      	movs	r2, #0
3400d194:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
#if USE_LEGACY_API && USE_RENDEZVOUS
		tcb->wrdvno = tskid;
#endif

		QueInsert(&tcb->tskque, &knl_free_tcb);
3400d198:	68bb      	ldr	r3, [r7, #8]
3400d19a:	490d      	ldr	r1, [pc, #52]	@ (3400d1d0 <knl_task_initialize+0x7c>)
3400d19c:	4618      	mov	r0, r3
3400d19e:	f7ff fe8f 	bl	3400cec0 <QueInsert>
	for ( tcb = knl_tcb_table, i = 0; i < NUM_TSKID; tcb++, i++ ) {
3400d1a2:	68bb      	ldr	r3, [r7, #8]
3400d1a4:	3368      	adds	r3, #104	@ 0x68
3400d1a6:	60bb      	str	r3, [r7, #8]
3400d1a8:	68fb      	ldr	r3, [r7, #12]
3400d1aa:	3301      	adds	r3, #1
3400d1ac:	60fb      	str	r3, [r7, #12]
3400d1ae:	68fb      	ldr	r3, [r7, #12]
3400d1b0:	2b1f      	cmp	r3, #31
3400d1b2:	dde7      	ble.n	3400d184 <knl_task_initialize+0x30>
	}

	return E_OK;
3400d1b4:	2300      	movs	r3, #0
}
3400d1b6:	4618      	mov	r0, r3
3400d1b8:	3710      	adds	r7, #16
3400d1ba:	46bd      	mov	sp, r7
3400d1bc:	bd80      	pop	{r7, pc}
3400d1be:	bf00      	nop
3400d1c0:	34012804 	.word	0x34012804
3400d1c4:	34012800 	.word	0x34012800
3400d1c8:	34012808 	.word	0x34012808
3400d1cc:	340127fc 	.word	0x340127fc
3400d1d0:	34013618 	.word	0x34013618
3400d1d4:	34012918 	.word	0x34012918

3400d1d8 <knl_make_dormant>:

/*
 * Prepare task execution.
 */
EXPORT void knl_make_dormant( TCB *tcb )
{
3400d1d8:	b580      	push	{r7, lr}
3400d1da:	b082      	sub	sp, #8
3400d1dc:	af00      	add	r7, sp, #0
3400d1de:	6078      	str	r0, [r7, #4]
	/* Initialize variables which should be reset at DORMANT state */
	tcb->state	= TS_DORMANT;
3400d1e0:	687b      	ldr	r3, [r7, #4]
3400d1e2:	2208      	movs	r2, #8
3400d1e4:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
	tcb->priority	= tcb->bpriority = tcb->ipriority;
3400d1e8:	687b      	ldr	r3, [r7, #4]
3400d1ea:	f893 2024 	ldrb.w	r2, [r3, #36]	@ 0x24
3400d1ee:	687b      	ldr	r3, [r7, #4]
3400d1f0:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25
3400d1f4:	687b      	ldr	r3, [r7, #4]
3400d1f6:	f893 2025 	ldrb.w	r2, [r3, #37]	@ 0x25
3400d1fa:	687b      	ldr	r3, [r7, #4]
3400d1fc:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
	tcb->sysmode	= tcb->isysmode;
3400d200:	687b      	ldr	r3, [r7, #4]
3400d202:	f993 3020 	ldrsb.w	r3, [r3, #32]
3400d206:	461a      	mov	r2, r3
3400d208:	687b      	ldr	r3, [r7, #4]
3400d20a:	845a      	strh	r2, [r3, #34]	@ 0x22
	tcb->wupcnt	= 0;
3400d20c:	687b      	ldr	r3, [r7, #4]
3400d20e:	2200      	movs	r2, #0
3400d210:	635a      	str	r2, [r3, #52]	@ 0x34
	tcb->suscnt	= 0;
3400d212:	687b      	ldr	r3, [r7, #4]
3400d214:	2200      	movs	r2, #0
3400d216:	639a      	str	r2, [r3, #56]	@ 0x38

	tcb->klockwait	= FALSE;
3400d218:	687a      	ldr	r2, [r7, #4]
3400d21a:	f892 3028 	ldrb.w	r3, [r2, #40]	@ 0x28
3400d21e:	f023 0301 	bic.w	r3, r3, #1
3400d222:	f882 3028 	strb.w	r3, [r2, #40]	@ 0x28
	tcb->klocked	= FALSE;
3400d226:	687a      	ldr	r2, [r7, #4]
3400d228:	f892 3028 	ldrb.w	r3, [r2, #40]	@ 0x28
3400d22c:	f023 0302 	bic.w	r3, r3, #2
3400d230:	f882 3028 	strb.w	r3, [r2, #40]	@ 0x28
#if USE_DBGSPT && defined(USE_FUNC_TD_INF_TSK)
	tcb->stime	= 0;
	tcb->utime	= 0;
#endif

	tcb->wercd = NULL;
3400d234:	687b      	ldr	r3, [r7, #4]
3400d236:	2200      	movs	r2, #0
3400d238:	63da      	str	r2, [r3, #60]	@ 0x3c

#if USE_MUTEX == 1
	tcb->mtxlist	= NULL;
3400d23a:	687b      	ldr	r3, [r7, #4]
3400d23c:	2200      	movs	r2, #0
3400d23e:	665a      	str	r2, [r3, #100]	@ 0x64
#endif

	/* Set context to start task */
	knl_setup_context(tcb);
3400d240:	6878      	ldr	r0, [r7, #4]
3400d242:	f7ff ff5c 	bl	3400d0fe <knl_setup_context>
}
3400d246:	bf00      	nop
3400d248:	3708      	adds	r7, #8
3400d24a:	46bd      	mov	sp, r7
3400d24c:	bd80      	pop	{r7, pc}
	...

3400d250 <knl_make_ready>:
 * Set task to READY state.
 *	Update the task state and insert in the ready queue. If necessary, 
 *	update 'knl_schedtsk' and request to start task dispatcher. 
 */
EXPORT void knl_make_ready( TCB *tcb )
{
3400d250:	b580      	push	{r7, lr}
3400d252:	b082      	sub	sp, #8
3400d254:	af00      	add	r7, sp, #0
3400d256:	6078      	str	r0, [r7, #4]
	tcb->state = TS_READY;
3400d258:	687b      	ldr	r3, [r7, #4]
3400d25a:	2201      	movs	r2, #1
3400d25c:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
	if ( knl_ready_queue_insert(&knl_ready_queue, tcb) ) {
3400d260:	6879      	ldr	r1, [r7, #4]
3400d262:	4806      	ldr	r0, [pc, #24]	@ (3400d27c <knl_make_ready+0x2c>)
3400d264:	f7ff febf 	bl	3400cfe6 <knl_ready_queue_insert>
3400d268:	4603      	mov	r3, r0
3400d26a:	2b00      	cmp	r3, #0
3400d26c:	d002      	beq.n	3400d274 <knl_make_ready+0x24>
		knl_schedtsk = tcb;
3400d26e:	4a04      	ldr	r2, [pc, #16]	@ (3400d280 <knl_make_ready+0x30>)
3400d270:	687b      	ldr	r3, [r7, #4]
3400d272:	6013      	str	r3, [r2, #0]
	}
}
3400d274:	bf00      	nop
3400d276:	3708      	adds	r7, #8
3400d278:	46bd      	mov	sp, r7
3400d27a:	bd80      	pop	{r7, pc}
3400d27c:	34012808 	.word	0x34012808
3400d280:	34012804 	.word	0x34012804

3400d284 <knl_make_non_ready>:
 *	If the deleted task is 'knl_schedtsk', set 'knl_schedtsk' to the
 *	highest priority task in the ready queue. 
 *	'tcb' task must be READY.
 */
EXPORT void knl_make_non_ready( TCB *tcb )
{
3400d284:	b580      	push	{r7, lr}
3400d286:	b082      	sub	sp, #8
3400d288:	af00      	add	r7, sp, #0
3400d28a:	6078      	str	r0, [r7, #4]
	knl_ready_queue_delete(&knl_ready_queue, tcb);
3400d28c:	6879      	ldr	r1, [r7, #4]
3400d28e:	4809      	ldr	r0, [pc, #36]	@ (3400d2b4 <knl_make_non_ready+0x30>)
3400d290:	f7ff fee1 	bl	3400d056 <knl_ready_queue_delete>
	if ( knl_schedtsk == tcb ) {
3400d294:	4b08      	ldr	r3, [pc, #32]	@ (3400d2b8 <knl_make_non_ready+0x34>)
3400d296:	681b      	ldr	r3, [r3, #0]
3400d298:	687a      	ldr	r2, [r7, #4]
3400d29a:	429a      	cmp	r2, r3
3400d29c:	d105      	bne.n	3400d2aa <knl_make_non_ready+0x26>
		knl_schedtsk = knl_ready_queue_top(&knl_ready_queue);
3400d29e:	4805      	ldr	r0, [pc, #20]	@ (3400d2b4 <knl_make_non_ready+0x30>)
3400d2a0:	f7ff fe88 	bl	3400cfb4 <knl_ready_queue_top>
3400d2a4:	4603      	mov	r3, r0
3400d2a6:	4a04      	ldr	r2, [pc, #16]	@ (3400d2b8 <knl_make_non_ready+0x34>)
3400d2a8:	6013      	str	r3, [r2, #0]
	}
}
3400d2aa:	bf00      	nop
3400d2ac:	3708      	adds	r7, #8
3400d2ae:	46bd      	mov	sp, r7
3400d2b0:	bd80      	pop	{r7, pc}
3400d2b2:	bf00      	nop
3400d2b4:	34012808 	.word	0x34012808
3400d2b8:	34012804 	.word	0x34012804

3400d2bc <QueRemoveNext>:
{
3400d2bc:	b480      	push	{r7}
3400d2be:	b085      	sub	sp, #20
3400d2c0:	af00      	add	r7, sp, #0
3400d2c2:	6078      	str	r0, [r7, #4]
	if ( que->next == que ) {
3400d2c4:	687b      	ldr	r3, [r7, #4]
3400d2c6:	681b      	ldr	r3, [r3, #0]
3400d2c8:	687a      	ldr	r2, [r7, #4]
3400d2ca:	429a      	cmp	r2, r3
3400d2cc:	d101      	bne.n	3400d2d2 <QueRemoveNext+0x16>
		return NULL;
3400d2ce:	2300      	movs	r3, #0
3400d2d0:	e00b      	b.n	3400d2ea <QueRemoveNext+0x2e>
	entry = que->next;
3400d2d2:	687b      	ldr	r3, [r7, #4]
3400d2d4:	681b      	ldr	r3, [r3, #0]
3400d2d6:	60fb      	str	r3, [r7, #12]
	que->next = (struct queue*)entry->next;
3400d2d8:	68fb      	ldr	r3, [r7, #12]
3400d2da:	681a      	ldr	r2, [r3, #0]
3400d2dc:	687b      	ldr	r3, [r7, #4]
3400d2de:	601a      	str	r2, [r3, #0]
	entry->next->prev = que;
3400d2e0:	68fb      	ldr	r3, [r7, #12]
3400d2e2:	681b      	ldr	r3, [r3, #0]
3400d2e4:	687a      	ldr	r2, [r7, #4]
3400d2e6:	605a      	str	r2, [r3, #4]
	return entry;
3400d2e8:	68fb      	ldr	r3, [r7, #12]
}
3400d2ea:	4618      	mov	r0, r3
3400d2ec:	3714      	adds	r7, #20
3400d2ee:	46bd      	mov	sp, r7
3400d2f0:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d2f4:	4770      	bx	lr
	...

3400d2f8 <knl_isTaskIndependent>:
{
3400d2f8:	b480      	push	{r7}
3400d2fa:	af00      	add	r7, sp, #0
	return ( knl_taskindp > 0 )? TRUE: FALSE;
3400d2fc:	4b05      	ldr	r3, [pc, #20]	@ (3400d314 <knl_isTaskIndependent+0x1c>)
3400d2fe:	681b      	ldr	r3, [r3, #0]
3400d300:	2b00      	cmp	r3, #0
3400d302:	bfcc      	ite	gt
3400d304:	2301      	movgt	r3, #1
3400d306:	2300      	movle	r3, #0
3400d308:	b2db      	uxtb	r3, r3
}
3400d30a:	4618      	mov	r0, r3
3400d30c:	46bd      	mov	sp, r7
3400d30e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d312:	4770      	bx	lr
3400d314:	340114e8 	.word	0x340114e8

3400d318 <knl_setup_stacd>:
/*
 * Set task startup code
 *	Called by 'tk_sta_tsk()' processing.
 */
Inline void knl_setup_stacd( TCB *tcb, INT stacd )
{
3400d318:	b480      	push	{r7}
3400d31a:	b085      	sub	sp, #20
3400d31c:	af00      	add	r7, sp, #0
3400d31e:	6078      	str	r0, [r7, #4]
3400d320:	6039      	str	r1, [r7, #0]
	SStackFrame	*ssp;
	
	ssp = tcb->tskctxb.ssp;
3400d322:	687b      	ldr	r3, [r7, #4]
3400d324:	699b      	ldr	r3, [r3, #24]
3400d326:	60fb      	str	r3, [r7, #12]

	ssp->r[0] = stacd;
3400d328:	683a      	ldr	r2, [r7, #0]
3400d32a:	68fb      	ldr	r3, [r7, #12]
3400d32c:	625a      	str	r2, [r3, #36]	@ 0x24
	ssp->r[1] = (VW)tcb->exinf;
3400d32e:	687b      	ldr	r3, [r7, #4]
3400d330:	68db      	ldr	r3, [r3, #12]
3400d332:	461a      	mov	r2, r3
3400d334:	68fb      	ldr	r3, [r7, #12]
3400d336:	629a      	str	r2, [r3, #40]	@ 0x28
}
3400d338:	bf00      	nop
3400d33a:	3714      	adds	r7, #20
3400d33c:	46bd      	mov	sp, r7
3400d33e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d342:	4770      	bx	lr

3400d344 <tk_cre_tsk>:

/*
 * Create task
 */
SYSCALL ID tk_cre_tsk( CONST T_CTSK *pk_ctsk )
{
3400d344:	b580      	push	{r7, lr}
3400d346:	b088      	sub	sp, #32
3400d348:	af00      	add	r7, sp, #0
3400d34a:	6078      	str	r0, [r7, #4]
#if CHK_RSATR
	const ATR VALID_TSKATR = {	/* Valid value of task attribute */
3400d34c:	f241 3321 	movw	r3, #4897	@ 0x1321
3400d350:	613b      	str	r3, [r7, #16]
	TCB	*tcb;
	W	sstksz;
	void	*stack;
	ER	ercd;

	CHECK_RSATR(pk_ctsk->tskatr, VALID_TSKATR);
3400d352:	687b      	ldr	r3, [r7, #4]
3400d354:	685a      	ldr	r2, [r3, #4]
3400d356:	693b      	ldr	r3, [r7, #16]
3400d358:	43db      	mvns	r3, r3
3400d35a:	4013      	ands	r3, r2
3400d35c:	2b00      	cmp	r3, #0
3400d35e:	d002      	beq.n	3400d366 <tk_cre_tsk+0x22>
3400d360:	f06f 030a 	mvn.w	r3, #10
3400d364:	e090      	b.n	3400d488 <tk_cre_tsk+0x144>
#if !USE_IMALLOC
	/* TA_USERBUF must be specified if configured in no Imalloc */
	CHECK_PAR((pk_ctsk->tskatr & TA_USERBUF) != 0);
#endif
	CHECK_PAR(pk_ctsk->stksz >= 0);
3400d366:	687b      	ldr	r3, [r7, #4]
3400d368:	691b      	ldr	r3, [r3, #16]
3400d36a:	2b00      	cmp	r3, #0
3400d36c:	da02      	bge.n	3400d374 <tk_cre_tsk+0x30>
3400d36e:	f06f 0310 	mvn.w	r3, #16
3400d372:	e089      	b.n	3400d488 <tk_cre_tsk+0x144>
	CHECK_PRI(pk_ctsk->itskpri);
3400d374:	687b      	ldr	r3, [r7, #4]
3400d376:	68db      	ldr	r3, [r3, #12]
3400d378:	2b00      	cmp	r3, #0
3400d37a:	dd03      	ble.n	3400d384 <tk_cre_tsk+0x40>
3400d37c:	687b      	ldr	r3, [r7, #4]
3400d37e:	68db      	ldr	r3, [r3, #12]
3400d380:	2b20      	cmp	r3, #32
3400d382:	dd02      	ble.n	3400d38a <tk_cre_tsk+0x46>
3400d384:	f06f 0310 	mvn.w	r3, #16
3400d388:	e07e      	b.n	3400d488 <tk_cre_tsk+0x144>

	if ( (pk_ctsk->tskatr & TA_USERBUF) != 0 ) {
3400d38a:	687b      	ldr	r3, [r7, #4]
3400d38c:	685b      	ldr	r3, [r3, #4]
3400d38e:	f003 0320 	and.w	r3, r3, #32
3400d392:	2b00      	cmp	r3, #0
3400d394:	d00c      	beq.n	3400d3b0 <tk_cre_tsk+0x6c>
		/* Use user buffer */
		sstksz = pk_ctsk->stksz;
3400d396:	687b      	ldr	r3, [r7, #4]
3400d398:	691b      	ldr	r3, [r3, #16]
3400d39a:	61fb      	str	r3, [r7, #28]
		CHECK_PAR(sstksz >= MIN_SYS_STACK_SIZE);
3400d39c:	69fb      	ldr	r3, [r7, #28]
3400d39e:	2b7f      	cmp	r3, #127	@ 0x7f
3400d3a0:	dc02      	bgt.n	3400d3a8 <tk_cre_tsk+0x64>
3400d3a2:	f06f 0310 	mvn.w	r3, #16
3400d3a6:	e06f      	b.n	3400d488 <tk_cre_tsk+0x144>
		stack = pk_ctsk->bufptr;
3400d3a8:	687b      	ldr	r3, [r7, #4]
3400d3aa:	695b      	ldr	r3, [r3, #20]
3400d3ac:	61bb      	str	r3, [r7, #24]
3400d3ae:	e015      	b.n	3400d3dc <tk_cre_tsk+0x98>
	} else {
#if USE_IMALLOC
		/* Allocate system stack area */
		sstksz = pk_ctsk->stksz + DEFAULT_SYS_STKSZ;
3400d3b0:	687b      	ldr	r3, [r7, #4]
3400d3b2:	691b      	ldr	r3, [r3, #16]
3400d3b4:	3380      	adds	r3, #128	@ 0x80
3400d3b6:	61fb      	str	r3, [r7, #28]
		sstksz  = (sstksz  + 7) / 8 * 8;	/* Align to a multiple of 8 */
3400d3b8:	69fb      	ldr	r3, [r7, #28]
3400d3ba:	3307      	adds	r3, #7
3400d3bc:	2b00      	cmp	r3, #0
3400d3be:	da00      	bge.n	3400d3c2 <tk_cre_tsk+0x7e>
3400d3c0:	3307      	adds	r3, #7
3400d3c2:	10db      	asrs	r3, r3, #3
3400d3c4:	00db      	lsls	r3, r3, #3
3400d3c6:	61fb      	str	r3, [r7, #28]
		stack = knl_Imalloc((UW)sstksz);
3400d3c8:	69f8      	ldr	r0, [r7, #28]
3400d3ca:	f7ff f82b 	bl	3400c424 <knl_Imalloc>
3400d3ce:	61b8      	str	r0, [r7, #24]
		if ( stack == NULL ) {
3400d3d0:	69bb      	ldr	r3, [r7, #24]
3400d3d2:	2b00      	cmp	r3, #0
3400d3d4:	d102      	bne.n	3400d3dc <tk_cre_tsk+0x98>
			return E_NOMEM;
3400d3d6:	f06f 0320 	mvn.w	r3, #32
3400d3da:	e055      	b.n	3400d488 <tk_cre_tsk+0x144>
		}
#endif
	}

	BEGIN_CRITICAL_SECTION;
3400d3dc:	f002 fc11 	bl	3400fc02 <disint>
3400d3e0:	60f8      	str	r0, [r7, #12]
	/* Get control block from FreeQue */
	tcb = (TCB*)QueRemoveNext(&knl_free_tcb);
3400d3e2:	482b      	ldr	r0, [pc, #172]	@ (3400d490 <tk_cre_tsk+0x14c>)
3400d3e4:	f7ff ff6a 	bl	3400d2bc <QueRemoveNext>
3400d3e8:	60b8      	str	r0, [r7, #8]
	if ( tcb == NULL ) {
3400d3ea:	68bb      	ldr	r3, [r7, #8]
3400d3ec:	2b00      	cmp	r3, #0
3400d3ee:	d103      	bne.n	3400d3f8 <tk_cre_tsk+0xb4>
		ercd = E_LIMIT;
3400d3f0:	f06f 0321 	mvn.w	r3, #33	@ 0x21
3400d3f4:	617b      	str	r3, [r7, #20]
		goto error_exit;
3400d3f6:	e028      	b.n	3400d44a <tk_cre_tsk+0x106>
	}

	/* Initialize control block */
	tcb->exinf     = pk_ctsk->exinf;
3400d3f8:	687b      	ldr	r3, [r7, #4]
3400d3fa:	681a      	ldr	r2, [r3, #0]
3400d3fc:	68bb      	ldr	r3, [r7, #8]
3400d3fe:	60da      	str	r2, [r3, #12]
	tcb->tskatr    = pk_ctsk->tskatr;
3400d400:	687b      	ldr	r3, [r7, #4]
3400d402:	685a      	ldr	r2, [r3, #4]
3400d404:	68bb      	ldr	r3, [r7, #8]
3400d406:	611a      	str	r2, [r3, #16]
	tcb->task      = pk_ctsk->task;
3400d408:	687b      	ldr	r3, [r7, #4]
3400d40a:	689a      	ldr	r2, [r3, #8]
3400d40c:	68bb      	ldr	r3, [r7, #8]
3400d40e:	615a      	str	r2, [r3, #20]
	tcb->ipriority = (UB)int_priority(pk_ctsk->itskpri);
3400d410:	687b      	ldr	r3, [r7, #4]
3400d412:	68db      	ldr	r3, [r3, #12]
3400d414:	b2db      	uxtb	r3, r3
3400d416:	3b01      	subs	r3, #1
3400d418:	b2da      	uxtb	r2, r3
3400d41a:	68bb      	ldr	r3, [r7, #8]
3400d41c:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
	tcb->sstksz    = sstksz;
3400d420:	68bb      	ldr	r3, [r7, #8]
3400d422:	69fa      	ldr	r2, [r7, #28]
3400d424:	61da      	str	r2, [r3, #28]
		knl_strncpy((char*)tcb->name, (char*)pk_ctsk->dsname, OBJECT_NAME_LENGTH);
	}
#endif

	/* Set stack pointer */
	tcb->isstack = (VB*)stack + sstksz;
3400d426:	69fb      	ldr	r3, [r7, #28]
3400d428:	69ba      	ldr	r2, [r7, #24]
3400d42a:	441a      	add	r2, r3
3400d42c:	68bb      	ldr	r3, [r7, #8]
3400d42e:	661a      	str	r2, [r3, #96]	@ 0x60

	/* Set initial value of task operation mode */
	tcb->isysmode = 1;
3400d430:	68bb      	ldr	r3, [r7, #8]
3400d432:	2201      	movs	r2, #1
3400d434:	f883 2020 	strb.w	r2, [r3, #32]
	tcb->sysmode  = 1;
3400d438:	68bb      	ldr	r3, [r7, #8]
3400d43a:	2201      	movs	r2, #1
3400d43c:	845a      	strh	r2, [r3, #34]	@ 0x22

	/* make it to DORMANT state */
	knl_make_dormant(tcb);
3400d43e:	68b8      	ldr	r0, [r7, #8]
3400d440:	f7ff feca 	bl	3400d1d8 <knl_make_dormant>

	ercd = tcb->tskid;
3400d444:	68bb      	ldr	r3, [r7, #8]
3400d446:	689b      	ldr	r3, [r3, #8]
3400d448:	617b      	str	r3, [r7, #20]

    error_exit:
	END_CRITICAL_SECTION;
3400d44a:	68fb      	ldr	r3, [r7, #12]
3400d44c:	2b00      	cmp	r3, #0
3400d44e:	d10b      	bne.n	3400d468 <tk_cre_tsk+0x124>
3400d450:	4b10      	ldr	r3, [pc, #64]	@ (3400d494 <tk_cre_tsk+0x150>)
3400d452:	681a      	ldr	r2, [r3, #0]
3400d454:	4b10      	ldr	r3, [pc, #64]	@ (3400d498 <tk_cre_tsk+0x154>)
3400d456:	681b      	ldr	r3, [r3, #0]
3400d458:	429a      	cmp	r2, r3
3400d45a:	d005      	beq.n	3400d468 <tk_cre_tsk+0x124>
3400d45c:	4b0f      	ldr	r3, [pc, #60]	@ (3400d49c <tk_cre_tsk+0x158>)
3400d45e:	681b      	ldr	r3, [r3, #0]
3400d460:	2b00      	cmp	r3, #0
3400d462:	d101      	bne.n	3400d468 <tk_cre_tsk+0x124>
3400d464:	f001 fc8e 	bl	3400ed84 <knl_dispatch>
3400d468:	68f8      	ldr	r0, [r7, #12]
3400d46a:	f002 fbae 	bl	3400fbca <set_basepri>

#if USE_IMALLOC
	if ( (ercd < E_OK) && ((pk_ctsk->tskatr & TA_USERBUF) == 0) ) {
3400d46e:	697b      	ldr	r3, [r7, #20]
3400d470:	2b00      	cmp	r3, #0
3400d472:	da08      	bge.n	3400d486 <tk_cre_tsk+0x142>
3400d474:	687b      	ldr	r3, [r7, #4]
3400d476:	685b      	ldr	r3, [r3, #4]
3400d478:	f003 0320 	and.w	r3, r3, #32
3400d47c:	2b00      	cmp	r3, #0
3400d47e:	d102      	bne.n	3400d486 <tk_cre_tsk+0x142>
		knl_Ifree(stack);
3400d480:	69b8      	ldr	r0, [r7, #24]
3400d482:	f7ff f825 	bl	3400c4d0 <knl_Ifree>
	}
#endif

	return ercd;
3400d486:	697b      	ldr	r3, [r7, #20]
}
3400d488:	4618      	mov	r0, r3
3400d48a:	3720      	adds	r7, #32
3400d48c:	46bd      	mov	sp, r7
3400d48e:	bd80      	pop	{r7, pc}
3400d490:	34013618 	.word	0x34013618
3400d494:	34012800 	.word	0x34012800
3400d498:	34012804 	.word	0x34012804
3400d49c:	340127fc 	.word	0x340127fc

3400d4a0 <tk_sta_tsk>:

/*
 * Start task
 */
SYSCALL ER tk_sta_tsk( ID tskid, INT stacd )
{
3400d4a0:	b580      	push	{r7, lr}
3400d4a2:	b086      	sub	sp, #24
3400d4a4:	af00      	add	r7, sp, #0
3400d4a6:	6078      	str	r0, [r7, #4]
3400d4a8:	6039      	str	r1, [r7, #0]
	TCB	*tcb;
	TSTAT	state;
	ER	ercd = E_OK;
3400d4aa:	2300      	movs	r3, #0
3400d4ac:	617b      	str	r3, [r7, #20]

	CHECK_TSKID(tskid);
3400d4ae:	f7ff ff23 	bl	3400d2f8 <knl_isTaskIndependent>
3400d4b2:	4603      	mov	r3, r0
3400d4b4:	2b00      	cmp	r3, #0
3400d4b6:	d109      	bne.n	3400d4cc <tk_sta_tsk+0x2c>
3400d4b8:	4b2f      	ldr	r3, [pc, #188]	@ (3400d578 <tk_sta_tsk+0xd8>)
3400d4ba:	681b      	ldr	r3, [r3, #0]
3400d4bc:	2b00      	cmp	r3, #0
3400d4be:	d005      	beq.n	3400d4cc <tk_sta_tsk+0x2c>
3400d4c0:	687b      	ldr	r3, [r7, #4]
3400d4c2:	2b00      	cmp	r3, #0
3400d4c4:	d102      	bne.n	3400d4cc <tk_sta_tsk+0x2c>
3400d4c6:	f06f 0328 	mvn.w	r3, #40	@ 0x28
3400d4ca:	e050      	b.n	3400d56e <tk_sta_tsk+0xce>
3400d4cc:	687b      	ldr	r3, [r7, #4]
3400d4ce:	2b00      	cmp	r3, #0
3400d4d0:	dd02      	ble.n	3400d4d8 <tk_sta_tsk+0x38>
3400d4d2:	687b      	ldr	r3, [r7, #4]
3400d4d4:	2b20      	cmp	r3, #32
3400d4d6:	dd02      	ble.n	3400d4de <tk_sta_tsk+0x3e>
3400d4d8:	f06f 0311 	mvn.w	r3, #17
3400d4dc:	e047      	b.n	3400d56e <tk_sta_tsk+0xce>
	CHECK_NONSELF(tskid);
3400d4de:	f7ff ff0b 	bl	3400d2f8 <knl_isTaskIndependent>
3400d4e2:	4603      	mov	r3, r0
3400d4e4:	2b00      	cmp	r3, #0
3400d4e6:	d10c      	bne.n	3400d502 <tk_sta_tsk+0x62>
3400d4e8:	4b23      	ldr	r3, [pc, #140]	@ (3400d578 <tk_sta_tsk+0xd8>)
3400d4ea:	681b      	ldr	r3, [r3, #0]
3400d4ec:	2b00      	cmp	r3, #0
3400d4ee:	d008      	beq.n	3400d502 <tk_sta_tsk+0x62>
3400d4f0:	4b21      	ldr	r3, [pc, #132]	@ (3400d578 <tk_sta_tsk+0xd8>)
3400d4f2:	681b      	ldr	r3, [r3, #0]
3400d4f4:	689b      	ldr	r3, [r3, #8]
3400d4f6:	687a      	ldr	r2, [r7, #4]
3400d4f8:	429a      	cmp	r2, r3
3400d4fa:	d102      	bne.n	3400d502 <tk_sta_tsk+0x62>
3400d4fc:	f06f 0328 	mvn.w	r3, #40	@ 0x28
3400d500:	e035      	b.n	3400d56e <tk_sta_tsk+0xce>

	tcb = get_tcb(tskid);
3400d502:	687b      	ldr	r3, [r7, #4]
3400d504:	3b01      	subs	r3, #1
3400d506:	2268      	movs	r2, #104	@ 0x68
3400d508:	fb02 f303 	mul.w	r3, r2, r3
3400d50c:	4a1b      	ldr	r2, [pc, #108]	@ (3400d57c <tk_sta_tsk+0xdc>)
3400d50e:	4413      	add	r3, r2
3400d510:	613b      	str	r3, [r7, #16]

	BEGIN_CRITICAL_SECTION;
3400d512:	f002 fb76 	bl	3400fc02 <disint>
3400d516:	60f8      	str	r0, [r7, #12]
	state = (TSTAT)tcb->state;
3400d518:	693b      	ldr	r3, [r7, #16]
3400d51a:	f893 3027 	ldrb.w	r3, [r3, #39]	@ 0x27
3400d51e:	72fb      	strb	r3, [r7, #11]
	if ( state != TS_DORMANT ) {
3400d520:	7afb      	ldrb	r3, [r7, #11]
3400d522:	2b08      	cmp	r3, #8
3400d524:	d009      	beq.n	3400d53a <tk_sta_tsk+0x9a>
		ercd = ( state == TS_NONEXIST )? E_NOEXS: E_OBJ;
3400d526:	7afb      	ldrb	r3, [r7, #11]
3400d528:	2b00      	cmp	r3, #0
3400d52a:	d102      	bne.n	3400d532 <tk_sta_tsk+0x92>
3400d52c:	f06f 0329 	mvn.w	r3, #41	@ 0x29
3400d530:	e001      	b.n	3400d536 <tk_sta_tsk+0x96>
3400d532:	f06f 0328 	mvn.w	r3, #40	@ 0x28
3400d536:	617b      	str	r3, [r7, #20]
3400d538:	e006      	b.n	3400d548 <tk_sta_tsk+0xa8>
	} else {
		knl_setup_stacd(tcb, stacd);
3400d53a:	6839      	ldr	r1, [r7, #0]
3400d53c:	6938      	ldr	r0, [r7, #16]
3400d53e:	f7ff feeb 	bl	3400d318 <knl_setup_stacd>
		knl_make_ready(tcb);
3400d542:	6938      	ldr	r0, [r7, #16]
3400d544:	f7ff fe84 	bl	3400d250 <knl_make_ready>
	}
	END_CRITICAL_SECTION;
3400d548:	68fb      	ldr	r3, [r7, #12]
3400d54a:	2b00      	cmp	r3, #0
3400d54c:	d10b      	bne.n	3400d566 <tk_sta_tsk+0xc6>
3400d54e:	4b0a      	ldr	r3, [pc, #40]	@ (3400d578 <tk_sta_tsk+0xd8>)
3400d550:	681a      	ldr	r2, [r3, #0]
3400d552:	4b0b      	ldr	r3, [pc, #44]	@ (3400d580 <tk_sta_tsk+0xe0>)
3400d554:	681b      	ldr	r3, [r3, #0]
3400d556:	429a      	cmp	r2, r3
3400d558:	d005      	beq.n	3400d566 <tk_sta_tsk+0xc6>
3400d55a:	4b0a      	ldr	r3, [pc, #40]	@ (3400d584 <tk_sta_tsk+0xe4>)
3400d55c:	681b      	ldr	r3, [r3, #0]
3400d55e:	2b00      	cmp	r3, #0
3400d560:	d101      	bne.n	3400d566 <tk_sta_tsk+0xc6>
3400d562:	f001 fc0f 	bl	3400ed84 <knl_dispatch>
3400d566:	68f8      	ldr	r0, [r7, #12]
3400d568:	f002 fb2f 	bl	3400fbca <set_basepri>

	return ercd;
3400d56c:	697b      	ldr	r3, [r7, #20]
}
3400d56e:	4618      	mov	r0, r3
3400d570:	3718      	adds	r7, #24
3400d572:	46bd      	mov	sp, r7
3400d574:	bd80      	pop	{r7, pc}
3400d576:	bf00      	nop
3400d578:	34012800 	.word	0x34012800
3400d57c:	34012918 	.word	0x34012918
3400d580:	34012804 	.word	0x34012804
3400d584:	340127fc 	.word	0x340127fc

3400d588 <tk_get_tid>:
#ifdef USE_FUNC_TK_GET_TID
/*
 * Refer task ID at execution
 */
SYSCALL ID tk_get_tid( void )
{
3400d588:	b480      	push	{r7}
3400d58a:	af00      	add	r7, sp, #0
	return ( knl_ctxtsk == NULL )? 0: knl_ctxtsk->tskid;
3400d58c:	4b06      	ldr	r3, [pc, #24]	@ (3400d5a8 <tk_get_tid+0x20>)
3400d58e:	681b      	ldr	r3, [r3, #0]
3400d590:	2b00      	cmp	r3, #0
3400d592:	d003      	beq.n	3400d59c <tk_get_tid+0x14>
3400d594:	4b04      	ldr	r3, [pc, #16]	@ (3400d5a8 <tk_get_tid+0x20>)
3400d596:	681b      	ldr	r3, [r3, #0]
3400d598:	689b      	ldr	r3, [r3, #8]
3400d59a:	e000      	b.n	3400d59e <tk_get_tid+0x16>
3400d59c:	2300      	movs	r3, #0
}
3400d59e:	4618      	mov	r0, r3
3400d5a0:	46bd      	mov	sp, r7
3400d5a2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d5a6:	4770      	bx	lr
3400d5a8:	34012800 	.word	0x34012800

3400d5ac <QueInit>:
{
3400d5ac:	b480      	push	{r7}
3400d5ae:	b083      	sub	sp, #12
3400d5b0:	af00      	add	r7, sp, #0
3400d5b2:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400d5b4:	687b      	ldr	r3, [r7, #4]
3400d5b6:	687a      	ldr	r2, [r7, #4]
3400d5b8:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400d5ba:	687b      	ldr	r3, [r7, #4]
3400d5bc:	687a      	ldr	r2, [r7, #4]
3400d5be:	605a      	str	r2, [r3, #4]
}
3400d5c0:	bf00      	nop
3400d5c2:	370c      	adds	r7, #12
3400d5c4:	46bd      	mov	sp, r7
3400d5c6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d5ca:	4770      	bx	lr

3400d5cc <knl_isTaskIndependent>:
{
3400d5cc:	b480      	push	{r7}
3400d5ce:	af00      	add	r7, sp, #0
	return ( knl_taskindp > 0 )? TRUE: FALSE;
3400d5d0:	4b05      	ldr	r3, [pc, #20]	@ (3400d5e8 <knl_isTaskIndependent+0x1c>)
3400d5d2:	681b      	ldr	r3, [r3, #0]
3400d5d4:	2b00      	cmp	r3, #0
3400d5d6:	bfcc      	ite	gt
3400d5d8:	2301      	movgt	r3, #1
3400d5da:	2300      	movle	r3, #0
3400d5dc:	b2db      	uxtb	r3, r3
}
3400d5de:	4618      	mov	r0, r3
3400d5e0:	46bd      	mov	sp, r7
3400d5e2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d5e6:	4770      	bx	lr
3400d5e8:	340114e8 	.word	0x340114e8

3400d5ec <tk_slp_tsk>:
#ifdef USE_FUNC_TK_SLP_TSK
/*
 * Move its own task state to wait state
 */
SYSCALL ER tk_slp_tsk( TMO tmout )
{
3400d5ec:	b580      	push	{r7, lr}
3400d5ee:	b084      	sub	sp, #16
3400d5f0:	af00      	add	r7, sp, #0
3400d5f2:	6078      	str	r0, [r7, #4]
	ER	ercd = E_OK;
3400d5f4:	2300      	movs	r3, #0
3400d5f6:	60bb      	str	r3, [r7, #8]

	CHECK_TMOUT(tmout);
3400d5f8:	687b      	ldr	r3, [r7, #4]
3400d5fa:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
3400d5fe:	da02      	bge.n	3400d606 <tk_slp_tsk+0x1a>
3400d600:	f06f 0310 	mvn.w	r3, #16
3400d604:	e051      	b.n	3400d6aa <tk_slp_tsk+0xbe>
	CHECK_DISPATCH();
3400d606:	4b2b      	ldr	r3, [pc, #172]	@ (3400d6b4 <tk_slp_tsk+0xc8>)
3400d608:	681b      	ldr	r3, [r3, #0]
3400d60a:	2b00      	cmp	r3, #0
3400d60c:	d10d      	bne.n	3400d62a <tk_slp_tsk+0x3e>
3400d60e:	f7ff ffdd 	bl	3400d5cc <knl_isTaskIndependent>
3400d612:	4603      	mov	r3, r0
3400d614:	2b00      	cmp	r3, #0
3400d616:	d108      	bne.n	3400d62a <tk_slp_tsk+0x3e>
3400d618:	4b27      	ldr	r3, [pc, #156]	@ (3400d6b8 <tk_slp_tsk+0xcc>)
3400d61a:	681b      	ldr	r3, [r3, #0]
3400d61c:	2b00      	cmp	r3, #0
3400d61e:	d004      	beq.n	3400d62a <tk_slp_tsk+0x3e>
3400d620:	f002 fae2 	bl	3400fbe8 <get_basepri>
3400d624:	4603      	mov	r3, r0
3400d626:	2b00      	cmp	r3, #0
3400d628:	d002      	beq.n	3400d630 <tk_slp_tsk+0x44>
3400d62a:	f06f 0318 	mvn.w	r3, #24
3400d62e:	e03c      	b.n	3400d6aa <tk_slp_tsk+0xbe>

	BEGIN_CRITICAL_SECTION;
3400d630:	f002 fae7 	bl	3400fc02 <disint>
3400d634:	60f8      	str	r0, [r7, #12]

	if ( knl_ctxtsk->wupcnt > 0 ) {
3400d636:	4b20      	ldr	r3, [pc, #128]	@ (3400d6b8 <tk_slp_tsk+0xcc>)
3400d638:	681b      	ldr	r3, [r3, #0]
3400d63a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
3400d63c:	2b00      	cmp	r3, #0
3400d63e:	dd05      	ble.n	3400d64c <tk_slp_tsk+0x60>
		knl_ctxtsk->wupcnt--;
3400d640:	4b1d      	ldr	r3, [pc, #116]	@ (3400d6b8 <tk_slp_tsk+0xcc>)
3400d642:	681b      	ldr	r3, [r3, #0]
3400d644:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
3400d646:	3a01      	subs	r2, #1
3400d648:	635a      	str	r2, [r3, #52]	@ 0x34
3400d64a:	e01b      	b.n	3400d684 <tk_slp_tsk+0x98>
	} else {
		ercd = E_TMOUT;
3400d64c:	f06f 0331 	mvn.w	r3, #49	@ 0x31
3400d650:	60bb      	str	r3, [r7, #8]
		if ( tmout != TMO_POL ) {
3400d652:	687b      	ldr	r3, [r7, #4]
3400d654:	2b00      	cmp	r3, #0
3400d656:	d015      	beq.n	3400d684 <tk_slp_tsk+0x98>
			knl_ctxtsk->wspec = &knl_wspec_slp;
3400d658:	4b17      	ldr	r3, [pc, #92]	@ (3400d6b8 <tk_slp_tsk+0xcc>)
3400d65a:	681b      	ldr	r3, [r3, #0]
3400d65c:	4a17      	ldr	r2, [pc, #92]	@ (3400d6bc <tk_slp_tsk+0xd0>)
3400d65e:	62da      	str	r2, [r3, #44]	@ 0x2c
			knl_ctxtsk->wid = 0;
3400d660:	4b15      	ldr	r3, [pc, #84]	@ (3400d6b8 <tk_slp_tsk+0xcc>)
3400d662:	681b      	ldr	r3, [r3, #0]
3400d664:	2200      	movs	r2, #0
3400d666:	631a      	str	r2, [r3, #48]	@ 0x30
			knl_ctxtsk->wercd = &ercd;
3400d668:	4b13      	ldr	r3, [pc, #76]	@ (3400d6b8 <tk_slp_tsk+0xcc>)
3400d66a:	681b      	ldr	r3, [r3, #0]
3400d66c:	f107 0208 	add.w	r2, r7, #8
3400d670:	63da      	str	r2, [r3, #60]	@ 0x3c
			knl_make_wait(tmout, TA_NULL);
3400d672:	2100      	movs	r1, #0
3400d674:	6878      	ldr	r0, [r7, #4]
3400d676:	f000 fbe7 	bl	3400de48 <knl_make_wait>
			QueInit(&knl_ctxtsk->tskque);
3400d67a:	4b0f      	ldr	r3, [pc, #60]	@ (3400d6b8 <tk_slp_tsk+0xcc>)
3400d67c:	681b      	ldr	r3, [r3, #0]
3400d67e:	4618      	mov	r0, r3
3400d680:	f7ff ff94 	bl	3400d5ac <QueInit>
		}
	}

	END_CRITICAL_SECTION;
3400d684:	68fb      	ldr	r3, [r7, #12]
3400d686:	2b00      	cmp	r3, #0
3400d688:	d10b      	bne.n	3400d6a2 <tk_slp_tsk+0xb6>
3400d68a:	4b0b      	ldr	r3, [pc, #44]	@ (3400d6b8 <tk_slp_tsk+0xcc>)
3400d68c:	681a      	ldr	r2, [r3, #0]
3400d68e:	4b0c      	ldr	r3, [pc, #48]	@ (3400d6c0 <tk_slp_tsk+0xd4>)
3400d690:	681b      	ldr	r3, [r3, #0]
3400d692:	429a      	cmp	r2, r3
3400d694:	d005      	beq.n	3400d6a2 <tk_slp_tsk+0xb6>
3400d696:	4b07      	ldr	r3, [pc, #28]	@ (3400d6b4 <tk_slp_tsk+0xc8>)
3400d698:	681b      	ldr	r3, [r3, #0]
3400d69a:	2b00      	cmp	r3, #0
3400d69c:	d101      	bne.n	3400d6a2 <tk_slp_tsk+0xb6>
3400d69e:	f001 fb71 	bl	3400ed84 <knl_dispatch>
3400d6a2:	68f8      	ldr	r0, [r7, #12]
3400d6a4:	f002 fa91 	bl	3400fbca <set_basepri>

	return ercd;
3400d6a8:	68bb      	ldr	r3, [r7, #8]
}
3400d6aa:	4618      	mov	r0, r3
3400d6ac:	3710      	adds	r7, #16
3400d6ae:	46bd      	mov	sp, r7
3400d6b0:	bd80      	pop	{r7, pc}
3400d6b2:	bf00      	nop
3400d6b4:	340127fc 	.word	0x340127fc
3400d6b8:	34012800 	.word	0x34012800
3400d6bc:	340100c0 	.word	0x340100c0
3400d6c0:	34012804 	.word	0x34012804

3400d6c4 <tk_dly_tsk>:

/*
 * Task delay
 */
SYSCALL ER tk_dly_tsk( RELTIM dlytim )
{
3400d6c4:	b580      	push	{r7, lr}
3400d6c6:	b084      	sub	sp, #16
3400d6c8:	af00      	add	r7, sp, #0
3400d6ca:	6078      	str	r0, [r7, #4]
	ER	ercd = E_OK;
3400d6cc:	2300      	movs	r3, #0
3400d6ce:	60bb      	str	r3, [r7, #8]

	CHECK_RELTIM(dlytim);
3400d6d0:	687b      	ldr	r3, [r7, #4]
3400d6d2:	2b00      	cmp	r3, #0
3400d6d4:	da02      	bge.n	3400d6dc <tk_dly_tsk+0x18>
3400d6d6:	f06f 0310 	mvn.w	r3, #16
3400d6da:	e043      	b.n	3400d764 <tk_dly_tsk+0xa0>

	CHECK_DISPATCH();
3400d6dc:	4b23      	ldr	r3, [pc, #140]	@ (3400d76c <tk_dly_tsk+0xa8>)
3400d6de:	681b      	ldr	r3, [r3, #0]
3400d6e0:	2b00      	cmp	r3, #0
3400d6e2:	d10d      	bne.n	3400d700 <tk_dly_tsk+0x3c>
3400d6e4:	f7ff ff72 	bl	3400d5cc <knl_isTaskIndependent>
3400d6e8:	4603      	mov	r3, r0
3400d6ea:	2b00      	cmp	r3, #0
3400d6ec:	d108      	bne.n	3400d700 <tk_dly_tsk+0x3c>
3400d6ee:	4b20      	ldr	r3, [pc, #128]	@ (3400d770 <tk_dly_tsk+0xac>)
3400d6f0:	681b      	ldr	r3, [r3, #0]
3400d6f2:	2b00      	cmp	r3, #0
3400d6f4:	d004      	beq.n	3400d700 <tk_dly_tsk+0x3c>
3400d6f6:	f002 fa77 	bl	3400fbe8 <get_basepri>
3400d6fa:	4603      	mov	r3, r0
3400d6fc:	2b00      	cmp	r3, #0
3400d6fe:	d002      	beq.n	3400d706 <tk_dly_tsk+0x42>
3400d700:	f06f 0318 	mvn.w	r3, #24
3400d704:	e02e      	b.n	3400d764 <tk_dly_tsk+0xa0>

	if ( dlytim > 0 ) {
3400d706:	687b      	ldr	r3, [r7, #4]
3400d708:	2b00      	cmp	r3, #0
3400d70a:	d02a      	beq.n	3400d762 <tk_dly_tsk+0x9e>
		BEGIN_CRITICAL_SECTION;
3400d70c:	f002 fa79 	bl	3400fc02 <disint>
3400d710:	60f8      	str	r0, [r7, #12]
		knl_ctxtsk->wspec = &knl_wspec_dly;
3400d712:	4b17      	ldr	r3, [pc, #92]	@ (3400d770 <tk_dly_tsk+0xac>)
3400d714:	681b      	ldr	r3, [r3, #0]
3400d716:	4a17      	ldr	r2, [pc, #92]	@ (3400d774 <tk_dly_tsk+0xb0>)
3400d718:	62da      	str	r2, [r3, #44]	@ 0x2c
		knl_ctxtsk->wid = 0;
3400d71a:	4b15      	ldr	r3, [pc, #84]	@ (3400d770 <tk_dly_tsk+0xac>)
3400d71c:	681b      	ldr	r3, [r3, #0]
3400d71e:	2200      	movs	r2, #0
3400d720:	631a      	str	r2, [r3, #48]	@ 0x30
		knl_ctxtsk->wercd = &ercd;
3400d722:	4b13      	ldr	r3, [pc, #76]	@ (3400d770 <tk_dly_tsk+0xac>)
3400d724:	681b      	ldr	r3, [r3, #0]
3400d726:	f107 0208 	add.w	r2, r7, #8
3400d72a:	63da      	str	r2, [r3, #60]	@ 0x3c
		knl_make_wait_reltim(dlytim, TA_NULL);
3400d72c:	2100      	movs	r1, #0
3400d72e:	6878      	ldr	r0, [r7, #4]
3400d730:	f000 fbbc 	bl	3400deac <knl_make_wait_reltim>
		QueInit(&knl_ctxtsk->tskque);
3400d734:	4b0e      	ldr	r3, [pc, #56]	@ (3400d770 <tk_dly_tsk+0xac>)
3400d736:	681b      	ldr	r3, [r3, #0]
3400d738:	4618      	mov	r0, r3
3400d73a:	f7ff ff37 	bl	3400d5ac <QueInit>
		END_CRITICAL_SECTION;
3400d73e:	68fb      	ldr	r3, [r7, #12]
3400d740:	2b00      	cmp	r3, #0
3400d742:	d10b      	bne.n	3400d75c <tk_dly_tsk+0x98>
3400d744:	4b0a      	ldr	r3, [pc, #40]	@ (3400d770 <tk_dly_tsk+0xac>)
3400d746:	681a      	ldr	r2, [r3, #0]
3400d748:	4b0b      	ldr	r3, [pc, #44]	@ (3400d778 <tk_dly_tsk+0xb4>)
3400d74a:	681b      	ldr	r3, [r3, #0]
3400d74c:	429a      	cmp	r2, r3
3400d74e:	d005      	beq.n	3400d75c <tk_dly_tsk+0x98>
3400d750:	4b06      	ldr	r3, [pc, #24]	@ (3400d76c <tk_dly_tsk+0xa8>)
3400d752:	681b      	ldr	r3, [r3, #0]
3400d754:	2b00      	cmp	r3, #0
3400d756:	d101      	bne.n	3400d75c <tk_dly_tsk+0x98>
3400d758:	f001 fb14 	bl	3400ed84 <knl_dispatch>
3400d75c:	68f8      	ldr	r0, [r7, #12]
3400d75e:	f002 fa34 	bl	3400fbca <set_basepri>
	}

	return ercd;
3400d762:	68bb      	ldr	r3, [r7, #8]
}
3400d764:	4618      	mov	r0, r3
3400d766:	3710      	adds	r7, #16
3400d768:	46bd      	mov	sp, r7
3400d76a:	bd80      	pop	{r7, pc}
3400d76c:	340127fc 	.word	0x340127fc
3400d770:	34012800 	.word	0x34012800
3400d774:	340100cc 	.word	0x340100cc
3400d778:	34012804 	.word	0x34012804

3400d77c <QueInit>:
{
3400d77c:	b480      	push	{r7}
3400d77e:	b083      	sub	sp, #12
3400d780:	af00      	add	r7, sp, #0
3400d782:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400d784:	687b      	ldr	r3, [r7, #4]
3400d786:	687a      	ldr	r2, [r7, #4]
3400d788:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400d78a:	687b      	ldr	r3, [r7, #4]
3400d78c:	687a      	ldr	r2, [r7, #4]
3400d78e:	605a      	str	r2, [r3, #4]
}
3400d790:	bf00      	nop
3400d792:	370c      	adds	r7, #12
3400d794:	46bd      	mov	sp, r7
3400d796:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d79a:	4770      	bx	lr

3400d79c <QueInsert>:
{
3400d79c:	b480      	push	{r7}
3400d79e:	b083      	sub	sp, #12
3400d7a0:	af00      	add	r7, sp, #0
3400d7a2:	6078      	str	r0, [r7, #4]
3400d7a4:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400d7a6:	683b      	ldr	r3, [r7, #0]
3400d7a8:	685a      	ldr	r2, [r3, #4]
3400d7aa:	687b      	ldr	r3, [r7, #4]
3400d7ac:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400d7ae:	687b      	ldr	r3, [r7, #4]
3400d7b0:	683a      	ldr	r2, [r7, #0]
3400d7b2:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400d7b4:	683b      	ldr	r3, [r7, #0]
3400d7b6:	685b      	ldr	r3, [r3, #4]
3400d7b8:	687a      	ldr	r2, [r7, #4]
3400d7ba:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400d7bc:	683b      	ldr	r3, [r7, #0]
3400d7be:	687a      	ldr	r2, [r7, #4]
3400d7c0:	605a      	str	r2, [r3, #4]
}
3400d7c2:	bf00      	nop
3400d7c4:	370c      	adds	r7, #12
3400d7c6:	46bd      	mov	sp, r7
3400d7c8:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d7cc:	4770      	bx	lr
	...

3400d7d0 <knl_cyclichandler_initialize>:

/*
 * Initialization of cyclic handler control block
 */
EXPORT ER knl_cyclichandler_initialize( void )
{
3400d7d0:	b580      	push	{r7, lr}
3400d7d2:	b082      	sub	sp, #8
3400d7d4:	af00      	add	r7, sp, #0
	if ( NUM_CYCID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_cyccb);
3400d7d6:	480d      	ldr	r0, [pc, #52]	@ (3400d80c <knl_cyclichandler_initialize+0x3c>)
3400d7d8:	f7ff ffd0 	bl	3400d77c <QueInit>
	end = knl_cyccb_table + NUM_CYCID;
3400d7dc:	4b0c      	ldr	r3, [pc, #48]	@ (3400d810 <knl_cyclichandler_initialize+0x40>)
3400d7de:	603b      	str	r3, [r7, #0]
	for ( cyccb = knl_cyccb_table; cyccb < end; cyccb++ ) {
3400d7e0:	4b0c      	ldr	r3, [pc, #48]	@ (3400d814 <knl_cyclichandler_initialize+0x44>)
3400d7e2:	607b      	str	r3, [r7, #4]
3400d7e4:	e009      	b.n	3400d7fa <knl_cyclichandler_initialize+0x2a>
		cyccb->cychdr = NULL; /* Unregistered handler */
3400d7e6:	687b      	ldr	r3, [r7, #4]
3400d7e8:	2200      	movs	r2, #0
3400d7ea:	609a      	str	r2, [r3, #8]
		QueInsert((QUEUE*)cyccb, &knl_free_cyccb);
3400d7ec:	4907      	ldr	r1, [pc, #28]	@ (3400d80c <knl_cyclichandler_initialize+0x3c>)
3400d7ee:	6878      	ldr	r0, [r7, #4]
3400d7f0:	f7ff ffd4 	bl	3400d79c <QueInsert>
	for ( cyccb = knl_cyccb_table; cyccb < end; cyccb++ ) {
3400d7f4:	687b      	ldr	r3, [r7, #4]
3400d7f6:	3328      	adds	r3, #40	@ 0x28
3400d7f8:	607b      	str	r3, [r7, #4]
3400d7fa:	687a      	ldr	r2, [r7, #4]
3400d7fc:	683b      	ldr	r3, [r7, #0]
3400d7fe:	429a      	cmp	r2, r3
3400d800:	d3f1      	bcc.n	3400d7e6 <knl_cyclichandler_initialize+0x16>
	}

	return E_OK;
3400d802:	2300      	movs	r3, #0
}
3400d804:	4618      	mov	r0, r3
3400d806:	3708      	adds	r7, #8
3400d808:	46bd      	mov	sp, r7
3400d80a:	bd80      	pop	{r7, pc}
3400d80c:	340136c0 	.word	0x340136c0
3400d810:	340136c0 	.word	0x340136c0
3400d814:	34013620 	.word	0x34013620

3400d818 <knl_alarmhandler_initialize>:

/*
 * Initialization of alarm handler control block 
 */
EXPORT ER knl_alarmhandler_initialize( void )
{
3400d818:	b580      	push	{r7, lr}
3400d81a:	b082      	sub	sp, #8
3400d81c:	af00      	add	r7, sp, #0
	if ( NUM_ALMID < 1 ) {
		return E_SYS;
	}

	/* Register all control blocks onto FreeQue */
	QueInit(&knl_free_almcb);
3400d81e:	480d      	ldr	r0, [pc, #52]	@ (3400d854 <knl_alarmhandler_initialize+0x3c>)
3400d820:	f7ff ffac 	bl	3400d77c <QueInit>
	end = knl_almcb_table + NUM_ALMID;
3400d824:	4b0c      	ldr	r3, [pc, #48]	@ (3400d858 <knl_alarmhandler_initialize+0x40>)
3400d826:	603b      	str	r3, [r7, #0]
	for ( almcb = knl_almcb_table; almcb < end; almcb++ ) {
3400d828:	4b0c      	ldr	r3, [pc, #48]	@ (3400d85c <knl_alarmhandler_initialize+0x44>)
3400d82a:	607b      	str	r3, [r7, #4]
3400d82c:	e009      	b.n	3400d842 <knl_alarmhandler_initialize+0x2a>
		almcb->almhdr = NULL; /* Unregistered handler */
3400d82e:	687b      	ldr	r3, [r7, #4]
3400d830:	2200      	movs	r2, #0
3400d832:	609a      	str	r2, [r3, #8]
		QueInsert((QUEUE*)almcb, &knl_free_almcb);
3400d834:	4907      	ldr	r1, [pc, #28]	@ (3400d854 <knl_alarmhandler_initialize+0x3c>)
3400d836:	6878      	ldr	r0, [r7, #4]
3400d838:	f7ff ffb0 	bl	3400d79c <QueInsert>
	for ( almcb = knl_almcb_table; almcb < end; almcb++ ) {
3400d83c:	687b      	ldr	r3, [r7, #4]
3400d83e:	3324      	adds	r3, #36	@ 0x24
3400d840:	607b      	str	r3, [r7, #4]
3400d842:	687a      	ldr	r2, [r7, #4]
3400d844:	683b      	ldr	r3, [r7, #0]
3400d846:	429a      	cmp	r2, r3
3400d848:	d3f1      	bcc.n	3400d82e <knl_alarmhandler_initialize+0x16>
	}

	return E_OK;
3400d84a:	2300      	movs	r3, #0
}
3400d84c:	4618      	mov	r0, r3
3400d84e:	3708      	adds	r7, #8
3400d850:	46bd      	mov	sp, r7
3400d852:	bd80      	pop	{r7, pc}
3400d854:	340137e8 	.word	0x340137e8
3400d858:	340137e8 	.word	0x340137e8
3400d85c:	340136c8 	.word	0x340136c8

3400d860 <out_w>:
Inline void out_d( UW port, UD data )
{
	*(_UD*)port = data;
}
Inline void out_w( UW port, UW data )
{
3400d860:	b480      	push	{r7}
3400d862:	b083      	sub	sp, #12
3400d864:	af00      	add	r7, sp, #0
3400d866:	6078      	str	r0, [r7, #4]
3400d868:	6039      	str	r1, [r7, #0]
	*(_UW*)port = data;
3400d86a:	687b      	ldr	r3, [r7, #4]
3400d86c:	683a      	ldr	r2, [r7, #0]
3400d86e:	601a      	str	r2, [r3, #0]
}
3400d870:	bf00      	nop
3400d872:	370c      	adds	r7, #12
3400d874:	46bd      	mov	sp, r7
3400d876:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d87a:	4770      	bx	lr

3400d87c <in_w>:
Inline UD in_d( UW port )
{
	return *(_UD*)port;
}
Inline UW in_w( UW port )
{
3400d87c:	b480      	push	{r7}
3400d87e:	b083      	sub	sp, #12
3400d880:	af00      	add	r7, sp, #0
3400d882:	6078      	str	r0, [r7, #4]
	return *(_UW*)port;
3400d884:	687b      	ldr	r3, [r7, #4]
3400d886:	681b      	ldr	r3, [r3, #0]
}
3400d888:	4618      	mov	r0, r3
3400d88a:	370c      	adds	r7, #12
3400d88c:	46bd      	mov	sp, r7
3400d88e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d892:	4770      	bx	lr

3400d894 <QueInit>:
{
3400d894:	b480      	push	{r7}
3400d896:	b083      	sub	sp, #12
3400d898:	af00      	add	r7, sp, #0
3400d89a:	6078      	str	r0, [r7, #4]
	que->next = (struct queue *)que;
3400d89c:	687b      	ldr	r3, [r7, #4]
3400d89e:	687a      	ldr	r2, [r7, #4]
3400d8a0:	601a      	str	r2, [r3, #0]
	que->prev = (struct queue *)que;
3400d8a2:	687b      	ldr	r3, [r7, #4]
3400d8a4:	687a      	ldr	r2, [r7, #4]
3400d8a6:	605a      	str	r2, [r3, #4]
}
3400d8a8:	bf00      	nop
3400d8aa:	370c      	adds	r7, #12
3400d8ac:	46bd      	mov	sp, r7
3400d8ae:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d8b2:	4770      	bx	lr

3400d8b4 <isQueEmpty>:
{
3400d8b4:	b480      	push	{r7}
3400d8b6:	b083      	sub	sp, #12
3400d8b8:	af00      	add	r7, sp, #0
3400d8ba:	6078      	str	r0, [r7, #4]
	return ( que->next == que )? TRUE: FALSE;
3400d8bc:	687b      	ldr	r3, [r7, #4]
3400d8be:	681b      	ldr	r3, [r3, #0]
3400d8c0:	687a      	ldr	r2, [r7, #4]
3400d8c2:	429a      	cmp	r2, r3
3400d8c4:	bf0c      	ite	eq
3400d8c6:	2301      	moveq	r3, #1
3400d8c8:	2300      	movne	r3, #0
3400d8ca:	b2db      	uxtb	r3, r3
}
3400d8cc:	4618      	mov	r0, r3
3400d8ce:	370c      	adds	r7, #12
3400d8d0:	46bd      	mov	sp, r7
3400d8d2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d8d6:	4770      	bx	lr

3400d8d8 <QueInsert>:
{
3400d8d8:	b480      	push	{r7}
3400d8da:	b083      	sub	sp, #12
3400d8dc:	af00      	add	r7, sp, #0
3400d8de:	6078      	str	r0, [r7, #4]
3400d8e0:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400d8e2:	683b      	ldr	r3, [r7, #0]
3400d8e4:	685a      	ldr	r2, [r3, #4]
3400d8e6:	687b      	ldr	r3, [r7, #4]
3400d8e8:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400d8ea:	687b      	ldr	r3, [r7, #4]
3400d8ec:	683a      	ldr	r2, [r7, #0]
3400d8ee:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400d8f0:	683b      	ldr	r3, [r7, #0]
3400d8f2:	685b      	ldr	r3, [r3, #4]
3400d8f4:	687a      	ldr	r2, [r7, #4]
3400d8f6:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400d8f8:	683b      	ldr	r3, [r7, #0]
3400d8fa:	687a      	ldr	r2, [r7, #4]
3400d8fc:	605a      	str	r2, [r3, #4]
}
3400d8fe:	bf00      	nop
3400d900:	370c      	adds	r7, #12
3400d902:	46bd      	mov	sp, r7
3400d904:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d908:	4770      	bx	lr

3400d90a <QueRemove>:
{
3400d90a:	b480      	push	{r7}
3400d90c:	b083      	sub	sp, #12
3400d90e:	af00      	add	r7, sp, #0
3400d910:	6078      	str	r0, [r7, #4]
	if ( entry->next != entry ) {
3400d912:	687b      	ldr	r3, [r7, #4]
3400d914:	681b      	ldr	r3, [r3, #0]
3400d916:	687a      	ldr	r2, [r7, #4]
3400d918:	429a      	cmp	r2, r3
3400d91a:	d009      	beq.n	3400d930 <QueRemove+0x26>
		entry->prev->next = (struct queue*) entry->next;
3400d91c:	687b      	ldr	r3, [r7, #4]
3400d91e:	685b      	ldr	r3, [r3, #4]
3400d920:	687a      	ldr	r2, [r7, #4]
3400d922:	6812      	ldr	r2, [r2, #0]
3400d924:	601a      	str	r2, [r3, #0]
		entry->next->prev = (struct queue*) entry->prev;
3400d926:	687b      	ldr	r3, [r7, #4]
3400d928:	681b      	ldr	r3, [r3, #0]
3400d92a:	687a      	ldr	r2, [r7, #4]
3400d92c:	6852      	ldr	r2, [r2, #4]
3400d92e:	605a      	str	r2, [r3, #4]
}
3400d930:	bf00      	nop
3400d932:	370c      	adds	r7, #12
3400d934:	46bd      	mov	sp, r7
3400d936:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d93a:	4770      	bx	lr

3400d93c <knl_abstim_reached>:
typedef	UW	ABSTIM;

#define ABSTIM_DIFF_MIN  (0x7FFFFFFF)

Inline BOOL knl_abstim_reached( ABSTIM curtim, ABSTIM evttim )
{
3400d93c:	b480      	push	{r7}
3400d93e:	b083      	sub	sp, #12
3400d940:	af00      	add	r7, sp, #0
3400d942:	6078      	str	r0, [r7, #4]
3400d944:	6039      	str	r1, [r7, #0]
	return (ABSTIM)(curtim - evttim) <= (ABSTIM)ABSTIM_DIFF_MIN;
3400d946:	687a      	ldr	r2, [r7, #4]
3400d948:	683b      	ldr	r3, [r7, #0]
3400d94a:	1ad3      	subs	r3, r2, r3
3400d94c:	43db      	mvns	r3, r3
3400d94e:	0fdb      	lsrs	r3, r3, #31
3400d950:	b2db      	uxtb	r3, r3
}
3400d952:	4618      	mov	r0, r3
3400d954:	370c      	adds	r7, #12
3400d956:	46bd      	mov	sp, r7
3400d958:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d95c:	4770      	bx	lr
	...

3400d960 <knl_start_hw_timer>:
/*
 * Timer start processing
 *	Initialize the timer and start the periodical timer interrupt.
 */
Inline void knl_start_hw_timer( void )
{
3400d960:	b580      	push	{r7, lr}
3400d962:	b082      	sub	sp, #8
3400d964:	af00      	add	r7, sp, #0
	UINT	n, imask;

	DI(imask);
3400d966:	f002 f94c 	bl	3400fc02 <disint>
3400d96a:	6078      	str	r0, [r7, #4]

	/* Set System timer CLK source to Core, Systick exception enable */
	out_w(SYST_CSR, 0x00000006);
3400d96c:	2106      	movs	r1, #6
3400d96e:	4811      	ldr	r0, [pc, #68]	@ (3400d9b4 <knl_start_hw_timer+0x54>)
3400d970:	f7ff ff76 	bl	3400d860 <out_w>

	/* Set counter: TMCLK(MHz) */
	n = (UINT)(TIMER_PERIOD * TMCLK_KHz - 1);
3400d974:	4b10      	ldr	r3, [pc, #64]	@ (3400d9b8 <knl_start_hw_timer+0x58>)
3400d976:	681b      	ldr	r3, [r3, #0]
3400d978:	4a10      	ldr	r2, [pc, #64]	@ (3400d9bc <knl_start_hw_timer+0x5c>)
3400d97a:	fba2 2303 	umull	r2, r3, r2, r3
3400d97e:	099a      	lsrs	r2, r3, #6
3400d980:	4613      	mov	r3, r2
3400d982:	009b      	lsls	r3, r3, #2
3400d984:	4413      	add	r3, r2
3400d986:	005b      	lsls	r3, r3, #1
3400d988:	3b01      	subs	r3, #1
3400d98a:	603b      	str	r3, [r7, #0]
	out_w(SYST_RVR, n);
3400d98c:	6839      	ldr	r1, [r7, #0]
3400d98e:	480c      	ldr	r0, [pc, #48]	@ (3400d9c0 <knl_start_hw_timer+0x60>)
3400d990:	f7ff ff66 	bl	3400d860 <out_w>
	out_w(SYST_CVR, 0);
3400d994:	2100      	movs	r1, #0
3400d996:	480b      	ldr	r0, [pc, #44]	@ (3400d9c4 <knl_start_hw_timer+0x64>)
3400d998:	f7ff ff62 	bl	3400d860 <out_w>

	/* Start timer count */
	out_w(SYST_CSR, 0x00000007);
3400d99c:	2107      	movs	r1, #7
3400d99e:	4805      	ldr	r0, [pc, #20]	@ (3400d9b4 <knl_start_hw_timer+0x54>)
3400d9a0:	f7ff ff5e 	bl	3400d860 <out_w>

	EI(imask);
3400d9a4:	6878      	ldr	r0, [r7, #4]
3400d9a6:	f002 f910 	bl	3400fbca <set_basepri>
}
3400d9aa:	bf00      	nop
3400d9ac:	3708      	adds	r7, #8
3400d9ae:	46bd      	mov	sp, r7
3400d9b0:	bd80      	pop	{r7, pc}
3400d9b2:	bf00      	nop
3400d9b4:	e000e010 	.word	0xe000e010
3400d9b8:	340114ec 	.word	0x340114ec
3400d9bc:	10624dd3 	.word	0x10624dd3
3400d9c0:	e000e014 	.word	0xe000e014
3400d9c4:	e000e018 	.word	0xe000e018

3400d9c8 <knl_clear_hw_timer_interrupt>:
 *	'end_of_hw_timer_interrupt()' is called at the end of the timer
 *	interrupt handler.
 *	Use either or both according to hardware.
 */
Inline void knl_clear_hw_timer_interrupt( void )
{
3400d9c8:	b580      	push	{r7, lr}
3400d9ca:	af00      	add	r7, sp, #0
	(void)in_w(SYST_CSR);			/* Clear COUNTFLAG */
3400d9cc:	4804      	ldr	r0, [pc, #16]	@ (3400d9e0 <knl_clear_hw_timer_interrupt+0x18>)
3400d9ce:	f7ff ff55 	bl	3400d87c <in_w>
	out_w(SCB_ICSR, ICSR_PENDSTCLR);
3400d9d2:	f04f 7100 	mov.w	r1, #33554432	@ 0x2000000
3400d9d6:	4803      	ldr	r0, [pc, #12]	@ (3400d9e4 <knl_clear_hw_timer_interrupt+0x1c>)
3400d9d8:	f7ff ff42 	bl	3400d860 <out_w>
}
3400d9dc:	bf00      	nop
3400d9de:	bd80      	pop	{r7, pc}
3400d9e0:	e000e010 	.word	0xe000e010
3400d9e4:	e000ed04 	.word	0xe000ed04

3400d9e8 <knl_end_of_hw_timer_interrupt>:

Inline void knl_end_of_hw_timer_interrupt( void )
{
3400d9e8:	b480      	push	{r7}
3400d9ea:	af00      	add	r7, sp, #0
	/* No processing */
}
3400d9ec:	bf00      	nop
3400d9ee:	46bd      	mov	sp, r7
3400d9f0:	f85d 7b04 	ldr.w	r7, [sp], #4
3400d9f4:	4770      	bx	lr
	...

3400d9f8 <knl_terminate_hw_timer>:
 * Timer stop processing
 *	Stop the timer operation.
 *	Called when system stops.
 */
Inline void knl_terminate_hw_timer( void )
{
3400d9f8:	b580      	push	{r7, lr}
3400d9fa:	af00      	add	r7, sp, #0
	/* Timer interrupt disable */
	out_w(SYST_CSR, 0x00000000);
3400d9fc:	2100      	movs	r1, #0
3400d9fe:	4802      	ldr	r0, [pc, #8]	@ (3400da08 <knl_terminate_hw_timer+0x10>)
3400da00:	f7ff ff2e 	bl	3400d860 <out_w>
}
3400da04:	bf00      	nop
3400da06:	bd80      	pop	{r7, pc}
3400da08:	e000e010 	.word	0xe000e010

3400da0c <knl_timer_startup>:

/*
 * Start system timer
 */
EXPORT ER knl_timer_startup( void )
{
3400da0c:	b580      	push	{r7, lr}
3400da0e:	af00      	add	r7, sp, #0
	knl_current_time = knl_real_time_ofs = uitoll(0);
3400da10:	490a      	ldr	r1, [pc, #40]	@ (3400da3c <knl_timer_startup+0x30>)
3400da12:	f04f 0200 	mov.w	r2, #0
3400da16:	f04f 0300 	mov.w	r3, #0
3400da1a:	e9c1 2300 	strd	r2, r3, [r1]
3400da1e:	4b07      	ldr	r3, [pc, #28]	@ (3400da3c <knl_timer_startup+0x30>)
3400da20:	e9d3 2300 	ldrd	r2, r3, [r3]
3400da24:	4906      	ldr	r1, [pc, #24]	@ (3400da40 <knl_timer_startup+0x34>)
3400da26:	e9c1 2300 	strd	r2, r3, [r1]
	QueInit(&knl_timer_queue);
3400da2a:	4806      	ldr	r0, [pc, #24]	@ (3400da44 <knl_timer_startup+0x38>)
3400da2c:	f7ff ff32 	bl	3400d894 <QueInit>

	/* Start timer interrupt */
	knl_start_hw_timer();
3400da30:	f7ff ff96 	bl	3400d960 <knl_start_hw_timer>

	return E_OK;
3400da34:	2300      	movs	r3, #0
}
3400da36:	4618      	mov	r0, r3
3400da38:	bd80      	pop	{r7, pc}
3400da3a:	bf00      	nop
3400da3c:	340137f8 	.word	0x340137f8
3400da40:	340137f0 	.word	0x340137f0
3400da44:	34013800 	.word	0x34013800

3400da48 <knl_timer_shutdown>:
#if USE_SHUTDOWN
/*
 * Stop system timer
 */
EXPORT void knl_timer_shutdown( void )
{
3400da48:	b580      	push	{r7, lr}
3400da4a:	af00      	add	r7, sp, #0
	knl_terminate_hw_timer();
3400da4c:	f7ff ffd4 	bl	3400d9f8 <knl_terminate_hw_timer>
}
3400da50:	bf00      	nop
3400da52:	bd80      	pop	{r7, pc}

3400da54 <knl_enqueue_tmeb>:

/*
 * Insert timer event to timer event queue
 */
LOCAL void knl_enqueue_tmeb( TMEB *event )
{
3400da54:	b580      	push	{r7, lr}
3400da56:	b084      	sub	sp, #16
3400da58:	af00      	add	r7, sp, #0
3400da5a:	6078      	str	r0, [r7, #4]
	QUEUE	*q;
	ABSTIM	ofs = lltoul(knl_current_time) - ABSTIM_DIFF_MIN;
3400da5c:	4b13      	ldr	r3, [pc, #76]	@ (3400daac <knl_enqueue_tmeb+0x58>)
3400da5e:	e9d3 2300 	ldrd	r2, r3, [r3]
3400da62:	4613      	mov	r3, r2
3400da64:	f103 4300 	add.w	r3, r3, #2147483648	@ 0x80000000
3400da68:	3301      	adds	r3, #1
3400da6a:	60bb      	str	r3, [r7, #8]

	for ( q = knl_timer_queue.next; q != &knl_timer_queue; q = q->next ) {
3400da6c:	4b10      	ldr	r3, [pc, #64]	@ (3400dab0 <knl_enqueue_tmeb+0x5c>)
3400da6e:	681b      	ldr	r3, [r3, #0]
3400da70:	60fb      	str	r3, [r7, #12]
3400da72:	e00c      	b.n	3400da8e <knl_enqueue_tmeb+0x3a>
		if ( (ABSTIM)(event->time - ofs) < (ABSTIM)((((TMEB*)q)->time) - ofs) ) {
3400da74:	687b      	ldr	r3, [r7, #4]
3400da76:	689a      	ldr	r2, [r3, #8]
3400da78:	68bb      	ldr	r3, [r7, #8]
3400da7a:	1ad2      	subs	r2, r2, r3
3400da7c:	68fb      	ldr	r3, [r7, #12]
3400da7e:	6899      	ldr	r1, [r3, #8]
3400da80:	68bb      	ldr	r3, [r7, #8]
3400da82:	1acb      	subs	r3, r1, r3
3400da84:	429a      	cmp	r2, r3
3400da86:	d307      	bcc.n	3400da98 <knl_enqueue_tmeb+0x44>
	for ( q = knl_timer_queue.next; q != &knl_timer_queue; q = q->next ) {
3400da88:	68fb      	ldr	r3, [r7, #12]
3400da8a:	681b      	ldr	r3, [r3, #0]
3400da8c:	60fb      	str	r3, [r7, #12]
3400da8e:	68fb      	ldr	r3, [r7, #12]
3400da90:	4a07      	ldr	r2, [pc, #28]	@ (3400dab0 <knl_enqueue_tmeb+0x5c>)
3400da92:	4293      	cmp	r3, r2
3400da94:	d1ee      	bne.n	3400da74 <knl_enqueue_tmeb+0x20>
3400da96:	e000      	b.n	3400da9a <knl_enqueue_tmeb+0x46>
			break;
3400da98:	bf00      	nop
		}
	}
	QueInsert(&event->queue, q);
3400da9a:	687b      	ldr	r3, [r7, #4]
3400da9c:	68f9      	ldr	r1, [r7, #12]
3400da9e:	4618      	mov	r0, r3
3400daa0:	f7ff ff1a 	bl	3400d8d8 <QueInsert>
}
3400daa4:	bf00      	nop
3400daa6:	3710      	adds	r7, #16
3400daa8:	46bd      	mov	sp, r7
3400daaa:	bd80      	pop	{r7, pc}
3400daac:	340137f0 	.word	0x340137f0
3400dab0:	34013800 	.word	0x34013800

3400dab4 <knl_timer_insert>:
 *	typedef	W		TMO;
 *	typedef UW		RELTIM;
 *	#define TMO_FEVR	(-1)
 */
EXPORT void knl_timer_insert( TMEB *event, TMO tmout, CBACK callback, void *arg )
{
3400dab4:	b580      	push	{r7, lr}
3400dab6:	b084      	sub	sp, #16
3400dab8:	af00      	add	r7, sp, #0
3400daba:	60f8      	str	r0, [r7, #12]
3400dabc:	60b9      	str	r1, [r7, #8]
3400dabe:	607a      	str	r2, [r7, #4]
3400dac0:	603b      	str	r3, [r7, #0]
	event->callback = callback;
3400dac2:	68fb      	ldr	r3, [r7, #12]
3400dac4:	687a      	ldr	r2, [r7, #4]
3400dac6:	60da      	str	r2, [r3, #12]
	event->arg = arg;
3400dac8:	68fb      	ldr	r3, [r7, #12]
3400daca:	683a      	ldr	r2, [r7, #0]
3400dacc:	611a      	str	r2, [r3, #16]

	if ( tmout == TMO_FEVR ) {
3400dace:	68bb      	ldr	r3, [r7, #8]
3400dad0:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
3400dad4:	d104      	bne.n	3400dae0 <knl_timer_insert+0x2c>
		QueInit(&event->queue);
3400dad6:	68fb      	ldr	r3, [r7, #12]
3400dad8:	4618      	mov	r0, r3
3400dada:	f7ff fedb 	bl	3400d894 <QueInit>
		/* To guarantee longer wait time specified by 'tmout',
		   add TIMER_PERIOD on wait time */
		event->time = lltoul(knl_current_time) + tmout + TIMER_PERIOD;
		knl_enqueue_tmeb(event);
	}
}
3400dade:	e00b      	b.n	3400daf8 <knl_timer_insert+0x44>
		event->time = lltoul(knl_current_time) + tmout + TIMER_PERIOD;
3400dae0:	4b07      	ldr	r3, [pc, #28]	@ (3400db00 <knl_timer_insert+0x4c>)
3400dae2:	e9d3 2300 	ldrd	r2, r3, [r3]
3400dae6:	68bb      	ldr	r3, [r7, #8]
3400dae8:	4413      	add	r3, r2
3400daea:	f103 020a 	add.w	r2, r3, #10
3400daee:	68fb      	ldr	r3, [r7, #12]
3400daf0:	609a      	str	r2, [r3, #8]
		knl_enqueue_tmeb(event);
3400daf2:	68f8      	ldr	r0, [r7, #12]
3400daf4:	f7ff ffae 	bl	3400da54 <knl_enqueue_tmeb>
}
3400daf8:	bf00      	nop
3400dafa:	3710      	adds	r7, #16
3400dafc:	46bd      	mov	sp, r7
3400dafe:	bd80      	pop	{r7, pc}
3400db00:	340137f0 	.word	0x340137f0

3400db04 <knl_timer_insert_reltim>:

EXPORT void knl_timer_insert_reltim( TMEB *event, RELTIM tmout, CBACK callback, void *arg )
{
3400db04:	b580      	push	{r7, lr}
3400db06:	b084      	sub	sp, #16
3400db08:	af00      	add	r7, sp, #0
3400db0a:	60f8      	str	r0, [r7, #12]
3400db0c:	60b9      	str	r1, [r7, #8]
3400db0e:	607a      	str	r2, [r7, #4]
3400db10:	603b      	str	r3, [r7, #0]
	event->callback = callback;
3400db12:	68fb      	ldr	r3, [r7, #12]
3400db14:	687a      	ldr	r2, [r7, #4]
3400db16:	60da      	str	r2, [r3, #12]
	event->arg = arg;
3400db18:	68fb      	ldr	r3, [r7, #12]
3400db1a:	683a      	ldr	r2, [r7, #0]
3400db1c:	611a      	str	r2, [r3, #16]

	/* To guarantee longer wait time specified by 'tmout',
	   add TIMER_PERIOD on wait time */
	event->time = lltoul(knl_current_time) + tmout + TIMER_PERIOD;
3400db1e:	4b08      	ldr	r3, [pc, #32]	@ (3400db40 <knl_timer_insert_reltim+0x3c>)
3400db20:	e9d3 2300 	ldrd	r2, r3, [r3]
3400db24:	68bb      	ldr	r3, [r7, #8]
3400db26:	4413      	add	r3, r2
3400db28:	f103 020a 	add.w	r2, r3, #10
3400db2c:	68fb      	ldr	r3, [r7, #12]
3400db2e:	609a      	str	r2, [r3, #8]
	knl_enqueue_tmeb(event);
3400db30:	68f8      	ldr	r0, [r7, #12]
3400db32:	f7ff ff8f 	bl	3400da54 <knl_enqueue_tmeb>
}
3400db36:	bf00      	nop
3400db38:	3710      	adds	r7, #16
3400db3a:	46bd      	mov	sp, r7
3400db3c:	bd80      	pop	{r7, pc}
3400db3e:	bf00      	nop
3400db40:	340137f0 	.word	0x340137f0

3400db44 <knl_timer_handler>:
 *	interval by hardware timer. Update the software clock and start the 
 *	timer event upon arriving at start time.
 */

EXPORT void knl_timer_handler( void )
{
3400db44:	b5b0      	push	{r4, r5, r7, lr}
3400db46:	b084      	sub	sp, #16
3400db48:	af00      	add	r7, sp, #0
	TMEB	*event;
	ABSTIM	cur;

	knl_clear_hw_timer_interrupt();		/* Clear timer interrupt */
3400db4a:	f7ff ff3d 	bl	3400d9c8 <knl_clear_hw_timer_interrupt>

	BEGIN_CRITICAL_SECTION;
3400db4e:	f002 f858 	bl	3400fc02 <disint>
3400db52:	60f8      	str	r0, [r7, #12]
	knl_current_time = ll_add(knl_current_time, uitoll(TIMER_PERIOD));
3400db54:	4b24      	ldr	r3, [pc, #144]	@ (3400dbe8 <knl_timer_handler+0xa4>)
3400db56:	e9d3 2300 	ldrd	r2, r3, [r3]
3400db5a:	f112 040a 	adds.w	r4, r2, #10
3400db5e:	f143 0500 	adc.w	r5, r3, #0
3400db62:	4b21      	ldr	r3, [pc, #132]	@ (3400dbe8 <knl_timer_handler+0xa4>)
3400db64:	e9c3 4500 	strd	r4, r5, [r3]
	cur = lltoul(knl_current_time);
3400db68:	4b1f      	ldr	r3, [pc, #124]	@ (3400dbe8 <knl_timer_handler+0xa4>)
3400db6a:	e9d3 2300 	ldrd	r2, r3, [r3]
3400db6e:	4613      	mov	r3, r2
3400db70:	60bb      	str	r3, [r7, #8]
		}
	}
#endif

	/* Execute event that passed occurring time. */
	while ( !isQueEmpty(&knl_timer_queue) ) {
3400db72:	e019      	b.n	3400dba8 <knl_timer_handler+0x64>
		event = (TMEB*)knl_timer_queue.next;
3400db74:	4b1d      	ldr	r3, [pc, #116]	@ (3400dbec <knl_timer_handler+0xa8>)
3400db76:	681b      	ldr	r3, [r3, #0]
3400db78:	607b      	str	r3, [r7, #4]

		if ( !knl_abstim_reached(cur, event->time) ) {
3400db7a:	687b      	ldr	r3, [r7, #4]
3400db7c:	689b      	ldr	r3, [r3, #8]
3400db7e:	4619      	mov	r1, r3
3400db80:	68b8      	ldr	r0, [r7, #8]
3400db82:	f7ff fedb 	bl	3400d93c <knl_abstim_reached>
3400db86:	4603      	mov	r3, r0
3400db88:	2b00      	cmp	r3, #0
3400db8a:	d014      	beq.n	3400dbb6 <knl_timer_handler+0x72>
			break;
		}

		QueRemove(&event->queue);
3400db8c:	687b      	ldr	r3, [r7, #4]
3400db8e:	4618      	mov	r0, r3
3400db90:	f7ff febb 	bl	3400d90a <QueRemove>
		if ( event->callback != NULL ) {
3400db94:	687b      	ldr	r3, [r7, #4]
3400db96:	68db      	ldr	r3, [r3, #12]
3400db98:	2b00      	cmp	r3, #0
3400db9a:	d005      	beq.n	3400dba8 <knl_timer_handler+0x64>
			(*event->callback)(event->arg);
3400db9c:	687b      	ldr	r3, [r7, #4]
3400db9e:	68db      	ldr	r3, [r3, #12]
3400dba0:	687a      	ldr	r2, [r7, #4]
3400dba2:	6912      	ldr	r2, [r2, #16]
3400dba4:	4610      	mov	r0, r2
3400dba6:	4798      	blx	r3
	while ( !isQueEmpty(&knl_timer_queue) ) {
3400dba8:	4810      	ldr	r0, [pc, #64]	@ (3400dbec <knl_timer_handler+0xa8>)
3400dbaa:	f7ff fe83 	bl	3400d8b4 <isQueEmpty>
3400dbae:	4603      	mov	r3, r0
3400dbb0:	2b00      	cmp	r3, #0
3400dbb2:	d0df      	beq.n	3400db74 <knl_timer_handler+0x30>
3400dbb4:	e000      	b.n	3400dbb8 <knl_timer_handler+0x74>
			break;
3400dbb6:	bf00      	nop
		}
	}

	END_CRITICAL_SECTION;
3400dbb8:	68fb      	ldr	r3, [r7, #12]
3400dbba:	2b00      	cmp	r3, #0
3400dbbc:	d10b      	bne.n	3400dbd6 <knl_timer_handler+0x92>
3400dbbe:	4b0c      	ldr	r3, [pc, #48]	@ (3400dbf0 <knl_timer_handler+0xac>)
3400dbc0:	681a      	ldr	r2, [r3, #0]
3400dbc2:	4b0c      	ldr	r3, [pc, #48]	@ (3400dbf4 <knl_timer_handler+0xb0>)
3400dbc4:	681b      	ldr	r3, [r3, #0]
3400dbc6:	429a      	cmp	r2, r3
3400dbc8:	d005      	beq.n	3400dbd6 <knl_timer_handler+0x92>
3400dbca:	4b0b      	ldr	r3, [pc, #44]	@ (3400dbf8 <knl_timer_handler+0xb4>)
3400dbcc:	681b      	ldr	r3, [r3, #0]
3400dbce:	2b00      	cmp	r3, #0
3400dbd0:	d101      	bne.n	3400dbd6 <knl_timer_handler+0x92>
3400dbd2:	f001 f8d7 	bl	3400ed84 <knl_dispatch>
3400dbd6:	68f8      	ldr	r0, [r7, #12]
3400dbd8:	f001 fff7 	bl	3400fbca <set_basepri>

	knl_end_of_hw_timer_interrupt();		/* Clear timer interrupt */
3400dbdc:	f7ff ff04 	bl	3400d9e8 <knl_end_of_hw_timer_interrupt>
}
3400dbe0:	bf00      	nop
3400dbe2:	3710      	adds	r7, #16
3400dbe4:	46bd      	mov	sp, r7
3400dbe6:	bdb0      	pop	{r4, r5, r7, pc}
3400dbe8:	340137f0 	.word	0x340137f0
3400dbec:	34013800 	.word	0x34013800
3400dbf0:	34012800 	.word	0x34012800
3400dbf4:	34012804 	.word	0x34012804
3400dbf8:	340127fc 	.word	0x340127fc

3400dbfc <knl_init_object>:

/*
 * Each kernel-object initialization
 */
EXPORT ER knl_init_object( void)
{	
3400dbfc:	b580      	push	{r7, lr}
3400dbfe:	b082      	sub	sp, #8
3400dc00:	af00      	add	r7, sp, #0
	ER	ercd;

	ercd = knl_task_initialize();
3400dc02:	f7ff faa7 	bl	3400d154 <knl_task_initialize>
3400dc06:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400dc08:	687b      	ldr	r3, [r7, #4]
3400dc0a:	2b00      	cmp	r3, #0
3400dc0c:	da01      	bge.n	3400dc12 <knl_init_object+0x16>
3400dc0e:	687b      	ldr	r3, [r7, #4]
3400dc10:	e048      	b.n	3400dca4 <knl_init_object+0xa8>

#if USE_SEMAPHORE
	ercd = knl_semaphore_initialize();
3400dc12:	f7fe fec1 	bl	3400c998 <knl_semaphore_initialize>
3400dc16:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400dc18:	687b      	ldr	r3, [r7, #4]
3400dc1a:	2b00      	cmp	r3, #0
3400dc1c:	da01      	bge.n	3400dc22 <knl_init_object+0x26>
3400dc1e:	687b      	ldr	r3, [r7, #4]
3400dc20:	e040      	b.n	3400dca4 <knl_init_object+0xa8>
#endif
#if USE_EVENTFLAG
	ercd = knl_eventflag_initialize();
3400dc22:	f7fd ffc7 	bl	3400bbb4 <knl_eventflag_initialize>
3400dc26:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400dc28:	687b      	ldr	r3, [r7, #4]
3400dc2a:	2b00      	cmp	r3, #0
3400dc2c:	da01      	bge.n	3400dc32 <knl_init_object+0x36>
3400dc2e:	687b      	ldr	r3, [r7, #4]
3400dc30:	e038      	b.n	3400dca4 <knl_init_object+0xa8>
#endif
#if USE_MAILBOX
	ercd = knl_mailbox_initialize();
3400dc32:	f7fe fa71 	bl	3400c118 <knl_mailbox_initialize>
3400dc36:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400dc38:	687b      	ldr	r3, [r7, #4]
3400dc3a:	2b00      	cmp	r3, #0
3400dc3c:	da01      	bge.n	3400dc42 <knl_init_object+0x46>
3400dc3e:	687b      	ldr	r3, [r7, #4]
3400dc40:	e030      	b.n	3400dca4 <knl_init_object+0xa8>
#endif
#if USE_MESSAGEBUFFER
	ercd = knl_messagebuffer_initialize();
3400dc42:	f7fe fddd 	bl	3400c800 <knl_messagebuffer_initialize>
3400dc46:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400dc48:	687b      	ldr	r3, [r7, #4]
3400dc4a:	2b00      	cmp	r3, #0
3400dc4c:	da01      	bge.n	3400dc52 <knl_init_object+0x56>
3400dc4e:	687b      	ldr	r3, [r7, #4]
3400dc50:	e028      	b.n	3400dca4 <knl_init_object+0xa8>
#if USE_LEGACY_API && USE_RENDEZVOUS
	ercd = knl_rendezvous_initialize();
	if(ercd < E_OK) return ercd;
#endif
#if USE_MUTEX
	ercd = knl_mutex_initialize();
3400dc52:	f7fe fe25 	bl	3400c8a0 <knl_mutex_initialize>
3400dc56:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400dc58:	687b      	ldr	r3, [r7, #4]
3400dc5a:	2b00      	cmp	r3, #0
3400dc5c:	da01      	bge.n	3400dc62 <knl_init_object+0x66>
3400dc5e:	687b      	ldr	r3, [r7, #4]
3400dc60:	e020      	b.n	3400dca4 <knl_init_object+0xa8>
#endif
#if USE_MEMORYPOOL
	ercd = knl_memorypool_initialize();
3400dc62:	f7fe fd7d 	bl	3400c760 <knl_memorypool_initialize>
3400dc66:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400dc68:	687b      	ldr	r3, [r7, #4]
3400dc6a:	2b00      	cmp	r3, #0
3400dc6c:	da01      	bge.n	3400dc72 <knl_init_object+0x76>
3400dc6e:	687b      	ldr	r3, [r7, #4]
3400dc70:	e018      	b.n	3400dca4 <knl_init_object+0xa8>
#endif
#if USE_FIX_MEMORYPOOL
	ercd = knl_fix_memorypool_initialize();
3400dc72:	f7fe fd21 	bl	3400c6b8 <knl_fix_memorypool_initialize>
3400dc76:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400dc78:	687b      	ldr	r3, [r7, #4]
3400dc7a:	2b00      	cmp	r3, #0
3400dc7c:	da01      	bge.n	3400dc82 <knl_init_object+0x86>
3400dc7e:	687b      	ldr	r3, [r7, #4]
3400dc80:	e010      	b.n	3400dca4 <knl_init_object+0xa8>
#endif
#if USE_CYCLICHANDLER
	ercd = knl_cyclichandler_initialize();
3400dc82:	f7ff fda5 	bl	3400d7d0 <knl_cyclichandler_initialize>
3400dc86:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400dc88:	687b      	ldr	r3, [r7, #4]
3400dc8a:	2b00      	cmp	r3, #0
3400dc8c:	da01      	bge.n	3400dc92 <knl_init_object+0x96>
3400dc8e:	687b      	ldr	r3, [r7, #4]
3400dc90:	e008      	b.n	3400dca4 <knl_init_object+0xa8>
#endif
#if USE_ALARMHANDLER
	ercd = knl_alarmhandler_initialize();
3400dc92:	f7ff fdc1 	bl	3400d818 <knl_alarmhandler_initialize>
3400dc96:	6078      	str	r0, [r7, #4]
	if(ercd < E_OK) return ercd;
3400dc98:	687b      	ldr	r3, [r7, #4]
3400dc9a:	2b00      	cmp	r3, #0
3400dc9c:	da01      	bge.n	3400dca2 <knl_init_object+0xa6>
3400dc9e:	687b      	ldr	r3, [r7, #4]
3400dca0:	e000      	b.n	3400dca4 <knl_init_object+0xa8>
#endif

	return E_OK;
3400dca2:	2300      	movs	r3, #0
}
3400dca4:	4618      	mov	r0, r3
3400dca6:	3708      	adds	r7, #8
3400dca8:	46bd      	mov	sp, r7
3400dcaa:	bd80      	pop	{r7, pc}

3400dcac <isQueEmpty>:
{
3400dcac:	b480      	push	{r7}
3400dcae:	b083      	sub	sp, #12
3400dcb0:	af00      	add	r7, sp, #0
3400dcb2:	6078      	str	r0, [r7, #4]
	return ( que->next == que )? TRUE: FALSE;
3400dcb4:	687b      	ldr	r3, [r7, #4]
3400dcb6:	681b      	ldr	r3, [r3, #0]
3400dcb8:	687a      	ldr	r2, [r7, #4]
3400dcba:	429a      	cmp	r2, r3
3400dcbc:	bf0c      	ite	eq
3400dcbe:	2301      	moveq	r3, #1
3400dcc0:	2300      	movne	r3, #0
3400dcc2:	b2db      	uxtb	r3, r3
}
3400dcc4:	4618      	mov	r0, r3
3400dcc6:	370c      	adds	r7, #12
3400dcc8:	46bd      	mov	sp, r7
3400dcca:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dcce:	4770      	bx	lr

3400dcd0 <QueInsert>:
{
3400dcd0:	b480      	push	{r7}
3400dcd2:	b083      	sub	sp, #12
3400dcd4:	af00      	add	r7, sp, #0
3400dcd6:	6078      	str	r0, [r7, #4]
3400dcd8:	6039      	str	r1, [r7, #0]
	entry->prev = (struct queue*) que->prev;
3400dcda:	683b      	ldr	r3, [r7, #0]
3400dcdc:	685a      	ldr	r2, [r3, #4]
3400dcde:	687b      	ldr	r3, [r7, #4]
3400dce0:	605a      	str	r2, [r3, #4]
	entry->next = que;
3400dce2:	687b      	ldr	r3, [r7, #4]
3400dce4:	683a      	ldr	r2, [r7, #0]
3400dce6:	601a      	str	r2, [r3, #0]
	que->prev->next = entry;
3400dce8:	683b      	ldr	r3, [r7, #0]
3400dcea:	685b      	ldr	r3, [r3, #4]
3400dcec:	687a      	ldr	r2, [r7, #4]
3400dcee:	601a      	str	r2, [r3, #0]
	que->prev = entry;
3400dcf0:	683b      	ldr	r3, [r7, #0]
3400dcf2:	687a      	ldr	r2, [r7, #4]
3400dcf4:	605a      	str	r2, [r3, #4]
}
3400dcf6:	bf00      	nop
3400dcf8:	370c      	adds	r7, #12
3400dcfa:	46bd      	mov	sp, r7
3400dcfc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dd00:	4770      	bx	lr

3400dd02 <QueRemove>:
{
3400dd02:	b480      	push	{r7}
3400dd04:	b083      	sub	sp, #12
3400dd06:	af00      	add	r7, sp, #0
3400dd08:	6078      	str	r0, [r7, #4]
	if ( entry->next != entry ) {
3400dd0a:	687b      	ldr	r3, [r7, #4]
3400dd0c:	681b      	ldr	r3, [r3, #0]
3400dd0e:	687a      	ldr	r2, [r7, #4]
3400dd10:	429a      	cmp	r2, r3
3400dd12:	d009      	beq.n	3400dd28 <QueRemove+0x26>
		entry->prev->next = (struct queue*) entry->next;
3400dd14:	687b      	ldr	r3, [r7, #4]
3400dd16:	685b      	ldr	r3, [r3, #4]
3400dd18:	687a      	ldr	r2, [r7, #4]
3400dd1a:	6812      	ldr	r2, [r2, #0]
3400dd1c:	601a      	str	r2, [r3, #0]
		entry->next->prev = (struct queue*) entry->prev;
3400dd1e:	687b      	ldr	r3, [r7, #4]
3400dd20:	681b      	ldr	r3, [r3, #0]
3400dd22:	687a      	ldr	r2, [r7, #4]
3400dd24:	6852      	ldr	r2, [r2, #4]
3400dd26:	605a      	str	r2, [r3, #4]
}
3400dd28:	bf00      	nop
3400dd2a:	370c      	adds	r7, #12
3400dd2c:	46bd      	mov	sp, r7
3400dd2e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400dd32:	4770      	bx	lr

3400dd34 <knl_timer_delete>:

/*
 * Delete from time-event queue
 */
Inline void knl_timer_delete( TMEB *event )
{
3400dd34:	b580      	push	{r7, lr}
3400dd36:	b082      	sub	sp, #8
3400dd38:	af00      	add	r7, sp, #0
3400dd3a:	6078      	str	r0, [r7, #4]
	QueRemove(&event->queue);
3400dd3c:	687b      	ldr	r3, [r7, #4]
3400dd3e:	4618      	mov	r0, r3
3400dd40:	f7ff ffdf 	bl	3400dd02 <QueRemove>
}
3400dd44:	bf00      	nop
3400dd46:	3708      	adds	r7, #8
3400dd48:	46bd      	mov	sp, r7
3400dd4a:	bd80      	pop	{r7, pc}

3400dd4c <knl_queue_insert_tpri>:

/*
 * Connect the task to the prioritized wait queue.
 */
Inline void knl_queue_insert_tpri( TCB *tcb, QUEUE *queue )
{
3400dd4c:	b580      	push	{r7, lr}
3400dd4e:	b088      	sub	sp, #32
3400dd50:	af00      	add	r7, sp, #0
3400dd52:	6078      	str	r0, [r7, #4]
3400dd54:	6039      	str	r1, [r7, #0]
	QUEUE *q;
	QUEUE *start, *end;
	UB val;
	W offset;

	start = end = queue;
3400dd56:	683b      	ldr	r3, [r7, #0]
3400dd58:	61bb      	str	r3, [r7, #24]
3400dd5a:	69bb      	ldr	r3, [r7, #24]
3400dd5c:	617b      	str	r3, [r7, #20]
	val = tcb->priority;
3400dd5e:	687b      	ldr	r3, [r7, #4]
3400dd60:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
3400dd64:	74fb      	strb	r3, [r7, #19]
	offset = offsetof(TCB, priority);
3400dd66:	2326      	movs	r3, #38	@ 0x26
3400dd68:	60fb      	str	r3, [r7, #12]

	for ( q = start->next; q != end; q = q->next ) {
3400dd6a:	697b      	ldr	r3, [r7, #20]
3400dd6c:	681b      	ldr	r3, [r3, #0]
3400dd6e:	61fb      	str	r3, [r7, #28]
3400dd70:	e009      	b.n	3400dd86 <knl_queue_insert_tpri+0x3a>
		if ( *(UB*)((VB*)q + offset) > val ) {
3400dd72:	68fb      	ldr	r3, [r7, #12]
3400dd74:	69fa      	ldr	r2, [r7, #28]
3400dd76:	4413      	add	r3, r2
3400dd78:	781b      	ldrb	r3, [r3, #0]
3400dd7a:	7cfa      	ldrb	r2, [r7, #19]
3400dd7c:	429a      	cmp	r2, r3
3400dd7e:	d307      	bcc.n	3400dd90 <knl_queue_insert_tpri+0x44>
	for ( q = start->next; q != end; q = q->next ) {
3400dd80:	69fb      	ldr	r3, [r7, #28]
3400dd82:	681b      	ldr	r3, [r3, #0]
3400dd84:	61fb      	str	r3, [r7, #28]
3400dd86:	69fa      	ldr	r2, [r7, #28]
3400dd88:	69bb      	ldr	r3, [r7, #24]
3400dd8a:	429a      	cmp	r2, r3
3400dd8c:	d1f1      	bne.n	3400dd72 <knl_queue_insert_tpri+0x26>
3400dd8e:	e000      	b.n	3400dd92 <knl_queue_insert_tpri+0x46>
			break;
3400dd90:	bf00      	nop
		}
	}

	QueInsert(&tcb->tskque, q);
3400dd92:	687b      	ldr	r3, [r7, #4]
3400dd94:	69f9      	ldr	r1, [r7, #28]
3400dd96:	4618      	mov	r0, r3
3400dd98:	f7ff ff9a 	bl	3400dcd0 <QueInsert>
}
3400dd9c:	bf00      	nop
3400dd9e:	3720      	adds	r7, #32
3400dda0:	46bd      	mov	sp, r7
3400dda2:	bd80      	pop	{r7, pc}

3400dda4 <knl_make_non_wait>:
 * Update the task state to release wait. When it becomes ready state,
 * connect to the ready queue.
 * Call when the task is in the wait state (including double wait).
 */
Inline void knl_make_non_wait( TCB *tcb )
{
3400dda4:	b580      	push	{r7, lr}
3400dda6:	b082      	sub	sp, #8
3400dda8:	af00      	add	r7, sp, #0
3400ddaa:	6078      	str	r0, [r7, #4]
	if ( tcb->state == TS_WAIT ) {
3400ddac:	687b      	ldr	r3, [r7, #4]
3400ddae:	f893 3027 	ldrb.w	r3, [r3, #39]	@ 0x27
3400ddb2:	2b02      	cmp	r3, #2
3400ddb4:	d103      	bne.n	3400ddbe <knl_make_non_wait+0x1a>
		knl_make_ready(tcb);
3400ddb6:	6878      	ldr	r0, [r7, #4]
3400ddb8:	f7ff fa4a 	bl	3400d250 <knl_make_ready>
	} else {
		tcb->state = TS_SUSPEND;
	}
}
3400ddbc:	e003      	b.n	3400ddc6 <knl_make_non_wait+0x22>
		tcb->state = TS_SUSPEND;
3400ddbe:	687b      	ldr	r3, [r7, #4]
3400ddc0:	2204      	movs	r2, #4
3400ddc2:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
}
3400ddc6:	bf00      	nop
3400ddc8:	3708      	adds	r7, #8
3400ddca:	46bd      	mov	sp, r7
3400ddcc:	bd80      	pop	{r7, pc}

3400ddce <knl_wait_release>:

/*
 * Release wait state of the task.
 */
Inline void knl_wait_release( TCB *tcb )
{
3400ddce:	b580      	push	{r7, lr}
3400ddd0:	b082      	sub	sp, #8
3400ddd2:	af00      	add	r7, sp, #0
3400ddd4:	6078      	str	r0, [r7, #4]
	knl_timer_delete(&tcb->wtmeb);
3400ddd6:	687b      	ldr	r3, [r7, #4]
3400ddd8:	334c      	adds	r3, #76	@ 0x4c
3400ddda:	4618      	mov	r0, r3
3400dddc:	f7ff ffaa 	bl	3400dd34 <knl_timer_delete>
	QueRemove(&tcb->tskque);
3400dde0:	687b      	ldr	r3, [r7, #4]
3400dde2:	4618      	mov	r0, r3
3400dde4:	f7ff ff8d 	bl	3400dd02 <QueRemove>
	knl_make_non_wait(tcb);
3400dde8:	6878      	ldr	r0, [r7, #4]
3400ddea:	f7ff ffdb 	bl	3400dda4 <knl_make_non_wait>
}
3400ddee:	bf00      	nop
3400ddf0:	3708      	adds	r7, #8
3400ddf2:	46bd      	mov	sp, r7
3400ddf4:	bd80      	pop	{r7, pc}

3400ddf6 <knl_wait_release_ok>:

#include "kernel.h"
#include "wait.h"

EXPORT void knl_wait_release_ok( TCB *tcb )
{
3400ddf6:	b580      	push	{r7, lr}
3400ddf8:	b082      	sub	sp, #8
3400ddfa:	af00      	add	r7, sp, #0
3400ddfc:	6078      	str	r0, [r7, #4]
	knl_wait_release(tcb);
3400ddfe:	6878      	ldr	r0, [r7, #4]
3400de00:	f7ff ffe5 	bl	3400ddce <knl_wait_release>
	*tcb->wercd = E_OK;
3400de04:	687b      	ldr	r3, [r7, #4]
3400de06:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400de08:	2200      	movs	r2, #0
3400de0a:	601a      	str	r2, [r3, #0]
}
3400de0c:	bf00      	nop
3400de0e:	3708      	adds	r7, #8
3400de10:	46bd      	mov	sp, r7
3400de12:	bd80      	pop	{r7, pc}

3400de14 <knl_wait_release_tmout>:
	}
	*tcb->wercd = ercd;
}

EXPORT void knl_wait_release_tmout( TCB *tcb )
{
3400de14:	b580      	push	{r7, lr}
3400de16:	b082      	sub	sp, #8
3400de18:	af00      	add	r7, sp, #0
3400de1a:	6078      	str	r0, [r7, #4]
	QueRemove(&tcb->tskque);
3400de1c:	687b      	ldr	r3, [r7, #4]
3400de1e:	4618      	mov	r0, r3
3400de20:	f7ff ff6f 	bl	3400dd02 <QueRemove>
	knl_make_non_wait(tcb);
3400de24:	6878      	ldr	r0, [r7, #4]
3400de26:	f7ff ffbd 	bl	3400dda4 <knl_make_non_wait>
	if ( tcb->wspec->rel_wai_hook != NULL ) {
3400de2a:	687b      	ldr	r3, [r7, #4]
3400de2c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400de2e:	689b      	ldr	r3, [r3, #8]
3400de30:	2b00      	cmp	r3, #0
3400de32:	d004      	beq.n	3400de3e <knl_wait_release_tmout+0x2a>
		(*tcb->wspec->rel_wai_hook)(tcb);
3400de34:	687b      	ldr	r3, [r7, #4]
3400de36:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
3400de38:	689b      	ldr	r3, [r3, #8]
3400de3a:	6878      	ldr	r0, [r7, #4]
3400de3c:	4798      	blx	r3
	}
}
3400de3e:	bf00      	nop
3400de40:	3708      	adds	r7, #8
3400de42:	46bd      	mov	sp, r7
3400de44:	bd80      	pop	{r7, pc}
	...

3400de48 <knl_make_wait>:
 *	typedef	W		TMO;
 *	typedef UW		RELTIM;
 *	#define TMO_FEVR	(-1)
 */
EXPORT void knl_make_wait( TMO tmout, ATR atr )
{
3400de48:	b580      	push	{r7, lr}
3400de4a:	b082      	sub	sp, #8
3400de4c:	af00      	add	r7, sp, #0
3400de4e:	6078      	str	r0, [r7, #4]
3400de50:	6039      	str	r1, [r7, #0]
	switch ( knl_ctxtsk->state ) {
3400de52:	4b14      	ldr	r3, [pc, #80]	@ (3400dea4 <knl_make_wait+0x5c>)
3400de54:	681b      	ldr	r3, [r3, #0]
3400de56:	f893 3027 	ldrb.w	r3, [r3, #39]	@ 0x27
3400de5a:	2b01      	cmp	r3, #1
3400de5c:	d002      	beq.n	3400de64 <knl_make_wait+0x1c>
3400de5e:	2b04      	cmp	r3, #4
3400de60:	d00b      	beq.n	3400de7a <knl_make_wait+0x32>
3400de62:	e010      	b.n	3400de86 <knl_make_wait+0x3e>
	  case TS_READY:
		knl_make_non_ready(knl_ctxtsk);
3400de64:	4b0f      	ldr	r3, [pc, #60]	@ (3400dea4 <knl_make_wait+0x5c>)
3400de66:	681b      	ldr	r3, [r3, #0]
3400de68:	4618      	mov	r0, r3
3400de6a:	f7ff fa0b 	bl	3400d284 <knl_make_non_ready>
		knl_ctxtsk->state = TS_WAIT;
3400de6e:	4b0d      	ldr	r3, [pc, #52]	@ (3400dea4 <knl_make_wait+0x5c>)
3400de70:	681b      	ldr	r3, [r3, #0]
3400de72:	2202      	movs	r2, #2
3400de74:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
		break;
3400de78:	e005      	b.n	3400de86 <knl_make_wait+0x3e>
	  case TS_SUSPEND:
		knl_ctxtsk->state = TS_WAITSUS;
3400de7a:	4b0a      	ldr	r3, [pc, #40]	@ (3400dea4 <knl_make_wait+0x5c>)
3400de7c:	681b      	ldr	r3, [r3, #0]
3400de7e:	2206      	movs	r2, #6
3400de80:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
		break;
3400de84:	bf00      	nop
	}
	knl_timer_insert(&knl_ctxtsk->wtmeb, tmout, (CBACK)knl_wait_release_tmout, knl_ctxtsk);
3400de86:	4b07      	ldr	r3, [pc, #28]	@ (3400dea4 <knl_make_wait+0x5c>)
3400de88:	681b      	ldr	r3, [r3, #0]
3400de8a:	f103 004c 	add.w	r0, r3, #76	@ 0x4c
3400de8e:	4b05      	ldr	r3, [pc, #20]	@ (3400dea4 <knl_make_wait+0x5c>)
3400de90:	681b      	ldr	r3, [r3, #0]
3400de92:	4a05      	ldr	r2, [pc, #20]	@ (3400dea8 <knl_make_wait+0x60>)
3400de94:	6879      	ldr	r1, [r7, #4]
3400de96:	f7ff fe0d 	bl	3400dab4 <knl_timer_insert>
}
3400de9a:	bf00      	nop
3400de9c:	3708      	adds	r7, #8
3400de9e:	46bd      	mov	sp, r7
3400dea0:	bd80      	pop	{r7, pc}
3400dea2:	bf00      	nop
3400dea4:	34012800 	.word	0x34012800
3400dea8:	3400de15 	.word	0x3400de15

3400deac <knl_make_wait_reltim>:

EXPORT void knl_make_wait_reltim( RELTIM tmout, ATR atr )
{
3400deac:	b580      	push	{r7, lr}
3400deae:	b082      	sub	sp, #8
3400deb0:	af00      	add	r7, sp, #0
3400deb2:	6078      	str	r0, [r7, #4]
3400deb4:	6039      	str	r1, [r7, #0]
	switch ( knl_ctxtsk->state ) {
3400deb6:	4b14      	ldr	r3, [pc, #80]	@ (3400df08 <knl_make_wait_reltim+0x5c>)
3400deb8:	681b      	ldr	r3, [r3, #0]
3400deba:	f893 3027 	ldrb.w	r3, [r3, #39]	@ 0x27
3400debe:	2b01      	cmp	r3, #1
3400dec0:	d002      	beq.n	3400dec8 <knl_make_wait_reltim+0x1c>
3400dec2:	2b04      	cmp	r3, #4
3400dec4:	d00b      	beq.n	3400dede <knl_make_wait_reltim+0x32>
3400dec6:	e010      	b.n	3400deea <knl_make_wait_reltim+0x3e>
	  case TS_READY:
		knl_make_non_ready(knl_ctxtsk);
3400dec8:	4b0f      	ldr	r3, [pc, #60]	@ (3400df08 <knl_make_wait_reltim+0x5c>)
3400deca:	681b      	ldr	r3, [r3, #0]
3400decc:	4618      	mov	r0, r3
3400dece:	f7ff f9d9 	bl	3400d284 <knl_make_non_ready>
		knl_ctxtsk->state = TS_WAIT;
3400ded2:	4b0d      	ldr	r3, [pc, #52]	@ (3400df08 <knl_make_wait_reltim+0x5c>)
3400ded4:	681b      	ldr	r3, [r3, #0]
3400ded6:	2202      	movs	r2, #2
3400ded8:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
		break;
3400dedc:	e005      	b.n	3400deea <knl_make_wait_reltim+0x3e>
	  case TS_SUSPEND:
		knl_ctxtsk->state = TS_WAITSUS;
3400dede:	4b0a      	ldr	r3, [pc, #40]	@ (3400df08 <knl_make_wait_reltim+0x5c>)
3400dee0:	681b      	ldr	r3, [r3, #0]
3400dee2:	2206      	movs	r2, #6
3400dee4:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
		break;
3400dee8:	bf00      	nop
	}
	knl_timer_insert_reltim(&knl_ctxtsk->wtmeb, tmout, (CBACK)knl_wait_release_tmout, knl_ctxtsk);
3400deea:	4b07      	ldr	r3, [pc, #28]	@ (3400df08 <knl_make_wait_reltim+0x5c>)
3400deec:	681b      	ldr	r3, [r3, #0]
3400deee:	f103 004c 	add.w	r0, r3, #76	@ 0x4c
3400def2:	4b05      	ldr	r3, [pc, #20]	@ (3400df08 <knl_make_wait_reltim+0x5c>)
3400def4:	681b      	ldr	r3, [r3, #0]
3400def6:	4a05      	ldr	r2, [pc, #20]	@ (3400df0c <knl_make_wait_reltim+0x60>)
3400def8:	6879      	ldr	r1, [r7, #4]
3400defa:	f7ff fe03 	bl	3400db04 <knl_timer_insert_reltim>
}
3400defe:	bf00      	nop
3400df00:	3708      	adds	r7, #8
3400df02:	46bd      	mov	sp, r7
3400df04:	bd80      	pop	{r7, pc}
3400df06:	bf00      	nop
3400df08:	34012800 	.word	0x34012800
3400df0c:	3400de15 	.word	0x3400de15

3400df10 <knl_wait_delete>:
/*
 * Release all tasks connected to the wait queue, and define it
 * as E_DLT error.
 */
EXPORT void knl_wait_delete( QUEUE *wait_queue )
{
3400df10:	b580      	push	{r7, lr}
3400df12:	b084      	sub	sp, #16
3400df14:	af00      	add	r7, sp, #0
3400df16:	6078      	str	r0, [r7, #4]
	TCB	*tcb;

	while ( !isQueEmpty(wait_queue) ) {
3400df18:	e00a      	b.n	3400df30 <knl_wait_delete+0x20>
		tcb = (TCB*)wait_queue->next;
3400df1a:	687b      	ldr	r3, [r7, #4]
3400df1c:	681b      	ldr	r3, [r3, #0]
3400df1e:	60fb      	str	r3, [r7, #12]
		knl_wait_release(tcb);
3400df20:	68f8      	ldr	r0, [r7, #12]
3400df22:	f7ff ff54 	bl	3400ddce <knl_wait_release>
		*tcb->wercd = E_DLT;
3400df26:	68fb      	ldr	r3, [r7, #12]
3400df28:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400df2a:	f06f 0232 	mvn.w	r2, #50	@ 0x32
3400df2e:	601a      	str	r2, [r3, #0]
	while ( !isQueEmpty(wait_queue) ) {
3400df30:	6878      	ldr	r0, [r7, #4]
3400df32:	f7ff febb 	bl	3400dcac <isQueEmpty>
3400df36:	4603      	mov	r3, r0
3400df38:	2b00      	cmp	r3, #0
3400df3a:	d0ee      	beq.n	3400df1a <knl_wait_delete+0xa>
	}
}
3400df3c:	bf00      	nop
3400df3e:	bf00      	nop
3400df40:	3710      	adds	r7, #16
3400df42:	46bd      	mov	sp, r7
3400df44:	bd80      	pop	{r7, pc}
	...

3400df48 <knl_gcb_make_wait>:
/*
 * Change the active task state to wait state and connect to the timer wait 
 * queue and the object wait queue. Also set 'wid' in 'knl_ctxtsk'.
 */
EXPORT void knl_gcb_make_wait( GCB *gcb, TMO tmout )
{
3400df48:	b580      	push	{r7, lr}
3400df4a:	b082      	sub	sp, #8
3400df4c:	af00      	add	r7, sp, #0
3400df4e:	6078      	str	r0, [r7, #4]
3400df50:	6039      	str	r1, [r7, #0]
	*knl_ctxtsk->wercd = E_TMOUT;
3400df52:	4b17      	ldr	r3, [pc, #92]	@ (3400dfb0 <knl_gcb_make_wait+0x68>)
3400df54:	681b      	ldr	r3, [r3, #0]
3400df56:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
3400df58:	f06f 0231 	mvn.w	r2, #49	@ 0x31
3400df5c:	601a      	str	r2, [r3, #0]
	if ( tmout != TMO_POL ) {
3400df5e:	683b      	ldr	r3, [r7, #0]
3400df60:	2b00      	cmp	r3, #0
3400df62:	d020      	beq.n	3400dfa6 <knl_gcb_make_wait+0x5e>
		knl_ctxtsk->wid = gcb->objid;
3400df64:	4b12      	ldr	r3, [pc, #72]	@ (3400dfb0 <knl_gcb_make_wait+0x68>)
3400df66:	681b      	ldr	r3, [r3, #0]
3400df68:	687a      	ldr	r2, [r7, #4]
3400df6a:	6892      	ldr	r2, [r2, #8]
3400df6c:	631a      	str	r2, [r3, #48]	@ 0x30
		knl_make_wait(tmout, gcb->objatr);
3400df6e:	687b      	ldr	r3, [r7, #4]
3400df70:	691b      	ldr	r3, [r3, #16]
3400df72:	4619      	mov	r1, r3
3400df74:	6838      	ldr	r0, [r7, #0]
3400df76:	f7ff ff67 	bl	3400de48 <knl_make_wait>
		if ( (gcb->objatr & TA_TPRI) != 0 ) {
3400df7a:	687b      	ldr	r3, [r7, #4]
3400df7c:	691b      	ldr	r3, [r3, #16]
3400df7e:	f003 0301 	and.w	r3, r3, #1
3400df82:	2b00      	cmp	r3, #0
3400df84:	d007      	beq.n	3400df96 <knl_gcb_make_wait+0x4e>
			knl_queue_insert_tpri(knl_ctxtsk, &gcb->wait_queue);
3400df86:	4b0a      	ldr	r3, [pc, #40]	@ (3400dfb0 <knl_gcb_make_wait+0x68>)
3400df88:	681b      	ldr	r3, [r3, #0]
3400df8a:	687a      	ldr	r2, [r7, #4]
3400df8c:	4611      	mov	r1, r2
3400df8e:	4618      	mov	r0, r3
3400df90:	f7ff fedc 	bl	3400dd4c <knl_queue_insert_tpri>
		} else {
			QueInsert(&knl_ctxtsk->tskque, &gcb->wait_queue);
		}
	}
}
3400df94:	e007      	b.n	3400dfa6 <knl_gcb_make_wait+0x5e>
			QueInsert(&knl_ctxtsk->tskque, &gcb->wait_queue);
3400df96:	4b06      	ldr	r3, [pc, #24]	@ (3400dfb0 <knl_gcb_make_wait+0x68>)
3400df98:	681b      	ldr	r3, [r3, #0]
3400df9a:	461a      	mov	r2, r3
3400df9c:	687b      	ldr	r3, [r7, #4]
3400df9e:	4619      	mov	r1, r3
3400dfa0:	4610      	mov	r0, r2
3400dfa2:	f7ff fe95 	bl	3400dcd0 <QueInsert>
}
3400dfa6:	bf00      	nop
3400dfa8:	3708      	adds	r7, #8
3400dfaa:	46bd      	mov	sp, r7
3400dfac:	bd80      	pop	{r7, pc}
3400dfae:	bf00      	nop
3400dfb0:	34012800 	.word	0x34012800

3400dfb4 <knl_gcb_change_priority>:
 * When the task priority changes, adjust the task position at the wait queue.
 * It is called only if the object attribute TA_TPRI is specified.
 *
 */
EXPORT void knl_gcb_change_priority( GCB *gcb, TCB *tcb )
{
3400dfb4:	b580      	push	{r7, lr}
3400dfb6:	b082      	sub	sp, #8
3400dfb8:	af00      	add	r7, sp, #0
3400dfba:	6078      	str	r0, [r7, #4]
3400dfbc:	6039      	str	r1, [r7, #0]
	QueRemove(&tcb->tskque);
3400dfbe:	683b      	ldr	r3, [r7, #0]
3400dfc0:	4618      	mov	r0, r3
3400dfc2:	f7ff fe9e 	bl	3400dd02 <QueRemove>
	knl_queue_insert_tpri(tcb, &gcb->wait_queue);
3400dfc6:	687b      	ldr	r3, [r7, #4]
3400dfc8:	4619      	mov	r1, r3
3400dfca:	6838      	ldr	r0, [r7, #0]
3400dfcc:	f7ff febe 	bl	3400dd4c <knl_queue_insert_tpri>
}
3400dfd0:	bf00      	nop
3400dfd2:	3708      	adds	r7, #8
3400dfd4:	46bd      	mov	sp, r7
3400dfd6:	bd80      	pop	{r7, pc}

3400dfd8 <knl_gcb_top_of_wait_queue>:
 * Search the first task of wait queue include "tcb" with target.
 * (Not insert "tcb" into wait queue.)
 *
 */
EXPORT TCB* knl_gcb_top_of_wait_queue( GCB *gcb, TCB *tcb )
{
3400dfd8:	b580      	push	{r7, lr}
3400dfda:	b084      	sub	sp, #16
3400dfdc:	af00      	add	r7, sp, #0
3400dfde:	6078      	str	r0, [r7, #4]
3400dfe0:	6039      	str	r1, [r7, #0]
	TCB	*q;

	if ( isQueEmpty(&gcb->wait_queue) ) {
3400dfe2:	687b      	ldr	r3, [r7, #4]
3400dfe4:	4618      	mov	r0, r3
3400dfe6:	f7ff fe61 	bl	3400dcac <isQueEmpty>
3400dfea:	4603      	mov	r3, r0
3400dfec:	2b00      	cmp	r3, #0
3400dfee:	d001      	beq.n	3400dff4 <knl_gcb_top_of_wait_queue+0x1c>
		return tcb;
3400dff0:	683b      	ldr	r3, [r7, #0]
3400dff2:	e015      	b.n	3400e020 <knl_gcb_top_of_wait_queue+0x48>
	}

	q = (TCB*)gcb->wait_queue.next;
3400dff4:	687b      	ldr	r3, [r7, #4]
3400dff6:	681b      	ldr	r3, [r3, #0]
3400dff8:	60fb      	str	r3, [r7, #12]
	if ( (gcb->objatr & TA_TPRI) == 0 ) {
3400dffa:	687b      	ldr	r3, [r7, #4]
3400dffc:	691b      	ldr	r3, [r3, #16]
3400dffe:	f003 0301 	and.w	r3, r3, #1
3400e002:	2b00      	cmp	r3, #0
3400e004:	d101      	bne.n	3400e00a <knl_gcb_top_of_wait_queue+0x32>
		return q;
3400e006:	68fb      	ldr	r3, [r7, #12]
3400e008:	e00a      	b.n	3400e020 <knl_gcb_top_of_wait_queue+0x48>
	}

	return ( tcb->priority < q->priority )? tcb: q;
3400e00a:	683b      	ldr	r3, [r7, #0]
3400e00c:	f893 2026 	ldrb.w	r2, [r3, #38]	@ 0x26
3400e010:	68fb      	ldr	r3, [r7, #12]
3400e012:	f893 3026 	ldrb.w	r3, [r3, #38]	@ 0x26
3400e016:	429a      	cmp	r2, r3
3400e018:	d201      	bcs.n	3400e01e <knl_gcb_top_of_wait_queue+0x46>
3400e01a:	683b      	ldr	r3, [r7, #0]
3400e01c:	e000      	b.n	3400e020 <knl_gcb_top_of_wait_queue+0x48>
3400e01e:	68fb      	ldr	r3, [r7, #12]
}
3400e020:	4618      	mov	r0, r3
3400e022:	3710      	adds	r7, #16
3400e024:	46bd      	mov	sp, r7
3400e026:	bd80      	pop	{r7, pc}

3400e028 <knl_memset>:
#include "kernel.h"

/*** binary operation ***/
/* memset : fill memory area */
void* knl_memset( void *s, int c, SZ n )
{
3400e028:	b4f0      	push	{r4, r5, r6, r7}
3400e02a:	b084      	sub	sp, #16
3400e02c:	af00      	add	r7, sp, #0
3400e02e:	60f8      	str	r0, [r7, #12]
3400e030:	60b9      	str	r1, [r7, #8]
3400e032:	607a      	str	r2, [r7, #4]
	register unsigned char *cp, cval;
	register unsigned long *lp, lval;

	cp = (unsigned char *)s;
3400e034:	68fc      	ldr	r4, [r7, #12]
	cval = (unsigned char)c;
3400e036:	68bb      	ldr	r3, [r7, #8]
3400e038:	b2dd      	uxtb	r5, r3
	
	if (n < 8) {
3400e03a:	687b      	ldr	r3, [r7, #4]
3400e03c:	2b07      	cmp	r3, #7
3400e03e:	dc12      	bgt.n	3400e066 <knl_memset+0x3e>
		while (n-- > 0) {
3400e040:	e003      	b.n	3400e04a <knl_memset+0x22>
			*cp++ = cval;
3400e042:	4623      	mov	r3, r4
3400e044:	1c5c      	adds	r4, r3, #1
3400e046:	462a      	mov	r2, r5
3400e048:	701a      	strb	r2, [r3, #0]
		while (n-- > 0) {
3400e04a:	687b      	ldr	r3, [r7, #4]
3400e04c:	1e5a      	subs	r2, r3, #1
3400e04e:	607a      	str	r2, [r7, #4]
3400e050:	2b00      	cmp	r3, #0
3400e052:	dcf6      	bgt.n	3400e042 <knl_memset+0x1a>
		}
		return s;
3400e054:	68fb      	ldr	r3, [r7, #12]
3400e056:	e02e      	b.n	3400e0b6 <knl_memset+0x8e>
	}

	while ((long)cp % 4) {
		--n;
3400e058:	687b      	ldr	r3, [r7, #4]
3400e05a:	3b01      	subs	r3, #1
3400e05c:	607b      	str	r3, [r7, #4]
		*cp++ = cval;
3400e05e:	4623      	mov	r3, r4
3400e060:	1c5c      	adds	r4, r3, #1
3400e062:	462a      	mov	r2, r5
3400e064:	701a      	strb	r2, [r3, #0]
	while ((long)cp % 4) {
3400e066:	4623      	mov	r3, r4
3400e068:	f003 0303 	and.w	r3, r3, #3
3400e06c:	2b00      	cmp	r3, #0
3400e06e:	d1f3      	bne.n	3400e058 <knl_memset+0x30>
	}

	lp = (unsigned long *)cp;
3400e070:	4626      	mov	r6, r4
	lval = (unsigned long)cval |
3400e072:	462a      	mov	r2, r5
3400e074:	4613      	mov	r3, r2
3400e076:	021b      	lsls	r3, r3, #8
3400e078:	441a      	add	r2, r3
		(unsigned long)cval << 8 |
		(unsigned long)cval << 16 |
3400e07a:	462b      	mov	r3, r5
3400e07c:	041b      	lsls	r3, r3, #16
		(unsigned long)cval << 8 |
3400e07e:	431a      	orrs	r2, r3
		(unsigned long)cval << 24;
3400e080:	462b      	mov	r3, r5
3400e082:	061b      	lsls	r3, r3, #24
	lval = (unsigned long)cval |
3400e084:	ea42 0403 	orr.w	r4, r2, r3

	while (n >= 4) {
3400e088:	e005      	b.n	3400e096 <knl_memset+0x6e>
		*lp++ = lval;
3400e08a:	4633      	mov	r3, r6
3400e08c:	1d1e      	adds	r6, r3, #4
3400e08e:	601c      	str	r4, [r3, #0]
		n -= 4;
3400e090:	687b      	ldr	r3, [r7, #4]
3400e092:	3b04      	subs	r3, #4
3400e094:	607b      	str	r3, [r7, #4]
	while (n >= 4) {
3400e096:	687b      	ldr	r3, [r7, #4]
3400e098:	2b03      	cmp	r3, #3
3400e09a:	dcf6      	bgt.n	3400e08a <knl_memset+0x62>
	}

	cp = (unsigned char *)lp;
3400e09c:	4634      	mov	r4, r6
	while (n) {
3400e09e:	e006      	b.n	3400e0ae <knl_memset+0x86>
		*cp++ = cval;
3400e0a0:	4623      	mov	r3, r4
3400e0a2:	1c5c      	adds	r4, r3, #1
3400e0a4:	462a      	mov	r2, r5
3400e0a6:	701a      	strb	r2, [r3, #0]
		--n;
3400e0a8:	687b      	ldr	r3, [r7, #4]
3400e0aa:	3b01      	subs	r3, #1
3400e0ac:	607b      	str	r3, [r7, #4]
	while (n) {
3400e0ae:	687b      	ldr	r3, [r7, #4]
3400e0b0:	2b00      	cmp	r3, #0
3400e0b2:	d1f5      	bne.n	3400e0a0 <knl_memset+0x78>
	}

	return s;
3400e0b4:	68fb      	ldr	r3, [r7, #12]
}
3400e0b6:	4618      	mov	r0, r3
3400e0b8:	3710      	adds	r7, #16
3400e0ba:	46bd      	mov	sp, r7
3400e0bc:	bcf0      	pop	{r4, r5, r6, r7}
3400e0be:	4770      	bx	lr

3400e0c0 <knl_strlen>:
	return dst;
}

/* strlen : get text string length */
SZ knl_strlen( const char *s )
{
3400e0c0:	b490      	push	{r4, r7}
3400e0c2:	b082      	sub	sp, #8
3400e0c4:	af00      	add	r7, sp, #0
3400e0c6:	6078      	str	r0, [r7, #4]
	register char *cp;

	cp = (char *)s;
3400e0c8:	687c      	ldr	r4, [r7, #4]
	while (*cp) {
3400e0ca:	e000      	b.n	3400e0ce <knl_strlen+0xe>
		++cp;
3400e0cc:	3401      	adds	r4, #1
	while (*cp) {
3400e0ce:	7823      	ldrb	r3, [r4, #0]
3400e0d0:	2b00      	cmp	r3, #0
3400e0d2:	d1fb      	bne.n	3400e0cc <knl_strlen+0xc>
	}
	return (SZ)(cp - s);
3400e0d4:	687b      	ldr	r3, [r7, #4]
3400e0d6:	1ae3      	subs	r3, r4, r3
}
3400e0d8:	4618      	mov	r0, r3
3400e0da:	3708      	adds	r7, #8
3400e0dc:	46bd      	mov	sp, r7
3400e0de:	bc90      	pop	{r4, r7}
3400e0e0:	4770      	bx	lr

3400e0e2 <knl_strcpy>:

/* strcpy : copy text string */
char* knl_strcpy( char *dst, const char *src )
{
3400e0e2:	b490      	push	{r4, r7}
3400e0e4:	b082      	sub	sp, #8
3400e0e6:	af00      	add	r7, sp, #0
3400e0e8:	6078      	str	r0, [r7, #4]
3400e0ea:	6039      	str	r1, [r7, #0]
	register char *cp;

	cp = dst;
3400e0ec:	687c      	ldr	r4, [r7, #4]
	do {
		*cp++ = *src;
3400e0ee:	4623      	mov	r3, r4
3400e0f0:	1c5c      	adds	r4, r3, #1
3400e0f2:	683a      	ldr	r2, [r7, #0]
3400e0f4:	7812      	ldrb	r2, [r2, #0]
3400e0f6:	701a      	strb	r2, [r3, #0]
	} while (*src++);
3400e0f8:	683b      	ldr	r3, [r7, #0]
3400e0fa:	1c5a      	adds	r2, r3, #1
3400e0fc:	603a      	str	r2, [r7, #0]
3400e0fe:	781b      	ldrb	r3, [r3, #0]
3400e100:	2b00      	cmp	r3, #0
3400e102:	d1f4      	bne.n	3400e0ee <knl_strcpy+0xc>

	return dst;
3400e104:	687b      	ldr	r3, [r7, #4]
}
3400e106:	4618      	mov	r0, r3
3400e108:	3708      	adds	r7, #8
3400e10a:	46bd      	mov	sp, r7
3400e10c:	bc90      	pop	{r4, r7}
3400e10e:	4770      	bx	lr

3400e110 <knl_strncpy>:

char* knl_strncpy( char *dst, const char *src, SZ n )
{
3400e110:	b490      	push	{r4, r7}
3400e112:	b084      	sub	sp, #16
3400e114:	af00      	add	r7, sp, #0
3400e116:	60f8      	str	r0, [r7, #12]
3400e118:	60b9      	str	r1, [r7, #8]
3400e11a:	607a      	str	r2, [r7, #4]
	register char *cp;

	cp = dst;
3400e11c:	68fc      	ldr	r4, [r7, #12]
	do {
		if (n-- <= 0) {
3400e11e:	687b      	ldr	r3, [r7, #4]
3400e120:	1e5a      	subs	r2, r3, #1
3400e122:	607a      	str	r2, [r7, #4]
3400e124:	2b00      	cmp	r3, #0
3400e126:	dc01      	bgt.n	3400e12c <knl_strncpy+0x1c>
			return dst;
3400e128:	68fb      	ldr	r3, [r7, #12]
3400e12a:	e015      	b.n	3400e158 <knl_strncpy+0x48>
		}
		*cp++ = *src;
3400e12c:	4623      	mov	r3, r4
3400e12e:	1c5c      	adds	r4, r3, #1
3400e130:	68ba      	ldr	r2, [r7, #8]
3400e132:	7812      	ldrb	r2, [r2, #0]
3400e134:	701a      	strb	r2, [r3, #0]
	} while (*src++);
3400e136:	68bb      	ldr	r3, [r7, #8]
3400e138:	1c5a      	adds	r2, r3, #1
3400e13a:	60ba      	str	r2, [r7, #8]
3400e13c:	781b      	ldrb	r3, [r3, #0]
3400e13e:	2b00      	cmp	r3, #0
3400e140:	d1ed      	bne.n	3400e11e <knl_strncpy+0xe>

	while (n-- > 0) {
3400e142:	e003      	b.n	3400e14c <knl_strncpy+0x3c>
		*cp++ = 0;
3400e144:	4623      	mov	r3, r4
3400e146:	1c5c      	adds	r4, r3, #1
3400e148:	2200      	movs	r2, #0
3400e14a:	701a      	strb	r2, [r3, #0]
	while (n-- > 0) {
3400e14c:	687b      	ldr	r3, [r7, #4]
3400e14e:	1e5a      	subs	r2, r3, #1
3400e150:	607a      	str	r2, [r7, #4]
3400e152:	2b00      	cmp	r3, #0
3400e154:	dcf6      	bgt.n	3400e144 <knl_strncpy+0x34>
	}

	return dst;
3400e156:	68fb      	ldr	r3, [r7, #12]
}
3400e158:	4618      	mov	r0, r3
3400e15a:	3710      	adds	r7, #16
3400e15c:	46bd      	mov	sp, r7
3400e15e:	bc90      	pop	{r4, r7}
3400e160:	4770      	bx	lr

3400e162 <knl_strcmp>:

/* strcmp : perform text string comparison */
int knl_strcmp( const char *s1, const char *s2 )
{
3400e162:	b490      	push	{r4, r7}
3400e164:	b082      	sub	sp, #8
3400e166:	af00      	add	r7, sp, #0
3400e168:	6078      	str	r0, [r7, #4]
3400e16a:	6039      	str	r1, [r7, #0]
	register int result;

	while (*s1) {
3400e16c:	e00d      	b.n	3400e18a <knl_strcmp+0x28>
		result = (unsigned char)*s1++ - (unsigned char)*s2++;
3400e16e:	687b      	ldr	r3, [r7, #4]
3400e170:	1c5a      	adds	r2, r3, #1
3400e172:	607a      	str	r2, [r7, #4]
3400e174:	781b      	ldrb	r3, [r3, #0]
3400e176:	4619      	mov	r1, r3
3400e178:	683b      	ldr	r3, [r7, #0]
3400e17a:	1c5a      	adds	r2, r3, #1
3400e17c:	603a      	str	r2, [r7, #0]
3400e17e:	781b      	ldrb	r3, [r3, #0]
3400e180:	1acc      	subs	r4, r1, r3
		if (result) {
3400e182:	2c00      	cmp	r4, #0
3400e184:	d001      	beq.n	3400e18a <knl_strcmp+0x28>
			return result;
3400e186:	4623      	mov	r3, r4
3400e188:	e009      	b.n	3400e19e <knl_strcmp+0x3c>
	while (*s1) {
3400e18a:	687b      	ldr	r3, [r7, #4]
3400e18c:	781b      	ldrb	r3, [r3, #0]
3400e18e:	2b00      	cmp	r3, #0
3400e190:	d1ed      	bne.n	3400e16e <knl_strcmp+0xc>
		}
	}

	return (unsigned char)*s1 - (unsigned char)*s2;
3400e192:	687b      	ldr	r3, [r7, #4]
3400e194:	781b      	ldrb	r3, [r3, #0]
3400e196:	461a      	mov	r2, r3
3400e198:	683b      	ldr	r3, [r7, #0]
3400e19a:	781b      	ldrb	r3, [r3, #0]
3400e19c:	1ad3      	subs	r3, r2, r3
}
3400e19e:	4618      	mov	r0, r3
3400e1a0:	3708      	adds	r7, #8
3400e1a2:	46bd      	mov	sp, r7
3400e1a4:	bc90      	pop	{r4, r7}
3400e1a6:	4770      	bx	lr

3400e1a8 <Inc>:
 *	Increment/Decrement and evaluation of the associated result must
 *	be executed exclusively.
 */

Inline INT Inc( FastLock *lock )
{
3400e1a8:	b580      	push	{r7, lr}
3400e1aa:	b084      	sub	sp, #16
3400e1ac:	af00      	add	r7, sp, #0
3400e1ae:	6078      	str	r0, [r7, #4]
	UINT	imask;
	INT	c;
	DI(imask);
3400e1b0:	f001 fd27 	bl	3400fc02 <disint>
3400e1b4:	60f8      	str	r0, [r7, #12]
	c = ++lock->cnt;
3400e1b6:	687b      	ldr	r3, [r7, #4]
3400e1b8:	681b      	ldr	r3, [r3, #0]
3400e1ba:	1c5a      	adds	r2, r3, #1
3400e1bc:	687b      	ldr	r3, [r7, #4]
3400e1be:	601a      	str	r2, [r3, #0]
3400e1c0:	687b      	ldr	r3, [r7, #4]
3400e1c2:	681b      	ldr	r3, [r3, #0]
3400e1c4:	60bb      	str	r3, [r7, #8]
	EI(imask);
3400e1c6:	68f8      	ldr	r0, [r7, #12]
3400e1c8:	f001 fcff 	bl	3400fbca <set_basepri>
	return c;
3400e1cc:	68bb      	ldr	r3, [r7, #8]
}
3400e1ce:	4618      	mov	r0, r3
3400e1d0:	3710      	adds	r7, #16
3400e1d2:	46bd      	mov	sp, r7
3400e1d4:	bd80      	pop	{r7, pc}

3400e1d6 <Dec>:
Inline INT Dec( FastLock *lock )
{
3400e1d6:	b580      	push	{r7, lr}
3400e1d8:	b084      	sub	sp, #16
3400e1da:	af00      	add	r7, sp, #0
3400e1dc:	6078      	str	r0, [r7, #4]
	UINT	imask;
	INT	c;
	DI(imask);
3400e1de:	f001 fd10 	bl	3400fc02 <disint>
3400e1e2:	60f8      	str	r0, [r7, #12]
	c = lock->cnt--;
3400e1e4:	687b      	ldr	r3, [r7, #4]
3400e1e6:	681b      	ldr	r3, [r3, #0]
3400e1e8:	1e59      	subs	r1, r3, #1
3400e1ea:	687a      	ldr	r2, [r7, #4]
3400e1ec:	6011      	str	r1, [r2, #0]
3400e1ee:	60bb      	str	r3, [r7, #8]
	EI(imask);
3400e1f0:	68f8      	ldr	r0, [r7, #12]
3400e1f2:	f001 fcea 	bl	3400fbca <set_basepri>
	return c;
3400e1f6:	68bb      	ldr	r3, [r7, #8]
}
3400e1f8:	4618      	mov	r0, r3
3400e1fa:	3710      	adds	r7, #16
3400e1fc:	46bd      	mov	sp, r7
3400e1fe:	bd80      	pop	{r7, pc}

3400e200 <Lock>:

/*
 * Lock 
 */
EXPORT void Lock( FastLock *lock )
{
3400e200:	b580      	push	{r7, lr}
3400e202:	b082      	sub	sp, #8
3400e204:	af00      	add	r7, sp, #0
3400e206:	6078      	str	r0, [r7, #4]
	if ( Inc(lock) > 0 ) {
3400e208:	6878      	ldr	r0, [r7, #4]
3400e20a:	f7ff ffcd 	bl	3400e1a8 <Inc>
3400e20e:	4603      	mov	r3, r0
3400e210:	2b00      	cmp	r3, #0
3400e212:	dd07      	ble.n	3400e224 <Lock+0x24>
		tk_wai_sem(lock->id, 1, TMO_FEVR);
3400e214:	687b      	ldr	r3, [r7, #4]
3400e216:	685b      	ldr	r3, [r3, #4]
3400e218:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
3400e21c:	2101      	movs	r1, #1
3400e21e:	4618      	mov	r0, r3
3400e220:	f7fe fd82 	bl	3400cd28 <tk_wai_sem>
	}
}
3400e224:	bf00      	nop
3400e226:	3708      	adds	r7, #8
3400e228:	46bd      	mov	sp, r7
3400e22a:	bd80      	pop	{r7, pc}

3400e22c <Unlock>:

/*
 * Lock release
 */
EXPORT void Unlock( FastLock *lock )
{
3400e22c:	b580      	push	{r7, lr}
3400e22e:	b082      	sub	sp, #8
3400e230:	af00      	add	r7, sp, #0
3400e232:	6078      	str	r0, [r7, #4]
	if ( Dec(lock) > 0 ) {
3400e234:	6878      	ldr	r0, [r7, #4]
3400e236:	f7ff ffce 	bl	3400e1d6 <Dec>
3400e23a:	4603      	mov	r3, r0
3400e23c:	2b00      	cmp	r3, #0
3400e23e:	dd05      	ble.n	3400e24c <Unlock+0x20>
		tk_sig_sem(lock->id, 1);
3400e240:	687b      	ldr	r3, [r7, #4]
3400e242:	685b      	ldr	r3, [r3, #4]
3400e244:	2101      	movs	r1, #1
3400e246:	4618      	mov	r0, r3
3400e248:	f7fe fc96 	bl	3400cb78 <tk_sig_sem>
	}
}
3400e24c:	bf00      	nop
3400e24e:	3708      	adds	r7, #8
3400e250:	46bd      	mov	sp, r7
3400e252:	bd80      	pop	{r7, pc}

3400e254 <CreateLock>:

/*
 * Create high-speed lock 
 */
EXPORT ER CreateLock( FastLock *lock, CONST UB *name )
{
3400e254:	b580      	push	{r7, lr}
3400e256:	b08a      	sub	sp, #40	@ 0x28
3400e258:	af00      	add	r7, sp, #0
3400e25a:	6078      	str	r0, [r7, #4]
3400e25c:	6039      	str	r1, [r7, #0]
	T_CSEM	csem;
	ER	ercd;

	csem.sematr  = TA_TPRI;
3400e25e:	2301      	movs	r3, #1
3400e260:	60fb      	str	r3, [r7, #12]
	csem.isemcnt = 0;
3400e262:	2300      	movs	r3, #0
3400e264:	613b      	str	r3, [r7, #16]
	csem.maxsem  = 1;
3400e266:	2301      	movs	r3, #1
3400e268:	617b      	str	r3, [r7, #20]
	SetOBJNAME(csem.exinf, "FLOC");
3400e26a:	f107 0308 	add.w	r3, r7, #8
3400e26e:	627b      	str	r3, [r7, #36]	@ 0x24
3400e270:	4b16      	ldr	r3, [pc, #88]	@ (3400e2cc <CreateLock+0x78>)
3400e272:	623b      	str	r3, [r7, #32]
3400e274:	2300      	movs	r3, #0
3400e276:	61fb      	str	r3, [r7, #28]
3400e278:	e00a      	b.n	3400e290 <CreateLock+0x3c>
3400e27a:	6a3a      	ldr	r2, [r7, #32]
3400e27c:	1c53      	adds	r3, r2, #1
3400e27e:	623b      	str	r3, [r7, #32]
3400e280:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400e282:	1c59      	adds	r1, r3, #1
3400e284:	6279      	str	r1, [r7, #36]	@ 0x24
3400e286:	7812      	ldrb	r2, [r2, #0]
3400e288:	701a      	strb	r2, [r3, #0]
3400e28a:	69fb      	ldr	r3, [r7, #28]
3400e28c:	3301      	adds	r3, #1
3400e28e:	61fb      	str	r3, [r7, #28]
3400e290:	69fb      	ldr	r3, [r7, #28]
3400e292:	2b03      	cmp	r3, #3
3400e294:	ddf1      	ble.n	3400e27a <CreateLock+0x26>

	ercd = tk_cre_sem(&csem);
3400e296:	f107 0308 	add.w	r3, r7, #8
3400e29a:	4618      	mov	r0, r3
3400e29c:	f7fe fba2 	bl	3400c9e4 <tk_cre_sem>
3400e2a0:	61b8      	str	r0, [r7, #24]
	if ( ercd < E_OK ) {
3400e2a2:	69bb      	ldr	r3, [r7, #24]
3400e2a4:	2b00      	cmp	r3, #0
3400e2a6:	da01      	bge.n	3400e2ac <CreateLock+0x58>
		return ercd;
3400e2a8:	69bb      	ldr	r3, [r7, #24]
3400e2aa:	e00a      	b.n	3400e2c2 <CreateLock+0x6e>
	}

	lock->id = ercd;
3400e2ac:	687b      	ldr	r3, [r7, #4]
3400e2ae:	69ba      	ldr	r2, [r7, #24]
3400e2b0:	605a      	str	r2, [r3, #4]
	lock->cnt = -1;
3400e2b2:	687b      	ldr	r3, [r7, #4]
3400e2b4:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
3400e2b8:	601a      	str	r2, [r3, #0]
	lock->name = name;
3400e2ba:	687b      	ldr	r3, [r7, #4]
3400e2bc:	683a      	ldr	r2, [r7, #0]
3400e2be:	609a      	str	r2, [r3, #8]
  
	return E_OK;
3400e2c0:	2300      	movs	r3, #0
}
3400e2c2:	4618      	mov	r0, r3
3400e2c4:	3728      	adds	r7, #40	@ 0x28
3400e2c6:	46bd      	mov	sp, r7
3400e2c8:	bd80      	pop	{r7, pc}
3400e2ca:	bf00      	nop
3400e2cc:	3400feb0 	.word	0x3400feb0

3400e2d0 <DeleteLock>:

/*
 * Delete high-speed lock
 */
EXPORT void DeleteLock( FastLock *lock )
{
3400e2d0:	b580      	push	{r7, lr}
3400e2d2:	b082      	sub	sp, #8
3400e2d4:	af00      	add	r7, sp, #0
3400e2d6:	6078      	str	r0, [r7, #4]
	if ( lock->id > 0 ) {
3400e2d8:	687b      	ldr	r3, [r7, #4]
3400e2da:	685b      	ldr	r3, [r3, #4]
3400e2dc:	2b00      	cmp	r3, #0
3400e2de:	dd04      	ble.n	3400e2ea <DeleteLock+0x1a>
		tk_del_sem(lock->id);
3400e2e0:	687b      	ldr	r3, [r7, #4]
3400e2e2:	685b      	ldr	r3, [r3, #4]
3400e2e4:	4618      	mov	r0, r3
3400e2e6:	f7fe fbf7 	bl	3400cad8 <tk_del_sem>
	}
	lock->id = 0;
3400e2ea:	687b      	ldr	r3, [r7, #4]
3400e2ec:	2200      	movs	r2, #0
3400e2ee:	605a      	str	r2, [r3, #4]
}
3400e2f0:	bf00      	nop
3400e2f2:	3708      	adds	r7, #8
3400e2f4:	46bd      	mov	sp, r7
3400e2f6:	bd80      	pop	{r7, pc}

3400e2f8 <INC>:
 *
 *	The above must be operated exclusively.
 */

Inline void INC( INT *val )
{
3400e2f8:	b580      	push	{r7, lr}
3400e2fa:	b084      	sub	sp, #16
3400e2fc:	af00      	add	r7, sp, #0
3400e2fe:	6078      	str	r0, [r7, #4]
	UINT	imask;

	DI(imask);
3400e300:	f001 fc7f 	bl	3400fc02 <disint>
3400e304:	60f8      	str	r0, [r7, #12]
	(*val)++;
3400e306:	687b      	ldr	r3, [r7, #4]
3400e308:	681b      	ldr	r3, [r3, #0]
3400e30a:	1c5a      	adds	r2, r3, #1
3400e30c:	687b      	ldr	r3, [r7, #4]
3400e30e:	601a      	str	r2, [r3, #0]
	EI(imask);
3400e310:	68f8      	ldr	r0, [r7, #12]
3400e312:	f001 fc5a 	bl	3400fbca <set_basepri>
}
3400e316:	bf00      	nop
3400e318:	3710      	adds	r7, #16
3400e31a:	46bd      	mov	sp, r7
3400e31c:	bd80      	pop	{r7, pc}

3400e31e <DEC>:

Inline void DEC( INT *val )
{
3400e31e:	b580      	push	{r7, lr}
3400e320:	b084      	sub	sp, #16
3400e322:	af00      	add	r7, sp, #0
3400e324:	6078      	str	r0, [r7, #4]
	UINT	imask;

	DI(imask);
3400e326:	f001 fc6c 	bl	3400fc02 <disint>
3400e32a:	60f8      	str	r0, [r7, #12]
	(*val)--;
3400e32c:	687b      	ldr	r3, [r7, #4]
3400e32e:	681b      	ldr	r3, [r3, #0]
3400e330:	1e5a      	subs	r2, r3, #1
3400e332:	687b      	ldr	r3, [r7, #4]
3400e334:	601a      	str	r2, [r3, #0]
	EI(imask);
3400e336:	68f8      	ldr	r0, [r7, #12]
3400e338:	f001 fc47 	bl	3400fbca <set_basepri>
}
3400e33c:	bf00      	nop
3400e33e:	3710      	adds	r7, #16
3400e340:	46bd      	mov	sp, r7
3400e342:	bd80      	pop	{r7, pc}

3400e344 <BTS>:

Inline BOOL BTS( UINT *val, INT no )
{
3400e344:	b580      	push	{r7, lr}
3400e346:	b086      	sub	sp, #24
3400e348:	af00      	add	r7, sp, #0
3400e34a:	6078      	str	r0, [r7, #4]
3400e34c:	6039      	str	r1, [r7, #0]
	UINT	imask;
	UINT	b;
	UINT	bm = (UINT)(1 << no);
3400e34e:	2201      	movs	r2, #1
3400e350:	683b      	ldr	r3, [r7, #0]
3400e352:	fa02 f303 	lsl.w	r3, r2, r3
3400e356:	617b      	str	r3, [r7, #20]

	DI(imask);
3400e358:	f001 fc53 	bl	3400fc02 <disint>
3400e35c:	6138      	str	r0, [r7, #16]
	b = *val & bm;
3400e35e:	687b      	ldr	r3, [r7, #4]
3400e360:	681b      	ldr	r3, [r3, #0]
3400e362:	697a      	ldr	r2, [r7, #20]
3400e364:	4013      	ands	r3, r2
3400e366:	60fb      	str	r3, [r7, #12]
	*val |= bm;
3400e368:	687b      	ldr	r3, [r7, #4]
3400e36a:	681a      	ldr	r2, [r3, #0]
3400e36c:	697b      	ldr	r3, [r7, #20]
3400e36e:	431a      	orrs	r2, r3
3400e370:	687b      	ldr	r3, [r7, #4]
3400e372:	601a      	str	r2, [r3, #0]
	EI(imask);
3400e374:	6938      	ldr	r0, [r7, #16]
3400e376:	f001 fc28 	bl	3400fbca <set_basepri>
	return (BOOL)b;
3400e37a:	68fb      	ldr	r3, [r7, #12]
}
3400e37c:	4618      	mov	r0, r3
3400e37e:	3718      	adds	r7, #24
3400e380:	46bd      	mov	sp, r7
3400e382:	bd80      	pop	{r7, pc}

3400e384 <BR>:

Inline void BR( UINT *val, INT no )
{
3400e384:	b580      	push	{r7, lr}
3400e386:	b084      	sub	sp, #16
3400e388:	af00      	add	r7, sp, #0
3400e38a:	6078      	str	r0, [r7, #4]
3400e38c:	6039      	str	r1, [r7, #0]
	UINT	imask;

	DI(imask);
3400e38e:	f001 fc38 	bl	3400fc02 <disint>
3400e392:	60f8      	str	r0, [r7, #12]
	*val &= ~(UINT)(1 << no);
3400e394:	687b      	ldr	r3, [r7, #4]
3400e396:	681a      	ldr	r2, [r3, #0]
3400e398:	2101      	movs	r1, #1
3400e39a:	683b      	ldr	r3, [r7, #0]
3400e39c:	fa01 f303 	lsl.w	r3, r1, r3
3400e3a0:	43db      	mvns	r3, r3
3400e3a2:	401a      	ands	r2, r3
3400e3a4:	687b      	ldr	r3, [r7, #4]
3400e3a6:	601a      	str	r2, [r3, #0]
	EI(imask);
3400e3a8:	68f8      	ldr	r0, [r7, #12]
3400e3aa:	f001 fc0e 	bl	3400fbca <set_basepri>
}
3400e3ae:	bf00      	nop
3400e3b0:	3710      	adds	r7, #16
3400e3b2:	46bd      	mov	sp, r7
3400e3b4:	bd80      	pop	{r7, pc}

3400e3b6 <MLockTmo>:
/*
 * Lock with wait time designation 
 *	no	lock number 0 - 31 
 */
EXPORT ER MLockTmo( FastMLock *lock, INT no, TMO tmo )
{
3400e3b6:	b580      	push	{r7, lr}
3400e3b8:	b08a      	sub	sp, #40	@ 0x28
3400e3ba:	af02      	add	r7, sp, #8
3400e3bc:	60f8      	str	r0, [r7, #12]
3400e3be:	60b9      	str	r1, [r7, #8]
3400e3c0:	607a      	str	r2, [r7, #4]
	UINT	ptn = (UINT)(1 << no);
3400e3c2:	2201      	movs	r2, #1
3400e3c4:	68bb      	ldr	r3, [r7, #8]
3400e3c6:	fa02 f303 	lsl.w	r3, r2, r3
3400e3ca:	61bb      	str	r3, [r7, #24]
	UINT	flg;
	ER	ercd;

	INC(&lock->wai);
3400e3cc:	68fb      	ldr	r3, [r7, #12]
3400e3ce:	3304      	adds	r3, #4
3400e3d0:	4618      	mov	r0, r3
3400e3d2:	f7ff ff91 	bl	3400e2f8 <INC>
	for ( ;; ) {
		if ( !BTS(&lock->flg, no) ) {
3400e3d6:	68fb      	ldr	r3, [r7, #12]
3400e3d8:	68b9      	ldr	r1, [r7, #8]
3400e3da:	4618      	mov	r0, r3
3400e3dc:	f7ff ffb2 	bl	3400e344 <BTS>
3400e3e0:	4603      	mov	r3, r0
3400e3e2:	2b00      	cmp	r3, #0
3400e3e4:	d102      	bne.n	3400e3ec <MLockTmo+0x36>
			ercd = E_OK;
3400e3e6:	2300      	movs	r3, #0
3400e3e8:	61fb      	str	r3, [r7, #28]
			break;
3400e3ea:	e010      	b.n	3400e40e <MLockTmo+0x58>
		}

		ercd = tk_wai_flg(lock->id, ptn, TWF_ORW|TWF_BITCLR, &flg, tmo);
3400e3ec:	68fb      	ldr	r3, [r7, #12]
3400e3ee:	6898      	ldr	r0, [r3, #8]
3400e3f0:	f107 0214 	add.w	r2, r7, #20
3400e3f4:	687b      	ldr	r3, [r7, #4]
3400e3f6:	9300      	str	r3, [sp, #0]
3400e3f8:	4613      	mov	r3, r2
3400e3fa:	2221      	movs	r2, #33	@ 0x21
3400e3fc:	69b9      	ldr	r1, [r7, #24]
3400e3fe:	f7fd fd9b 	bl	3400bf38 <tk_wai_flg>
3400e402:	61f8      	str	r0, [r7, #28]
		if ( ercd < E_OK ) {
3400e404:	69fb      	ldr	r3, [r7, #28]
3400e406:	2b00      	cmp	r3, #0
3400e408:	db00      	blt.n	3400e40c <MLockTmo+0x56>
		if ( !BTS(&lock->flg, no) ) {
3400e40a:	e7e4      	b.n	3400e3d6 <MLockTmo+0x20>
			break;
3400e40c:	bf00      	nop
		}
	}
	DEC(&lock->wai);
3400e40e:	68fb      	ldr	r3, [r7, #12]
3400e410:	3304      	adds	r3, #4
3400e412:	4618      	mov	r0, r3
3400e414:	f7ff ff83 	bl	3400e31e <DEC>

	return ercd;
3400e418:	69fb      	ldr	r3, [r7, #28]
}
3400e41a:	4618      	mov	r0, r3
3400e41c:	3720      	adds	r7, #32
3400e41e:	46bd      	mov	sp, r7
3400e420:	bd80      	pop	{r7, pc}

3400e422 <MLock>:
/*
 * Lock 
 *	no	Lock number 0 - 31 
 */
EXPORT ER MLock( FastMLock *lock, INT no )
{
3400e422:	b580      	push	{r7, lr}
3400e424:	b082      	sub	sp, #8
3400e426:	af00      	add	r7, sp, #0
3400e428:	6078      	str	r0, [r7, #4]
3400e42a:	6039      	str	r1, [r7, #0]
	return MLockTmo(lock, no, TMO_FEVR);
3400e42c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
3400e430:	6839      	ldr	r1, [r7, #0]
3400e432:	6878      	ldr	r0, [r7, #4]
3400e434:	f7ff ffbf 	bl	3400e3b6 <MLockTmo>
3400e438:	4603      	mov	r3, r0
}
3400e43a:	4618      	mov	r0, r3
3400e43c:	3708      	adds	r7, #8
3400e43e:	46bd      	mov	sp, r7
3400e440:	bd80      	pop	{r7, pc}

3400e442 <MUnlock>:
/*
 * Lock release 
 *	no	Lock number 0 - 31 
 */
EXPORT ER MUnlock( FastMLock *lock, INT no )
{
3400e442:	b580      	push	{r7, lr}
3400e444:	b084      	sub	sp, #16
3400e446:	af00      	add	r7, sp, #0
3400e448:	6078      	str	r0, [r7, #4]
3400e44a:	6039      	str	r1, [r7, #0]
	UINT	ptn = (UINT)(1 << no);
3400e44c:	2201      	movs	r2, #1
3400e44e:	683b      	ldr	r3, [r7, #0]
3400e450:	fa02 f303 	lsl.w	r3, r2, r3
3400e454:	60fb      	str	r3, [r7, #12]
	ER	ercd;

	BR(&lock->flg, no);
3400e456:	687b      	ldr	r3, [r7, #4]
3400e458:	6839      	ldr	r1, [r7, #0]
3400e45a:	4618      	mov	r0, r3
3400e45c:	f7ff ff92 	bl	3400e384 <BR>
	ercd = ( lock->wai == 0 )? E_OK: tk_set_flg(lock->id, ptn);
3400e460:	687b      	ldr	r3, [r7, #4]
3400e462:	685b      	ldr	r3, [r3, #4]
3400e464:	2b00      	cmp	r3, #0
3400e466:	d007      	beq.n	3400e478 <MUnlock+0x36>
3400e468:	687b      	ldr	r3, [r7, #4]
3400e46a:	689b      	ldr	r3, [r3, #8]
3400e46c:	68f9      	ldr	r1, [r7, #12]
3400e46e:	4618      	mov	r0, r3
3400e470:	f7fd fc76 	bl	3400bd60 <tk_set_flg>
3400e474:	4603      	mov	r3, r0
3400e476:	e000      	b.n	3400e47a <MUnlock+0x38>
3400e478:	2300      	movs	r3, #0
3400e47a:	60bb      	str	r3, [r7, #8]

	return ercd;
3400e47c:	68bb      	ldr	r3, [r7, #8]
}
3400e47e:	4618      	mov	r0, r3
3400e480:	3710      	adds	r7, #16
3400e482:	46bd      	mov	sp, r7
3400e484:	bd80      	pop	{r7, pc}
	...

3400e488 <CreateMLock>:

/*
 * Create multi-lock 
 */
EXPORT ER CreateMLock( FastMLock *lock, CONST UB *name )
{
3400e488:	b580      	push	{r7, lr}
3400e48a:	b08a      	sub	sp, #40	@ 0x28
3400e48c:	af00      	add	r7, sp, #0
3400e48e:	6078      	str	r0, [r7, #4]
3400e490:	6039      	str	r1, [r7, #0]
	T_CFLG	cflg;
	ER	ercd;

	cflg.flgatr  = TA_TPRI | TA_WMUL;
3400e492:	2309      	movs	r3, #9
3400e494:	613b      	str	r3, [r7, #16]
	cflg.iflgptn = 0;
3400e496:	2300      	movs	r3, #0
3400e498:	617b      	str	r3, [r7, #20]
	SetOBJNAME(cflg.exinf, "MLOC");
3400e49a:	f107 030c 	add.w	r3, r7, #12
3400e49e:	627b      	str	r3, [r7, #36]	@ 0x24
3400e4a0:	4b17      	ldr	r3, [pc, #92]	@ (3400e500 <CreateMLock+0x78>)
3400e4a2:	623b      	str	r3, [r7, #32]
3400e4a4:	2300      	movs	r3, #0
3400e4a6:	61fb      	str	r3, [r7, #28]
3400e4a8:	e00a      	b.n	3400e4c0 <CreateMLock+0x38>
3400e4aa:	6a3a      	ldr	r2, [r7, #32]
3400e4ac:	1c53      	adds	r3, r2, #1
3400e4ae:	623b      	str	r3, [r7, #32]
3400e4b0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
3400e4b2:	1c59      	adds	r1, r3, #1
3400e4b4:	6279      	str	r1, [r7, #36]	@ 0x24
3400e4b6:	7812      	ldrb	r2, [r2, #0]
3400e4b8:	701a      	strb	r2, [r3, #0]
3400e4ba:	69fb      	ldr	r3, [r7, #28]
3400e4bc:	3301      	adds	r3, #1
3400e4be:	61fb      	str	r3, [r7, #28]
3400e4c0:	69fb      	ldr	r3, [r7, #28]
3400e4c2:	2b03      	cmp	r3, #3
3400e4c4:	ddf1      	ble.n	3400e4aa <CreateMLock+0x22>

	lock->id = ercd = tk_cre_flg(&cflg);
3400e4c6:	f107 030c 	add.w	r3, r7, #12
3400e4ca:	4618      	mov	r0, r3
3400e4cc:	f7fd fb98 	bl	3400bc00 <tk_cre_flg>
3400e4d0:	61b8      	str	r0, [r7, #24]
3400e4d2:	687b      	ldr	r3, [r7, #4]
3400e4d4:	69ba      	ldr	r2, [r7, #24]
3400e4d6:	609a      	str	r2, [r3, #8]
	if ( ercd < E_OK ) {
3400e4d8:	69bb      	ldr	r3, [r7, #24]
3400e4da:	2b00      	cmp	r3, #0
3400e4dc:	da01      	bge.n	3400e4e2 <CreateMLock+0x5a>
		return ercd;
3400e4de:	69bb      	ldr	r3, [r7, #24]
3400e4e0:	e009      	b.n	3400e4f6 <CreateMLock+0x6e>
	}

	lock->wai = 0;
3400e4e2:	687b      	ldr	r3, [r7, #4]
3400e4e4:	2200      	movs	r2, #0
3400e4e6:	605a      	str	r2, [r3, #4]
	lock->flg = 0;
3400e4e8:	687b      	ldr	r3, [r7, #4]
3400e4ea:	2200      	movs	r2, #0
3400e4ec:	601a      	str	r2, [r3, #0]
	lock->name = name;
3400e4ee:	687b      	ldr	r3, [r7, #4]
3400e4f0:	683a      	ldr	r2, [r7, #0]
3400e4f2:	60da      	str	r2, [r3, #12]

	return E_OK;
3400e4f4:	2300      	movs	r3, #0
}
3400e4f6:	4618      	mov	r0, r3
3400e4f8:	3728      	adds	r7, #40	@ 0x28
3400e4fa:	46bd      	mov	sp, r7
3400e4fc:	bd80      	pop	{r7, pc}
3400e4fe:	bf00      	nop
3400e500:	3400feb8 	.word	0x3400feb8

3400e504 <DeleteMLock>:

/*
 * Delete multi-lock 
 */
EXPORT ER DeleteMLock( FastMLock *lock )
{
3400e504:	b580      	push	{r7, lr}
3400e506:	b084      	sub	sp, #16
3400e508:	af00      	add	r7, sp, #0
3400e50a:	6078      	str	r0, [r7, #4]
	ER	ercd;

	if ( lock->id <= 0 ) {
3400e50c:	687b      	ldr	r3, [r7, #4]
3400e50e:	689b      	ldr	r3, [r3, #8]
3400e510:	2b00      	cmp	r3, #0
3400e512:	dc02      	bgt.n	3400e51a <DeleteMLock+0x16>
		return E_PAR;
3400e514:	f06f 0310 	mvn.w	r3, #16
3400e518:	e00e      	b.n	3400e538 <DeleteMLock+0x34>
	}

	ercd = tk_del_flg(lock->id);
3400e51a:	687b      	ldr	r3, [r7, #4]
3400e51c:	689b      	ldr	r3, [r3, #8]
3400e51e:	4618      	mov	r0, r3
3400e520:	f7fd fbce 	bl	3400bcc0 <tk_del_flg>
3400e524:	60f8      	str	r0, [r7, #12]
	if ( ercd < E_OK ) {
3400e526:	68fb      	ldr	r3, [r7, #12]
3400e528:	2b00      	cmp	r3, #0
3400e52a:	da01      	bge.n	3400e530 <DeleteMLock+0x2c>
		return ercd;
3400e52c:	68fb      	ldr	r3, [r7, #12]
3400e52e:	e003      	b.n	3400e538 <DeleteMLock+0x34>
	}

	lock->id = 0;
3400e530:	687b      	ldr	r3, [r7, #4]
3400e532:	2200      	movs	r2, #0
3400e534:	609a      	str	r2, [r3, #8]

	return E_OK;
3400e536:	2300      	movs	r3, #0
}
3400e538:	4618      	mov	r0, r3
3400e53a:	3710      	adds	r7, #16
3400e53c:	46bd      	mov	sp, r7
3400e53e:	bd80      	pop	{r7, pc}

3400e540 <Kmalloc>:
/* --------------------------------------------------------------------- */
/*
 * Memory allocation API definition
 */
EXPORT void* Kmalloc( size_t size )
{
3400e540:	b580      	push	{r7, lr}
3400e542:	b082      	sub	sp, #8
3400e544:	af00      	add	r7, sp, #0
3400e546:	6078      	str	r0, [r7, #4]
	return knl_Imalloc(size);
3400e548:	687b      	ldr	r3, [r7, #4]
3400e54a:	4618      	mov	r0, r3
3400e54c:	f7fd ff6a 	bl	3400c424 <knl_Imalloc>
3400e550:	4603      	mov	r3, r0
}
3400e552:	4618      	mov	r0, r3
3400e554:	3708      	adds	r7, #8
3400e556:	46bd      	mov	sp, r7
3400e558:	bd80      	pop	{r7, pc}

3400e55a <Kfree>:
{
	return knl_Irealloc(ptr, size);
}

EXPORT void Kfree( void *ptr )
{
3400e55a:	b580      	push	{r7, lr}
3400e55c:	b082      	sub	sp, #8
3400e55e:	af00      	add	r7, sp, #0
3400e560:	6078      	str	r0, [r7, #4]
	knl_Ifree(ptr);
3400e562:	6878      	ldr	r0, [r7, #4]
3400e564:	f7fd ffb4 	bl	3400c4d0 <knl_Ifree>
}
3400e568:	bf00      	nop
3400e56a:	3708      	adds	r7, #8
3400e56c:	46bd      	mov	sp, r7
3400e56e:	bd80      	pop	{r7, pc}

3400e570 <libtm_init>:
/*
 * libtm_init() - libtm Initialize
 * supported only on wait != 0 (polling not supported)
 */
EXPORT void libtm_init(void)
{
3400e570:	b580      	push	{r7, lr}
3400e572:	af00      	add	r7, sp, #0
	tm_com_init();
3400e574:	f001 fb86 	bl	3400fc84 <tm_com_init>
}
3400e578:	bf00      	nop
3400e57a:	bd80      	pop	{r7, pc}

3400e57c <tm_putchar>:
/*
 * tm_putchar()
 * Ctrl-C is not supported
 */
EXPORT INT tm_putchar( INT c )
{
3400e57c:	b580      	push	{r7, lr}
3400e57e:	b084      	sub	sp, #16
3400e580:	af00      	add	r7, sp, #0
3400e582:	6078      	str	r0, [r7, #4]
	static const char CR = CHR_CR;
	UB buf = (UB)c;
3400e584:	687b      	ldr	r3, [r7, #4]
3400e586:	b2db      	uxtb	r3, r3
3400e588:	72fb      	strb	r3, [r7, #11]
	INT imask;

	DI(imask);
3400e58a:	f001 fb3a 	bl	3400fc02 <disint>
3400e58e:	4603      	mov	r3, r0
3400e590:	60fb      	str	r3, [r7, #12]
	if (buf == CHR_LF) {
3400e592:	7afb      	ldrb	r3, [r7, #11]
3400e594:	2b0a      	cmp	r3, #10
3400e596:	d103      	bne.n	3400e5a0 <tm_putchar+0x24>
		tm_snd_dat((const UB*)&CR, 1);
3400e598:	2101      	movs	r1, #1
3400e59a:	4809      	ldr	r0, [pc, #36]	@ (3400e5c0 <tm_putchar+0x44>)
3400e59c:	f001 fb44 	bl	3400fc28 <tm_snd_dat>
	}
	tm_snd_dat(&buf, 1);
3400e5a0:	f107 030b 	add.w	r3, r7, #11
3400e5a4:	2101      	movs	r1, #1
3400e5a6:	4618      	mov	r0, r3
3400e5a8:	f001 fb3e 	bl	3400fc28 <tm_snd_dat>
	EI(imask);
3400e5ac:	68fb      	ldr	r3, [r7, #12]
3400e5ae:	4618      	mov	r0, r3
3400e5b0:	f001 fb0b 	bl	3400fbca <set_basepri>

	return 0;
3400e5b4:	2300      	movs	r3, #0
}
3400e5b6:	4618      	mov	r0, r3
3400e5b8:	3710      	adds	r7, #16
3400e5ba:	46bd      	mov	sp, r7
3400e5bc:	bd80      	pop	{r7, pc}
3400e5be:	bf00      	nop
3400e5c0:	340100d8 	.word	0x340100d8

3400e5c4 <tm_putstring>:
/*
 * tm_putstring() - Put String
 * Ctrl-C is not supported
 */
EXPORT INT tm_putstring( const UB *buff )
{
3400e5c4:	b580      	push	{r7, lr}
3400e5c6:	b084      	sub	sp, #16
3400e5c8:	af00      	add	r7, sp, #0
3400e5ca:	6078      	str	r0, [r7, #4]
	const UB* p = buff;
3400e5cc:	687b      	ldr	r3, [r7, #4]
3400e5ce:	60fb      	str	r3, [r7, #12]
	INT imask;

	DI(imask);
3400e5d0:	f001 fb17 	bl	3400fc02 <disint>
3400e5d4:	4603      	mov	r3, r0
3400e5d6:	60bb      	str	r3, [r7, #8]
	while ( *p != (UB)'\0' ) {
3400e5d8:	e006      	b.n	3400e5e8 <tm_putstring+0x24>
		tm_putchar(*p++);
3400e5da:	68fb      	ldr	r3, [r7, #12]
3400e5dc:	1c5a      	adds	r2, r3, #1
3400e5de:	60fa      	str	r2, [r7, #12]
3400e5e0:	781b      	ldrb	r3, [r3, #0]
3400e5e2:	4618      	mov	r0, r3
3400e5e4:	f7ff ffca 	bl	3400e57c <tm_putchar>
	while ( *p != (UB)'\0' ) {
3400e5e8:	68fb      	ldr	r3, [r7, #12]
3400e5ea:	781b      	ldrb	r3, [r3, #0]
3400e5ec:	2b00      	cmp	r3, #0
3400e5ee:	d1f4      	bne.n	3400e5da <tm_putstring+0x16>
	}
	EI(imask);
3400e5f0:	68bb      	ldr	r3, [r7, #8]
3400e5f2:	4618      	mov	r0, r3
3400e5f4:	f001 fae9 	bl	3400fbca <set_basepri>

	return 0;
3400e5f8:	2300      	movs	r3, #0
}
3400e5fa:	4618      	mov	r0, r3
3400e5fc:	3710      	adds	r7, #16
3400e5fe:	46bd      	mov	sp, r7
3400e600:	bd80      	pop	{r7, pc}
	...

3400e604 <outint>:

/*
 *	Output integer value
 */
LOCAL	UB	*outint( UB *ep, UW val, UB base )
{
3400e604:	b480      	push	{r7}
3400e606:	b087      	sub	sp, #28
3400e608:	af00      	add	r7, sp, #0
3400e60a:	60f8      	str	r0, [r7, #12]
3400e60c:	60b9      	str	r1, [r7, #8]
3400e60e:	4613      	mov	r3, r2
3400e610:	71fb      	strb	r3, [r7, #7]
LOCAL const UB  digits[32] = "0123456789abcdef0123456789ABCDEF";
	UB	caps;

	caps = (base & 0x40) >> 2;		/* 'a' or 'A' */
3400e612:	79fb      	ldrb	r3, [r7, #7]
3400e614:	109b      	asrs	r3, r3, #2
3400e616:	b2db      	uxtb	r3, r3
3400e618:	f003 0310 	and.w	r3, r3, #16
3400e61c:	75fb      	strb	r3, [r7, #23]
	for (base &= 0x3F; val >= base; val /= base) {
3400e61e:	79fb      	ldrb	r3, [r7, #7]
3400e620:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
3400e624:	71fb      	strb	r3, [r7, #7]
3400e626:	e014      	b.n	3400e652 <outint+0x4e>
		*--ep = digits[(val % base) + caps];
3400e628:	79fa      	ldrb	r2, [r7, #7]
3400e62a:	68bb      	ldr	r3, [r7, #8]
3400e62c:	fbb3 f1f2 	udiv	r1, r3, r2
3400e630:	fb01 f202 	mul.w	r2, r1, r2
3400e634:	1a9a      	subs	r2, r3, r2
3400e636:	7dfb      	ldrb	r3, [r7, #23]
3400e638:	4413      	add	r3, r2
3400e63a:	68fa      	ldr	r2, [r7, #12]
3400e63c:	3a01      	subs	r2, #1
3400e63e:	60fa      	str	r2, [r7, #12]
3400e640:	4a0e      	ldr	r2, [pc, #56]	@ (3400e67c <outint+0x78>)
3400e642:	5cd2      	ldrb	r2, [r2, r3]
3400e644:	68fb      	ldr	r3, [r7, #12]
3400e646:	701a      	strb	r2, [r3, #0]
	for (base &= 0x3F; val >= base; val /= base) {
3400e648:	79fb      	ldrb	r3, [r7, #7]
3400e64a:	68ba      	ldr	r2, [r7, #8]
3400e64c:	fbb2 f3f3 	udiv	r3, r2, r3
3400e650:	60bb      	str	r3, [r7, #8]
3400e652:	79fb      	ldrb	r3, [r7, #7]
3400e654:	68ba      	ldr	r2, [r7, #8]
3400e656:	429a      	cmp	r2, r3
3400e658:	d2e6      	bcs.n	3400e628 <outint+0x24>
	}
	*--ep = digits[val + caps];
3400e65a:	7dfa      	ldrb	r2, [r7, #23]
3400e65c:	68bb      	ldr	r3, [r7, #8]
3400e65e:	4413      	add	r3, r2
3400e660:	68fa      	ldr	r2, [r7, #12]
3400e662:	3a01      	subs	r2, #1
3400e664:	60fa      	str	r2, [r7, #12]
3400e666:	4a05      	ldr	r2, [pc, #20]	@ (3400e67c <outint+0x78>)
3400e668:	5cd2      	ldrb	r2, [r2, r3]
3400e66a:	68fb      	ldr	r3, [r7, #12]
3400e66c:	701a      	strb	r2, [r3, #0]
	return ep;				/* buffer top pointer */
3400e66e:	68fb      	ldr	r3, [r7, #12]
}
3400e670:	4618      	mov	r0, r3
3400e672:	371c      	adds	r7, #28
3400e674:	46bd      	mov	sp, r7
3400e676:	f85d 7b04 	ldr.w	r7, [sp], #4
3400e67a:	4770      	bx	lr
3400e67c:	340100dc 	.word	0x340100dc

3400e680 <tm_vsprintf>:

/*
 *	Output with format (limited version)
 */
LOCAL	void	tm_vsprintf( OutFn ostr, OutPar *par, const UB *fmt, va_list ap )
{
3400e680:	b580      	push	{r7, lr}
3400e682:	b090      	sub	sp, #64	@ 0x40
3400e684:	af00      	add	r7, sp, #0
3400e686:	60f8      	str	r0, [r7, #12]
3400e688:	60b9      	str	r1, [r7, #8]
3400e68a:	607a      	str	r2, [r7, #4]
3400e68c:	603b      	str	r3, [r7, #0]
#define	F_PLUS		0x02
#define	F_SPACE		0x04
#define	F_PREFIX	0x08
#define	F_ZERO		0x10

	for (fms = NULL; (c = *fmt++) != '\0'; ) {
3400e68e:	2300      	movs	r3, #0
3400e690:	633b      	str	r3, [r7, #48]	@ 0x30
3400e692:	e2f1      	b.n	3400ec78 <tm_vsprintf+0x5f8>

		if (c != '%') {	/* Fixed string */
3400e694:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e698:	2b25      	cmp	r3, #37	@ 0x25
3400e69a:	d007      	beq.n	3400e6ac <tm_vsprintf+0x2c>
			if (fms == NULL) fms = (UB*)fmt - 1;
3400e69c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400e69e:	2b00      	cmp	r3, #0
3400e6a0:	f040 82e9 	bne.w	3400ec76 <tm_vsprintf+0x5f6>
3400e6a4:	687b      	ldr	r3, [r7, #4]
3400e6a6:	3b01      	subs	r3, #1
3400e6a8:	633b      	str	r3, [r7, #48]	@ 0x30
			continue;
3400e6aa:	e2e4      	b.n	3400ec76 <tm_vsprintf+0x5f6>
		}

		/* Output fix string */
		if (fms != NULL) {
3400e6ac:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400e6ae:	2b00      	cmp	r3, #0
3400e6b0:	d009      	beq.n	3400e6c6 <tm_vsprintf+0x46>
			(*ostr)(fms, fmt - fms - 1, par);
3400e6b2:	687a      	ldr	r2, [r7, #4]
3400e6b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400e6b6:	1ad3      	subs	r3, r2, r3
3400e6b8:	1e59      	subs	r1, r3, #1
3400e6ba:	68fb      	ldr	r3, [r7, #12]
3400e6bc:	68ba      	ldr	r2, [r7, #8]
3400e6be:	6b38      	ldr	r0, [r7, #48]	@ 0x30
3400e6c0:	4798      	blx	r3
			fms = NULL;
3400e6c2:	2300      	movs	r3, #0
3400e6c4:	633b      	str	r3, [r7, #48]	@ 0x30
		}

		/* Get flags */
		for (flg = 0; ; ) {
3400e6c6:	2300      	movs	r3, #0
3400e6c8:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
			switch (c = *fmt++) {
3400e6cc:	687b      	ldr	r3, [r7, #4]
3400e6ce:	1c5a      	adds	r2, r3, #1
3400e6d0:	607a      	str	r2, [r7, #4]
3400e6d2:	781b      	ldrb	r3, [r3, #0]
3400e6d4:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
3400e6d8:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e6dc:	3b20      	subs	r3, #32
3400e6de:	2b10      	cmp	r3, #16
3400e6e0:	d848      	bhi.n	3400e774 <tm_vsprintf+0xf4>
3400e6e2:	a201      	add	r2, pc, #4	@ (adr r2, 3400e6e8 <tm_vsprintf+0x68>)
3400e6e4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3400e6e8:	3400e749 	.word	0x3400e749
3400e6ec:	3400e775 	.word	0x3400e775
3400e6f0:	3400e775 	.word	0x3400e775
3400e6f4:	3400e757 	.word	0x3400e757
3400e6f8:	3400e775 	.word	0x3400e775
3400e6fc:	3400e775 	.word	0x3400e775
3400e700:	3400e775 	.word	0x3400e775
3400e704:	3400e775 	.word	0x3400e775
3400e708:	3400e775 	.word	0x3400e775
3400e70c:	3400e775 	.word	0x3400e775
3400e710:	3400e775 	.word	0x3400e775
3400e714:	3400e73b 	.word	0x3400e73b
3400e718:	3400e775 	.word	0x3400e775
3400e71c:	3400e72d 	.word	0x3400e72d
3400e720:	3400e775 	.word	0x3400e775
3400e724:	3400e775 	.word	0x3400e775
3400e728:	3400e765 	.word	0x3400e765
			case '-': flg |= F_LEFT;	continue;
3400e72c:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400e730:	f043 0301 	orr.w	r3, r3, #1
3400e734:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
3400e738:	e01b      	b.n	3400e772 <tm_vsprintf+0xf2>
			case '+': flg |= F_PLUS;	continue;
3400e73a:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400e73e:	f043 0302 	orr.w	r3, r3, #2
3400e742:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
3400e746:	e014      	b.n	3400e772 <tm_vsprintf+0xf2>
			case ' ': flg |= F_SPACE;	continue;
3400e748:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400e74c:	f043 0304 	orr.w	r3, r3, #4
3400e750:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
3400e754:	e00d      	b.n	3400e772 <tm_vsprintf+0xf2>
			case '#': flg |= F_PREFIX;	continue;
3400e756:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400e75a:	f043 0308 	orr.w	r3, r3, #8
3400e75e:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
3400e762:	e006      	b.n	3400e772 <tm_vsprintf+0xf2>
			case '0': flg |= F_ZERO;	continue;
3400e764:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400e768:	f043 0310 	orr.w	r3, r3, #16
3400e76c:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
3400e770:	bf00      	nop
			switch (c = *fmt++) {
3400e772:	e7ab      	b.n	3400e6cc <tm_vsprintf+0x4c>
			}
			break;
3400e774:	bf00      	nop
		}

		/* Get field width */
		if (c == '*') {
3400e776:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e77a:	2b2a      	cmp	r3, #42	@ 0x2a
3400e77c:	d119      	bne.n	3400e7b2 <tm_vsprintf+0x132>
			wid = va_arg(ap, INT);
3400e77e:	683b      	ldr	r3, [r7, #0]
3400e780:	1d1a      	adds	r2, r3, #4
3400e782:	603a      	str	r2, [r7, #0]
3400e784:	681b      	ldr	r3, [r3, #0]
3400e786:	877b      	strh	r3, [r7, #58]	@ 0x3a
			if (wid < 0) {
3400e788:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	@ 0x3a
3400e78c:	2b00      	cmp	r3, #0
3400e78e:	da09      	bge.n	3400e7a4 <tm_vsprintf+0x124>
				wid = -wid;
3400e790:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
3400e792:	425b      	negs	r3, r3
3400e794:	b29b      	uxth	r3, r3
3400e796:	877b      	strh	r3, [r7, #58]	@ 0x3a
				flg |= F_LEFT;
3400e798:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400e79c:	f043 0301 	orr.w	r3, r3, #1
3400e7a0:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
			}
			c = *fmt++;
3400e7a4:	687b      	ldr	r3, [r7, #4]
3400e7a6:	1c5a      	adds	r2, r3, #1
3400e7a8:	607a      	str	r2, [r7, #4]
3400e7aa:	781b      	ldrb	r3, [r3, #0]
3400e7ac:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
3400e7b0:	e01e      	b.n	3400e7f0 <tm_vsprintf+0x170>
		} else {
			for (wid = 0; c >= '0' && c <= '9'; c = *fmt++)
3400e7b2:	2300      	movs	r3, #0
3400e7b4:	877b      	strh	r3, [r7, #58]	@ 0x3a
3400e7b6:	e013      	b.n	3400e7e0 <tm_vsprintf+0x160>
				wid = wid * 10 + c - '0';
3400e7b8:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
3400e7ba:	461a      	mov	r2, r3
3400e7bc:	0092      	lsls	r2, r2, #2
3400e7be:	4413      	add	r3, r2
3400e7c0:	005b      	lsls	r3, r3, #1
3400e7c2:	b29a      	uxth	r2, r3
3400e7c4:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e7c8:	b29b      	uxth	r3, r3
3400e7ca:	4413      	add	r3, r2
3400e7cc:	b29b      	uxth	r3, r3
3400e7ce:	3b30      	subs	r3, #48	@ 0x30
3400e7d0:	b29b      	uxth	r3, r3
3400e7d2:	877b      	strh	r3, [r7, #58]	@ 0x3a
			for (wid = 0; c >= '0' && c <= '9'; c = *fmt++)
3400e7d4:	687b      	ldr	r3, [r7, #4]
3400e7d6:	1c5a      	adds	r2, r3, #1
3400e7d8:	607a      	str	r2, [r7, #4]
3400e7da:	781b      	ldrb	r3, [r3, #0]
3400e7dc:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
3400e7e0:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e7e4:	2b2f      	cmp	r3, #47	@ 0x2f
3400e7e6:	d903      	bls.n	3400e7f0 <tm_vsprintf+0x170>
3400e7e8:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e7ec:	2b39      	cmp	r3, #57	@ 0x39
3400e7ee:	d9e3      	bls.n	3400e7b8 <tm_vsprintf+0x138>
		}

		/* Get precision */
		prec = -1;
3400e7f0:	f64f 73ff 	movw	r3, #65535	@ 0xffff
3400e7f4:	873b      	strh	r3, [r7, #56]	@ 0x38
		if (c == '.') {
3400e7f6:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e7fa:	2b2e      	cmp	r3, #46	@ 0x2e
3400e7fc:	d140      	bne.n	3400e880 <tm_vsprintf+0x200>
			c = *fmt++;
3400e7fe:	687b      	ldr	r3, [r7, #4]
3400e800:	1c5a      	adds	r2, r3, #1
3400e802:	607a      	str	r2, [r7, #4]
3400e804:	781b      	ldrb	r3, [r3, #0]
3400e806:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
			if (c == '*') {
3400e80a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e80e:	2b2a      	cmp	r3, #42	@ 0x2a
3400e810:	d111      	bne.n	3400e836 <tm_vsprintf+0x1b6>
				prec = va_arg(ap, INT);
3400e812:	683b      	ldr	r3, [r7, #0]
3400e814:	1d1a      	adds	r2, r3, #4
3400e816:	603a      	str	r2, [r7, #0]
3400e818:	681b      	ldr	r3, [r3, #0]
3400e81a:	873b      	strh	r3, [r7, #56]	@ 0x38
				if (prec < 0) prec = 0;
3400e81c:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	@ 0x38
3400e820:	2b00      	cmp	r3, #0
3400e822:	da01      	bge.n	3400e828 <tm_vsprintf+0x1a8>
3400e824:	2300      	movs	r3, #0
3400e826:	873b      	strh	r3, [r7, #56]	@ 0x38
				c = *fmt++;
3400e828:	687b      	ldr	r3, [r7, #4]
3400e82a:	1c5a      	adds	r2, r3, #1
3400e82c:	607a      	str	r2, [r7, #4]
3400e82e:	781b      	ldrb	r3, [r3, #0]
3400e830:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
3400e834:	e01e      	b.n	3400e874 <tm_vsprintf+0x1f4>
			} else {
				for (prec = 0;c >= '0' && c <= '9';c = *fmt++)
3400e836:	2300      	movs	r3, #0
3400e838:	873b      	strh	r3, [r7, #56]	@ 0x38
3400e83a:	e013      	b.n	3400e864 <tm_vsprintf+0x1e4>
					prec = prec * 10 + c - '0';
3400e83c:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
3400e83e:	461a      	mov	r2, r3
3400e840:	0092      	lsls	r2, r2, #2
3400e842:	4413      	add	r3, r2
3400e844:	005b      	lsls	r3, r3, #1
3400e846:	b29a      	uxth	r2, r3
3400e848:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e84c:	b29b      	uxth	r3, r3
3400e84e:	4413      	add	r3, r2
3400e850:	b29b      	uxth	r3, r3
3400e852:	3b30      	subs	r3, #48	@ 0x30
3400e854:	b29b      	uxth	r3, r3
3400e856:	873b      	strh	r3, [r7, #56]	@ 0x38
				for (prec = 0;c >= '0' && c <= '9';c = *fmt++)
3400e858:	687b      	ldr	r3, [r7, #4]
3400e85a:	1c5a      	adds	r2, r3, #1
3400e85c:	607a      	str	r2, [r7, #4]
3400e85e:	781b      	ldrb	r3, [r3, #0]
3400e860:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
3400e864:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e868:	2b2f      	cmp	r3, #47	@ 0x2f
3400e86a:	d903      	bls.n	3400e874 <tm_vsprintf+0x1f4>
3400e86c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e870:	2b39      	cmp	r3, #57	@ 0x39
3400e872:	d9e3      	bls.n	3400e83c <tm_vsprintf+0x1bc>
			}
			flg &= ~F_ZERO;		/* No ZERO padding */
3400e874:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400e878:	f023 0310 	bic.w	r3, r3, #16
3400e87c:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
		}

		/* Get qualifier */
		qual = 0;
3400e880:	2300      	movs	r3, #0
3400e882:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
		if (c == 'h' || c == 'l') {
3400e886:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e88a:	2b68      	cmp	r3, #104	@ 0x68
3400e88c:	d003      	beq.n	3400e896 <tm_vsprintf+0x216>
3400e88e:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e892:	2b6c      	cmp	r3, #108	@ 0x6c
3400e894:	d109      	bne.n	3400e8aa <tm_vsprintf+0x22a>
			qual = c;
3400e896:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e89a:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
			c = *fmt++;
3400e89e:	687b      	ldr	r3, [r7, #4]
3400e8a0:	1c5a      	adds	r2, r3, #1
3400e8a2:	607a      	str	r2, [r7, #4]
3400e8a4:	781b      	ldrb	r3, [r3, #0]
3400e8a6:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
		}

		/* Format items */
		base = 10;
3400e8aa:	230a      	movs	r3, #10
3400e8ac:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
		sign = 0;
3400e8b0:	2300      	movs	r3, #0
3400e8b2:	74fb      	strb	r3, [r7, #19]
		cbe = &cbuf[MAX_DIGITS];	/* buffer end pointer */
3400e8b4:	f107 0314 	add.w	r3, r7, #20
3400e8b8:	330e      	adds	r3, #14
3400e8ba:	62bb      	str	r3, [r7, #40]	@ 0x28

		switch (c) {
3400e8bc:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e8c0:	2b78      	cmp	r3, #120	@ 0x78
3400e8c2:	f300 814d 	bgt.w	3400eb60 <tm_vsprintf+0x4e0>
3400e8c6:	2b64      	cmp	r3, #100	@ 0x64
3400e8c8:	da0b      	bge.n	3400e8e2 <tm_vsprintf+0x262>
3400e8ca:	2b63      	cmp	r3, #99	@ 0x63
3400e8cc:	f000 8135 	beq.w	3400eb3a <tm_vsprintf+0x4ba>
3400e8d0:	2b63      	cmp	r3, #99	@ 0x63
3400e8d2:	f300 8145 	bgt.w	3400eb60 <tm_vsprintf+0x4e0>
3400e8d6:	2b00      	cmp	r3, #0
3400e8d8:	f000 813e 	beq.w	3400eb58 <tm_vsprintf+0x4d8>
3400e8dc:	2b58      	cmp	r3, #88	@ 0x58
3400e8de:	d022      	beq.n	3400e926 <tm_vsprintf+0x2a6>
3400e8e0:	e13e      	b.n	3400eb60 <tm_vsprintf+0x4e0>
3400e8e2:	3b64      	subs	r3, #100	@ 0x64
3400e8e4:	2201      	movs	r2, #1
3400e8e6:	fa02 f303 	lsl.w	r3, r2, r3
3400e8ea:	4a9f      	ldr	r2, [pc, #636]	@ (3400eb68 <tm_vsprintf+0x4e8>)
3400e8ec:	401a      	ands	r2, r3
3400e8ee:	2a00      	cmp	r2, #0
3400e8f0:	bf14      	ite	ne
3400e8f2:	2201      	movne	r2, #1
3400e8f4:	2200      	moveq	r2, #0
3400e8f6:	b2d2      	uxtb	r2, r2
3400e8f8:	2a00      	cmp	r2, #0
3400e8fa:	d114      	bne.n	3400e926 <tm_vsprintf+0x2a6>
3400e8fc:	f403 4200 	and.w	r2, r3, #32768	@ 0x8000
3400e900:	2a00      	cmp	r2, #0
3400e902:	bf14      	ite	ne
3400e904:	2201      	movne	r2, #1
3400e906:	2200      	moveq	r2, #0
3400e908:	b2d2      	uxtb	r2, r2
3400e90a:	2a00      	cmp	r2, #0
3400e90c:	f040 80f1 	bne.w	3400eaf2 <tm_vsprintf+0x472>
3400e910:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
3400e914:	2b00      	cmp	r3, #0
3400e916:	bf14      	ite	ne
3400e918:	2301      	movne	r3, #1
3400e91a:	2300      	moveq	r3, #0
3400e91c:	b2db      	uxtb	r3, r3
3400e91e:	2b00      	cmp	r3, #0
3400e920:	f040 80cf 	bne.w	3400eac2 <tm_vsprintf+0x442>
3400e924:	e11c      	b.n	3400eb60 <tm_vsprintf+0x4e0>
		case 'd':
		case 'u':
		case 'X':
		case 'x':
		case 'o':
			if (qual == 'l') {
3400e926:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
3400e92a:	2b6c      	cmp	r3, #108	@ 0x6c
3400e92c:	d105      	bne.n	3400e93a <tm_vsprintf+0x2ba>
				v = va_arg(ap, UW);
3400e92e:	683b      	ldr	r3, [r7, #0]
3400e930:	1d1a      	adds	r2, r3, #4
3400e932:	603a      	str	r2, [r7, #0]
3400e934:	681b      	ldr	r3, [r3, #0]
3400e936:	63fb      	str	r3, [r7, #60]	@ 0x3c
3400e938:	e016      	b.n	3400e968 <tm_vsprintf+0x2e8>
			} else {
				v = va_arg(ap, UINT);
3400e93a:	683b      	ldr	r3, [r7, #0]
3400e93c:	1d1a      	adds	r2, r3, #4
3400e93e:	603a      	str	r2, [r7, #0]
3400e940:	681b      	ldr	r3, [r3, #0]
3400e942:	63fb      	str	r3, [r7, #60]	@ 0x3c
				if (qual == 'h') {
3400e944:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
3400e948:	2b68      	cmp	r3, #104	@ 0x68
3400e94a:	d10d      	bne.n	3400e968 <tm_vsprintf+0x2e8>
					v = (c == 'i' || c == 'd') ?
						(H)v :(UH)v;
3400e94c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e950:	2b69      	cmp	r3, #105	@ 0x69
3400e952:	d003      	beq.n	3400e95c <tm_vsprintf+0x2dc>
					v = (c == 'i' || c == 'd') ?
3400e954:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e958:	2b64      	cmp	r3, #100	@ 0x64
3400e95a:	d102      	bne.n	3400e962 <tm_vsprintf+0x2e2>
						(H)v :(UH)v;
3400e95c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400e95e:	b21b      	sxth	r3, r3
3400e960:	e001      	b.n	3400e966 <tm_vsprintf+0x2e6>
3400e962:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400e964:	b29b      	uxth	r3, r3
					v = (c == 'i' || c == 'd') ?
3400e966:	63fb      	str	r3, [r7, #60]	@ 0x3c
				}
			}
			switch (c) {
3400e968:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400e96c:	3b58      	subs	r3, #88	@ 0x58
3400e96e:	2b20      	cmp	r3, #32
3400e970:	f200 8094 	bhi.w	3400ea9c <tm_vsprintf+0x41c>
3400e974:	a201      	add	r2, pc, #4	@ (adr r2, 3400e97c <tm_vsprintf+0x2fc>)
3400e976:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
3400e97a:	bf00      	nop
3400e97c:	3400ea43 	.word	0x3400ea43
3400e980:	3400ea9d 	.word	0x3400ea9d
3400e984:	3400ea9d 	.word	0x3400ea9d
3400e988:	3400ea9d 	.word	0x3400ea9d
3400e98c:	3400ea9d 	.word	0x3400ea9d
3400e990:	3400ea9d 	.word	0x3400ea9d
3400e994:	3400ea9d 	.word	0x3400ea9d
3400e998:	3400ea9d 	.word	0x3400ea9d
3400e99c:	3400ea9d 	.word	0x3400ea9d
3400e9a0:	3400ea9d 	.word	0x3400ea9d
3400e9a4:	3400ea9d 	.word	0x3400ea9d
3400e9a8:	3400ea9d 	.word	0x3400ea9d
3400e9ac:	3400ea01 	.word	0x3400ea01
3400e9b0:	3400ea9d 	.word	0x3400ea9d
3400e9b4:	3400ea9d 	.word	0x3400ea9d
3400e9b8:	3400ea9d 	.word	0x3400ea9d
3400e9bc:	3400ea9d 	.word	0x3400ea9d
3400e9c0:	3400ea01 	.word	0x3400ea01
3400e9c4:	3400ea9d 	.word	0x3400ea9d
3400e9c8:	3400ea9d 	.word	0x3400ea9d
3400e9cc:	3400ea9d 	.word	0x3400ea9d
3400e9d0:	3400ea9d 	.word	0x3400ea9d
3400e9d4:	3400ea9d 	.word	0x3400ea9d
3400e9d8:	3400ea57 	.word	0x3400ea57
3400e9dc:	3400ea9d 	.word	0x3400ea9d
3400e9e0:	3400ea9d 	.word	0x3400ea9d
3400e9e4:	3400ea9d 	.word	0x3400ea9d
3400e9e8:	3400ea9d 	.word	0x3400ea9d
3400e9ec:	3400ea9d 	.word	0x3400ea9d
3400e9f0:	3400ea9d 	.word	0x3400ea9d
3400e9f4:	3400ea9d 	.word	0x3400ea9d
3400e9f8:	3400ea9d 	.word	0x3400ea9d
3400e9fc:	3400ea4d 	.word	0x3400ea4d
			case 'i':
			case 'd':
				if ((W)v < 0) {
3400ea00:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400ea02:	2b00      	cmp	r3, #0
3400ea04:	da05      	bge.n	3400ea12 <tm_vsprintf+0x392>
					v = - (W)v;
3400ea06:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400ea08:	425b      	negs	r3, r3
3400ea0a:	63fb      	str	r3, [r7, #60]	@ 0x3c
					sign = '-';
3400ea0c:	232d      	movs	r3, #45	@ 0x2d
3400ea0e:	74fb      	strb	r3, [r7, #19]
3400ea10:	e010      	b.n	3400ea34 <tm_vsprintf+0x3b4>
				} else if ((flg & F_PLUS) != 0) {
3400ea12:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400ea16:	f003 0302 	and.w	r3, r3, #2
3400ea1a:	2b00      	cmp	r3, #0
3400ea1c:	d002      	beq.n	3400ea24 <tm_vsprintf+0x3a4>
					sign = '+';
3400ea1e:	232b      	movs	r3, #43	@ 0x2b
3400ea20:	74fb      	strb	r3, [r7, #19]
3400ea22:	e007      	b.n	3400ea34 <tm_vsprintf+0x3b4>
				} else if ((flg & F_SPACE) != 0) {
3400ea24:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400ea28:	f003 0304 	and.w	r3, r3, #4
3400ea2c:	2b00      	cmp	r3, #0
3400ea2e:	d032      	beq.n	3400ea96 <tm_vsprintf+0x416>
					sign = ' ';
3400ea30:	2320      	movs	r3, #32
3400ea32:	74fb      	strb	r3, [r7, #19]
				} else {
					break;
				}
				wid--;		/* for sign */
3400ea34:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	@ 0x3a
3400ea38:	b29b      	uxth	r3, r3
3400ea3a:	3b01      	subs	r3, #1
3400ea3c:	b29b      	uxth	r3, r3
3400ea3e:	877b      	strh	r3, [r7, #58]	@ 0x3a
			case 'u':
				break;
3400ea40:	e02c      	b.n	3400ea9c <tm_vsprintf+0x41c>
			case 'X':
				base += 0x40;	/* base = 16 + 0x40 */
3400ea42:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400ea46:	3340      	adds	r3, #64	@ 0x40
3400ea48:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
			case 'x':
				base += 8;	/* base = 16 */
3400ea4c:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400ea50:	3308      	adds	r3, #8
3400ea52:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
			case 'o':
				base -= 2;	/* base = 8 */
3400ea56:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400ea5a:	3b02      	subs	r3, #2
3400ea5c:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
				if ((flg & F_PREFIX) != 0 && v != 0) {
3400ea60:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400ea64:	f003 0308 	and.w	r3, r3, #8
3400ea68:	2b00      	cmp	r3, #0
3400ea6a:	d016      	beq.n	3400ea9a <tm_vsprintf+0x41a>
3400ea6c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400ea6e:	2b00      	cmp	r3, #0
3400ea70:	d013      	beq.n	3400ea9a <tm_vsprintf+0x41a>
					wid -= (base == 8) ? 1 : 2;
3400ea72:	8f7a      	ldrh	r2, [r7, #58]	@ 0x3a
3400ea74:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400ea78:	2b08      	cmp	r3, #8
3400ea7a:	d101      	bne.n	3400ea80 <tm_vsprintf+0x400>
3400ea7c:	2301      	movs	r3, #1
3400ea7e:	e000      	b.n	3400ea82 <tm_vsprintf+0x402>
3400ea80:	2302      	movs	r3, #2
3400ea82:	1ad3      	subs	r3, r2, r3
3400ea84:	b29b      	uxth	r3, r3
3400ea86:	877b      	strh	r3, [r7, #58]	@ 0x3a
					base |= 0x80;
3400ea88:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400ea8c:	f063 037f 	orn	r3, r3, #127	@ 0x7f
3400ea90:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
				}
				break;
3400ea94:	e001      	b.n	3400ea9a <tm_vsprintf+0x41a>
					break;
3400ea96:	bf00      	nop
3400ea98:	e000      	b.n	3400ea9c <tm_vsprintf+0x41c>
				break;
3400ea9a:	bf00      	nop
			}
			/* Note: None outputs when v == 0 && prec == 0 */
			cbs = (v == 0 && prec == 0) ?
						cbe : outint(cbe, v, base);
3400ea9c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400ea9e:	2b00      	cmp	r3, #0
3400eaa0:	d103      	bne.n	3400eaaa <tm_vsprintf+0x42a>
			cbs = (v == 0 && prec == 0) ?
3400eaa2:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	@ 0x38
3400eaa6:	2b00      	cmp	r3, #0
3400eaa8:	d008      	beq.n	3400eabc <tm_vsprintf+0x43c>
						cbe : outint(cbe, v, base);
3400eaaa:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400eaae:	461a      	mov	r2, r3
3400eab0:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
3400eab2:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
3400eab4:	f7ff fda6 	bl	3400e604 <outint>
3400eab8:	4603      	mov	r3, r0
3400eaba:	e000      	b.n	3400eabe <tm_vsprintf+0x43e>
3400eabc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
			cbs = (v == 0 && prec == 0) ?
3400eabe:	62fb      	str	r3, [r7, #44]	@ 0x2c
			break;
3400eac0:	e055      	b.n	3400eb6e <tm_vsprintf+0x4ee>
		case 'p':
			v = (UW)va_arg(ap, void *);
3400eac2:	683b      	ldr	r3, [r7, #0]
3400eac4:	1d1a      	adds	r2, r3, #4
3400eac6:	603a      	str	r2, [r7, #0]
3400eac8:	681b      	ldr	r3, [r3, #0]
3400eaca:	63fb      	str	r3, [r7, #60]	@ 0x3c
			if (v != 0) {
3400eacc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400eace:	2b00      	cmp	r3, #0
3400ead0:	d006      	beq.n	3400eae0 <tm_vsprintf+0x460>
				base = 16 | 0x80;
3400ead2:	2390      	movs	r3, #144	@ 0x90
3400ead4:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
				wid -= 2;
3400ead8:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
3400eada:	3b02      	subs	r3, #2
3400eadc:	b29b      	uxth	r3, r3
3400eade:	877b      	strh	r3, [r7, #58]	@ 0x3a
			}
			cbs = outint(cbe, v, base);
3400eae0:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400eae4:	461a      	mov	r2, r3
3400eae6:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
3400eae8:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
3400eaea:	f7ff fd8b 	bl	3400e604 <outint>
3400eaee:	62f8      	str	r0, [r7, #44]	@ 0x2c
			break;
3400eaf0:	e03d      	b.n	3400eb6e <tm_vsprintf+0x4ee>
		case 's':
			cbe = cbs = va_arg(ap, UB *);
3400eaf2:	683b      	ldr	r3, [r7, #0]
3400eaf4:	1d1a      	adds	r2, r3, #4
3400eaf6:	603a      	str	r2, [r7, #0]
3400eaf8:	681b      	ldr	r3, [r3, #0]
3400eafa:	62fb      	str	r3, [r7, #44]	@ 0x2c
3400eafc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400eafe:	62bb      	str	r3, [r7, #40]	@ 0x28
			if (prec < 0) {
3400eb00:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	@ 0x38
3400eb04:	2b00      	cmp	r3, #0
3400eb06:	da0b      	bge.n	3400eb20 <tm_vsprintf+0x4a0>
				while (*cbe != '\0') cbe++;
3400eb08:	e002      	b.n	3400eb10 <tm_vsprintf+0x490>
3400eb0a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400eb0c:	3301      	adds	r3, #1
3400eb0e:	62bb      	str	r3, [r7, #40]	@ 0x28
3400eb10:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400eb12:	781b      	ldrb	r3, [r3, #0]
3400eb14:	2b00      	cmp	r3, #0
3400eb16:	d1f8      	bne.n	3400eb0a <tm_vsprintf+0x48a>
			} else {
				while (--prec >= 0 && *cbe != '\0') cbe++;
			}
			break;
3400eb18:	e028      	b.n	3400eb6c <tm_vsprintf+0x4ec>
				while (--prec >= 0 && *cbe != '\0') cbe++;
3400eb1a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400eb1c:	3301      	adds	r3, #1
3400eb1e:	62bb      	str	r3, [r7, #40]	@ 0x28
3400eb20:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
3400eb22:	3b01      	subs	r3, #1
3400eb24:	b29b      	uxth	r3, r3
3400eb26:	873b      	strh	r3, [r7, #56]	@ 0x38
3400eb28:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	@ 0x38
3400eb2c:	2b00      	cmp	r3, #0
3400eb2e:	db1d      	blt.n	3400eb6c <tm_vsprintf+0x4ec>
3400eb30:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400eb32:	781b      	ldrb	r3, [r3, #0]
3400eb34:	2b00      	cmp	r3, #0
3400eb36:	d1f0      	bne.n	3400eb1a <tm_vsprintf+0x49a>
			break;
3400eb38:	e018      	b.n	3400eb6c <tm_vsprintf+0x4ec>
		case 'c':
			cbs = cbe;
3400eb3a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
3400eb3c:	62fb      	str	r3, [r7, #44]	@ 0x2c
			*--cbs = (UB)va_arg(ap, INT);
3400eb3e:	683b      	ldr	r3, [r7, #0]
3400eb40:	1d1a      	adds	r2, r3, #4
3400eb42:	603a      	str	r2, [r7, #0]
3400eb44:	681a      	ldr	r2, [r3, #0]
3400eb46:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400eb48:	3b01      	subs	r3, #1
3400eb4a:	62fb      	str	r3, [r7, #44]	@ 0x2c
3400eb4c:	b2d2      	uxtb	r2, r2
3400eb4e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400eb50:	701a      	strb	r2, [r3, #0]
			prec = 0;
3400eb52:	2300      	movs	r3, #0
3400eb54:	873b      	strh	r3, [r7, #56]	@ 0x38
			break;
3400eb56:	e00a      	b.n	3400eb6e <tm_vsprintf+0x4ee>
		case '\0':
			fmt--;
3400eb58:	687b      	ldr	r3, [r7, #4]
3400eb5a:	3b01      	subs	r3, #1
3400eb5c:	607b      	str	r3, [r7, #4]
			continue;
3400eb5e:	e08b      	b.n	3400ec78 <tm_vsprintf+0x5f8>
		default:
			/* Output as fixed string */
			fms = (UB*)fmt - 1;
3400eb60:	687b      	ldr	r3, [r7, #4]
3400eb62:	3b01      	subs	r3, #1
3400eb64:	633b      	str	r3, [r7, #48]	@ 0x30
			continue;
3400eb66:	e087      	b.n	3400ec78 <tm_vsprintf+0x5f8>
3400eb68:	00120821 	.word	0x00120821
			break;
3400eb6c:	bf00      	nop
		}

		n = cbe - cbs;				/* item length */
3400eb6e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400eb70:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400eb72:	1ad3      	subs	r3, r2, r3
3400eb74:	86fb      	strh	r3, [r7, #54]	@ 0x36
		if ((prec -= n) > 0) n += prec;
3400eb76:	8f3a      	ldrh	r2, [r7, #56]	@ 0x38
3400eb78:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
3400eb7a:	1ad3      	subs	r3, r2, r3
3400eb7c:	b29b      	uxth	r3, r3
3400eb7e:	873b      	strh	r3, [r7, #56]	@ 0x38
3400eb80:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	@ 0x38
3400eb84:	2b00      	cmp	r3, #0
3400eb86:	dd04      	ble.n	3400eb92 <tm_vsprintf+0x512>
3400eb88:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
3400eb8a:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
3400eb8c:	4413      	add	r3, r2
3400eb8e:	b29b      	uxth	r3, r3
3400eb90:	86fb      	strh	r3, [r7, #54]	@ 0x36
		wid -= n;				/* pad length */
3400eb92:	8f7a      	ldrh	r2, [r7, #58]	@ 0x3a
3400eb94:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
3400eb96:	1ad3      	subs	r3, r2, r3
3400eb98:	b29b      	uxth	r3, r3
3400eb9a:	877b      	strh	r3, [r7, #58]	@ 0x3a

		/* Output preceding spaces */
		if ((flg & (F_LEFT | F_ZERO)) == 0 ) {
3400eb9c:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400eba0:	f003 0311 	and.w	r3, r3, #17
3400eba4:	2b00      	cmp	r3, #0
3400eba6:	d10d      	bne.n	3400ebc4 <tm_vsprintf+0x544>
			while (--wid >= 0) (*ostr)((UB*)" ", 1, par);
3400eba8:	e004      	b.n	3400ebb4 <tm_vsprintf+0x534>
3400ebaa:	68fb      	ldr	r3, [r7, #12]
3400ebac:	68ba      	ldr	r2, [r7, #8]
3400ebae:	2101      	movs	r1, #1
3400ebb0:	483e      	ldr	r0, [pc, #248]	@ (3400ecac <tm_vsprintf+0x62c>)
3400ebb2:	4798      	blx	r3
3400ebb4:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
3400ebb6:	3b01      	subs	r3, #1
3400ebb8:	b29b      	uxth	r3, r3
3400ebba:	877b      	strh	r3, [r7, #58]	@ 0x3a
3400ebbc:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	@ 0x3a
3400ebc0:	2b00      	cmp	r3, #0
3400ebc2:	daf2      	bge.n	3400ebaa <tm_vsprintf+0x52a>
		}

		/* Output sign */
		if (sign != 0) {
3400ebc4:	7cfb      	ldrb	r3, [r7, #19]
3400ebc6:	2b00      	cmp	r3, #0
3400ebc8:	d005      	beq.n	3400ebd6 <tm_vsprintf+0x556>
			(*ostr)(&sign, 1, par);
3400ebca:	f107 0013 	add.w	r0, r7, #19
3400ebce:	68fb      	ldr	r3, [r7, #12]
3400ebd0:	68ba      	ldr	r2, [r7, #8]
3400ebd2:	2101      	movs	r1, #1
3400ebd4:	4798      	blx	r3
		}

		/* Output prefix "0x", "0X" or "0" */
		if ((base & 0x80) != 0) {
3400ebd6:	f997 3026 	ldrsb.w	r3, [r7, #38]	@ 0x26
3400ebda:	2b00      	cmp	r3, #0
3400ebdc:	da17      	bge.n	3400ec0e <tm_vsprintf+0x58e>
			(*ostr)((UB*)"0", 1, par);
3400ebde:	68fb      	ldr	r3, [r7, #12]
3400ebe0:	68ba      	ldr	r2, [r7, #8]
3400ebe2:	2101      	movs	r1, #1
3400ebe4:	4832      	ldr	r0, [pc, #200]	@ (3400ecb0 <tm_vsprintf+0x630>)
3400ebe6:	4798      	blx	r3
			if ((base & 0x10) != 0) {
3400ebe8:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400ebec:	f003 0310 	and.w	r3, r3, #16
3400ebf0:	2b00      	cmp	r3, #0
3400ebf2:	d00c      	beq.n	3400ec0e <tm_vsprintf+0x58e>
				(*ostr)((base & 0x40) ? (UB*)"X" : (UB*)"x", 1, par);
3400ebf4:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
3400ebf8:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400ebfc:	2b00      	cmp	r3, #0
3400ebfe:	d001      	beq.n	3400ec04 <tm_vsprintf+0x584>
3400ec00:	482c      	ldr	r0, [pc, #176]	@ (3400ecb4 <tm_vsprintf+0x634>)
3400ec02:	e000      	b.n	3400ec06 <tm_vsprintf+0x586>
3400ec04:	482c      	ldr	r0, [pc, #176]	@ (3400ecb8 <tm_vsprintf+0x638>)
3400ec06:	68fb      	ldr	r3, [r7, #12]
3400ec08:	68ba      	ldr	r2, [r7, #8]
3400ec0a:	2101      	movs	r1, #1
3400ec0c:	4798      	blx	r3
			}
		}

		/* Output preceding zeros for precision or padding */
		if ((n = prec) <= 0) {
3400ec0e:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
3400ec10:	86fb      	strh	r3, [r7, #54]	@ 0x36
3400ec12:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	@ 0x36
3400ec16:	2b00      	cmp	r3, #0
3400ec18:	dc0f      	bgt.n	3400ec3a <tm_vsprintf+0x5ba>
			if ((flg & (F_LEFT | F_ZERO)) == F_ZERO ) {
3400ec1a:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
3400ec1e:	f003 0311 	and.w	r3, r3, #17
3400ec22:	2b10      	cmp	r3, #16
3400ec24:	d109      	bne.n	3400ec3a <tm_vsprintf+0x5ba>
				n = wid;
3400ec26:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
3400ec28:	86fb      	strh	r3, [r7, #54]	@ 0x36
				wid = 0;
3400ec2a:	2300      	movs	r3, #0
3400ec2c:	877b      	strh	r3, [r7, #58]	@ 0x3a
			}
		}
		while (--n >= 0) (*ostr)((UB*)"0", 1, par);
3400ec2e:	e004      	b.n	3400ec3a <tm_vsprintf+0x5ba>
3400ec30:	68fb      	ldr	r3, [r7, #12]
3400ec32:	68ba      	ldr	r2, [r7, #8]
3400ec34:	2101      	movs	r1, #1
3400ec36:	481e      	ldr	r0, [pc, #120]	@ (3400ecb0 <tm_vsprintf+0x630>)
3400ec38:	4798      	blx	r3
3400ec3a:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
3400ec3c:	3b01      	subs	r3, #1
3400ec3e:	b29b      	uxth	r3, r3
3400ec40:	86fb      	strh	r3, [r7, #54]	@ 0x36
3400ec42:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	@ 0x36
3400ec46:	2b00      	cmp	r3, #0
3400ec48:	daf2      	bge.n	3400ec30 <tm_vsprintf+0x5b0>

		/* Output item string */
		(*ostr)(cbs, cbe - cbs, par);
3400ec4a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
3400ec4c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
3400ec4e:	1ad1      	subs	r1, r2, r3
3400ec50:	68fb      	ldr	r3, [r7, #12]
3400ec52:	68ba      	ldr	r2, [r7, #8]
3400ec54:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
3400ec56:	4798      	blx	r3

		/* Output tailing spaces */
		while (--wid >= 0) (*ostr)((UB*)" ", 1, par);
3400ec58:	e004      	b.n	3400ec64 <tm_vsprintf+0x5e4>
3400ec5a:	68fb      	ldr	r3, [r7, #12]
3400ec5c:	68ba      	ldr	r2, [r7, #8]
3400ec5e:	2101      	movs	r1, #1
3400ec60:	4812      	ldr	r0, [pc, #72]	@ (3400ecac <tm_vsprintf+0x62c>)
3400ec62:	4798      	blx	r3
3400ec64:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
3400ec66:	3b01      	subs	r3, #1
3400ec68:	b29b      	uxth	r3, r3
3400ec6a:	877b      	strh	r3, [r7, #58]	@ 0x3a
3400ec6c:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	@ 0x3a
3400ec70:	2b00      	cmp	r3, #0
3400ec72:	daf2      	bge.n	3400ec5a <tm_vsprintf+0x5da>
3400ec74:	e000      	b.n	3400ec78 <tm_vsprintf+0x5f8>
			continue;
3400ec76:	bf00      	nop
	for (fms = NULL; (c = *fmt++) != '\0'; ) {
3400ec78:	687b      	ldr	r3, [r7, #4]
3400ec7a:	1c5a      	adds	r2, r3, #1
3400ec7c:	607a      	str	r2, [r7, #4]
3400ec7e:	781b      	ldrb	r3, [r3, #0]
3400ec80:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
3400ec84:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
3400ec88:	2b00      	cmp	r3, #0
3400ec8a:	f47f ad03 	bne.w	3400e694 <tm_vsprintf+0x14>
	}

	/* Output last fix string */
	if (fms != NULL) {
3400ec8e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400ec90:	2b00      	cmp	r3, #0
3400ec92:	d007      	beq.n	3400eca4 <tm_vsprintf+0x624>
		(*ostr)(fms, fmt - fms - 1, par);
3400ec94:	687a      	ldr	r2, [r7, #4]
3400ec96:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
3400ec98:	1ad3      	subs	r3, r2, r3
3400ec9a:	1e59      	subs	r1, r3, #1
3400ec9c:	68fb      	ldr	r3, [r7, #12]
3400ec9e:	68ba      	ldr	r2, [r7, #8]
3400eca0:	6b38      	ldr	r0, [r7, #48]	@ 0x30
3400eca2:	4798      	blx	r3
	}
#if	TM_OUTBUF_SZ > 0
	/* Flush output */
	(*ostr)(NULL, 0, par);
#endif
}
3400eca4:	bf00      	nop
3400eca6:	3740      	adds	r7, #64	@ 0x40
3400eca8:	46bd      	mov	sp, r7
3400ecaa:	bd80      	pop	{r7, pc}
3400ecac:	3400fec0 	.word	0x3400fec0
3400ecb0:	3400fec4 	.word	0x3400fec4
3400ecb4:	3400fec8 	.word	0x3400fec8
3400ecb8:	3400fecc 	.word	0x3400fecc

3400ecbc <out_cons>:

/*
 *	Output to console
 */
LOCAL	void	out_cons( UB *str, INT len,  OutPar *par )
{
3400ecbc:	b580      	push	{r7, lr}
3400ecbe:	b084      	sub	sp, #16
3400ecc0:	af00      	add	r7, sp, #0
3400ecc2:	60f8      	str	r0, [r7, #12]
3400ecc4:	60b9      	str	r1, [r7, #8]
3400ecc6:	607a      	str	r2, [r7, #4]
#if	TM_OUTBUF_SZ == 0
	/* Direct output to console */
	par->len += len;
3400ecc8:	687b      	ldr	r3, [r7, #4]
3400ecca:	f9b3 3000 	ldrsh.w	r3, [r3]
3400ecce:	b29a      	uxth	r2, r3
3400ecd0:	68bb      	ldr	r3, [r7, #8]
3400ecd2:	b29b      	uxth	r3, r3
3400ecd4:	4413      	add	r3, r2
3400ecd6:	b29b      	uxth	r3, r3
3400ecd8:	b21a      	sxth	r2, r3
3400ecda:	687b      	ldr	r3, [r7, #4]
3400ecdc:	801a      	strh	r2, [r3, #0]
	while (--len >= 0) tm_putchar(*str++);
3400ecde:	e006      	b.n	3400ecee <out_cons+0x32>
3400ece0:	68fb      	ldr	r3, [r7, #12]
3400ece2:	1c5a      	adds	r2, r3, #1
3400ece4:	60fa      	str	r2, [r7, #12]
3400ece6:	781b      	ldrb	r3, [r3, #0]
3400ece8:	4618      	mov	r0, r3
3400ecea:	f7ff fc47 	bl	3400e57c <tm_putchar>
3400ecee:	68bb      	ldr	r3, [r7, #8]
3400ecf0:	3b01      	subs	r3, #1
3400ecf2:	60bb      	str	r3, [r7, #8]
3400ecf4:	68bb      	ldr	r3, [r7, #8]
3400ecf6:	2b00      	cmp	r3, #0
3400ecf8:	daf2      	bge.n	3400ece0 <out_cons+0x24>
			}
			par->bufp[par->cnt++] = *str++;
		}
	}
#endif
}
3400ecfa:	bf00      	nop
3400ecfc:	bf00      	nop
3400ecfe:	3710      	adds	r7, #16
3400ed00:	46bd      	mov	sp, r7
3400ed02:	bd80      	pop	{r7, pc}

3400ed04 <tm_printf>:

EXPORT INT	tm_printf( const UB *format, ... )
{
3400ed04:	b40f      	push	{r0, r1, r2, r3}
3400ed06:	b580      	push	{r7, lr}
3400ed08:	b082      	sub	sp, #8
3400ed0a:	af00      	add	r7, sp, #0
	va_list	ap;

#if	TM_OUTBUF_SZ == 0
	H	len = 0;
3400ed0c:	2300      	movs	r3, #0
3400ed0e:	807b      	strh	r3, [r7, #2]

	va_start(ap, format);
3400ed10:	f107 0314 	add.w	r3, r7, #20
3400ed14:	607b      	str	r3, [r7, #4]
	tm_vsprintf(out_cons, (OutPar*)&len, format, ap);
3400ed16:	1cb9      	adds	r1, r7, #2
3400ed18:	687b      	ldr	r3, [r7, #4]
3400ed1a:	693a      	ldr	r2, [r7, #16]
3400ed1c:	4805      	ldr	r0, [pc, #20]	@ (3400ed34 <tm_printf+0x30>)
3400ed1e:	f7ff fcaf 	bl	3400e680 <tm_vsprintf>
	va_end(ap);
	return len;
3400ed22:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
	va_start(ap, format);
	tm_vsprintf(out_cons, (OutPar*)&par, format, ap);
	va_end(ap);
	return par.len;
#endif
}
3400ed26:	4618      	mov	r0, r3
3400ed28:	3708      	adds	r7, #8
3400ed2a:	46bd      	mov	sp, r7
3400ed2c:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
3400ed30:	b004      	add	sp, #16
3400ed32:	4770      	bx	lr
3400ed34:	3400ecbd 	.word	0x3400ecbd

3400ed38 <out_w>:
{
3400ed38:	b480      	push	{r7}
3400ed3a:	b083      	sub	sp, #12
3400ed3c:	af00      	add	r7, sp, #0
3400ed3e:	6078      	str	r0, [r7, #4]
3400ed40:	6039      	str	r1, [r7, #0]
	*(_UW*)port = data;
3400ed42:	687b      	ldr	r3, [r7, #4]
3400ed44:	683a      	ldr	r2, [r7, #0]
3400ed46:	601a      	str	r2, [r3, #0]
}
3400ed48:	bf00      	nop
3400ed4a:	370c      	adds	r7, #12
3400ed4c:	46bd      	mov	sp, r7
3400ed4e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ed52:	4770      	bx	lr

3400ed54 <knl_force_dispatch>:
/* ----------------------------------------------------------------------- */
/*
 *	Task dispatcher startup
 */
EXPORT void knl_force_dispatch( void )
{
3400ed54:	b580      	push	{r7, lr}
3400ed56:	af00      	add	r7, sp, #0
	knl_dispatch_disabled = DDS_DISABLE_IMPLICIT;
3400ed58:	4b07      	ldr	r3, [pc, #28]	@ (3400ed78 <knl_force_dispatch+0x24>)
3400ed5a:	2201      	movs	r2, #1
3400ed5c:	601a      	str	r2, [r3, #0]
	knl_ctxtsk = NULL;
3400ed5e:	4b07      	ldr	r3, [pc, #28]	@ (3400ed7c <knl_force_dispatch+0x28>)
3400ed60:	2200      	movs	r2, #0
3400ed62:	601a      	str	r2, [r3, #0]
	out_w(SCB_ICSR, ICSR_PENDSVSET);	/* pendsv exception */
3400ed64:	f04f 5180 	mov.w	r1, #268435456	@ 0x10000000
3400ed68:	4805      	ldr	r0, [pc, #20]	@ (3400ed80 <knl_force_dispatch+0x2c>)
3400ed6a:	f7ff ffe5 	bl	3400ed38 <out_w>
	set_basepri(0);
3400ed6e:	2000      	movs	r0, #0
3400ed70:	f000 ff2b 	bl	3400fbca <set_basepri>
}
3400ed74:	bf00      	nop
3400ed76:	bd80      	pop	{r7, pc}
3400ed78:	340127fc 	.word	0x340127fc
3400ed7c:	34012800 	.word	0x34012800
3400ed80:	e000ed04 	.word	0xe000ed04

3400ed84 <knl_dispatch>:

EXPORT void knl_dispatch( void )
{
3400ed84:	b580      	push	{r7, lr}
3400ed86:	af00      	add	r7, sp, #0
	out_w(SCB_ICSR, ICSR_PENDSVSET);	/* pendsv exception */
3400ed88:	f04f 5180 	mov.w	r1, #268435456	@ 0x10000000
3400ed8c:	4802      	ldr	r0, [pc, #8]	@ (3400ed98 <knl_dispatch+0x14>)
3400ed8e:	f7ff ffd3 	bl	3400ed38 <out_w>
}
3400ed92:	bf00      	nop
3400ed94:	bd80      	pop	{r7, pc}
3400ed96:	bf00      	nop
3400ed98:	e000ed04 	.word	0xe000ed04

3400ed9c <knl_nmi_handler>:

/*
 * NMI handler
 */
WEAK_FUNC EXPORT void knl_nmi_handler(void)
{
3400ed9c:	b580      	push	{r7, lr}
3400ed9e:	af00      	add	r7, sp, #0
	EXCEPTION_DBG_MSG("NMI\n");
3400eda0:	4802      	ldr	r0, [pc, #8]	@ (3400edac <knl_nmi_handler+0x10>)
3400eda2:	f7ff fc0f 	bl	3400e5c4 <tm_putstring>
	while(1);
3400eda6:	bf00      	nop
3400eda8:	e7fd      	b.n	3400eda6 <knl_nmi_handler+0xa>
3400edaa:	bf00      	nop
3400edac:	3400fed0 	.word	0x3400fed0

3400edb0 <knl_hardfault_handler>:
/*
 * Hard fault handler
 */
//WEAK_FUNC EXPORT void knl_hardfault_handler(void)
void knl_hardfault_handler(void)
{
3400edb0:	b580      	push	{r7, lr}
3400edb2:	b084      	sub	sp, #16
3400edb4:	af00      	add	r7, sp, #0
#if (USE_EXCEPTION_DBG_MSG  && USE_TMONITOR)

	UW	hfsr, cfsr;
	ID	ctskid;

	hfsr	= *(_UW *)SCB_HFSR;
3400edb6:	4b12      	ldr	r3, [pc, #72]	@ (3400ee00 <knl_hardfault_handler+0x50>)
3400edb8:	681b      	ldr	r3, [r3, #0]
3400edba:	60bb      	str	r3, [r7, #8]
	if(knl_ctxtsk != NULL) {
3400edbc:	4b11      	ldr	r3, [pc, #68]	@ (3400ee04 <knl_hardfault_handler+0x54>)
3400edbe:	681b      	ldr	r3, [r3, #0]
3400edc0:	2b00      	cmp	r3, #0
3400edc2:	d004      	beq.n	3400edce <knl_hardfault_handler+0x1e>
		ctskid = knl_ctxtsk->tskid;
3400edc4:	4b0f      	ldr	r3, [pc, #60]	@ (3400ee04 <knl_hardfault_handler+0x54>)
3400edc6:	681b      	ldr	r3, [r3, #0]
3400edc8:	689b      	ldr	r3, [r3, #8]
3400edca:	60fb      	str	r3, [r7, #12]
3400edcc:	e001      	b.n	3400edd2 <knl_hardfault_handler+0x22>
	} else {
		ctskid = 0;
3400edce:	2300      	movs	r3, #0
3400edd0:	60fb      	str	r3, [r7, #12]
	}

	if(hfsr & 0x40000000) {
3400edd2:	68bb      	ldr	r3, [r7, #8]
3400edd4:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
3400edd8:	2b00      	cmp	r3, #0
3400edda:	d009      	beq.n	3400edf0 <knl_hardfault_handler+0x40>
		cfsr = *(_UW*)SCB_CFSR;
3400eddc:	4b0a      	ldr	r3, [pc, #40]	@ (3400ee08 <knl_hardfault_handler+0x58>)
3400edde:	681b      	ldr	r3, [r3, #0]
3400ede0:	607b      	str	r3, [r7, #4]
		tm_printf((UB*)"*** Hard fault ***  ctxtsk:%d  HFSR:%x  CFSR:%x\n", ctskid, hfsr, cfsr);
3400ede2:	687b      	ldr	r3, [r7, #4]
3400ede4:	68ba      	ldr	r2, [r7, #8]
3400ede6:	68f9      	ldr	r1, [r7, #12]
3400ede8:	4808      	ldr	r0, [pc, #32]	@ (3400ee0c <knl_hardfault_handler+0x5c>)
3400edea:	f7ff ff8b 	bl	3400ed04 <tm_printf>
3400edee:	e005      	b.n	3400edfc <knl_hardfault_handler+0x4c>
	} else {
		tm_printf((UB*)"*** Hard fault ***  ctxtsk:%d  HFSR:%x%x\n", ctskid, hfsr);
3400edf0:	68ba      	ldr	r2, [r7, #8]
3400edf2:	68f9      	ldr	r1, [r7, #12]
3400edf4:	4806      	ldr	r0, [pc, #24]	@ (3400ee10 <knl_hardfault_handler+0x60>)
3400edf6:	f7ff ff85 	bl	3400ed04 <tm_printf>
	}
#endif
	while(1);
3400edfa:	bf00      	nop
3400edfc:	bf00      	nop
3400edfe:	e7fd      	b.n	3400edfc <knl_hardfault_handler+0x4c>
3400ee00:	e000ed2c 	.word	0xe000ed2c
3400ee04:	34012800 	.word	0x34012800
3400ee08:	e000ed28 	.word	0xe000ed28
3400ee0c:	3400fed8 	.word	0x3400fed8
3400ee10:	3400ff0c 	.word	0x3400ff0c

3400ee14 <knl_memmanage_handler>:

/*
 * MPU Fault Handler
 */
WEAK_FUNC EXPORT void knl_memmanage_handler(void)
{
3400ee14:	b580      	push	{r7, lr}
3400ee16:	af00      	add	r7, sp, #0
	EXCEPTION_DBG_MSG("MPU Fault\n");
3400ee18:	4802      	ldr	r0, [pc, #8]	@ (3400ee24 <knl_memmanage_handler+0x10>)
3400ee1a:	f7ff fbd3 	bl	3400e5c4 <tm_putstring>
	while(1);
3400ee1e:	bf00      	nop
3400ee20:	e7fd      	b.n	3400ee1e <knl_memmanage_handler+0xa>
3400ee22:	bf00      	nop
3400ee24:	3400ff38 	.word	0x3400ff38

3400ee28 <knl_busfault_handler>:

/* 
 * Bus Fault Handler
 */
WEAK_FUNC EXPORT void knl_busfault_handler(void)
{
3400ee28:	b580      	push	{r7, lr}
3400ee2a:	af00      	add	r7, sp, #0
	EXCEPTION_DBG_MSG("Bus Fault\n");
3400ee2c:	4802      	ldr	r0, [pc, #8]	@ (3400ee38 <knl_busfault_handler+0x10>)
3400ee2e:	f7ff fbc9 	bl	3400e5c4 <tm_putstring>
	while(1);
3400ee32:	bf00      	nop
3400ee34:	e7fd      	b.n	3400ee32 <knl_busfault_handler+0xa>
3400ee36:	bf00      	nop
3400ee38:	3400ff44 	.word	0x3400ff44

3400ee3c <knl_usagefault_handler>:
/*
 * Usage Fault Handler
 */
//WEAK_FUNC EXPORT void knl_usagefault_handler(void)
EXPORT void knl_usagefault_handler(void)
{
3400ee3c:	b580      	push	{r7, lr}
3400ee3e:	af00      	add	r7, sp, #0
	EXCEPTION_DBG_MSG("Usage Fault\n");
3400ee40:	4802      	ldr	r0, [pc, #8]	@ (3400ee4c <knl_usagefault_handler+0x10>)
3400ee42:	f7ff fbbf 	bl	3400e5c4 <tm_putstring>
	while(1);
3400ee46:	bf00      	nop
3400ee48:	e7fd      	b.n	3400ee46 <knl_usagefault_handler+0xa>
3400ee4a:	bf00      	nop
3400ee4c:	3400ff50 	.word	0x3400ff50

3400ee50 <knl_svcall_handler>:

/*
 * Svcall
 */
WEAK_FUNC EXPORT void knl_svcall_handler(void)
{
3400ee50:	b580      	push	{r7, lr}
3400ee52:	af00      	add	r7, sp, #0
	EXCEPTION_DBG_MSG("SVCall\n");
3400ee54:	4802      	ldr	r0, [pc, #8]	@ (3400ee60 <knl_svcall_handler+0x10>)
3400ee56:	f7ff fbb5 	bl	3400e5c4 <tm_putstring>
	while(1);
3400ee5a:	bf00      	nop
3400ee5c:	e7fd      	b.n	3400ee5a <knl_svcall_handler+0xa>
3400ee5e:	bf00      	nop
3400ee60:	3400ff60 	.word	0x3400ff60

3400ee64 <knl_debugmon_handler>:

/* 
 * Debug Monitor
 */
WEAK_FUNC EXPORT void knl_debugmon_handler(void)
{
3400ee64:	b580      	push	{r7, lr}
3400ee66:	af00      	add	r7, sp, #0
	EXCEPTION_DBG_MSG("Debug Monitor\n");
3400ee68:	4802      	ldr	r0, [pc, #8]	@ (3400ee74 <knl_debugmon_handler+0x10>)
3400ee6a:	f7ff fbab 	bl	3400e5c4 <tm_putstring>
	while(1);
3400ee6e:	bf00      	nop
3400ee70:	e7fd      	b.n	3400ee6e <knl_debugmon_handler+0xa>
3400ee72:	bf00      	nop
3400ee74:	3400ff68 	.word	0x3400ff68

3400ee78 <knl_EnterTaskIndependent>:
/*
 * Move to/Restore task independent part
 */
Inline void knl_EnterTaskIndependent( void )
{
3400ee78:	b480      	push	{r7}
3400ee7a:	af00      	add	r7, sp, #0
	knl_taskindp++;
3400ee7c:	4b04      	ldr	r3, [pc, #16]	@ (3400ee90 <knl_EnterTaskIndependent+0x18>)
3400ee7e:	681b      	ldr	r3, [r3, #0]
3400ee80:	3301      	adds	r3, #1
3400ee82:	4a03      	ldr	r2, [pc, #12]	@ (3400ee90 <knl_EnterTaskIndependent+0x18>)
3400ee84:	6013      	str	r3, [r2, #0]
}
3400ee86:	bf00      	nop
3400ee88:	46bd      	mov	sp, r7
3400ee8a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ee8e:	4770      	bx	lr
3400ee90:	340114e8 	.word	0x340114e8

3400ee94 <knl_LeaveTaskIndependent>:
Inline void knl_LeaveTaskIndependent( void )
{
3400ee94:	b480      	push	{r7}
3400ee96:	af00      	add	r7, sp, #0
	knl_taskindp--;
3400ee98:	4b04      	ldr	r3, [pc, #16]	@ (3400eeac <knl_LeaveTaskIndependent+0x18>)
3400ee9a:	681b      	ldr	r3, [r3, #0]
3400ee9c:	3b01      	subs	r3, #1
3400ee9e:	4a03      	ldr	r2, [pc, #12]	@ (3400eeac <knl_LeaveTaskIndependent+0x18>)
3400eea0:	6013      	str	r3, [r2, #0]
}
3400eea2:	bf00      	nop
3400eea4:	46bd      	mov	sp, r7
3400eea6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400eeaa:	4770      	bx	lr
3400eeac:	340114e8 	.word	0x340114e8

3400eeb0 <knl_systim_inthdr>:
/* ------------------------------------------------------------------------ */
/*
 * System-timer Interrupt handler
 */
EXPORT void knl_systim_inthdr(void)
{
3400eeb0:	b580      	push	{r7, lr}
3400eeb2:	af00      	add	r7, sp, #0
	ENTER_TASK_INDEPENDENT;
3400eeb4:	f7ff ffe0 	bl	3400ee78 <knl_EnterTaskIndependent>

	knl_timer_handler();
3400eeb8:	f7fe fe44 	bl	3400db44 <knl_timer_handler>

	LEAVE_TASK_INDEPENDENT;
3400eebc:	f7ff ffea 	bl	3400ee94 <knl_LeaveTaskIndependent>
}
3400eec0:	bf00      	nop
3400eec2:	bd80      	pop	{r7, pc}

3400eec4 <knl_init_interrupt>:
/* ------------------------------------------------------------------------ */
/*
 * Interrupt initialize
 */
EXPORT ER knl_init_interrupt( void )
{
3400eec4:	b480      	push	{r7}
3400eec6:	af00      	add	r7, sp, #0
	/* Set Exception handler */
	knl_exctbl[2]	= (UW)knl_nmi_handler;		/* 2: NMI Handler */
3400eec8:	4a10      	ldr	r2, [pc, #64]	@ (3400ef0c <knl_init_interrupt+0x48>)
3400eeca:	4b11      	ldr	r3, [pc, #68]	@ (3400ef10 <knl_init_interrupt+0x4c>)
3400eecc:	609a      	str	r2, [r3, #8]
	knl_exctbl[3]	= (UW)knl_hardfault_handler;	/* 3: Hard Fault Handler */
3400eece:	4a11      	ldr	r2, [pc, #68]	@ (3400ef14 <knl_init_interrupt+0x50>)
3400eed0:	4b0f      	ldr	r3, [pc, #60]	@ (3400ef10 <knl_init_interrupt+0x4c>)
3400eed2:	60da      	str	r2, [r3, #12]
	knl_exctbl[4]	= (UW)knl_memmanage_handler;	/* 4: MPU Fault Handler */
3400eed4:	4a10      	ldr	r2, [pc, #64]	@ (3400ef18 <knl_init_interrupt+0x54>)
3400eed6:	4b0e      	ldr	r3, [pc, #56]	@ (3400ef10 <knl_init_interrupt+0x4c>)
3400eed8:	611a      	str	r2, [r3, #16]
	knl_exctbl[5]	= (UW)knl_busfault_handler;	/* 5: Bus Fault Handler */
3400eeda:	4a10      	ldr	r2, [pc, #64]	@ (3400ef1c <knl_init_interrupt+0x58>)
3400eedc:	4b0c      	ldr	r3, [pc, #48]	@ (3400ef10 <knl_init_interrupt+0x4c>)
3400eede:	615a      	str	r2, [r3, #20]
	knl_exctbl[6]	= (UW)knl_usagefault_handler;	/* 6: Usage Fault Handler */
3400eee0:	4a0f      	ldr	r2, [pc, #60]	@ (3400ef20 <knl_init_interrupt+0x5c>)
3400eee2:	4b0b      	ldr	r3, [pc, #44]	@ (3400ef10 <knl_init_interrupt+0x4c>)
3400eee4:	619a      	str	r2, [r3, #24]

	knl_exctbl[11]	= (UW)knl_svcall_handler;	/* 11: Svcall */
3400eee6:	4a0f      	ldr	r2, [pc, #60]	@ (3400ef24 <knl_init_interrupt+0x60>)
3400eee8:	4b09      	ldr	r3, [pc, #36]	@ (3400ef10 <knl_init_interrupt+0x4c>)
3400eeea:	62da      	str	r2, [r3, #44]	@ 0x2c
	knl_exctbl[12]	= (UW)knl_debugmon_handler;	/* 12: Debug Monitor Handler */
3400eeec:	4a0e      	ldr	r2, [pc, #56]	@ (3400ef28 <knl_init_interrupt+0x64>)
3400eeee:	4b08      	ldr	r3, [pc, #32]	@ (3400ef10 <knl_init_interrupt+0x4c>)
3400eef0:	631a      	str	r2, [r3, #48]	@ 0x30

	knl_exctbl[14]	= (UW)knl_dispatch_entry;	/* 14: Pend SV */
3400eef2:	4a0e      	ldr	r2, [pc, #56]	@ (3400ef2c <knl_init_interrupt+0x68>)
3400eef4:	4b06      	ldr	r3, [pc, #24]	@ (3400ef10 <knl_init_interrupt+0x4c>)
3400eef6:	639a      	str	r2, [r3, #56]	@ 0x38
	knl_exctbl[15]	= (UW)knl_systim_inthdr;	/* 15: Systick */
3400eef8:	4a0d      	ldr	r2, [pc, #52]	@ (3400ef30 <knl_init_interrupt+0x6c>)
3400eefa:	4b05      	ldr	r3, [pc, #20]	@ (3400ef10 <knl_init_interrupt+0x4c>)
3400eefc:	63da      	str	r2, [r3, #60]	@ 0x3c

	return E_OK;
3400eefe:	2300      	movs	r3, #0
}
3400ef00:	4618      	mov	r0, r3
3400ef02:	46bd      	mov	sp, r7
3400ef04:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ef08:	4770      	bx	lr
3400ef0a:	bf00      	nop
3400ef0c:	3400ed9d 	.word	0x3400ed9d
3400ef10:	34010400 	.word	0x34010400
3400ef14:	3400edb1 	.word	0x3400edb1
3400ef18:	3400ee15 	.word	0x3400ee15
3400ef1c:	3400ee29 	.word	0x3400ee29
3400ef20:	3400ee3d 	.word	0x3400ee3d
3400ef24:	3400ee51 	.word	0x3400ee51
3400ef28:	3400ee65 	.word	0x3400ee65
3400ef2c:	3400078d 	.word	0x3400078d
3400ef30:	3400eeb1 	.word	0x3400eeb1

3400ef34 <out_w>:
{
3400ef34:	b480      	push	{r7}
3400ef36:	b083      	sub	sp, #12
3400ef38:	af00      	add	r7, sp, #0
3400ef3a:	6078      	str	r0, [r7, #4]
3400ef3c:	6039      	str	r1, [r7, #0]
	*(_UW*)port = data;
3400ef3e:	687b      	ldr	r3, [r7, #4]
3400ef40:	683a      	ldr	r2, [r7, #0]
3400ef42:	601a      	str	r2, [r3, #0]
}
3400ef44:	bf00      	nop
3400ef46:	370c      	adds	r7, #12
3400ef48:	46bd      	mov	sp, r7
3400ef4a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ef4e:	4770      	bx	lr

3400ef50 <in_w>:
{
3400ef50:	b480      	push	{r7}
3400ef52:	b083      	sub	sp, #12
3400ef54:	af00      	add	r7, sp, #0
3400ef56:	6078      	str	r0, [r7, #4]
	return *(_UW*)port;
3400ef58:	687b      	ldr	r3, [r7, #4]
3400ef5a:	681b      	ldr	r3, [r3, #0]
}
3400ef5c:	4618      	mov	r0, r3
3400ef5e:	370c      	adds	r7, #12
3400ef60:	46bd      	mov	sp, r7
3400ef62:	f85d 7b04 	ldr.w	r7, [sp], #4
3400ef66:	4770      	bx	lr

3400ef68 <knl_start_mtkernel>:
EXPORT void		*knl_sysmem_top	= 0;
EXPORT void		*knl_sysmem_end	= 0;
#endif

EXPORT void knl_start_mtkernel(void)
{
3400ef68:	b580      	push	{r7, lr}
3400ef6a:	b084      	sub	sp, #16
3400ef6c:	af00      	add	r7, sp, #0
	UW	*src, *top;
	UW	reg;
	INT	i;

	disint();		// Disable Interrupt
3400ef6e:	f000 fe48 	bl	3400fc02 <disint>

	knl_startup_hw();
3400ef72:	f000 fde3 	bl	3400fb3c <knl_startup_hw>

	/* Copy exception handler (ROM -> RAM) */
	src = knl_exctbl_o = (UW*)in_w(SCB_VTOR);
3400ef76:	4830      	ldr	r0, [pc, #192]	@ (3400f038 <knl_start_mtkernel+0xd0>)
3400ef78:	f7ff ffea 	bl	3400ef50 <in_w>
3400ef7c:	4603      	mov	r3, r0
3400ef7e:	461a      	mov	r2, r3
3400ef80:	4b2e      	ldr	r3, [pc, #184]	@ (3400f03c <knl_start_mtkernel+0xd4>)
3400ef82:	601a      	str	r2, [r3, #0]
3400ef84:	4b2d      	ldr	r3, [pc, #180]	@ (3400f03c <knl_start_mtkernel+0xd4>)
3400ef86:	681b      	ldr	r3, [r3, #0]
3400ef88:	60fb      	str	r3, [r7, #12]
	top = (UW*)knl_exctbl;
3400ef8a:	4b2d      	ldr	r3, [pc, #180]	@ (3400f040 <knl_start_mtkernel+0xd8>)
3400ef8c:	60bb      	str	r3, [r7, #8]
	for(i=0; i < (N_SYSVEC + N_INTVEC); i++) {
3400ef8e:	2300      	movs	r3, #0
3400ef90:	607b      	str	r3, [r7, #4]
3400ef92:	e00a      	b.n	3400efaa <knl_start_mtkernel+0x42>
		*top++ = *src++;
3400ef94:	68fa      	ldr	r2, [r7, #12]
3400ef96:	1d13      	adds	r3, r2, #4
3400ef98:	60fb      	str	r3, [r7, #12]
3400ef9a:	68bb      	ldr	r3, [r7, #8]
3400ef9c:	1d19      	adds	r1, r3, #4
3400ef9e:	60b9      	str	r1, [r7, #8]
3400efa0:	6812      	ldr	r2, [r2, #0]
3400efa2:	601a      	str	r2, [r3, #0]
	for(i=0; i < (N_SYSVEC + N_INTVEC); i++) {
3400efa4:	687b      	ldr	r3, [r7, #4]
3400efa6:	3301      	adds	r3, #1
3400efa8:	607b      	str	r3, [r7, #4]
3400efaa:	687b      	ldr	r3, [r7, #4]
3400efac:	2bd3      	cmp	r3, #211	@ 0xd3
3400efae:	ddf1      	ble.n	3400ef94 <knl_start_mtkernel+0x2c>
	}
	out_w(SCB_VTOR, (UW)knl_exctbl);
3400efb0:	4b23      	ldr	r3, [pc, #140]	@ (3400f040 <knl_start_mtkernel+0xd8>)
3400efb2:	4619      	mov	r1, r3
3400efb4:	4820      	ldr	r0, [pc, #128]	@ (3400f038 <knl_start_mtkernel+0xd0>)
3400efb6:	f7ff ffbd 	bl	3400ef34 <out_w>

	/* Configure exception priorities */
	reg = *(_UW*)SCB_AIRCR;
3400efba:	4b22      	ldr	r3, [pc, #136]	@ (3400f044 <knl_start_mtkernel+0xdc>)
3400efbc:	681b      	ldr	r3, [r3, #0]
3400efbe:	603b      	str	r3, [r7, #0]
	reg = (reg & (~AIRCR_PRIGROUP3)) | AIRCR_PRIGROUP0;	// PRIGRP:SUBPRI = 4 : 4
3400efc0:	683b      	ldr	r3, [r7, #0]
3400efc2:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
3400efc6:	603b      	str	r3, [r7, #0]
	*(_UW*)SCB_AIRCR = (reg & 0x0000FFFF) | AIRCR_VECTKEY;
3400efc8:	683b      	ldr	r3, [r7, #0]
3400efca:	b29b      	uxth	r3, r3
3400efcc:	4a1d      	ldr	r2, [pc, #116]	@ (3400f044 <knl_start_mtkernel+0xdc>)
3400efce:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
3400efd2:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
3400efd6:	6013      	str	r3, [r2, #0]

	/* Enable UsageFault & BusFault & MemFault */
	out_w(SCB_SHCSR, SHCSR_USGFAULTENA | SHCSR_BUSFAULTENA | SHCSR_MEMFAULTENA);
3400efd8:	f44f 21e0 	mov.w	r1, #458752	@ 0x70000
3400efdc:	481a      	ldr	r0, [pc, #104]	@ (3400f048 <knl_start_mtkernel+0xe0>)
3400efde:	f7ff ffa9 	bl	3400ef34 <out_w>

	out_w(SCB_SHPR2, SCB_SHPR2_VAL);		// SVC pri = 0
3400efe2:	2100      	movs	r1, #0
3400efe4:	4819      	ldr	r0, [pc, #100]	@ (3400f04c <knl_start_mtkernel+0xe4>)
3400efe6:	f7ff ffa5 	bl	3400ef34 <out_w>
	out_w(SCB_SHPR3, SCB_SHPR3_VAL);		// SysTick = 1 , PendSV = 15
3400efea:	4919      	ldr	r1, [pc, #100]	@ (3400f050 <knl_start_mtkernel+0xe8>)
3400efec:	4819      	ldr	r0, [pc, #100]	@ (3400f054 <knl_start_mtkernel+0xec>)
3400efee:	f7ff ffa1 	bl	3400ef34 <out_w>

	knl_sysclk	= SystemCoreClock;		// Get System clock frequency
3400eff2:	4b19      	ldr	r3, [pc, #100]	@ (3400f058 <knl_start_mtkernel+0xf0>)
3400eff4:	681b      	ldr	r3, [r3, #0]
3400eff6:	4a19      	ldr	r2, [pc, #100]	@ (3400f05c <knl_start_mtkernel+0xf4>)
3400eff8:	6013      	str	r3, [r2, #0]
	knl_lowmem_top = knl_system_mem;
	knl_lowmem_limit = &knl_system_mem[SYSTEM_MEM_SIZE/sizeof(UW)];
#else
	/* Set System memory area */
	if(INTERNAL_RAM_START > SYSTEMAREA_TOP) {
		knl_lowmem_top = (UW*)INTERNAL_RAM_START;
3400effa:	4b19      	ldr	r3, [pc, #100]	@ (3400f060 <knl_start_mtkernel+0xf8>)
3400effc:	4a19      	ldr	r2, [pc, #100]	@ (3400f064 <knl_start_mtkernel+0xfc>)
3400effe:	601a      	str	r2, [r3, #0]
	} else {
		knl_lowmem_top = (UW*)SYSTEMAREA_TOP;
	}
	if((UW)knl_lowmem_top < (UW)&_end) {
3400f000:	4b17      	ldr	r3, [pc, #92]	@ (3400f060 <knl_start_mtkernel+0xf8>)
3400f002:	681b      	ldr	r3, [r3, #0]
3400f004:	461a      	mov	r2, r3
3400f006:	4b18      	ldr	r3, [pc, #96]	@ (3400f068 <knl_start_mtkernel+0x100>)
3400f008:	429a      	cmp	r2, r3
3400f00a:	d202      	bcs.n	3400f012 <knl_start_mtkernel+0xaa>
		knl_lowmem_top = (UW*)&_end;
3400f00c:	4b14      	ldr	r3, [pc, #80]	@ (3400f060 <knl_start_mtkernel+0xf8>)
3400f00e:	4a16      	ldr	r2, [pc, #88]	@ (3400f068 <knl_start_mtkernel+0x100>)
3400f010:	601a      	str	r2, [r3, #0]
	}

	if((SYSTEMAREA_END != 0) && (INTERNAL_RAM_END > CNF_SYSTEMAREA_END)) {
		knl_lowmem_limit = (UW*)(SYSTEMAREA_END - EXC_STACK_SIZE);
	} else {
		knl_lowmem_limit = (UW*)(INTERNAL_RAM_END - EXC_STACK_SIZE);
3400f012:	4b16      	ldr	r3, [pc, #88]	@ (3400f06c <knl_start_mtkernel+0x104>)
3400f014:	4a16      	ldr	r2, [pc, #88]	@ (3400f070 <knl_start_mtkernel+0x108>)
3400f016:	601a      	str	r2, [r3, #0]
	}
#endif

#if USE_DEBUG_SYSMEMINFO
	knl_sysmem_top	= knl_lowmem_top;
3400f018:	4b11      	ldr	r3, [pc, #68]	@ (3400f060 <knl_start_mtkernel+0xf8>)
3400f01a:	681b      	ldr	r3, [r3, #0]
3400f01c:	4a15      	ldr	r2, [pc, #84]	@ (3400f074 <knl_start_mtkernel+0x10c>)
3400f01e:	6013      	str	r3, [r2, #0]
	knl_sysmem_end	= knl_lowmem_limit;
3400f020:	4b12      	ldr	r3, [pc, #72]	@ (3400f06c <knl_start_mtkernel+0x104>)
3400f022:	681b      	ldr	r3, [r3, #0]
3400f024:	4a14      	ldr	r2, [pc, #80]	@ (3400f078 <knl_start_mtkernel+0x110>)
3400f026:	6013      	str	r3, [r2, #0]
#endif	// USE_DEBUG_MEMINFO
#endif	// USE_IMALLOC

	/* Temporarily disable stack pointer protection */
	// set_msplim((uint32_t)INTERNAL_RAM_START);
	Asm ("msr msplim, %0" : : "r" ((uint32_t)INTERNAL_RAM_START));
3400f028:	4b0e      	ldr	r3, [pc, #56]	@ (3400f064 <knl_start_mtkernel+0xfc>)
3400f02a:	f383 880a 	msr	MSPLIM, r3

	/* Startup Kernel */
	knl_main();		// *** No return ****/
3400f02e:	f7fb ffdb 	bl	3400afe8 <knl_main>
	while(1);		// guard - infinite loops
3400f032:	bf00      	nop
3400f034:	e7fd      	b.n	3400f032 <knl_start_mtkernel+0xca>
3400f036:	bf00      	nop
3400f038:	e000ed08 	.word	0xe000ed08
3400f03c:	340114f0 	.word	0x340114f0
3400f040:	34010400 	.word	0x34010400
3400f044:	e000ed0c 	.word	0xe000ed0c
3400f048:	e000ed24 	.word	0xe000ed24
3400f04c:	e000ed1c 	.word	0xe000ed1c
3400f050:	10f00000 	.word	0x10f00000
3400f054:	e000ed20 	.word	0xe000ed20
3400f058:	3401017c 	.word	0x3401017c
3400f05c:	340114ec 	.word	0x340114ec
3400f060:	340114f4 	.word	0x340114f4
3400f064:	34000400 	.word	0x34000400
3400f068:	34013808 	.word	0x34013808
3400f06c:	340114f8 	.word	0x340114f8
3400f070:	34200000 	.word	0x34200000
3400f074:	340114fc 	.word	0x340114fc
3400f078:	34011500 	.word	0x34011500

3400f07c <knl_EnterTaskIndependent>:
{
3400f07c:	b480      	push	{r7}
3400f07e:	af00      	add	r7, sp, #0
	knl_taskindp++;
3400f080:	4b04      	ldr	r3, [pc, #16]	@ (3400f094 <knl_EnterTaskIndependent+0x18>)
3400f082:	681b      	ldr	r3, [r3, #0]
3400f084:	3301      	adds	r3, #1
3400f086:	4a03      	ldr	r2, [pc, #12]	@ (3400f094 <knl_EnterTaskIndependent+0x18>)
3400f088:	6013      	str	r3, [r2, #0]
}
3400f08a:	bf00      	nop
3400f08c:	46bd      	mov	sp, r7
3400f08e:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f092:	4770      	bx	lr
3400f094:	340114e8 	.word	0x340114e8

3400f098 <knl_LeaveTaskIndependent>:
{
3400f098:	b480      	push	{r7}
3400f09a:	af00      	add	r7, sp, #0
	knl_taskindp--;
3400f09c:	4b04      	ldr	r3, [pc, #16]	@ (3400f0b0 <knl_LeaveTaskIndependent+0x18>)
3400f09e:	681b      	ldr	r3, [r3, #0]
3400f0a0:	3b01      	subs	r3, #1
3400f0a2:	4a03      	ldr	r2, [pc, #12]	@ (3400f0b0 <knl_LeaveTaskIndependent+0x18>)
3400f0a4:	6013      	str	r3, [r2, #0]
}
3400f0a6:	bf00      	nop
3400f0a8:	46bd      	mov	sp, r7
3400f0aa:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f0ae:	4770      	bx	lr
3400f0b0:	340114e8 	.word	0x340114e8

3400f0b4 <read_atr>:

/*---------------------------------------------------------------------*/
/* Attribute data control
 */
LOCAL ER read_atr(T_HAL_ADC_DCB *p_dcb, T_DEVREQ *req)
{
3400f0b4:	b480      	push	{r7}
3400f0b6:	b083      	sub	sp, #12
3400f0b8:	af00      	add	r7, sp, #0
3400f0ba:	6078      	str	r0, [r7, #4]
3400f0bc:	6039      	str	r1, [r7, #0]
	return E_PAR;
3400f0be:	f06f 0310 	mvn.w	r3, #16
}
3400f0c2:	4618      	mov	r0, r3
3400f0c4:	370c      	adds	r7, #12
3400f0c6:	46bd      	mov	sp, r7
3400f0c8:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f0cc:	4770      	bx	lr

3400f0ce <write_atr>:

LOCAL ER write_atr(T_HAL_ADC_DCB *p_dcb, T_DEVREQ *req)
{
3400f0ce:	b480      	push	{r7}
3400f0d0:	b083      	sub	sp, #12
3400f0d2:	af00      	add	r7, sp, #0
3400f0d4:	6078      	str	r0, [r7, #4]
3400f0d6:	6039      	str	r1, [r7, #0]
	return E_PAR;
3400f0d8:	f06f 0310 	mvn.w	r3, #16
}
3400f0dc:	4618      	mov	r0, r3
3400f0de:	370c      	adds	r7, #12
3400f0e0:	46bd      	mov	sp, r7
3400f0e2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f0e6:	4770      	bx	lr

3400f0e8 <HAL_ADC_ConvCpltCallback>:
/* Device-specific data control
 */

/* HAL Callback functions */
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)
{
3400f0e8:	b580      	push	{r7, lr}
3400f0ea:	b084      	sub	sp, #16
3400f0ec:	af00      	add	r7, sp, #0
3400f0ee:	6078      	str	r0, [r7, #4]
	T_HAL_ADC_DCB	*p_dcb;
	UINT	i;

	ENTER_TASK_INDEPENDENT
3400f0f0:	f7ff ffc4 	bl	3400f07c <knl_EnterTaskIndependent>

	for(i = 0; i < DEV_HAL_ADC_UNITNM; i++) {
3400f0f4:	2300      	movs	r3, #0
3400f0f6:	60fb      	str	r3, [r7, #12]
3400f0f8:	e01b      	b.n	3400f132 <HAL_ADC_ConvCpltCallback+0x4a>
		p_dcb = get_dcb_ptr(i);
3400f0fa:	4a12      	ldr	r2, [pc, #72]	@ (3400f144 <HAL_ADC_ConvCpltCallback+0x5c>)
3400f0fc:	68fb      	ldr	r3, [r7, #12]
3400f0fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3400f102:	60bb      	str	r3, [r7, #8]
		if(p_dcb->hadc == hadc) {
3400f104:	68bb      	ldr	r3, [r7, #8]
3400f106:	681b      	ldr	r3, [r3, #0]
3400f108:	687a      	ldr	r2, [r7, #4]
3400f10a:	429a      	cmp	r2, r3
3400f10c:	d10e      	bne.n	3400f12c <HAL_ADC_ConvCpltCallback+0x44>
			p_dcb->err = E_OK;
3400f10e:	68bb      	ldr	r3, [r7, #8]
3400f110:	2200      	movs	r2, #0
3400f112:	615a      	str	r2, [r3, #20]
			tk_set_flg(id_flgid, 1<< p_dcb->unit);
3400f114:	4b0c      	ldr	r3, [pc, #48]	@ (3400f148 <HAL_ADC_ConvCpltCallback+0x60>)
3400f116:	681a      	ldr	r2, [r3, #0]
3400f118:	68bb      	ldr	r3, [r7, #8]
3400f11a:	689b      	ldr	r3, [r3, #8]
3400f11c:	2101      	movs	r1, #1
3400f11e:	fa01 f303 	lsl.w	r3, r1, r3
3400f122:	4619      	mov	r1, r3
3400f124:	4610      	mov	r0, r2
3400f126:	f7fc fe1b 	bl	3400bd60 <tk_set_flg>
			break;
3400f12a:	e005      	b.n	3400f138 <HAL_ADC_ConvCpltCallback+0x50>
	for(i = 0; i < DEV_HAL_ADC_UNITNM; i++) {
3400f12c:	68fb      	ldr	r3, [r7, #12]
3400f12e:	3301      	adds	r3, #1
3400f130:	60fb      	str	r3, [r7, #12]
3400f132:	68fb      	ldr	r3, [r7, #12]
3400f134:	2b02      	cmp	r3, #2
3400f136:	d9e0      	bls.n	3400f0fa <HAL_ADC_ConvCpltCallback+0x12>
		}
	}

	LEAVE_TASK_INDEPENDENT
3400f138:	f7ff ffae 	bl	3400f098 <knl_LeaveTaskIndependent>
}
3400f13c:	bf00      	nop
3400f13e:	3710      	adds	r7, #16
3400f140:	46bd      	mov	sp, r7
3400f142:	bd80      	pop	{r7, pc}
3400f144:	34011508 	.word	0x34011508
3400f148:	34011504 	.word	0x34011504

3400f14c <read_data>:

LOCAL ER read_data(T_HAL_ADC_DCB *p_dcb, T_DEVREQ *req)
{
3400f14c:	b580      	push	{r7, lr}
3400f14e:	b08a      	sub	sp, #40	@ 0x28
3400f150:	af02      	add	r7, sp, #8
3400f152:	6078      	str	r0, [r7, #4]
3400f154:	6039      	str	r1, [r7, #0]
	uint32_t		value;
	HAL_StatusTypeDef	hal_sts;
	UINT			wflgptn, rflgptn;
	ER			err;

	if(req->size == 0) {
3400f156:	683b      	ldr	r3, [r7, #0]
3400f158:	695b      	ldr	r3, [r3, #20]
3400f15a:	2b00      	cmp	r3, #0
3400f15c:	d104      	bne.n	3400f168 <read_data+0x1c>
		req->asize = 1;
3400f15e:	683b      	ldr	r3, [r7, #0]
3400f160:	2201      	movs	r2, #1
3400f162:	61da      	str	r2, [r3, #28]
		return E_OK;
3400f164:	2300      	movs	r3, #0
3400f166:	e051      	b.n	3400f20c <read_data+0xc0>
	}
	/* Configure for A/DC */
	err = dev_adc_setch(p_dcb->hadc, p_dcb->unit, req->start);
3400f168:	687b      	ldr	r3, [r7, #4]
3400f16a:	6818      	ldr	r0, [r3, #0]
3400f16c:	687b      	ldr	r3, [r7, #4]
3400f16e:	6899      	ldr	r1, [r3, #8]
3400f170:	683b      	ldr	r3, [r7, #0]
3400f172:	691b      	ldr	r3, [r3, #16]
3400f174:	461a      	mov	r2, r3
3400f176:	f000 f967 	bl	3400f448 <dev_adc_setch>
3400f17a:	61f8      	str	r0, [r7, #28]
	if(err != E_OK) return err;
3400f17c:	69fb      	ldr	r3, [r7, #28]
3400f17e:	2b00      	cmp	r3, #0
3400f180:	d001      	beq.n	3400f186 <read_data+0x3a>
3400f182:	69fb      	ldr	r3, [r7, #28]
3400f184:	e042      	b.n	3400f20c <read_data+0xc0>

	wflgptn = 1 << p_dcb->unit;
3400f186:	687b      	ldr	r3, [r7, #4]
3400f188:	689b      	ldr	r3, [r3, #8]
3400f18a:	2201      	movs	r2, #1
3400f18c:	fa02 f303 	lsl.w	r3, r2, r3
3400f190:	61bb      	str	r3, [r7, #24]
	tk_clr_flg(id_flgid, ~wflgptn);
3400f192:	4b20      	ldr	r3, [pc, #128]	@ (3400f214 <read_data+0xc8>)
3400f194:	681a      	ldr	r2, [r3, #0]
3400f196:	69bb      	ldr	r3, [r7, #24]
3400f198:	43db      	mvns	r3, r3
3400f19a:	4619      	mov	r1, r3
3400f19c:	4610      	mov	r0, r2
3400f19e:	f7fc fe67 	bl	3400be70 <tk_clr_flg>
	hal_sts = HAL_ADC_Start_IT(p_dcb->hadc);
3400f1a2:	687b      	ldr	r3, [r7, #4]
3400f1a4:	681b      	ldr	r3, [r3, #0]
3400f1a6:	4618      	mov	r0, r3
3400f1a8:	f7f3 ffbe 	bl	34003128 <HAL_ADC_Start_IT>
3400f1ac:	4603      	mov	r3, r0
3400f1ae:	75fb      	strb	r3, [r7, #23]
	if(hal_sts != HAL_OK) return E_BUSY;
3400f1b0:	7dfb      	ldrb	r3, [r7, #23]
3400f1b2:	2b00      	cmp	r3, #0
3400f1b4:	d002      	beq.n	3400f1bc <read_data+0x70>
3400f1b6:	f06f 0340 	mvn.w	r3, #64	@ 0x40
3400f1ba:	e027      	b.n	3400f20c <read_data+0xc0>

	err = tk_wai_flg(id_flgid, wflgptn, TWF_ANDW | TWF_BITCLR, &rflgptn, DEV_HAL_ADC_TMOUT);
3400f1bc:	4b15      	ldr	r3, [pc, #84]	@ (3400f214 <read_data+0xc8>)
3400f1be:	6818      	ldr	r0, [r3, #0]
3400f1c0:	f107 030c 	add.w	r3, r7, #12
3400f1c4:	f44f 72fa 	mov.w	r2, #500	@ 0x1f4
3400f1c8:	9200      	str	r2, [sp, #0]
3400f1ca:	2220      	movs	r2, #32
3400f1cc:	69b9      	ldr	r1, [r7, #24]
3400f1ce:	f7fc feb3 	bl	3400bf38 <tk_wai_flg>
3400f1d2:	61f8      	str	r0, [r7, #28]
	if(err >= E_OK) {
3400f1d4:	69fb      	ldr	r3, [r7, #28]
3400f1d6:	2b00      	cmp	r3, #0
3400f1d8:	db12      	blt.n	3400f200 <read_data+0xb4>
		err  = p_dcb->err;
3400f1da:	687b      	ldr	r3, [r7, #4]
3400f1dc:	695b      	ldr	r3, [r3, #20]
3400f1de:	61fb      	str	r3, [r7, #28]
		if(err >= E_OK) {
3400f1e0:	69fb      	ldr	r3, [r7, #28]
3400f1e2:	2b00      	cmp	r3, #0
3400f1e4:	db0c      	blt.n	3400f200 <read_data+0xb4>
			value = HAL_ADC_GetValue(p_dcb->hadc);
3400f1e6:	687b      	ldr	r3, [r7, #4]
3400f1e8:	681b      	ldr	r3, [r3, #0]
3400f1ea:	4618      	mov	r0, r3
3400f1ec:	f7f4 f905 	bl	340033fa <HAL_ADC_GetValue>
3400f1f0:	6138      	str	r0, [r7, #16]
			*(UW*)(req->buf) = (UW)value;
3400f1f2:	683b      	ldr	r3, [r7, #0]
3400f1f4:	699b      	ldr	r3, [r3, #24]
3400f1f6:	693a      	ldr	r2, [r7, #16]
3400f1f8:	601a      	str	r2, [r3, #0]
			req->asize= 1;
3400f1fa:	683b      	ldr	r3, [r7, #0]
3400f1fc:	2201      	movs	r2, #1
3400f1fe:	61da      	str	r2, [r3, #28]
		}
	}
	HAL_ADC_Stop_IT(p_dcb->hadc);
3400f200:	687b      	ldr	r3, [r7, #4]
3400f202:	681b      	ldr	r3, [r3, #0]
3400f204:	4618      	mov	r0, r3
3400f206:	f7f4 f8bd 	bl	34003384 <HAL_ADC_Stop_IT>

	return err;
3400f20a:	69fb      	ldr	r3, [r7, #28]
}
3400f20c:	4618      	mov	r0, r3
3400f20e:	3720      	adds	r7, #32
3400f210:	46bd      	mov	sp, r7
3400f212:	bd80      	pop	{r7, pc}
3400f214:	34011504 	.word	0x34011504

3400f218 <write_data>:

LOCAL ER write_data(T_HAL_ADC_DCB *p_dcb, T_DEVREQ *req)
{
3400f218:	b480      	push	{r7}
3400f21a:	b083      	sub	sp, #12
3400f21c:	af00      	add	r7, sp, #0
3400f21e:	6078      	str	r0, [r7, #4]
3400f220:	6039      	str	r1, [r7, #0]
	return E_RONLY;
3400f222:	f06f 0342 	mvn.w	r3, #66	@ 0x42
}
3400f226:	4618      	mov	r0, r3
3400f228:	370c      	adds	r7, #12
3400f22a:	46bd      	mov	sp, r7
3400f22c:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f230:	4770      	bx	lr

3400f232 <dev_adc_openfn>:
 */
/*
 * Open device
 */
LOCAL ER dev_adc_openfn( ID devid, UINT omode, T_MSDI *msdi)
{
3400f232:	b480      	push	{r7}
3400f234:	b087      	sub	sp, #28
3400f236:	af00      	add	r7, sp, #0
3400f238:	60f8      	str	r0, [r7, #12]
3400f23a:	60b9      	str	r1, [r7, #8]
3400f23c:	607a      	str	r2, [r7, #4]
	T_HAL_ADC_DCB	*p_dcb;

	p_dcb = (T_HAL_ADC_DCB*)(msdi->dmsdi.exinf);
3400f23e:	687b      	ldr	r3, [r7, #4]
3400f240:	691b      	ldr	r3, [r3, #16]
3400f242:	617b      	str	r3, [r7, #20]
	if(p_dcb->hadc == NULL) return E_IO;
3400f244:	697b      	ldr	r3, [r7, #20]
3400f246:	681b      	ldr	r3, [r3, #0]
3400f248:	2b00      	cmp	r3, #0
3400f24a:	d102      	bne.n	3400f252 <dev_adc_openfn+0x20>
3400f24c:	f06f 0338 	mvn.w	r3, #56	@ 0x38
3400f250:	e003      	b.n	3400f25a <dev_adc_openfn+0x28>

	p_dcb->omode = omode;
3400f252:	697b      	ldr	r3, [r7, #20]
3400f254:	68ba      	ldr	r2, [r7, #8]
3400f256:	60da      	str	r2, [r3, #12]
	return E_OK;
3400f258:	2300      	movs	r3, #0
}
3400f25a:	4618      	mov	r0, r3
3400f25c:	371c      	adds	r7, #28
3400f25e:	46bd      	mov	sp, r7
3400f260:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f264:	4770      	bx	lr

3400f266 <dev_adc_closefn>:

/*
 * Close Device
 */
LOCAL ER dev_adc_closefn( ID devid, UINT option, T_MSDI *msdi)
{
3400f266:	b480      	push	{r7}
3400f268:	b085      	sub	sp, #20
3400f26a:	af00      	add	r7, sp, #0
3400f26c:	60f8      	str	r0, [r7, #12]
3400f26e:	60b9      	str	r1, [r7, #8]
3400f270:	607a      	str	r2, [r7, #4]
	return E_OK;
3400f272:	2300      	movs	r3, #0
}
3400f274:	4618      	mov	r0, r3
3400f276:	3714      	adds	r7, #20
3400f278:	46bd      	mov	sp, r7
3400f27a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f27e:	4770      	bx	lr

3400f280 <dev_adc_readfn>:

/*
 * Read Device
 */
LOCAL ER dev_adc_readfn( T_DEVREQ *req, T_MSDI *p_msdi)
{
3400f280:	b580      	push	{r7, lr}
3400f282:	b084      	sub	sp, #16
3400f284:	af00      	add	r7, sp, #0
3400f286:	6078      	str	r0, [r7, #4]
3400f288:	6039      	str	r1, [r7, #0]
	T_HAL_ADC_DCB	*p_dcb;
	ER		err;

	p_dcb = (T_HAL_ADC_DCB*)(p_msdi->dmsdi.exinf);
3400f28a:	683b      	ldr	r3, [r7, #0]
3400f28c:	691b      	ldr	r3, [r3, #16]
3400f28e:	60bb      	str	r3, [r7, #8]
	if(p_dcb->hadc == NULL) return E_IO;
3400f290:	68bb      	ldr	r3, [r7, #8]
3400f292:	681b      	ldr	r3, [r3, #0]
3400f294:	2b00      	cmp	r3, #0
3400f296:	d102      	bne.n	3400f29e <dev_adc_readfn+0x1e>
3400f298:	f06f 0338 	mvn.w	r3, #56	@ 0x38
3400f29c:	e00f      	b.n	3400f2be <dev_adc_readfn+0x3e>

	if(req->start >= 0) {
3400f29e:	687b      	ldr	r3, [r7, #4]
3400f2a0:	691b      	ldr	r3, [r3, #16]
3400f2a2:	2b00      	cmp	r3, #0
3400f2a4:	db05      	blt.n	3400f2b2 <dev_adc_readfn+0x32>
		err = read_data( p_dcb, req);	// Device specific data
3400f2a6:	6879      	ldr	r1, [r7, #4]
3400f2a8:	68b8      	ldr	r0, [r7, #8]
3400f2aa:	f7ff ff4f 	bl	3400f14c <read_data>
3400f2ae:	60f8      	str	r0, [r7, #12]
3400f2b0:	e004      	b.n	3400f2bc <dev_adc_readfn+0x3c>
	} else {
		err = read_atr( p_dcb, req);	// Device attribute data
3400f2b2:	6879      	ldr	r1, [r7, #4]
3400f2b4:	68b8      	ldr	r0, [r7, #8]
3400f2b6:	f7ff fefd 	bl	3400f0b4 <read_atr>
3400f2ba:	60f8      	str	r0, [r7, #12]
	}
	return err;
3400f2bc:	68fb      	ldr	r3, [r7, #12]
}
3400f2be:	4618      	mov	r0, r3
3400f2c0:	3710      	adds	r7, #16
3400f2c2:	46bd      	mov	sp, r7
3400f2c4:	bd80      	pop	{r7, pc}

3400f2c6 <dev_adc_writefn>:

/*
 * Write Device
 */
LOCAL ER dev_adc_writefn( T_DEVREQ *req, T_MSDI *p_msdi)
{
3400f2c6:	b580      	push	{r7, lr}
3400f2c8:	b084      	sub	sp, #16
3400f2ca:	af00      	add	r7, sp, #0
3400f2cc:	6078      	str	r0, [r7, #4]
3400f2ce:	6039      	str	r1, [r7, #0]
	T_HAL_ADC_DCB	*p_dcb;
	ER		rtn;

	p_dcb = (T_HAL_ADC_DCB*)(p_msdi->dmsdi.exinf);
3400f2d0:	683b      	ldr	r3, [r7, #0]
3400f2d2:	691b      	ldr	r3, [r3, #16]
3400f2d4:	60bb      	str	r3, [r7, #8]
	if(p_dcb->hadc == NULL) return E_IO;
3400f2d6:	68bb      	ldr	r3, [r7, #8]
3400f2d8:	681b      	ldr	r3, [r3, #0]
3400f2da:	2b00      	cmp	r3, #0
3400f2dc:	d102      	bne.n	3400f2e4 <dev_adc_writefn+0x1e>
3400f2de:	f06f 0338 	mvn.w	r3, #56	@ 0x38
3400f2e2:	e00f      	b.n	3400f304 <dev_adc_writefn+0x3e>

	if(req->start >= 0) {
3400f2e4:	687b      	ldr	r3, [r7, #4]
3400f2e6:	691b      	ldr	r3, [r3, #16]
3400f2e8:	2b00      	cmp	r3, #0
3400f2ea:	db05      	blt.n	3400f2f8 <dev_adc_writefn+0x32>
		rtn = write_data( p_dcb, req);	// Device specific data
3400f2ec:	6879      	ldr	r1, [r7, #4]
3400f2ee:	68b8      	ldr	r0, [r7, #8]
3400f2f0:	f7ff ff92 	bl	3400f218 <write_data>
3400f2f4:	60f8      	str	r0, [r7, #12]
3400f2f6:	e004      	b.n	3400f302 <dev_adc_writefn+0x3c>
	} else {
		rtn = write_atr( p_dcb, req);	// Device attribute data
3400f2f8:	6879      	ldr	r1, [r7, #4]
3400f2fa:	68b8      	ldr	r0, [r7, #8]
3400f2fc:	f7ff fee7 	bl	3400f0ce <write_atr>
3400f300:	60f8      	str	r0, [r7, #12]
	}
	return rtn;
3400f302:	68fb      	ldr	r3, [r7, #12]
}
3400f304:	4618      	mov	r0, r3
3400f306:	3710      	adds	r7, #16
3400f308:	46bd      	mov	sp, r7
3400f30a:	bd80      	pop	{r7, pc}

3400f30c <dev_adc_eventfn>:

/*
 * Event Device
 */
LOCAL ER dev_adc_eventfn( INT evttyp, void *evtinf, T_MSDI *msdi)
{
3400f30c:	b480      	push	{r7}
3400f30e:	b085      	sub	sp, #20
3400f310:	af00      	add	r7, sp, #0
3400f312:	60f8      	str	r0, [r7, #12]
3400f314:	60b9      	str	r1, [r7, #8]
3400f316:	607a      	str	r2, [r7, #4]
	return E_NOSPT;
3400f318:	f06f 0308 	mvn.w	r3, #8
}
3400f31c:	4618      	mov	r0, r3
3400f31e:	3714      	adds	r7, #20
3400f320:	46bd      	mov	sp, r7
3400f322:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f326:	4770      	bx	lr

3400f328 <dev_init_hal_adc>:

/*----------------------------------------------------------------------
 * Device driver initialization and registration
 */
EXPORT ER dev_init_hal_adc( UW unit, ADC_HandleTypeDef *hadc )
{
3400f328:	b580      	push	{r7, lr}
3400f32a:	b094      	sub	sp, #80	@ 0x50
3400f32c:	af00      	add	r7, sp, #0
3400f32e:	6078      	str	r0, [r7, #4]
3400f330:	6039      	str	r1, [r7, #0]
	T_MSDI		*p_msdi;
	T_DMSDI		dmsdi;
	ER		err;
	INT		i;

	if( unit >= DEV_HAL_ADC_UNITNM) return E_PAR;
3400f332:	687b      	ldr	r3, [r7, #4]
3400f334:	2b02      	cmp	r3, #2
3400f336:	d902      	bls.n	3400f33e <dev_init_hal_adc+0x16>
3400f338:	f06f 0310 	mvn.w	r3, #16
3400f33c:	e06d      	b.n	3400f41a <dev_init_hal_adc+0xf2>

#if TK_SUPPORT_MEMLIB
	p_dcb = (T_HAL_ADC_DCB*)Kmalloc(sizeof(T_HAL_ADC_DCB));
3400f33e:	2020      	movs	r0, #32
3400f340:	f7ff f8fe 	bl	3400e540 <Kmalloc>
3400f344:	64b8      	str	r0, [r7, #72]	@ 0x48
	if( p_dcb == NULL) return E_NOMEM;
3400f346:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400f348:	2b00      	cmp	r3, #0
3400f34a:	d102      	bne.n	3400f352 <dev_init_hal_adc+0x2a>
3400f34c:	f06f 0320 	mvn.w	r3, #32
3400f350:	e063      	b.n	3400f41a <dev_init_hal_adc+0xf2>
	dev_adc_cb[unit]	= p_dcb;
3400f352:	4934      	ldr	r1, [pc, #208]	@ (3400f424 <dev_init_hal_adc+0xfc>)
3400f354:	687b      	ldr	r3, [r7, #4]
3400f356:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3400f358:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#else
	p_dcb = &dev_adc_cb[unit];
#endif

	id_flgid = tk_cre_flg(&id_flg);
3400f35c:	4832      	ldr	r0, [pc, #200]	@ (3400f428 <dev_init_hal_adc+0x100>)
3400f35e:	f7fc fc4f 	bl	3400bc00 <tk_cre_flg>
3400f362:	4603      	mov	r3, r0
3400f364:	4a31      	ldr	r2, [pc, #196]	@ (3400f42c <dev_init_hal_adc+0x104>)
3400f366:	6013      	str	r3, [r2, #0]
	if(id_flgid <= E_OK) {
3400f368:	4b30      	ldr	r3, [pc, #192]	@ (3400f42c <dev_init_hal_adc+0x104>)
3400f36a:	681b      	ldr	r3, [r3, #0]
3400f36c:	2b00      	cmp	r3, #0
3400f36e:	dc03      	bgt.n	3400f378 <dev_init_hal_adc+0x50>
		err = (ER)id_flgid;
3400f370:	4b2e      	ldr	r3, [pc, #184]	@ (3400f42c <dev_init_hal_adc+0x104>)
3400f372:	681b      	ldr	r3, [r3, #0]
3400f374:	64fb      	str	r3, [r7, #76]	@ 0x4c
		goto err_1;
3400f376:	e04c      	b.n	3400f412 <dev_init_hal_adc+0xea>
	}

	/* Device registration information */
	dmsdi.exinf	= p_dcb;
3400f378:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400f37a:	60bb      	str	r3, [r7, #8]
	dmsdi.drvatr	= 0;			/* Driver attributes */
3400f37c:	2300      	movs	r3, #0
3400f37e:	61bb      	str	r3, [r7, #24]
	dmsdi.devatr	= TDK_UNDEF;		/* Device attributes */
3400f380:	2300      	movs	r3, #0
3400f382:	61fb      	str	r3, [r7, #28]
	dmsdi.nsub	= 0;			/* Number of sub units */
3400f384:	2300      	movs	r3, #0
3400f386:	623b      	str	r3, [r7, #32]
	dmsdi.blksz	= 1;			/* Unique data block size (-1 = unknown) */
3400f388:	2301      	movs	r3, #1
3400f38a:	627b      	str	r3, [r7, #36]	@ 0x24
	dmsdi.openfn	= dev_adc_openfn;
3400f38c:	4b28      	ldr	r3, [pc, #160]	@ (3400f430 <dev_init_hal_adc+0x108>)
3400f38e:	62bb      	str	r3, [r7, #40]	@ 0x28
	dmsdi.closefn	= dev_adc_closefn;
3400f390:	4b28      	ldr	r3, [pc, #160]	@ (3400f434 <dev_init_hal_adc+0x10c>)
3400f392:	62fb      	str	r3, [r7, #44]	@ 0x2c
	dmsdi.readfn	= dev_adc_readfn;
3400f394:	4b28      	ldr	r3, [pc, #160]	@ (3400f438 <dev_init_hal_adc+0x110>)
3400f396:	633b      	str	r3, [r7, #48]	@ 0x30
	dmsdi.writefn	= dev_adc_writefn;
3400f398:	4b28      	ldr	r3, [pc, #160]	@ (3400f43c <dev_init_hal_adc+0x114>)
3400f39a:	637b      	str	r3, [r7, #52]	@ 0x34
	dmsdi.eventfn	= dev_adc_eventfn;
3400f39c:	4b28      	ldr	r3, [pc, #160]	@ (3400f440 <dev_init_hal_adc+0x118>)
3400f39e:	63bb      	str	r3, [r7, #56]	@ 0x38
	
	knl_strcpy( (char*)dmsdi.devnm, DEVNAME_HAL_ADC);
3400f3a0:	f107 0308 	add.w	r3, r7, #8
3400f3a4:	3304      	adds	r3, #4
3400f3a6:	4927      	ldr	r1, [pc, #156]	@ (3400f444 <dev_init_hal_adc+0x11c>)
3400f3a8:	4618      	mov	r0, r3
3400f3aa:	f7fe fe9a 	bl	3400e0e2 <knl_strcpy>
	i = knl_strlen(DEVNAME_HAL_ADC);
3400f3ae:	4825      	ldr	r0, [pc, #148]	@ (3400f444 <dev_init_hal_adc+0x11c>)
3400f3b0:	f7fe fe86 	bl	3400e0c0 <knl_strlen>
3400f3b4:	6478      	str	r0, [r7, #68]	@ 0x44
	dmsdi.devnm[i] = (UB)('a' + unit);
3400f3b6:	687b      	ldr	r3, [r7, #4]
3400f3b8:	b2db      	uxtb	r3, r3
3400f3ba:	3361      	adds	r3, #97	@ 0x61
3400f3bc:	b2d9      	uxtb	r1, r3
3400f3be:	f107 020c 	add.w	r2, r7, #12
3400f3c2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3400f3c4:	4413      	add	r3, r2
3400f3c6:	460a      	mov	r2, r1
3400f3c8:	701a      	strb	r2, [r3, #0]
	dmsdi.devnm[i+1] = 0;
3400f3ca:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3400f3cc:	3301      	adds	r3, #1
3400f3ce:	3350      	adds	r3, #80	@ 0x50
3400f3d0:	443b      	add	r3, r7
3400f3d2:	2200      	movs	r2, #0
3400f3d4:	f803 2c44 	strb.w	r2, [r3, #-68]

	err = msdi_def_dev( &dmsdi, &idev, &p_msdi);
3400f3d8:	f107 023c 	add.w	r2, r7, #60	@ 0x3c
3400f3dc:	f107 0140 	add.w	r1, r7, #64	@ 0x40
3400f3e0:	f107 0308 	add.w	r3, r7, #8
3400f3e4:	4618      	mov	r0, r3
3400f3e6:	f7fb fd33 	bl	3400ae50 <msdi_def_dev>
3400f3ea:	64f8      	str	r0, [r7, #76]	@ 0x4c
	if(err != E_OK) goto err_1;
3400f3ec:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3400f3ee:	2b00      	cmp	r3, #0
3400f3f0:	d10e      	bne.n	3400f410 <dev_init_hal_adc+0xe8>

	p_dcb->hadc	= hadc;
3400f3f2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400f3f4:	683a      	ldr	r2, [r7, #0]
3400f3f6:	601a      	str	r2, [r3, #0]
	p_dcb->devid	= p_msdi->devid;
3400f3f8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400f3fa:	681a      	ldr	r2, [r3, #0]
3400f3fc:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400f3fe:	605a      	str	r2, [r3, #4]
	p_dcb->unit	= unit;
3400f400:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400f402:	687a      	ldr	r2, [r7, #4]
3400f404:	609a      	str	r2, [r3, #8]
	p_dcb->evtmbfid	= idev.evtmbfid;
3400f406:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
3400f408:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400f40a:	619a      	str	r2, [r3, #24]

	return E_OK;
3400f40c:	2300      	movs	r3, #0
3400f40e:	e004      	b.n	3400f41a <dev_init_hal_adc+0xf2>
	if(err != E_OK) goto err_1;
3400f410:	bf00      	nop

err_1:
#if TK_SUPPORT_MEMLIB
	Kfree(p_dcb);
3400f412:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
3400f414:	f7ff f8a1 	bl	3400e55a <Kfree>
#endif
	return err;
3400f418:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
3400f41a:	4618      	mov	r0, r3
3400f41c:	3750      	adds	r7, #80	@ 0x50
3400f41e:	46bd      	mov	sp, r7
3400f420:	bd80      	pop	{r7, pc}
3400f422:	bf00      	nop
3400f424:	34011508 	.word	0x34011508
3400f428:	34010188 	.word	0x34010188
3400f42c:	34011504 	.word	0x34011504
3400f430:	3400f233 	.word	0x3400f233
3400f434:	3400f267 	.word	0x3400f267
3400f438:	3400f281 	.word	0x3400f281
3400f43c:	3400f2c7 	.word	0x3400f2c7
3400f440:	3400f30d 	.word	0x3400f30d
3400f444:	3400ff9c 	.word	0x3400ff9c

3400f448 <dev_adc_setch>:
	ADC_CHANNEL_12, ADC_CHANNEL_13, ADC_CHANNEL_14, ADC_CHANNEL_15, ADC_CHANNEL_16, ADC_CHANNEL_17, 
	ADC_CHANNEL_18, ADC_CHANNEL_19, 
};

EXPORT ER dev_adc_setch(ADC_HandleTypeDef *hadc, UW unit, W start)
{
3400f448:	b580      	push	{r7, lr}
3400f44a:	b08e      	sub	sp, #56	@ 0x38
3400f44c:	af00      	add	r7, sp, #0
3400f44e:	60f8      	str	r0, [r7, #12]
3400f450:	60b9      	str	r1, [r7, #8]
3400f452:	607a      	str	r2, [r7, #4]
	ADC_ChannelConfTypeDef	sConfig = {0};
3400f454:	f107 0314 	add.w	r3, r7, #20
3400f458:	2220      	movs	r2, #32
3400f45a:	2100      	movs	r1, #0
3400f45c:	4618      	mov	r0, r3
3400f45e:	f000 fc31 	bl	3400fcc4 <memset>
	HAL_StatusTypeDef	hal_sts;

	if(start >= sizeof(adc_cfg_ch)/sizeof(UW)) return E_PAR;
3400f462:	687b      	ldr	r3, [r7, #4]
3400f464:	2b13      	cmp	r3, #19
3400f466:	d902      	bls.n	3400f46e <dev_adc_setch+0x26>
3400f468:	f06f 0310 	mvn.w	r3, #16
3400f46c:	e036      	b.n	3400f4dc <dev_adc_setch+0x94>

	sConfig.Channel = adc_cfg_ch[start];
3400f46e:	4a1d      	ldr	r2, [pc, #116]	@ (3400f4e4 <dev_adc_setch+0x9c>)
3400f470:	687b      	ldr	r3, [r7, #4]
3400f472:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3400f476:	617b      	str	r3, [r7, #20]
	if(unit == 0) {		// ADC1
3400f478:	68bb      	ldr	r3, [r7, #8]
3400f47a:	2b00      	cmp	r3, #0
3400f47c:	d10b      	bne.n	3400f496 <dev_adc_setch+0x4e>
		sConfig.Rank = ADC_REGULAR_RANK_1;
3400f47e:	2306      	movs	r3, #6
3400f480:	61bb      	str	r3, [r7, #24]
		sConfig.SamplingTime = ADC_SAMPLETIME_246CYCLES_5;
3400f482:	2306      	movs	r3, #6
3400f484:	61fb      	str	r3, [r7, #28]
		sConfig.SingleDiff = ADC_SINGLE_ENDED;
3400f486:	f240 33ff 	movw	r3, #1023	@ 0x3ff
3400f48a:	623b      	str	r3, [r7, #32]
		sConfig.OffsetNumber = ADC_OFFSET_NONE;
3400f48c:	2304      	movs	r3, #4
3400f48e:	627b      	str	r3, [r7, #36]	@ 0x24
		sConfig.Offset = 0;
3400f490:	2300      	movs	r3, #0
3400f492:	62bb      	str	r3, [r7, #40]	@ 0x28
3400f494:	e011      	b.n	3400f4ba <dev_adc_setch+0x72>
	}else if(unit == 1) {	// ADC2
3400f496:	68bb      	ldr	r3, [r7, #8]
3400f498:	2b01      	cmp	r3, #1
3400f49a:	d10b      	bne.n	3400f4b4 <dev_adc_setch+0x6c>
		sConfig.Rank = ADC_REGULAR_RANK_1;
3400f49c:	2306      	movs	r3, #6
3400f49e:	61bb      	str	r3, [r7, #24]
		sConfig.SamplingTime = ADC_SAMPLETIME_246CYCLES_5;
3400f4a0:	2306      	movs	r3, #6
3400f4a2:	61fb      	str	r3, [r7, #28]
		sConfig.SingleDiff = ADC_SINGLE_ENDED;
3400f4a4:	f240 33ff 	movw	r3, #1023	@ 0x3ff
3400f4a8:	623b      	str	r3, [r7, #32]
		sConfig.OffsetNumber = ADC_OFFSET_NONE;
3400f4aa:	2304      	movs	r3, #4
3400f4ac:	627b      	str	r3, [r7, #36]	@ 0x24
		sConfig.Offset = 0;
3400f4ae:	2300      	movs	r3, #0
3400f4b0:	62bb      	str	r3, [r7, #40]	@ 0x28
3400f4b2:	e002      	b.n	3400f4ba <dev_adc_setch+0x72>
	} else {
		return E_IO;
3400f4b4:	f06f 0338 	mvn.w	r3, #56	@ 0x38
3400f4b8:	e010      	b.n	3400f4dc <dev_adc_setch+0x94>
	}

	hal_sts = HAL_ADC_ConfigChannel(hadc, &sConfig);
3400f4ba:	f107 0314 	add.w	r3, r7, #20
3400f4be:	4619      	mov	r1, r3
3400f4c0:	68f8      	ldr	r0, [r7, #12]
3400f4c2:	f7f4 f9a7 	bl	34003814 <HAL_ADC_ConfigChannel>
3400f4c6:	4603      	mov	r3, r0
3400f4c8:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37

	return (hal_sts == HAL_OK)?E_OK:E_IO;
3400f4cc:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
3400f4d0:	2b00      	cmp	r3, #0
3400f4d2:	d101      	bne.n	3400f4d8 <dev_adc_setch+0x90>
3400f4d4:	2300      	movs	r3, #0
3400f4d6:	e001      	b.n	3400f4dc <dev_adc_setch+0x94>
3400f4d8:	f06f 0338 	mvn.w	r3, #56	@ 0x38
}
3400f4dc:	4618      	mov	r0, r3
3400f4de:	3738      	adds	r7, #56	@ 0x38
3400f4e0:	46bd      	mov	sp, r7
3400f4e2:	bd80      	pop	{r7, pc}
3400f4e4:	340100fc 	.word	0x340100fc

3400f4e8 <knl_EnterTaskIndependent>:
{
3400f4e8:	b480      	push	{r7}
3400f4ea:	af00      	add	r7, sp, #0
	knl_taskindp++;
3400f4ec:	4b04      	ldr	r3, [pc, #16]	@ (3400f500 <knl_EnterTaskIndependent+0x18>)
3400f4ee:	681b      	ldr	r3, [r3, #0]
3400f4f0:	3301      	adds	r3, #1
3400f4f2:	4a03      	ldr	r2, [pc, #12]	@ (3400f500 <knl_EnterTaskIndependent+0x18>)
3400f4f4:	6013      	str	r3, [r2, #0]
}
3400f4f6:	bf00      	nop
3400f4f8:	46bd      	mov	sp, r7
3400f4fa:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f4fe:	4770      	bx	lr
3400f500:	340114e8 	.word	0x340114e8

3400f504 <knl_LeaveTaskIndependent>:
{
3400f504:	b480      	push	{r7}
3400f506:	af00      	add	r7, sp, #0
	knl_taskindp--;
3400f508:	4b04      	ldr	r3, [pc, #16]	@ (3400f51c <knl_LeaveTaskIndependent+0x18>)
3400f50a:	681b      	ldr	r3, [r3, #0]
3400f50c:	3b01      	subs	r3, #1
3400f50e:	4a03      	ldr	r2, [pc, #12]	@ (3400f51c <knl_LeaveTaskIndependent+0x18>)
3400f510:	6013      	str	r3, [r2, #0]
}
3400f512:	bf00      	nop
3400f514:	46bd      	mov	sp, r7
3400f516:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f51a:	4770      	bx	lr
3400f51c:	340114e8 	.word	0x340114e8

3400f520 <read_atr>:

/*---------------------------------------------------------------------*/
/* Attribute data control
 */
LOCAL ER read_atr(T_HAL_I2C_DCB *p_dcb, T_DEVREQ *req)
{
3400f520:	b480      	push	{r7}
3400f522:	b083      	sub	sp, #12
3400f524:	af00      	add	r7, sp, #0
3400f526:	6078      	str	r0, [r7, #4]
3400f528:	6039      	str	r1, [r7, #0]
	if((req->start >= TDN_HAL_I2C_MODE) && (req->start <= TDN_HAL_I2C_MAX)) return E_PAR;
3400f52a:	683b      	ldr	r3, [r7, #0]
3400f52c:	691b      	ldr	r3, [r3, #16]
3400f52e:	f113 0f64 	cmn.w	r3, #100	@ 0x64
3400f532:	db07      	blt.n	3400f544 <read_atr+0x24>
3400f534:	683b      	ldr	r3, [r7, #0]
3400f536:	691b      	ldr	r3, [r3, #16]
3400f538:	f113 0f64 	cmn.w	r3, #100	@ 0x64
3400f53c:	da02      	bge.n	3400f544 <read_atr+0x24>
3400f53e:	f06f 0310 	mvn.w	r3, #16
3400f542:	e027      	b.n	3400f594 <read_atr+0x74>

	req->asize = sizeof(UW);
3400f544:	683b      	ldr	r3, [r7, #0]
3400f546:	2204      	movs	r2, #4
3400f548:	61da      	str	r2, [r3, #28]
	
	if(req->size == 0) return E_OK;
3400f54a:	683b      	ldr	r3, [r7, #0]
3400f54c:	695b      	ldr	r3, [r3, #20]
3400f54e:	2b00      	cmp	r3, #0
3400f550:	d101      	bne.n	3400f556 <read_atr+0x36>
3400f552:	2300      	movs	r3, #0
3400f554:	e01e      	b.n	3400f594 <read_atr+0x74>
	else if(req->size != sizeof(UW)) return E_PAR;
3400f556:	683b      	ldr	r3, [r7, #0]
3400f558:	695b      	ldr	r3, [r3, #20]
3400f55a:	2b04      	cmp	r3, #4
3400f55c:	d002      	beq.n	3400f564 <read_atr+0x44>
3400f55e:	f06f 0310 	mvn.w	r3, #16
3400f562:	e017      	b.n	3400f594 <read_atr+0x74>

	switch(req->start) {
3400f564:	683b      	ldr	r3, [r7, #0]
3400f566:	691b      	ldr	r3, [r3, #16]
3400f568:	f113 0f65 	cmn.w	r3, #101	@ 0x65
3400f56c:	d008      	beq.n	3400f580 <read_atr+0x60>
3400f56e:	f113 0f64 	cmn.w	r3, #100	@ 0x64
3400f572:	d10b      	bne.n	3400f58c <read_atr+0x6c>
	case TDN_HAL_I2C_MODE:
		*(UW*)req->buf = p_dcb->dmode;
3400f574:	683b      	ldr	r3, [r7, #0]
3400f576:	699b      	ldr	r3, [r3, #24]
3400f578:	687a      	ldr	r2, [r7, #4]
3400f57a:	6992      	ldr	r2, [r2, #24]
3400f57c:	601a      	str	r2, [r3, #0]
		break;
3400f57e:	e008      	b.n	3400f592 <read_atr+0x72>
	case TDN_HAL_I2C_TADR:
		*(UW*)req->buf = p_dcb->tadr;
3400f580:	683b      	ldr	r3, [r7, #0]
3400f582:	699b      	ldr	r3, [r3, #24]
3400f584:	687a      	ldr	r2, [r7, #4]
3400f586:	69d2      	ldr	r2, [r2, #28]
3400f588:	601a      	str	r2, [r3, #0]
		break;
3400f58a:	e002      	b.n	3400f592 <read_atr+0x72>
	default:
		return E_PAR;
3400f58c:	f06f 0310 	mvn.w	r3, #16
3400f590:	e000      	b.n	3400f594 <read_atr+0x74>
	}
	return E_OK;
3400f592:	2300      	movs	r3, #0
}
3400f594:	4618      	mov	r0, r3
3400f596:	370c      	adds	r7, #12
3400f598:	46bd      	mov	sp, r7
3400f59a:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f59e:	4770      	bx	lr

3400f5a0 <write_atr>:

LOCAL ER write_atr(T_HAL_I2C_DCB *p_dcb, T_DEVREQ *req)
{
3400f5a0:	b480      	push	{r7}
3400f5a2:	b085      	sub	sp, #20
3400f5a4:	af00      	add	r7, sp, #0
3400f5a6:	6078      	str	r0, [r7, #4]
3400f5a8:	6039      	str	r1, [r7, #0]
	UW	data;

	if(req->size != sizeof(UW)) return E_PAR;
3400f5aa:	683b      	ldr	r3, [r7, #0]
3400f5ac:	695b      	ldr	r3, [r3, #20]
3400f5ae:	2b04      	cmp	r3, #4
3400f5b0:	d002      	beq.n	3400f5b8 <write_atr+0x18>
3400f5b2:	f06f 0310 	mvn.w	r3, #16
3400f5b6:	e020      	b.n	3400f5fa <write_atr+0x5a>
	data = *(UW*)req->buf;
3400f5b8:	683b      	ldr	r3, [r7, #0]
3400f5ba:	699b      	ldr	r3, [r3, #24]
3400f5bc:	681b      	ldr	r3, [r3, #0]
3400f5be:	60fb      	str	r3, [r7, #12]

	switch(req->start) {
3400f5c0:	683b      	ldr	r3, [r7, #0]
3400f5c2:	691b      	ldr	r3, [r3, #16]
3400f5c4:	f113 0f65 	cmn.w	r3, #101	@ 0x65
3400f5c8:	d00c      	beq.n	3400f5e4 <write_atr+0x44>
3400f5ca:	f113 0f64 	cmn.w	r3, #100	@ 0x64
3400f5ce:	d10d      	bne.n	3400f5ec <write_atr+0x4c>
	case TDN_HAL_I2C_MODE:
		if(data <HAL_I2C_MODE_CNT || data > HAL_I2C_MODE_TAR) return E_PAR;
3400f5d0:	68fb      	ldr	r3, [r7, #12]
3400f5d2:	2b01      	cmp	r3, #1
3400f5d4:	d902      	bls.n	3400f5dc <write_atr+0x3c>
3400f5d6:	f06f 0310 	mvn.w	r3, #16
3400f5da:	e00e      	b.n	3400f5fa <write_atr+0x5a>
		p_dcb->dmode = data;
3400f5dc:	687b      	ldr	r3, [r7, #4]
3400f5de:	68fa      	ldr	r2, [r7, #12]
3400f5e0:	619a      	str	r2, [r3, #24]
		break;
3400f5e2:	e006      	b.n	3400f5f2 <write_atr+0x52>
	case TDN_HAL_I2C_TADR:
		p_dcb->tadr = data;
3400f5e4:	687b      	ldr	r3, [r7, #4]
3400f5e6:	68fa      	ldr	r2, [r7, #12]
3400f5e8:	61da      	str	r2, [r3, #28]
		break;
3400f5ea:	e002      	b.n	3400f5f2 <write_atr+0x52>
	default:
		return E_PAR;
3400f5ec:	f06f 0310 	mvn.w	r3, #16
3400f5f0:	e003      	b.n	3400f5fa <write_atr+0x5a>
	}
	req->asize = sizeof(UW);
3400f5f2:	683b      	ldr	r3, [r7, #0]
3400f5f4:	2204      	movs	r2, #4
3400f5f6:	61da      	str	r2, [r3, #28]
	return E_OK;
3400f5f8:	2300      	movs	r3, #0
}
3400f5fa:	4618      	mov	r0, r3
3400f5fc:	3714      	adds	r7, #20
3400f5fe:	46bd      	mov	sp, r7
3400f600:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f604:	4770      	bx	lr
	...

3400f608 <HAL_I2C_Callback>:
/*Device-specific data control
 */

/* HAL Callback functions */
LOCAL void HAL_I2C_Callback(I2C_HandleTypeDef *hi2c, ER err)
{
3400f608:	b580      	push	{r7, lr}
3400f60a:	b084      	sub	sp, #16
3400f60c:	af00      	add	r7, sp, #0
3400f60e:	6078      	str	r0, [r7, #4]
3400f610:	6039      	str	r1, [r7, #0]
	T_HAL_I2C_DCB	*p_dcb;
	UINT	i;

	ENTER_TASK_INDEPENDENT
3400f612:	f7ff ff69 	bl	3400f4e8 <knl_EnterTaskIndependent>

	for(i = 0; i < DEV_HAL_I2C_UNITNM; i++) {
3400f616:	2300      	movs	r3, #0
3400f618:	60fb      	str	r3, [r7, #12]
3400f61a:	e01b      	b.n	3400f654 <HAL_I2C_Callback+0x4c>
		p_dcb = get_dcb_ptr(i);
3400f61c:	4a12      	ldr	r2, [pc, #72]	@ (3400f668 <HAL_I2C_Callback+0x60>)
3400f61e:	68fb      	ldr	r3, [r7, #12]
3400f620:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
3400f624:	60bb      	str	r3, [r7, #8]
		if(p_dcb->hi2c == hi2c) {
3400f626:	68bb      	ldr	r3, [r7, #8]
3400f628:	681b      	ldr	r3, [r3, #0]
3400f62a:	687a      	ldr	r2, [r7, #4]
3400f62c:	429a      	cmp	r2, r3
3400f62e:	d10e      	bne.n	3400f64e <HAL_I2C_Callback+0x46>
			p_dcb->err = err;
3400f630:	68bb      	ldr	r3, [r7, #8]
3400f632:	683a      	ldr	r2, [r7, #0]
3400f634:	611a      	str	r2, [r3, #16]
			tk_set_flg(id_flgid, 1<< p_dcb->unit);
3400f636:	4b0d      	ldr	r3, [pc, #52]	@ (3400f66c <HAL_I2C_Callback+0x64>)
3400f638:	681a      	ldr	r2, [r3, #0]
3400f63a:	68bb      	ldr	r3, [r7, #8]
3400f63c:	68db      	ldr	r3, [r3, #12]
3400f63e:	2101      	movs	r1, #1
3400f640:	fa01 f303 	lsl.w	r3, r1, r3
3400f644:	4619      	mov	r1, r3
3400f646:	4610      	mov	r0, r2
3400f648:	f7fc fb8a 	bl	3400bd60 <tk_set_flg>
			break;
3400f64c:	e005      	b.n	3400f65a <HAL_I2C_Callback+0x52>
	for(i = 0; i < DEV_HAL_I2C_UNITNM; i++) {
3400f64e:	68fb      	ldr	r3, [r7, #12]
3400f650:	3301      	adds	r3, #1
3400f652:	60fb      	str	r3, [r7, #12]
3400f654:	68fb      	ldr	r3, [r7, #12]
3400f656:	2b04      	cmp	r3, #4
3400f658:	d9e0      	bls.n	3400f61c <HAL_I2C_Callback+0x14>
		}
	}

	LEAVE_TASK_INDEPENDENT
3400f65a:	f7ff ff53 	bl	3400f504 <knl_LeaveTaskIndependent>
}
3400f65e:	bf00      	nop
3400f660:	3710      	adds	r7, #16
3400f662:	46bd      	mov	sp, r7
3400f664:	bd80      	pop	{r7, pc}
3400f666:	bf00      	nop
3400f668:	34011518 	.word	0x34011518
3400f66c:	34011514 	.word	0x34011514

3400f670 <HAL_I2C_MasterRxCpltCallback>:

void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
3400f670:	b580      	push	{r7, lr}
3400f672:	b082      	sub	sp, #8
3400f674:	af00      	add	r7, sp, #0
3400f676:	6078      	str	r0, [r7, #4]
	HAL_I2C_Callback(hi2c, E_OK);
3400f678:	2100      	movs	r1, #0
3400f67a:	6878      	ldr	r0, [r7, #4]
3400f67c:	f7ff ffc4 	bl	3400f608 <HAL_I2C_Callback>
}
3400f680:	bf00      	nop
3400f682:	3708      	adds	r7, #8
3400f684:	46bd      	mov	sp, r7
3400f686:	bd80      	pop	{r7, pc}

3400f688 <HAL_I2C_MasterTxCpltCallback>:

void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
3400f688:	b580      	push	{r7, lr}
3400f68a:	b082      	sub	sp, #8
3400f68c:	af00      	add	r7, sp, #0
3400f68e:	6078      	str	r0, [r7, #4]
	HAL_I2C_Callback(hi2c, E_OK);
3400f690:	2100      	movs	r1, #0
3400f692:	6878      	ldr	r0, [r7, #4]
3400f694:	f7ff ffb8 	bl	3400f608 <HAL_I2C_Callback>
}
3400f698:	bf00      	nop
3400f69a:	3708      	adds	r7, #8
3400f69c:	46bd      	mov	sp, r7
3400f69e:	bd80      	pop	{r7, pc}

3400f6a0 <HAL_I2C_SlaveRxCpltCallback>:

void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
3400f6a0:	b580      	push	{r7, lr}
3400f6a2:	b082      	sub	sp, #8
3400f6a4:	af00      	add	r7, sp, #0
3400f6a6:	6078      	str	r0, [r7, #4]
	HAL_I2C_Callback(hi2c, E_OK);
3400f6a8:	2100      	movs	r1, #0
3400f6aa:	6878      	ldr	r0, [r7, #4]
3400f6ac:	f7ff ffac 	bl	3400f608 <HAL_I2C_Callback>
}
3400f6b0:	bf00      	nop
3400f6b2:	3708      	adds	r7, #8
3400f6b4:	46bd      	mov	sp, r7
3400f6b6:	bd80      	pop	{r7, pc}

3400f6b8 <HAL_I2C_SlaveTxCpltCallback>:

void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
3400f6b8:	b580      	push	{r7, lr}
3400f6ba:	b082      	sub	sp, #8
3400f6bc:	af00      	add	r7, sp, #0
3400f6be:	6078      	str	r0, [r7, #4]
	HAL_I2C_Callback(hi2c, E_OK);
3400f6c0:	2100      	movs	r1, #0
3400f6c2:	6878      	ldr	r0, [r7, #4]
3400f6c4:	f7ff ffa0 	bl	3400f608 <HAL_I2C_Callback>
}
3400f6c8:	bf00      	nop
3400f6ca:	3708      	adds	r7, #8
3400f6cc:	46bd      	mov	sp, r7
3400f6ce:	bd80      	pop	{r7, pc}

3400f6d0 <HAL_I2C_MemRxCpltCallback>:

void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
3400f6d0:	b580      	push	{r7, lr}
3400f6d2:	b082      	sub	sp, #8
3400f6d4:	af00      	add	r7, sp, #0
3400f6d6:	6078      	str	r0, [r7, #4]
	HAL_I2C_Callback(hi2c, E_OK);
3400f6d8:	2100      	movs	r1, #0
3400f6da:	6878      	ldr	r0, [r7, #4]
3400f6dc:	f7ff ff94 	bl	3400f608 <HAL_I2C_Callback>
}
3400f6e0:	bf00      	nop
3400f6e2:	3708      	adds	r7, #8
3400f6e4:	46bd      	mov	sp, r7
3400f6e6:	bd80      	pop	{r7, pc}

3400f6e8 <HAL_I2C_MemTxCpltCallback>:

void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
3400f6e8:	b580      	push	{r7, lr}
3400f6ea:	b082      	sub	sp, #8
3400f6ec:	af00      	add	r7, sp, #0
3400f6ee:	6078      	str	r0, [r7, #4]
	HAL_I2C_Callback(hi2c, E_OK);
3400f6f0:	2100      	movs	r1, #0
3400f6f2:	6878      	ldr	r0, [r7, #4]
3400f6f4:	f7ff ff88 	bl	3400f608 <HAL_I2C_Callback>
}
3400f6f8:	bf00      	nop
3400f6fa:	3708      	adds	r7, #8
3400f6fc:	46bd      	mov	sp, r7
3400f6fe:	bd80      	pop	{r7, pc}

3400f700 <HAL_I2C_ErrorCallback>:

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
3400f700:	b580      	push	{r7, lr}
3400f702:	b082      	sub	sp, #8
3400f704:	af00      	add	r7, sp, #0
3400f706:	6078      	str	r0, [r7, #4]
	HAL_I2C_Callback(hi2c, E_IO);
3400f708:	f06f 0138 	mvn.w	r1, #56	@ 0x38
3400f70c:	6878      	ldr	r0, [r7, #4]
3400f70e:	f7ff ff7b 	bl	3400f608 <HAL_I2C_Callback>
}
3400f712:	bf00      	nop
3400f714:	3708      	adds	r7, #8
3400f716:	46bd      	mov	sp, r7
3400f718:	bd80      	pop	{r7, pc}

3400f71a <HAL_I2C_AbortCpltCallback>:

void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
{
3400f71a:	b580      	push	{r7, lr}
3400f71c:	b082      	sub	sp, #8
3400f71e:	af00      	add	r7, sp, #0
3400f720:	6078      	str	r0, [r7, #4]
	HAL_I2C_Callback(hi2c, E_ABORT);
3400f722:	f06f 0141 	mvn.w	r1, #65	@ 0x41
3400f726:	6878      	ldr	r0, [r7, #4]
3400f728:	f7ff ff6e 	bl	3400f608 <HAL_I2C_Callback>
}
3400f72c:	bf00      	nop
3400f72e:	3708      	adds	r7, #8
3400f730:	46bd      	mov	sp, r7
3400f732:	bd80      	pop	{r7, pc}

3400f734 <read_data>:

LOCAL ER read_data(T_HAL_I2C_DCB *p_dcb, T_DEVREQ *req)
{
3400f734:	b580      	push	{r7, lr}
3400f736:	b088      	sub	sp, #32
3400f738:	af02      	add	r7, sp, #8
3400f73a:	6078      	str	r0, [r7, #4]
3400f73c:	6039      	str	r1, [r7, #0]
	HAL_StatusTypeDef	hal_sts;
	UINT			wflgptn, rflgptn;
	ER			err;

	wflgptn = 1 << p_dcb->unit;
3400f73e:	687b      	ldr	r3, [r7, #4]
3400f740:	68db      	ldr	r3, [r3, #12]
3400f742:	2201      	movs	r2, #1
3400f744:	fa02 f303 	lsl.w	r3, r2, r3
3400f748:	60fb      	str	r3, [r7, #12]
	tk_clr_flg(id_flgid, ~wflgptn);
3400f74a:	4b2a      	ldr	r3, [pc, #168]	@ (3400f7f4 <read_data+0xc0>)
3400f74c:	681a      	ldr	r2, [r3, #0]
3400f74e:	68fb      	ldr	r3, [r7, #12]
3400f750:	43db      	mvns	r3, r3
3400f752:	4619      	mov	r1, r3
3400f754:	4610      	mov	r0, r2
3400f756:	f7fc fb8b 	bl	3400be70 <tk_clr_flg>

	switch(p_dcb->dmode) {
3400f75a:	687b      	ldr	r3, [r7, #4]
3400f75c:	699b      	ldr	r3, [r3, #24]
3400f75e:	2b00      	cmp	r3, #0
3400f760:	d002      	beq.n	3400f768 <read_data+0x34>
3400f762:	2b01      	cmp	r3, #1
3400f764:	d011      	beq.n	3400f78a <read_data+0x56>
3400f766:	e01d      	b.n	3400f7a4 <read_data+0x70>
	case HAL_I2C_MODE_CNT:
		hal_sts = HAL_I2C_Master_Receive_IT(
3400f768:	687b      	ldr	r3, [r7, #4]
3400f76a:	6818      	ldr	r0, [r3, #0]
			p_dcb->hi2c,		// I2C_Handle
			(req->start)<<1,	// Target device address
3400f76c:	683b      	ldr	r3, [r7, #0]
3400f76e:	691b      	ldr	r3, [r3, #16]
		hal_sts = HAL_I2C_Master_Receive_IT(
3400f770:	b29b      	uxth	r3, r3
3400f772:	005b      	lsls	r3, r3, #1
3400f774:	b299      	uxth	r1, r3
			req->buf,		// Pointer to data buffer
3400f776:	683b      	ldr	r3, [r7, #0]
3400f778:	699a      	ldr	r2, [r3, #24]
			req->size		// Amount of data to be sent
3400f77a:	683b      	ldr	r3, [r7, #0]
3400f77c:	695b      	ldr	r3, [r3, #20]
		hal_sts = HAL_I2C_Master_Receive_IT(
3400f77e:	b29b      	uxth	r3, r3
3400f780:	f7f5 fd30 	bl	340051e4 <HAL_I2C_Master_Receive_IT>
3400f784:	4603      	mov	r3, r0
3400f786:	75fb      	strb	r3, [r7, #23]
		);
		break;
3400f788:	e00f      	b.n	3400f7aa <read_data+0x76>
	case HAL_I2C_MODE_TAR:
		hal_sts = HAL_I2C_Slave_Receive_IT(
3400f78a:	687b      	ldr	r3, [r7, #4]
3400f78c:	6818      	ldr	r0, [r3, #0]
			p_dcb->hi2c,		// I2C_Handle
			req->buf,		// Pointer to data buffer
3400f78e:	683b      	ldr	r3, [r7, #0]
3400f790:	6999      	ldr	r1, [r3, #24]
			req->size		// Amount of data to be sent
3400f792:	683b      	ldr	r3, [r7, #0]
3400f794:	695b      	ldr	r3, [r3, #20]
		hal_sts = HAL_I2C_Slave_Receive_IT(
3400f796:	b29b      	uxth	r3, r3
3400f798:	461a      	mov	r2, r3
3400f79a:	f7f5 fe01 	bl	340053a0 <HAL_I2C_Slave_Receive_IT>
3400f79e:	4603      	mov	r3, r0
3400f7a0:	75fb      	strb	r3, [r7, #23]
		);
		break;
3400f7a2:	e002      	b.n	3400f7aa <read_data+0x76>
	default:
		return E_SYS;
3400f7a4:	f06f 0304 	mvn.w	r3, #4
3400f7a8:	e01f      	b.n	3400f7ea <read_data+0xb6>
	}
	if(hal_sts != HAL_OK) return E_BUSY;
3400f7aa:	7dfb      	ldrb	r3, [r7, #23]
3400f7ac:	2b00      	cmp	r3, #0
3400f7ae:	d002      	beq.n	3400f7b6 <read_data+0x82>
3400f7b0:	f06f 0340 	mvn.w	r3, #64	@ 0x40
3400f7b4:	e019      	b.n	3400f7ea <read_data+0xb6>

	err = tk_wai_flg(id_flgid, wflgptn, TWF_ANDW | TWF_BITCLR, &rflgptn, DEV_HAL_I2C_TMOUT);
3400f7b6:	4b0f      	ldr	r3, [pc, #60]	@ (3400f7f4 <read_data+0xc0>)
3400f7b8:	6818      	ldr	r0, [r3, #0]
3400f7ba:	f107 0308 	add.w	r3, r7, #8
3400f7be:	f44f 72fa 	mov.w	r2, #500	@ 0x1f4
3400f7c2:	9200      	str	r2, [sp, #0]
3400f7c4:	2220      	movs	r2, #32
3400f7c6:	68f9      	ldr	r1, [r7, #12]
3400f7c8:	f7fc fbb6 	bl	3400bf38 <tk_wai_flg>
3400f7cc:	6138      	str	r0, [r7, #16]
	if(err >= E_OK) {
3400f7ce:	693b      	ldr	r3, [r7, #16]
3400f7d0:	2b00      	cmp	r3, #0
3400f7d2:	db09      	blt.n	3400f7e8 <read_data+0xb4>
		err  = p_dcb->err;
3400f7d4:	687b      	ldr	r3, [r7, #4]
3400f7d6:	691b      	ldr	r3, [r3, #16]
3400f7d8:	613b      	str	r3, [r7, #16]
		if(err >= E_OK) req->asize = req->size;
3400f7da:	693b      	ldr	r3, [r7, #16]
3400f7dc:	2b00      	cmp	r3, #0
3400f7de:	db03      	blt.n	3400f7e8 <read_data+0xb4>
3400f7e0:	683b      	ldr	r3, [r7, #0]
3400f7e2:	695a      	ldr	r2, [r3, #20]
3400f7e4:	683b      	ldr	r3, [r7, #0]
3400f7e6:	61da      	str	r2, [r3, #28]
	}

	return err;
3400f7e8:	693b      	ldr	r3, [r7, #16]
}
3400f7ea:	4618      	mov	r0, r3
3400f7ec:	3718      	adds	r7, #24
3400f7ee:	46bd      	mov	sp, r7
3400f7f0:	bd80      	pop	{r7, pc}
3400f7f2:	bf00      	nop
3400f7f4:	34011514 	.word	0x34011514

3400f7f8 <write_data>:

LOCAL ER write_data(T_HAL_I2C_DCB *p_dcb, T_DEVREQ *req)
{
3400f7f8:	b580      	push	{r7, lr}
3400f7fa:	b088      	sub	sp, #32
3400f7fc:	af02      	add	r7, sp, #8
3400f7fe:	6078      	str	r0, [r7, #4]
3400f800:	6039      	str	r1, [r7, #0]
	HAL_StatusTypeDef	hal_sts;
	UINT			wflgptn, rflgptn;
	ER			err;

	wflgptn = 1 << p_dcb->unit;
3400f802:	687b      	ldr	r3, [r7, #4]
3400f804:	68db      	ldr	r3, [r3, #12]
3400f806:	2201      	movs	r2, #1
3400f808:	fa02 f303 	lsl.w	r3, r2, r3
3400f80c:	60fb      	str	r3, [r7, #12]
	tk_clr_flg(id_flgid, ~wflgptn);
3400f80e:	4b2a      	ldr	r3, [pc, #168]	@ (3400f8b8 <write_data+0xc0>)
3400f810:	681a      	ldr	r2, [r3, #0]
3400f812:	68fb      	ldr	r3, [r7, #12]
3400f814:	43db      	mvns	r3, r3
3400f816:	4619      	mov	r1, r3
3400f818:	4610      	mov	r0, r2
3400f81a:	f7fc fb29 	bl	3400be70 <tk_clr_flg>

	switch(p_dcb->dmode) {
3400f81e:	687b      	ldr	r3, [r7, #4]
3400f820:	699b      	ldr	r3, [r3, #24]
3400f822:	2b00      	cmp	r3, #0
3400f824:	d002      	beq.n	3400f82c <write_data+0x34>
3400f826:	2b01      	cmp	r3, #1
3400f828:	d011      	beq.n	3400f84e <write_data+0x56>
3400f82a:	e01d      	b.n	3400f868 <write_data+0x70>
	case HAL_I2C_MODE_CNT:
		hal_sts = HAL_I2C_Master_Transmit_IT(
3400f82c:	687b      	ldr	r3, [r7, #4]
3400f82e:	6818      	ldr	r0, [r3, #0]
			p_dcb->hi2c,		// I2C_Handle
			(req->start)<<1,	// Target device address
3400f830:	683b      	ldr	r3, [r7, #0]
3400f832:	691b      	ldr	r3, [r3, #16]
		hal_sts = HAL_I2C_Master_Transmit_IT(
3400f834:	b29b      	uxth	r3, r3
3400f836:	005b      	lsls	r3, r3, #1
3400f838:	b299      	uxth	r1, r3
			req->buf,		// Pointer to data buffer
3400f83a:	683b      	ldr	r3, [r7, #0]
3400f83c:	699a      	ldr	r2, [r3, #24]
			req->size		// Amount of data to be sent
3400f83e:	683b      	ldr	r3, [r7, #0]
3400f840:	695b      	ldr	r3, [r3, #20]
		hal_sts = HAL_I2C_Master_Transmit_IT(
3400f842:	b29b      	uxth	r3, r3
3400f844:	f7f5 fc5e 	bl	34005104 <HAL_I2C_Master_Transmit_IT>
3400f848:	4603      	mov	r3, r0
3400f84a:	75fb      	strb	r3, [r7, #23]
		);
		break;
3400f84c:	e00f      	b.n	3400f86e <write_data+0x76>
	case HAL_I2C_MODE_TAR:
		hal_sts = HAL_I2C_Slave_Transmit_IT(
3400f84e:	687b      	ldr	r3, [r7, #4]
3400f850:	6818      	ldr	r0, [r3, #0]
			p_dcb->hi2c,		// I2C_Handle
			req->buf,		// Pointer to data buffer
3400f852:	683b      	ldr	r3, [r7, #0]
3400f854:	6999      	ldr	r1, [r3, #24]
			req->size		// Amount of data to be sent
3400f856:	683b      	ldr	r3, [r7, #0]
3400f858:	695b      	ldr	r3, [r3, #20]
		hal_sts = HAL_I2C_Slave_Transmit_IT(
3400f85a:	b29b      	uxth	r3, r3
3400f85c:	461a      	mov	r2, r3
3400f85e:	f7f5 fd31 	bl	340052c4 <HAL_I2C_Slave_Transmit_IT>
3400f862:	4603      	mov	r3, r0
3400f864:	75fb      	strb	r3, [r7, #23]
		);
		break;
3400f866:	e002      	b.n	3400f86e <write_data+0x76>
	default:
		return E_SYS;
3400f868:	f06f 0304 	mvn.w	r3, #4
3400f86c:	e01f      	b.n	3400f8ae <write_data+0xb6>
	}
	if(hal_sts != HAL_OK) return E_BUSY;
3400f86e:	7dfb      	ldrb	r3, [r7, #23]
3400f870:	2b00      	cmp	r3, #0
3400f872:	d002      	beq.n	3400f87a <write_data+0x82>
3400f874:	f06f 0340 	mvn.w	r3, #64	@ 0x40
3400f878:	e019      	b.n	3400f8ae <write_data+0xb6>

	err = tk_wai_flg(id_flgid, wflgptn, TWF_ANDW | TWF_BITCLR, &rflgptn, DEV_HAL_I2C_TMOUT);
3400f87a:	4b0f      	ldr	r3, [pc, #60]	@ (3400f8b8 <write_data+0xc0>)
3400f87c:	6818      	ldr	r0, [r3, #0]
3400f87e:	f107 0308 	add.w	r3, r7, #8
3400f882:	f44f 72fa 	mov.w	r2, #500	@ 0x1f4
3400f886:	9200      	str	r2, [sp, #0]
3400f888:	2220      	movs	r2, #32
3400f88a:	68f9      	ldr	r1, [r7, #12]
3400f88c:	f7fc fb54 	bl	3400bf38 <tk_wai_flg>
3400f890:	6138      	str	r0, [r7, #16]
	if(err >= E_OK) {
3400f892:	693b      	ldr	r3, [r7, #16]
3400f894:	2b00      	cmp	r3, #0
3400f896:	db09      	blt.n	3400f8ac <write_data+0xb4>
		err  = p_dcb->err;
3400f898:	687b      	ldr	r3, [r7, #4]
3400f89a:	691b      	ldr	r3, [r3, #16]
3400f89c:	613b      	str	r3, [r7, #16]
		if(err >= E_OK) req->asize = req->size;
3400f89e:	693b      	ldr	r3, [r7, #16]
3400f8a0:	2b00      	cmp	r3, #0
3400f8a2:	db03      	blt.n	3400f8ac <write_data+0xb4>
3400f8a4:	683b      	ldr	r3, [r7, #0]
3400f8a6:	695a      	ldr	r2, [r3, #20]
3400f8a8:	683b      	ldr	r3, [r7, #0]
3400f8aa:	61da      	str	r2, [r3, #28]
	}

	return err;
3400f8ac:	693b      	ldr	r3, [r7, #16]
}
3400f8ae:	4618      	mov	r0, r3
3400f8b0:	3718      	adds	r7, #24
3400f8b2:	46bd      	mov	sp, r7
3400f8b4:	bd80      	pop	{r7, pc}
3400f8b6:	bf00      	nop
3400f8b8:	34011514 	.word	0x34011514

3400f8bc <dev_i2c_openfn>:
 */
/*
 * Open device
 */
LOCAL ER dev_i2c_openfn( ID devid, UINT omode, T_MSDI *msdi)
{
3400f8bc:	b480      	push	{r7}
3400f8be:	b087      	sub	sp, #28
3400f8c0:	af00      	add	r7, sp, #0
3400f8c2:	60f8      	str	r0, [r7, #12]
3400f8c4:	60b9      	str	r1, [r7, #8]
3400f8c6:	607a      	str	r2, [r7, #4]
	T_HAL_I2C_DCB	*p_dcb;

	p_dcb = (T_HAL_I2C_DCB*)(msdi->dmsdi.exinf);
3400f8c8:	687b      	ldr	r3, [r7, #4]
3400f8ca:	691b      	ldr	r3, [r3, #16]
3400f8cc:	617b      	str	r3, [r7, #20]
	p_dcb->omode = omode;
3400f8ce:	697b      	ldr	r3, [r7, #20]
3400f8d0:	68ba      	ldr	r2, [r7, #8]
3400f8d2:	609a      	str	r2, [r3, #8]
	return E_OK;
3400f8d4:	2300      	movs	r3, #0
}
3400f8d6:	4618      	mov	r0, r3
3400f8d8:	371c      	adds	r7, #28
3400f8da:	46bd      	mov	sp, r7
3400f8dc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f8e0:	4770      	bx	lr

3400f8e2 <dev_i2c_closefn>:

/*
 * Close Device
 */
LOCAL ER dev_i2c_closefn( ID devid, UINT option, T_MSDI *msdi)
{
3400f8e2:	b480      	push	{r7}
3400f8e4:	b085      	sub	sp, #20
3400f8e6:	af00      	add	r7, sp, #0
3400f8e8:	60f8      	str	r0, [r7, #12]
3400f8ea:	60b9      	str	r1, [r7, #8]
3400f8ec:	607a      	str	r2, [r7, #4]
	return E_OK;
3400f8ee:	2300      	movs	r3, #0
}
3400f8f0:	4618      	mov	r0, r3
3400f8f2:	3714      	adds	r7, #20
3400f8f4:	46bd      	mov	sp, r7
3400f8f6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f8fa:	4770      	bx	lr

3400f8fc <dev_i2c_readfn>:

/*
 * Read Device
 */
LOCAL ER dev_i2c_readfn( T_DEVREQ *req, T_MSDI *p_msdi)
{
3400f8fc:	b580      	push	{r7, lr}
3400f8fe:	b084      	sub	sp, #16
3400f900:	af00      	add	r7, sp, #0
3400f902:	6078      	str	r0, [r7, #4]
3400f904:	6039      	str	r1, [r7, #0]
	T_HAL_I2C_DCB	*p_dcb;
	ER		err;

	p_dcb = (T_HAL_I2C_DCB*)(p_msdi->dmsdi.exinf);
3400f906:	683b      	ldr	r3, [r7, #0]
3400f908:	691b      	ldr	r3, [r3, #16]
3400f90a:	60bb      	str	r3, [r7, #8]

	if(req->start >= 0) {
3400f90c:	687b      	ldr	r3, [r7, #4]
3400f90e:	691b      	ldr	r3, [r3, #16]
3400f910:	2b00      	cmp	r3, #0
3400f912:	db05      	blt.n	3400f920 <dev_i2c_readfn+0x24>
		err = read_data( p_dcb, req);	// Device specific data
3400f914:	6879      	ldr	r1, [r7, #4]
3400f916:	68b8      	ldr	r0, [r7, #8]
3400f918:	f7ff ff0c 	bl	3400f734 <read_data>
3400f91c:	60f8      	str	r0, [r7, #12]
3400f91e:	e004      	b.n	3400f92a <dev_i2c_readfn+0x2e>
	} else {
		err = read_atr( p_dcb, req);	// Device attribute data
3400f920:	6879      	ldr	r1, [r7, #4]
3400f922:	68b8      	ldr	r0, [r7, #8]
3400f924:	f7ff fdfc 	bl	3400f520 <read_atr>
3400f928:	60f8      	str	r0, [r7, #12]
	}
	return err;
3400f92a:	68fb      	ldr	r3, [r7, #12]
}
3400f92c:	4618      	mov	r0, r3
3400f92e:	3710      	adds	r7, #16
3400f930:	46bd      	mov	sp, r7
3400f932:	bd80      	pop	{r7, pc}

3400f934 <dev_i2c_writefn>:

/*
 * Write Device
 */
LOCAL ER dev_i2c_writefn( T_DEVREQ *req, T_MSDI *p_msdi)
{
3400f934:	b580      	push	{r7, lr}
3400f936:	b084      	sub	sp, #16
3400f938:	af00      	add	r7, sp, #0
3400f93a:	6078      	str	r0, [r7, #4]
3400f93c:	6039      	str	r1, [r7, #0]
	T_HAL_I2C_DCB	*p_dcb;
	ER		rtn;

	p_dcb = (T_HAL_I2C_DCB*)(p_msdi->dmsdi.exinf);
3400f93e:	683b      	ldr	r3, [r7, #0]
3400f940:	691b      	ldr	r3, [r3, #16]
3400f942:	60bb      	str	r3, [r7, #8]

	if(req->start >= 0) {
3400f944:	687b      	ldr	r3, [r7, #4]
3400f946:	691b      	ldr	r3, [r3, #16]
3400f948:	2b00      	cmp	r3, #0
3400f94a:	db05      	blt.n	3400f958 <dev_i2c_writefn+0x24>
		rtn = write_data( p_dcb, req);	// Device specific data
3400f94c:	6879      	ldr	r1, [r7, #4]
3400f94e:	68b8      	ldr	r0, [r7, #8]
3400f950:	f7ff ff52 	bl	3400f7f8 <write_data>
3400f954:	60f8      	str	r0, [r7, #12]
3400f956:	e004      	b.n	3400f962 <dev_i2c_writefn+0x2e>
	} else {
		rtn = write_atr( p_dcb, req);	// Device attribute data
3400f958:	6879      	ldr	r1, [r7, #4]
3400f95a:	68b8      	ldr	r0, [r7, #8]
3400f95c:	f7ff fe20 	bl	3400f5a0 <write_atr>
3400f960:	60f8      	str	r0, [r7, #12]
	}
	return rtn;
3400f962:	68fb      	ldr	r3, [r7, #12]
}
3400f964:	4618      	mov	r0, r3
3400f966:	3710      	adds	r7, #16
3400f968:	46bd      	mov	sp, r7
3400f96a:	bd80      	pop	{r7, pc}

3400f96c <dev_i2c_eventfn>:

/*
 * Event Device
 */
LOCAL ER dev_i2c_eventfn( INT evttyp, void *evtinf, T_MSDI *msdi)
{
3400f96c:	b480      	push	{r7}
3400f96e:	b085      	sub	sp, #20
3400f970:	af00      	add	r7, sp, #0
3400f972:	60f8      	str	r0, [r7, #12]
3400f974:	60b9      	str	r1, [r7, #8]
3400f976:	607a      	str	r2, [r7, #4]
	return E_NOSPT;
3400f978:	f06f 0308 	mvn.w	r3, #8
}
3400f97c:	4618      	mov	r0, r3
3400f97e:	3714      	adds	r7, #20
3400f980:	46bd      	mov	sp, r7
3400f982:	f85d 7b04 	ldr.w	r7, [sp], #4
3400f986:	4770      	bx	lr

3400f988 <dev_init_hal_i2c>:

/*----------------------------------------------------------------------
 * Device driver initialization and registration
 */
EXPORT ER dev_init_hal_i2c( UW unit, I2C_HandleTypeDef *hi2c )
{
3400f988:	b580      	push	{r7, lr}
3400f98a:	b094      	sub	sp, #80	@ 0x50
3400f98c:	af00      	add	r7, sp, #0
3400f98e:	6078      	str	r0, [r7, #4]
3400f990:	6039      	str	r1, [r7, #0]
	T_MSDI		*p_msdi;
	T_DMSDI		dmsdi;
	ER		err;
	INT		i;

	if( unit >= DEV_HAL_I2C_UNITNM) return E_PAR;
3400f992:	687b      	ldr	r3, [r7, #4]
3400f994:	2b04      	cmp	r3, #4
3400f996:	d902      	bls.n	3400f99e <dev_init_hal_i2c+0x16>
3400f998:	f06f 0310 	mvn.w	r3, #16
3400f99c:	e070      	b.n	3400fa80 <dev_init_hal_i2c+0xf8>

#if TK_SUPPORT_MEMLIB
	p_dcb = (T_HAL_I2C_DCB*)Kmalloc(sizeof(T_HAL_I2C_DCB));
3400f99e:	2020      	movs	r0, #32
3400f9a0:	f7fe fdce 	bl	3400e540 <Kmalloc>
3400f9a4:	64b8      	str	r0, [r7, #72]	@ 0x48
	if( p_dcb == NULL) return E_NOMEM;
3400f9a6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400f9a8:	2b00      	cmp	r3, #0
3400f9aa:	d102      	bne.n	3400f9b2 <dev_init_hal_i2c+0x2a>
3400f9ac:	f06f 0320 	mvn.w	r3, #32
3400f9b0:	e066      	b.n	3400fa80 <dev_init_hal_i2c+0xf8>
	dev_i2c_cb[unit]	= p_dcb;
3400f9b2:	4935      	ldr	r1, [pc, #212]	@ (3400fa88 <dev_init_hal_i2c+0x100>)
3400f9b4:	687b      	ldr	r3, [r7, #4]
3400f9b6:	6cba      	ldr	r2, [r7, #72]	@ 0x48
3400f9b8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#else
	p_dcb = &dev_i2c_cb[unit];
#endif

	id_flgid = tk_cre_flg(&id_flg);
3400f9bc:	4833      	ldr	r0, [pc, #204]	@ (3400fa8c <dev_init_hal_i2c+0x104>)
3400f9be:	f7fc f91f 	bl	3400bc00 <tk_cre_flg>
3400f9c2:	4603      	mov	r3, r0
3400f9c4:	4a32      	ldr	r2, [pc, #200]	@ (3400fa90 <dev_init_hal_i2c+0x108>)
3400f9c6:	6013      	str	r3, [r2, #0]
	if(id_flgid <= E_OK) {
3400f9c8:	4b31      	ldr	r3, [pc, #196]	@ (3400fa90 <dev_init_hal_i2c+0x108>)
3400f9ca:	681b      	ldr	r3, [r3, #0]
3400f9cc:	2b00      	cmp	r3, #0
3400f9ce:	dc03      	bgt.n	3400f9d8 <dev_init_hal_i2c+0x50>
		err = (ER)id_flgid;
3400f9d0:	4b2f      	ldr	r3, [pc, #188]	@ (3400fa90 <dev_init_hal_i2c+0x108>)
3400f9d2:	681b      	ldr	r3, [r3, #0]
3400f9d4:	64fb      	str	r3, [r7, #76]	@ 0x4c
		goto err_1;
3400f9d6:	e04f      	b.n	3400fa78 <dev_init_hal_i2c+0xf0>
	}

	/* Device registration information */
	dmsdi.exinf	= p_dcb;
3400f9d8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400f9da:	60bb      	str	r3, [r7, #8]
	dmsdi.drvatr	= 0;			/* Driver attributes */
3400f9dc:	2300      	movs	r3, #0
3400f9de:	61bb      	str	r3, [r7, #24]
	dmsdi.devatr	= TDK_UNDEF;		/* Device attributes */
3400f9e0:	2300      	movs	r3, #0
3400f9e2:	61fb      	str	r3, [r7, #28]
	dmsdi.nsub	= 0;			/* Number of sub units */
3400f9e4:	2300      	movs	r3, #0
3400f9e6:	623b      	str	r3, [r7, #32]
	dmsdi.blksz	= 1;			/* Unique data block size (-1 = unknown) */
3400f9e8:	2301      	movs	r3, #1
3400f9ea:	627b      	str	r3, [r7, #36]	@ 0x24
	dmsdi.openfn	= dev_i2c_openfn;
3400f9ec:	4b29      	ldr	r3, [pc, #164]	@ (3400fa94 <dev_init_hal_i2c+0x10c>)
3400f9ee:	62bb      	str	r3, [r7, #40]	@ 0x28
	dmsdi.closefn	= dev_i2c_closefn;
3400f9f0:	4b29      	ldr	r3, [pc, #164]	@ (3400fa98 <dev_init_hal_i2c+0x110>)
3400f9f2:	62fb      	str	r3, [r7, #44]	@ 0x2c
	dmsdi.readfn	= dev_i2c_readfn;
3400f9f4:	4b29      	ldr	r3, [pc, #164]	@ (3400fa9c <dev_init_hal_i2c+0x114>)
3400f9f6:	633b      	str	r3, [r7, #48]	@ 0x30
	dmsdi.writefn	= dev_i2c_writefn;
3400f9f8:	4b29      	ldr	r3, [pc, #164]	@ (3400faa0 <dev_init_hal_i2c+0x118>)
3400f9fa:	637b      	str	r3, [r7, #52]	@ 0x34
	dmsdi.eventfn	= dev_i2c_eventfn;
3400f9fc:	4b29      	ldr	r3, [pc, #164]	@ (3400faa4 <dev_init_hal_i2c+0x11c>)
3400f9fe:	63bb      	str	r3, [r7, #56]	@ 0x38
	
	knl_strcpy( (char*)dmsdi.devnm, DEVNAME_HAL_I2C);
3400fa00:	f107 0308 	add.w	r3, r7, #8
3400fa04:	3304      	adds	r3, #4
3400fa06:	4928      	ldr	r1, [pc, #160]	@ (3400faa8 <dev_init_hal_i2c+0x120>)
3400fa08:	4618      	mov	r0, r3
3400fa0a:	f7fe fb6a 	bl	3400e0e2 <knl_strcpy>
	i = knl_strlen(DEVNAME_HAL_I2C);
3400fa0e:	4826      	ldr	r0, [pc, #152]	@ (3400faa8 <dev_init_hal_i2c+0x120>)
3400fa10:	f7fe fb56 	bl	3400e0c0 <knl_strlen>
3400fa14:	6478      	str	r0, [r7, #68]	@ 0x44
	dmsdi.devnm[i] = (UB)('a' + unit);
3400fa16:	687b      	ldr	r3, [r7, #4]
3400fa18:	b2db      	uxtb	r3, r3
3400fa1a:	3361      	adds	r3, #97	@ 0x61
3400fa1c:	b2d9      	uxtb	r1, r3
3400fa1e:	f107 020c 	add.w	r2, r7, #12
3400fa22:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3400fa24:	4413      	add	r3, r2
3400fa26:	460a      	mov	r2, r1
3400fa28:	701a      	strb	r2, [r3, #0]
	dmsdi.devnm[i+1] = 0;
3400fa2a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
3400fa2c:	3301      	adds	r3, #1
3400fa2e:	3350      	adds	r3, #80	@ 0x50
3400fa30:	443b      	add	r3, r7
3400fa32:	2200      	movs	r2, #0
3400fa34:	f803 2c44 	strb.w	r2, [r3, #-68]

	err = msdi_def_dev( &dmsdi, &idev, &p_msdi);
3400fa38:	f107 023c 	add.w	r2, r7, #60	@ 0x3c
3400fa3c:	f107 0140 	add.w	r1, r7, #64	@ 0x40
3400fa40:	f107 0308 	add.w	r3, r7, #8
3400fa44:	4618      	mov	r0, r3
3400fa46:	f7fb fa03 	bl	3400ae50 <msdi_def_dev>
3400fa4a:	64f8      	str	r0, [r7, #76]	@ 0x4c
	if(err != E_OK) goto err_1;
3400fa4c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
3400fa4e:	2b00      	cmp	r3, #0
3400fa50:	d111      	bne.n	3400fa76 <dev_init_hal_i2c+0xee>

	p_dcb->hi2c	= hi2c;
3400fa52:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400fa54:	683a      	ldr	r2, [r7, #0]
3400fa56:	601a      	str	r2, [r3, #0]
	p_dcb->devid	= p_msdi->devid;
3400fa58:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
3400fa5a:	681a      	ldr	r2, [r3, #0]
3400fa5c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400fa5e:	605a      	str	r2, [r3, #4]
	p_dcb->unit	= unit;
3400fa60:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400fa62:	687a      	ldr	r2, [r7, #4]
3400fa64:	60da      	str	r2, [r3, #12]
	p_dcb->evtmbfid	= idev.evtmbfid;
3400fa66:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
3400fa68:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400fa6a:	615a      	str	r2, [r3, #20]
	p_dcb->dmode	= HAL_I2C_MODE_CNT;
3400fa6c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
3400fa6e:	2200      	movs	r2, #0
3400fa70:	619a      	str	r2, [r3, #24]

	return E_OK;
3400fa72:	2300      	movs	r3, #0
3400fa74:	e004      	b.n	3400fa80 <dev_init_hal_i2c+0xf8>
	if(err != E_OK) goto err_1;
3400fa76:	bf00      	nop

err_1:
#if TK_SUPPORT_MEMLIB
	Kfree(p_dcb);
3400fa78:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
3400fa7a:	f7fe fd6e 	bl	3400e55a <Kfree>
#endif
	return err;
3400fa7e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
}
3400fa80:	4618      	mov	r0, r3
3400fa82:	3750      	adds	r7, #80	@ 0x50
3400fa84:	46bd      	mov	sp, r7
3400fa86:	bd80      	pop	{r7, pc}
3400fa88:	34011518 	.word	0x34011518
3400fa8c:	34010194 	.word	0x34010194
3400fa90:	34011514 	.word	0x34011514
3400fa94:	3400f8bd 	.word	0x3400f8bd
3400fa98:	3400f8e3 	.word	0x3400f8e3
3400fa9c:	3400f8fd 	.word	0x3400f8fd
3400faa0:	3400f935 	.word	0x3400f935
3400faa4:	3400f96d 	.word	0x3400f96d
3400faa8:	3400ffa4 	.word	0x3400ffa4

3400faac <knl_init_device>:
/*
 * Initialization before micro T-Kernel starts
 */

EXPORT ER knl_init_device( void )
{
3400faac:	b480      	push	{r7}
3400faae:	af00      	add	r7, sp, #0
	return E_OK;
3400fab0:	2300      	movs	r3, #0
}
3400fab2:	4618      	mov	r0, r3
3400fab4:	46bd      	mov	sp, r7
3400fab6:	f85d 7b04 	ldr.w	r7, [sp], #4
3400faba:	4770      	bx	lr

3400fabc <knl_start_device>:
/*
 * Start processing after T-Kernel starts
 *	Called from the initial task contexts.
 */
EXPORT ER knl_start_device( void )
{
3400fabc:	b580      	push	{r7, lr}
3400fabe:	b082      	sub	sp, #8
3400fac0:	af00      	add	r7, sp, #0
	ER	err	= E_OK;
3400fac2:	2300      	movs	r3, #0
3400fac4:	607b      	str	r3, [r7, #4]

#if DEVCNF_USE_HAL_IIC
	IMPORT I2C_HandleTypeDef	hi2c1;

	err = dev_init_hal_i2c(DEV_HAL_I2C1, &hi2c1);
3400fac6:	4916      	ldr	r1, [pc, #88]	@ (3400fb20 <knl_start_device+0x64>)
3400fac8:	2000      	movs	r0, #0
3400faca:	f7ff ff5d 	bl	3400f988 <dev_init_hal_i2c>
3400face:	6078      	str	r0, [r7, #4]
	if(err < E_OK) return err;
3400fad0:	687b      	ldr	r3, [r7, #4]
3400fad2:	2b00      	cmp	r3, #0
3400fad4:	da01      	bge.n	3400fada <knl_start_device+0x1e>
3400fad6:	687b      	ldr	r3, [r7, #4]
3400fad8:	e01e      	b.n	3400fb18 <knl_start_device+0x5c>
#endif

#if DEVCNF_USE_HAL_ADC
	IMPORT ADC_HandleTypeDef	hadc1;
	err = dev_init_hal_adc(DEV_HAL_ADC1, &hadc1);
3400fada:	4912      	ldr	r1, [pc, #72]	@ (3400fb24 <knl_start_device+0x68>)
3400fadc:	2000      	movs	r0, #0
3400fade:	f7ff fc23 	bl	3400f328 <dev_init_hal_adc>
3400fae2:	6078      	str	r0, [r7, #4]
	if(err < E_OK) return err;
3400fae4:	687b      	ldr	r3, [r7, #4]
3400fae6:	2b00      	cmp	r3, #0
3400fae8:	da01      	bge.n	3400faee <knl_start_device+0x32>
3400faea:	687b      	ldr	r3, [r7, #4]
3400faec:	e014      	b.n	3400fb18 <knl_start_device+0x5c>
	if(err < E_OK) return err;

#elif defined(MTKBSP_NUCLEO_STM32G431) || defined(MTKBSP_NUCLEO_STM32G491)|| defined(MTKBSP_DISCOVERY_STM32N657)
	IMPORT ADC_HandleTypeDef	hadc2;
	
	err = dev_init_hal_adc(DEV_HAL_ADC2, &hadc2);
3400faee:	490e      	ldr	r1, [pc, #56]	@ (3400fb28 <knl_start_device+0x6c>)
3400faf0:	2001      	movs	r0, #1
3400faf2:	f7ff fc19 	bl	3400f328 <dev_init_hal_adc>
3400faf6:	6078      	str	r0, [r7, #4]
	if(err < E_OK) return err;
3400faf8:	687b      	ldr	r3, [r7, #4]
3400fafa:	2b00      	cmp	r3, #0
3400fafc:	da01      	bge.n	3400fb02 <knl_start_device+0x46>
3400fafe:	687b      	ldr	r3, [r7, #4]
3400fb00:	e00a      	b.n	3400fb18 <knl_start_device+0x5c>
	err = dev_init_hal_adc(DEV_HAL_ADC3, NULL);	// hadc3 is not used.
3400fb02:	2100      	movs	r1, #0
3400fb04:	2002      	movs	r0, #2
3400fb06:	f7ff fc0f 	bl	3400f328 <dev_init_hal_adc>
3400fb0a:	6078      	str	r0, [r7, #4]
	if(err < E_OK) return err;
3400fb0c:	687b      	ldr	r3, [r7, #4]
3400fb0e:	2b00      	cmp	r3, #0
3400fb10:	da01      	bge.n	3400fb16 <knl_start_device+0x5a>
3400fb12:	687b      	ldr	r3, [r7, #4]
3400fb14:	e000      	b.n	3400fb18 <knl_start_device+0x5c>
	if(err < E_OK) return err;

#endif
#endif	/* DEVCNF_USE_HAL_ADC */

	return err;
3400fb16:	687b      	ldr	r3, [r7, #4]
}
3400fb18:	4618      	mov	r0, r3
3400fb1a:	3708      	adds	r7, #8
3400fb1c:	46bd      	mov	sp, r7
3400fb1e:	bd80      	pop	{r7, pc}
3400fb20:	3401124c 	.word	0x3401124c
3400fb24:	3401118c 	.word	0x3401118c
3400fb28:	340111ec 	.word	0x340111ec

3400fb2c <knl_finish_device>:
 * System finalization
 *	Called just before system shutdown.
 *	Execute finalization that must be done before system shutdown.
 */
EXPORT ER knl_finish_device( void )
{
3400fb2c:	b480      	push	{r7}
3400fb2e:	af00      	add	r7, sp, #0
	return E_OK;
3400fb30:	2300      	movs	r3, #0
}
3400fb32:	4618      	mov	r0, r3
3400fb34:	46bd      	mov	sp, r7
3400fb36:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fb3a:	4770      	bx	lr

3400fb3c <knl_startup_hw>:

/*
 * Startup Device
 */
EXPORT void knl_startup_hw(void)
{
3400fb3c:	b480      	push	{r7}
3400fb3e:	af00      	add	r7, sp, #0
#if USE_PTMR
	void knl_init_ptmr(void);
	knl_init_ptmr();
#endif
}
3400fb40:	bf00      	nop
3400fb42:	46bd      	mov	sp, r7
3400fb44:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fb48:	4770      	bx	lr

3400fb4a <knl_shutdown_hw>:
#if USE_SHUTDOWN
/*
 * Shutdown device
 */
EXPORT void knl_shutdown_hw( void )
{
3400fb4a:	b580      	push	{r7, lr}
3400fb4c:	af00      	add	r7, sp, #0
	disint();
3400fb4e:	f000 f858 	bl	3400fc02 <disint>
	while(1);
3400fb52:	bf00      	nop
3400fb54:	e7fd      	b.n	3400fb52 <knl_shutdown_hw+0x8>
	...

3400fb58 <knl_restart_hw>:
 *	mode = -1		reset and re-start	(Reset -> Boot -> Start)
 *	mode = -2		fast re-start		(Start)
 *	mode = -3		Normal re-start		(Boot -> Start)
 */
EXPORT ER knl_restart_hw( W mode )
{
3400fb58:	b580      	push	{r7, lr}
3400fb5a:	b082      	sub	sp, #8
3400fb5c:	af00      	add	r7, sp, #0
3400fb5e:	6078      	str	r0, [r7, #4]
	switch(mode) {
3400fb60:	687b      	ldr	r3, [r7, #4]
3400fb62:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
3400fb66:	d00b      	beq.n	3400fb80 <knl_restart_hw+0x28>
3400fb68:	687b      	ldr	r3, [r7, #4]
3400fb6a:	2b00      	cmp	r3, #0
3400fb6c:	da1a      	bge.n	3400fba4 <knl_restart_hw+0x4c>
3400fb6e:	687b      	ldr	r3, [r7, #4]
3400fb70:	f113 0f03 	cmn.w	r3, #3
3400fb74:	d010      	beq.n	3400fb98 <knl_restart_hw+0x40>
3400fb76:	687b      	ldr	r3, [r7, #4]
3400fb78:	f113 0f02 	cmn.w	r3, #2
3400fb7c:	d006      	beq.n	3400fb8c <knl_restart_hw+0x34>
3400fb7e:	e011      	b.n	3400fba4 <knl_restart_hw+0x4c>
	case -1: /* Reset and re-start */
		SYSTEM_MESSAGE("\n<< SYSTEM RESET & RESTART >>\n");
3400fb80:	480b      	ldr	r0, [pc, #44]	@ (3400fbb0 <knl_restart_hw+0x58>)
3400fb82:	f7fe fd1f 	bl	3400e5c4 <tm_putstring>
		return E_NOSPT;
3400fb86:	f06f 0308 	mvn.w	r3, #8
3400fb8a:	e00d      	b.n	3400fba8 <knl_restart_hw+0x50>
	case -2: /* fast re-start */
		SYSTEM_MESSAGE("\n<< SYSTEM FAST RESTART >>\n");
3400fb8c:	4809      	ldr	r0, [pc, #36]	@ (3400fbb4 <knl_restart_hw+0x5c>)
3400fb8e:	f7fe fd19 	bl	3400e5c4 <tm_putstring>
		return E_NOSPT;
3400fb92:	f06f 0308 	mvn.w	r3, #8
3400fb96:	e007      	b.n	3400fba8 <knl_restart_hw+0x50>
	case -3: /* Normal re-start */
		SYSTEM_MESSAGE("\n<< SYSTEM RESTART >>\n");
3400fb98:	4807      	ldr	r0, [pc, #28]	@ (3400fbb8 <knl_restart_hw+0x60>)
3400fb9a:	f7fe fd13 	bl	3400e5c4 <tm_putstring>
		return E_NOSPT;
3400fb9e:	f06f 0308 	mvn.w	r3, #8
3400fba2:	e001      	b.n	3400fba8 <knl_restart_hw+0x50>
	default:
		return E_PAR;
3400fba4:	f06f 0310 	mvn.w	r3, #16
	}
}
3400fba8:	4618      	mov	r0, r3
3400fbaa:	3708      	adds	r7, #8
3400fbac:	46bd      	mov	sp, r7
3400fbae:	bd80      	pop	{r7, pc}
3400fbb0:	3400ffac 	.word	0x3400ffac
3400fbb4:	3400ffcc 	.word	0x3400ffcc
3400fbb8:	3400ffe8 	.word	0x3400ffe8

3400fbbc <low_pow>:

/*
 * Switch to power-saving mode
 */
EXPORT void low_pow( void )
{
3400fbbc:	b480      	push	{r7}
3400fbbe:	af00      	add	r7, sp, #0
}
3400fbc0:	bf00      	nop
3400fbc2:	46bd      	mov	sp, r7
3400fbc4:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fbc8:	4770      	bx	lr

3400fbca <set_basepri>:

/*
 * Set Base Priority register
 */
EXPORT void set_basepri(UW intsts)
{	
3400fbca:	b480      	push	{r7}
3400fbcc:	b083      	sub	sp, #12
3400fbce:	af00      	add	r7, sp, #0
3400fbd0:	6078      	str	r0, [r7, #4]
	Asm("msr basepri, %0":: "r"(intsts));
3400fbd2:	687b      	ldr	r3, [r7, #4]
3400fbd4:	f383 8811 	msr	BASEPRI, r3
	Asm("isb");
3400fbd8:	f3bf 8f6f 	isb	sy
}
3400fbdc:	bf00      	nop
3400fbde:	370c      	adds	r7, #12
3400fbe0:	46bd      	mov	sp, r7
3400fbe2:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fbe6:	4770      	bx	lr

3400fbe8 <get_basepri>:

/*
 * Get Base Priority register
 */
EXPORT UW get_basepri(void)
{
3400fbe8:	b480      	push	{r7}
3400fbea:	b083      	sub	sp, #12
3400fbec:	af00      	add	r7, sp, #0
	UW	basepri;

	Asm("mrs %0, basepri": "=r"(basepri));
3400fbee:	f3ef 8311 	mrs	r3, BASEPRI
3400fbf2:	607b      	str	r3, [r7, #4]
	return basepri;
3400fbf4:	687b      	ldr	r3, [r7, #4]
}
3400fbf6:	4618      	mov	r0, r3
3400fbf8:	370c      	adds	r7, #12
3400fbfa:	46bd      	mov	sp, r7
3400fbfc:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fc00:	4770      	bx	lr

3400fc02 <disint>:

/* 
 * Disable interrupt 
 */
EXPORT UW disint(void)
{
3400fc02:	b480      	push	{r7}
3400fc04:	b083      	sub	sp, #12
3400fc06:	af00      	add	r7, sp, #0
	UW	intsts, maxint;

	maxint = INTPRI_VAL(INTPRI_MAX_EXTINT_PRI);
3400fc08:	2310      	movs	r3, #16
3400fc0a:	607b      	str	r3, [r7, #4]
	Asm("mrs %0, basepri": "=r"(intsts));
3400fc0c:	f3ef 8311 	mrs	r3, BASEPRI
3400fc10:	603b      	str	r3, [r7, #0]
	Asm("msr basepri, %0":: "r"(maxint));
3400fc12:	687b      	ldr	r3, [r7, #4]
3400fc14:	f383 8811 	msr	BASEPRI, r3

	return intsts;
3400fc18:	683b      	ldr	r3, [r7, #0]
}
3400fc1a:	4618      	mov	r0, r3
3400fc1c:	370c      	adds	r7, #12
3400fc1e:	46bd      	mov	sp, r7
3400fc20:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fc24:	4770      	bx	lr
	...

3400fc28 <tm_snd_dat>:

/* Communication speed */
#define UART_BAUD	(115200)			/* 115200 bps */

EXPORT	void	tm_snd_dat( const UB* buf, INT size )
{
3400fc28:	b480      	push	{r7}
3400fc2a:	b085      	sub	sp, #20
3400fc2c:	af00      	add	r7, sp, #0
3400fc2e:	6078      	str	r0, [r7, #4]
3400fc30:	6039      	str	r1, [r7, #0]
	UB	*b;

	for( b = (UB *)buf; size > 0; size--, b++ ){
3400fc32:	687b      	ldr	r3, [r7, #4]
3400fc34:	60fb      	str	r3, [r7, #12]
3400fc36:	e017      	b.n	3400fc68 <tm_snd_dat+0x40>
		while ((UART_ISR & ISR_TXE) == 0 );
3400fc38:	bf00      	nop
3400fc3a:	4b10      	ldr	r3, [pc, #64]	@ (3400fc7c <tm_snd_dat+0x54>)
3400fc3c:	681b      	ldr	r3, [r3, #0]
3400fc3e:	f003 0380 	and.w	r3, r3, #128	@ 0x80
3400fc42:	2b00      	cmp	r3, #0
3400fc44:	d0f9      	beq.n	3400fc3a <tm_snd_dat+0x12>
		UART_TDR = *b;
3400fc46:	68fb      	ldr	r3, [r7, #12]
3400fc48:	781a      	ldrb	r2, [r3, #0]
3400fc4a:	4b0d      	ldr	r3, [pc, #52]	@ (3400fc80 <tm_snd_dat+0x58>)
3400fc4c:	601a      	str	r2, [r3, #0]
		while ((UART_ISR & ISR_TC) == 0 );
3400fc4e:	bf00      	nop
3400fc50:	4b0a      	ldr	r3, [pc, #40]	@ (3400fc7c <tm_snd_dat+0x54>)
3400fc52:	681b      	ldr	r3, [r3, #0]
3400fc54:	f003 0340 	and.w	r3, r3, #64	@ 0x40
3400fc58:	2b00      	cmp	r3, #0
3400fc5a:	d0f9      	beq.n	3400fc50 <tm_snd_dat+0x28>
	for( b = (UB *)buf; size > 0; size--, b++ ){
3400fc5c:	683b      	ldr	r3, [r7, #0]
3400fc5e:	3b01      	subs	r3, #1
3400fc60:	603b      	str	r3, [r7, #0]
3400fc62:	68fb      	ldr	r3, [r7, #12]
3400fc64:	3301      	adds	r3, #1
3400fc66:	60fb      	str	r3, [r7, #12]
3400fc68:	683b      	ldr	r3, [r7, #0]
3400fc6a:	2b00      	cmp	r3, #0
3400fc6c:	dce4      	bgt.n	3400fc38 <tm_snd_dat+0x10>
	}
}
3400fc6e:	bf00      	nop
3400fc70:	bf00      	nop
3400fc72:	3714      	adds	r7, #20
3400fc74:	46bd      	mov	sp, r7
3400fc76:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fc7a:	4770      	bx	lr
3400fc7c:	5200101c 	.word	0x5200101c
3400fc80:	52001028 	.word	0x52001028

3400fc84 <tm_com_init>:
}

UW get_pclk1(void);

EXPORT	void	tm_com_init(void)
{
3400fc84:	b480      	push	{r7}
3400fc86:	af00      	add	r7, sp, #0
	/* Initialize serial communication. Disable all interrupt. */
	UART_CR1 = 0;		/* 8bit, Non parity (Reset value) */
3400fc88:	4b0a      	ldr	r3, [pc, #40]	@ (3400fcb4 <tm_com_init+0x30>)
3400fc8a:	2200      	movs	r2, #0
3400fc8c:	601a      	str	r2, [r3, #0]
	UART_CR2 = 0;		/* Stop bit 1 (Reset value) */
3400fc8e:	4b0a      	ldr	r3, [pc, #40]	@ (3400fcb8 <tm_com_init+0x34>)
3400fc90:	2200      	movs	r2, #0
3400fc92:	601a      	str	r2, [r3, #0]
	UART_CR3 = 0;		/* No hard flow control (Reset value) */
3400fc94:	4b09      	ldr	r3, [pc, #36]	@ (3400fcbc <tm_com_init+0x38>)
3400fc96:	2200      	movs	r2, #0
3400fc98:	601a      	str	r2, [r3, #0]
	UART_BRR = 0x022C;	/* Set baud rate */
3400fc9a:	4b09      	ldr	r3, [pc, #36]	@ (3400fcc0 <tm_com_init+0x3c>)
3400fc9c:	f44f 720b 	mov.w	r2, #556	@ 0x22c
3400fca0:	601a      	str	r2, [r3, #0]

	UART_CR1 = CR1_UE | CR1_RE |CR1_TE;	/* Start UART */
3400fca2:	4b04      	ldr	r3, [pc, #16]	@ (3400fcb4 <tm_com_init+0x30>)
3400fca4:	220d      	movs	r2, #13
3400fca6:	601a      	str	r2, [r3, #0]
}
3400fca8:	bf00      	nop
3400fcaa:	46bd      	mov	sp, r7
3400fcac:	f85d 7b04 	ldr.w	r7, [sp], #4
3400fcb0:	4770      	bx	lr
3400fcb2:	bf00      	nop
3400fcb4:	52001000 	.word	0x52001000
3400fcb8:	52001004 	.word	0x52001004
3400fcbc:	52001008 	.word	0x52001008
3400fcc0:	5200100c 	.word	0x5200100c

3400fcc4 <memset>:
3400fcc4:	4402      	add	r2, r0
3400fcc6:	4603      	mov	r3, r0
3400fcc8:	4293      	cmp	r3, r2
3400fcca:	d100      	bne.n	3400fcce <memset+0xa>
3400fccc:	4770      	bx	lr
3400fcce:	f803 1b01 	strb.w	r1, [r3], #1
3400fcd2:	e7f9      	b.n	3400fcc8 <memset+0x4>

3400fcd4 <__libc_init_array>:
3400fcd4:	b570      	push	{r4, r5, r6, lr}
3400fcd6:	4d0d      	ldr	r5, [pc, #52]	@ (3400fd0c <__libc_init_array+0x38>)
3400fcd8:	2600      	movs	r6, #0
3400fcda:	4c0d      	ldr	r4, [pc, #52]	@ (3400fd10 <__libc_init_array+0x3c>)
3400fcdc:	1b64      	subs	r4, r4, r5
3400fcde:	10a4      	asrs	r4, r4, #2
3400fce0:	42a6      	cmp	r6, r4
3400fce2:	d109      	bne.n	3400fcf8 <__libc_init_array+0x24>
3400fce4:	4d0b      	ldr	r5, [pc, #44]	@ (3400fd14 <__libc_init_array+0x40>)
3400fce6:	2600      	movs	r6, #0
3400fce8:	4c0b      	ldr	r4, [pc, #44]	@ (3400fd18 <__libc_init_array+0x44>)
3400fcea:	f000 f817 	bl	3400fd1c <_init>
3400fcee:	1b64      	subs	r4, r4, r5
3400fcf0:	10a4      	asrs	r4, r4, #2
3400fcf2:	42a6      	cmp	r6, r4
3400fcf4:	d105      	bne.n	3400fd02 <__libc_init_array+0x2e>
3400fcf6:	bd70      	pop	{r4, r5, r6, pc}
3400fcf8:	f855 3b04 	ldr.w	r3, [r5], #4
3400fcfc:	3601      	adds	r6, #1
3400fcfe:	4798      	blx	r3
3400fd00:	e7ee      	b.n	3400fce0 <__libc_init_array+0xc>
3400fd02:	f855 3b04 	ldr.w	r3, [r5], #4
3400fd06:	3601      	adds	r6, #1
3400fd08:	4798      	blx	r3
3400fd0a:	e7f2      	b.n	3400fcf2 <__libc_init_array+0x1e>
3400fd0c:	3401014c 	.word	0x3401014c
3400fd10:	3401014c 	.word	0x3401014c
3400fd14:	3401014c 	.word	0x3401014c
3400fd18:	34010150 	.word	0x34010150

3400fd1c <_init>:
3400fd1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3400fd1e:	bf00      	nop
3400fd20:	bcf8      	pop	{r3, r4, r5, r6, r7}
3400fd22:	bc08      	pop	{r3}
3400fd24:	469e      	mov	lr, r3
3400fd26:	4770      	bx	lr

3400fd28 <_fini>:
3400fd28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
3400fd2a:	bf00      	nop
3400fd2c:	bcf8      	pop	{r3, r4, r5, r6, r7}
3400fd2e:	bc08      	pop	{r3}
3400fd30:	469e      	mov	lr, r3
3400fd32:	4770      	bx	lr

Disassembly of section .gnu.sgstubs:

34011140 <SECURE_SystemCoreClockUpdate>:
34011140:	e97f e97f 	sg
34011144:	f7f0 bc98 	b.w	34001a78 <__acle_se_SECURE_SystemCoreClockUpdate>

34011148 <SECURE_RegisterCallback>:
34011148:	e97f e97f 	sg
3401114c:	f7f0 b824 	b.w	34001198 <__acle_se_SECURE_RegisterCallback>
	...
